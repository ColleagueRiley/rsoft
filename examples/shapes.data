/*
* Copyright (c) 2021-24 ColleagueRiley ColleagueRiley@gmail.com
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following r estrictions:
*
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*
*
*/

/*
preprocessor args

make sure 

** #define RFONT_IMPLEMENTATION ** - include function defines

is in exactly one of your files or arguments

#define RFONT_NO_OPENGL - do not define graphics functions (that use opengl)
#define RFONT_NO_STDIO - do not include stdio.h
#define RFONT_EXTERNAL_STB - load stb_truetype from stb_truetype.h instead of using the internal version
#define RFONT_NO_GRAPHICS - do not include any graphics functions at all
#define RFONT_RENDER_RGL - use RGL functions for rendering
#define RFONT_RENDER_LEGACY - use opengl legacy functions for rendering (if RGL is not chosen)
-- NOTE: By default, opengl 3.3 vbos are used for rendering --
*/

/*
credits :

stb_truetype.h - a dependency for RFont, most of (a slightly motified version of) stb_truetype.h is included directly into RFont.h
http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ - UTF-8 decoding function
fontstash - fontstash was used as a refference for some parts
*/

/*

... = [add code here]

BASIC TEMPLATE :
#define RFONT_IMPLEMENTATION
#include "RFont.h"

...

int main () {
   ...

   RFont_init(window_width, window_height);

   RFont_font* font = RFont_font_init("font.ttf");

   while (1) {
      ...
      RFont_draw_text(font, "text", 100, 100, 20);
      ...
   }

   RFont_font_free(font);
   RFont_close();
   ...
}
*/


#ifndef RFONT_NO_STDIO
#include <stdio.h>
#endif

#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <string.h>

#if !defined(u8)
	#if defined(_MSC_VER) || defined(__SYMBIAN32__)
		typedef unsigned char 	u8;
		typedef signed char		i8;
		typedef unsigned short  u16;
		typedef signed short 	i16;
		typedef unsigned int 	u32;
		typedef signed int		i32;
		typedef unsigned long	u64;
		typedef signed long		i64;
	#else
		#include <stdint.h>

		typedef uint8_t     u8;
		typedef int8_t      i8;
		typedef uint16_t   u16;
		typedef int16_t    i16;
		typedef uint32_t   u32;
		typedef int32_t    i32;
		typedef uint64_t   u64;
		typedef int64_t    i64;
	#endif
#endif

#if !defined(b8)
	typedef u8 b8;
#endif
/* 
You can define these yourself if 
you want to change anything
*/

#ifndef RFONT_MAX_GLYPHS
#define RFONT_MAX_GLYPHS 652
#endif

#ifndef RFONT_ATLAS_WIDTH
#define RFONT_ATLAS_WIDTH 6000
#endif

#ifndef RFONT_ATLAS_HEIGHT
#define RFONT_ATLAS_HEIGHT 400
#endif

#ifndef RFONT_INIT_TEXT_SIZE
#define RFONT_INIT_TEXT_SIZE 500
#endif

#ifndef RFONT_INIT_VERTS
#define RFONT_INIT_VERTS 1024
#endif

#ifndef RFONT_TEXTFORMAT_MAX_SIZE
   #define RFONT_TEXTFORMAT_MAX_SIZE 923
#endif

#ifndef RFONT_VSNPRINTF
#define RFONT_VSNPRINTF vsnprintf
#endif

#ifndef RFONT_UNUSED
#define RFONT_UNUSED(x) (void) (x);
#endif

/* make sure RFont declares aren't declared twice */
#ifndef RFONT_H
#define RFONT_H

#ifndef RFont_area
typedef struct { u32 w, h; } RFont_area;
#endif

typedef struct RFont_font RFont_font;

typedef struct {
   u32 codepoint; /* the character (for checking) */
   size_t size; /* the size of the glyph */
   i32 x, x2;  /* coords of the character on the texture */

   /* source glyph data */
   i32 src;
   float w, h, x1, y1, advance;
} RFont_glyph;

/**
 * @brief Sets the framebuffer size AND runs the graphics init function.
 * @param width The framebuffer width.
 * @param height The framebuffer height.
*/
inline void RFont_init(size_t width, size_t height);
/**
 * @brief Frees data allocated by the RFont for the RFont
*/
inline void RFont_close(void);
/**
 * @brief Just updates the framebuffer size.
 * @param width The framebuffer width.
 * @param height The framebuffer height.
*/
inline void RFont_update_framebuffer(size_t width, size_t height);

#ifndef RFONT_NO_STDIO
/**
 * @brief Init font stucture with a TTF file path.
 * @param font_name The TTF file path.
 * @return The `RFont_font` created using the TTF file data.
*/
inline RFont_font* RFont_font_init(const char* font_name);
#endif


/**
 * @brief Init font stucture with raw TTF data.
 * @param font_data The raw TTF data.
 * @param auto_free If the memory should be automatically freed by `RFont_font_free`.
 * @return The `RFont_font` created from the data.
*/
inline RFont_font* RFont_font_init_data(u8* font_data, b8 auto_free);

/**
 * @brief Free data from the font stucture, including the stucture itself
 * @param font The font stucture to free
*/
inline void RFont_font_free(RFont_font* font);

/**
 * @brief Add a character to the font's atlas.
 * @param font The font to use.
 * @param ch The character to add to the atlas.
 * @param size The size of the character.
 * @return The `RFont_glyph` created from the data and added to the atlas.
*/
inline RFont_glyph RFont_font_add_char(RFont_font* font, char ch, size_t size);

#ifndef RFONT_NO_FMT
/**
 * @brief Formats a string.
 * @param string The source string
 * @param ... format data
 * @return The formatted string 
*/
inline const char* RFont_fmt(const char* string, ...);
#endif

/**
 * @brief Add a string to the font's atlas.
 * @param font The font to use.
 * @param ch The character to add to the atlas.
 * @param sizes The supported sizes of the character.
 * @param sizeLen length of the size array
*/
inline void RFont_font_add_string(RFont_font* font, const char* string, size_t* sizes, size_t sizeLen);

/**
 * @brief Add a string to the font's atlas based on a given string length.
 * @param font The font to use.
 * @param ch The character to add to the atlas.
 * @param strLen length of the string
 * @param sizes The supported sizes of the character.
 * @param sizeLen length of the size array
*/
inline void RFont_font_add_string_len(RFont_font* font, const char* string, size_t strLen, size_t* sizes, size_t sizeLen);

/**
 * @brief Get the area of the text based on the size using the font.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param size The size of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_text_area(RFont_font* font, const char* text, u32 size);

/**
 * @brief Get the area of the text based on the size using the font, using a given length.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param size The size of the text
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_text_area_spacing(RFont_font* font, const char* text, float spacing, u32 size);

/**
 * @brief Get the area of the text based on the size using the font, using a given length.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param len The length of the string
 * @param size The size of the text
 * @param stopNL the number of \n s until it stops (0 = don't stop until the end)
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_text_area_len(RFont_font* font, const char* text, size_t len, u32 size, size_t stopNL, float spacing);

/**
 * @brief Draw a text string using the font.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param x The x position of the text
 * @param y The y position of the text
 * @param size The size of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_draw_text(RFont_font* font, const char* text, float x, float y, u32 size);

/**
 * @brief Draw a text string using the font and a given spacing.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param x The x position of the text
 * @param y The y position of the text
 * @param size The size of the text
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_draw_text_spacing(RFont_font* font, const char* text, float x, float y, u32 size, float spacing);

/**
 * @brief Draw a text string using the font using a given length and a given spacing.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param len The length of the string
 * @param x The x position of the text
 * @param y The y position of the text
 * @param size The size of the text
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_draw_text_len(RFont_font* font, const char* text, size_t len, float x, float y, u32 size, float spacing);

#define RFont_set_color RFont_render_set_color

#ifndef RFONT_NO_GRAPHICS
/* 
    if you do not want to use opengl (or want to create your own implemntation of these functions), 
    you'll have to define these yourself 
    and add `#define RFONT_NO_OPENGL`
*/
inline void RFont_render_set_color(float r, float g, float b, float a); /* set the current rendering color */
inline void RFont_render_init(void); /* any initalizations the renderer needs to do */
inline u32 RFont_create_atlas(u32 atlasWidth, u32 atlasHeight); /* create a bitmap texture based on the given size */
inline void RFont_bitmap_to_atlas(u32 atlas, u8* bitmap, float x, float y, float w, float h); /* add the given bitmap to the texture based on the given coords and size data */
inline void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts); /* render the text, using the vertices, atlas texture, and texture coords given. */
inline void RFont_render_free(u32 atlas); /* free any memory the renderer might need to free */

/* (if modern opengl is being used) switch to rendering using opengl legacy or not */
inline void RFont_render_legacy(u8 legacy);
#endif

#endif /* RFONT_H */

#ifdef RFONT_IMPLEMENTATION

#ifdef RFONT_EXTERNAL_STB
#define STB_TRUETYPE_IMPLEMENTATION
#include "stb_truetype.h"
#endif

#ifndef RFONT_GET_TEXPOSX 
#define RFONT_GET_TEXPOSX(x) (float)((float)(x) / (float)(RFONT_ATLAS_WIDTH))
#define RFONT_GET_TEXPOSY(y) (float)((float)(y) / (float)(RFONT_ATLAS_HEIGHT))
#endif

#ifndef RFONT_GET_WORLD_X
#define RFONT_GET_WORLD_X(x, w) (float)((x) / (((w) / 2.0f)) - 1.0f)
#define RFONT_GET_WORLD_Y(y, h) (float)(1.0f - ((y) / ((h) / 2.0f)))
#endif

/* 
stb defines required by RFont

you probably don't care about this part if you're reading just the RFont code
*/

#ifndef RFONT_EXTERNAL_STB
// private structure
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

typedef struct stbtt_fontinfo stbtt_fontinfo;

struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              // pointer to .ttf file
   int              fontstart;         // offset of start of font

   int numGlyphs;                     // number of glyphs, needed for range checking

   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf
   int index_map;                     // a cmap mapping for our chosen character encoding
   int indexToLocFormat;              // format needed to map from glyph index to glyph

   stbtt__buf cff;                    // cff font data
   stbtt__buf charstrings;            // the charstring index
   stbtt__buf gsubrs;                 // global charstring subroutines index
   stbtt__buf subrs;                  // private charstring subroutines index
   stbtt__buf fontdicts;              // array of font dicts
   stbtt__buf fdselect;               // map from glyph to fontdict
};

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern inline
#endif

STBTT_DEF i16 ttSHORT(u8 *p);
STBTT_DEF u16 ttUSHORT(u8 *p); 
STBTT_DEF u32 ttULONG(u8 *p);

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);

STBTT_DEF unsigned char* stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
#endif /* RFONT_EXTERNAL_STB */

/* 
END of stb defines required by RFont

you probably care about this part 
*/

#ifndef RFONT_NO_FMT
#include <stdarg.h>

const char* RFont_fmt(const char* string, ...) {
   static char output[RFONT_TEXTFORMAT_MAX_SIZE];

   va_list args;
   va_start(args, string);
   
   RFONT_VSNPRINTF(output, RFONT_TEXTFORMAT_MAX_SIZE, string, args);
   va_end(args);

   return output;
}
#endif

struct RFont_font {
   stbtt_fontinfo info; /* source stb font */
   b8 free_font_memory;
   float fheight; /* font height from stb */
   float descent; /* font descent */
   float numOfLongHorMetrics;
   float space_adv;

   RFont_glyph glyphs[RFONT_MAX_GLYPHS]; /* glyphs */
   size_t glyph_len;

   u32 atlas; /* atlas texture */
   float atlasX; /* the current x position inside the atlas */
};

size_t RFont_width = 0, RFont_height = 0;

float* RFont_verts;
float* RFont_tcoords;

RFont_font* font2;

void RFont_update_framebuffer(size_t width, size_t height) {
   /* set size of the framebuffer (for rendering later on) */
   RFont_width = width;
   RFont_height = height;
}

void RFont_init(size_t width, size_t height) {
    RFont_update_framebuffer(width, height);

    #ifndef RFONT_NO_GRAPHICS
    /* init any rendering stuff that needs to be initalized (eg. vbo objects) */
    RFont_render_init();
    #endif

   RFont_verts = malloc(sizeof(float) * RFONT_INIT_VERTS * 600);
   RFont_tcoords = malloc(sizeof(float) * RFONT_INIT_VERTS * 600);
}

#ifndef RFONT_NO_STDIO
RFont_font* RFont_font_init(const char* font_name) {
   FILE* ttf_file = fopen(font_name, "rb");

   fseek(ttf_file, 0U, SEEK_END);
   size_t size = ftell(ttf_file);

   char* ttf_buffer = (char*)malloc(sizeof(char) * size); 
   fseek(ttf_file, 0U, SEEK_SET);

   size_t out = fread(ttf_buffer, 1, size, ttf_file);
   RFONT_UNUSED(out)


   return RFont_font_init_data((u8*)ttf_buffer, 1);
}
#endif

RFont_font* RFont_font_init_data(u8* font_data, b8 auto_free) {
   RFont_font* font = (RFont_font*)malloc(sizeof(RFont_font));

   stbtt_InitFont(&font->info, font_data, 0);

   font->fheight = ttSHORT(font->info.data + font->info.hhea + 4) - ttSHORT(font->info.data + font->info.hhea + 6);
   font->descent = ttSHORT(font->info.data + font->info.hhea + 6);

   font->numOfLongHorMetrics = ttUSHORT(font->info.data + font->info.hhea + 34);
   font->space_adv = ttSHORT(font->info.data + font->info.hmtx + 4 * (u32)(font->numOfLongHorMetrics - 1));
 

   #ifndef RFONT_NO_GRAPHICS
   font->atlas = RFont_create_atlas(RFONT_ATLAS_WIDTH, RFONT_ATLAS_HEIGHT);
   #endif
   font->atlasX = 0;
   font->glyph_len = 0;

   font->free_font_memory = auto_free;
   
   return font;
}

void RFont_font_free(RFont_font* font) {
   #ifndef RFONT_NO_GRAPHICS
   RFont_render_free(font->atlas);
   #endif

   if (font->free_font_memory)
      free(font->info.data);
   
   free(font);
}

void RFont_close(void) {
   free(RFont_verts);
   free(RFont_tcoords);
}


/*
decode utf8 character to codepoint 
*/

// Copyright (c) 2008-2010 Bjoern Hoehrmann <bjoern@hoehrmann.de>
// See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.

#define RFONT_UTF8_ACCEPT 0
#define RFont_UTF8_REJECT 12

inline static u32 RFont_decode_utf8(u32* state, u32* codep, u32 byte);

static u32 RFont_decode_utf8(u32* state, u32* codep, u32 byte) {
   static const uint8_t utf8d[] = {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..1f
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 20..3f
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40..5f
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60..7f
      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, // 80..9f
      7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, // a0..bf
      8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // c0..df
      0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, // e0..ef
      0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, // f0..ff
      0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, // s0..s0
      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, // s1..s2
      1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, // s3..s4
      1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, // s5..s6
      1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // s7..s8
   };

   uint32_t type = utf8d[byte];

   *codep = (*state != RFONT_UTF8_ACCEPT) ?
      (byte & 0x3fu) | (*codep << 6) :
      (0xff >> type) & (byte);

   *state = utf8d[256 + *state * 16 + type];
   return *state;
}

void RFont_font_add_string(RFont_font* font, const char* string, size_t* sizes, size_t sizeLen) {
   RFont_font_add_string_len(font, string, 0, sizes, sizeLen);
}

void RFont_font_add_string_len(RFont_font* font, const char* string, size_t strLen, size_t* sizes, size_t sizeLen) {
   u32 i;
   char* str;
   for (str = (char*)string; (!strLen || (size_t)(str - string) < strLen) && *str; str++)
      for (i = 0; i < sizeLen; i++)
         RFont_font_add_char(font, *str, sizes[i]);
}


RFont_glyph RFont_font_add_char(RFont_font* font, char ch, size_t size) {
   static u32 utf8state = 0, codepoint = 0; 

   if (RFont_decode_utf8(&utf8state, &codepoint, (u8)ch) != RFONT_UTF8_ACCEPT)
      return (RFont_glyph){0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

	u32 i;
   for (i = 0; i < font->glyph_len; i++)
      if (font->glyphs[i].codepoint == codepoint && font->glyphs[i].size == size)
         return font->glyphs[i];

   RFont_glyph* glyph = &font->glyphs[i];

   glyph->src = stbtt_FindGlyphIndex(&font->info, codepoint);

   if (glyph->src == 0 && font2 != NULL && font2->info.data != font->info.data) {
      stbtt_fontinfo saveInfo = font->info;

      RFont_font* fakeFont = font;
      fakeFont->info = font2->info;

      RFont_glyph g = RFont_font_add_char(fakeFont, 't', size);

      fakeFont->info = saveInfo;

      return g;
   }

   font->glyph_len++;

   i32 x0, y0, x1, y1, w = 0, h = 0;
   if (stbtt_GetGlyphBox(&font->info, glyph->src, &x0, &y0, &x1, &y1) == 0)
      return (RFont_glyph){0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

   float scale = ((float)size) / font->fheight;

   u8* bitmap =  stbtt_GetGlyphBitmapSubpixel(&font->info, 0, scale, 0.0f, 0.0f, glyph->src, &w, &h, 0, 0);

   glyph->w = (float)w;
   glyph->h = (float)h;

   glyph->codepoint = codepoint;
   glyph->size = size;
   glyph->x = font->atlasX;
   glyph->x2 = font->atlasX + glyph->w;
   glyph->x1 = floorf(x0 * scale);
   glyph->y1 = floor(-y1 * scale);

   #ifndef RFONT_NO_GRAPHICS
   RFont_bitmap_to_atlas(font->atlas, bitmap, font->atlasX, 0, glyph->w, glyph->h);
   #endif

   font->atlasX += glyph->w;

   free(bitmap);

   i32 advanceX;
   
   if (glyph->src < font->numOfLongHorMetrics)
      advanceX = ttSHORT(font->info.data + font->info.hmtx + 4 * glyph->src);
   else
      advanceX = ttSHORT(font->info.data + font->info.hmtx + 4 * (u32)(font->numOfLongHorMetrics - 1));

   glyph->advance = advanceX * scale;

   return *glyph;
}

RFont_area RFont_text_area(RFont_font* font, const char* text, u32 size) {
   return RFont_text_area_len(font, text, 0, size, 0, 0.0f);
}

RFont_area RFont_text_area_spacing(RFont_font* font, const char* text, float spacing, u32 size) {
   return RFont_text_area_len(font, text, 0, size, 0, spacing);
}

RFont_area RFont_text_area_len(RFont_font* font, const char* text, size_t len, u32 size, size_t stopNL, float spacing) {
   float x = 0;
   size_t y = 1;

   char* str;

   float scale = (((float)size) / font->fheight);

   float space_adv = (scale * font->space_adv) / 2;
   
   for (str = (char*)text; (len == 0 || (size_t)(str - text) < len) && *str; str++) {        
      if (*str == '\n') { 
         if (y == stopNL)
            return (RFont_area){(u32)x, y * size};
         
         y++;
         x = 0;
         continue;
      }
      
      if (*str == ' ' || *str == '\t') {
         x += space_adv + spacing;
         continue;
      }

      RFont_glyph glyph = RFont_font_add_char(font,  *str, size);

      if (glyph.codepoint == 0 && glyph.size == 0)
         continue;
      
      x += (float)glyph.advance + spacing;
   }

   return (RFont_area){(u32)x, y * size};
}

RFont_area RFont_draw_text(RFont_font* font, const char* text, float x, float y, u32 size) {
   return RFont_draw_text_len(font, text, 0, x, y, size, 0.0f);
}

RFont_area RFont_draw_text_spacing(RFont_font* font, const char* text, float x, float y, u32 size, float spacing) {
   return RFont_draw_text_len(font, text, 0, x, y, size, spacing);
}

RFont_area RFont_draw_text_len(RFont_font* font, const char* text, size_t len, float x, float y, u32 size, float spacing) {
   float* verts = RFont_verts;
   float* tcoords = RFont_tcoords;

   float startX = x;
   float startY = y;
   
   y += size;

   u32 i = 0;
   u32 tIndex = 0;

   char* str;

   float scale = (((float)size) / font->fheight);
   float space_adv = (scale * font->space_adv) / 2;

   y -= (-font->descent * scale);

   for (str = (char*)text; (len == 0 || (size_t)(str - text) < len) && *str; str++) {        
      if (*str == '\n') { 
         x = startX;
         y += size;
         continue;
      }

      if (*str == ' ' || *str == '\t') {
         x += space_adv + spacing;
         continue;
      }

      RFont_glyph glyph = RFont_font_add_char(font, *str, size);

      if (glyph.codepoint == 0 && glyph.size == 0)
         continue;

      float realX = x + glyph.x1;
      float realY = y + glyph.y1;

      verts[i] = RFONT_GET_WORLD_X((i32)realX, RFont_width); 
      verts[i + 1] = RFONT_GET_WORLD_Y(realY, RFont_height);
      verts[i + 2] = 0;
      /*  */
      verts[i + 3] = RFONT_GET_WORLD_X((i32)realX, RFont_width);
      verts[i + 4] = RFONT_GET_WORLD_Y(realY + glyph.h , RFont_height);
      verts[i + 5] = 0;
      /*  */
      verts[i + 6] = RFONT_GET_WORLD_X((i32)(realX + glyph.w), RFont_width);
      verts[i + 7] = RFONT_GET_WORLD_Y(realY + glyph.h , RFont_height);
      verts[i + 8] = 0;
      /*  */
      /*  */
      verts[i + 9] = RFONT_GET_WORLD_X((i32)(realX + glyph.w), RFont_width);
      verts[i + 10] = RFONT_GET_WORLD_Y(realY, RFont_height);
      verts[i + 11] = 0;
      /*  */
      verts[i + 12] = RFONT_GET_WORLD_X((i32)realX, RFont_width); 
      verts[i + 13] = RFONT_GET_WORLD_Y(realY, RFont_height);
      verts[i + 14] = 0;
      /*  */

      verts[i + 15] = RFONT_GET_WORLD_X((i32)(realX + glyph.w), RFont_width);
      verts[i + 16] = RFONT_GET_WORLD_Y(realY + glyph.h , RFont_height);
      verts[i + 17] = 0;

      /* texture coords */

      //#if defined(RFONT_RENDER_LEGACY) || defined(RFONT_RENDER_RGL)
      tcoords[tIndex] = RFONT_GET_TEXPOSX(glyph.x);
      tcoords[tIndex + 1] = 0;
      //#endif

      /*  */
      tcoords[tIndex + 2] = RFONT_GET_TEXPOSX(glyph.x); 
      tcoords[tIndex + 3] = RFONT_GET_TEXPOSY(glyph.h);
      /*  */
      tcoords[tIndex + 4] = RFONT_GET_TEXPOSX(glyph.x2);
      tcoords[tIndex + 5] = RFONT_GET_TEXPOSY(glyph.h);
      /*  */
      /*  */
      tcoords[tIndex + 6] = RFONT_GET_TEXPOSX(glyph.x2);
      tcoords[tIndex + 7] = 0;
      /*  */
      tcoords[tIndex + 8] = RFONT_GET_TEXPOSX(glyph.x);
      tcoords[tIndex + 9] = 0;
      /*  */ 
      tcoords[tIndex + 10] = RFONT_GET_TEXPOSX(glyph.x2);
      tcoords[tIndex + 11] = RFONT_GET_TEXPOSY(glyph.h);

      i += 18;
      tIndex += 12;

      x += glyph.advance + spacing;
   }

   #ifndef RFONT_NO_GRAPHICS
   RFont_render_text(font->atlas, verts, tcoords, i / 3);
   #endif
   
   return (RFont_area){(u32)(x - startX), (u32)(y - startY) + (-font->descent * scale)};
}

#ifndef __APPLE__
#include <GL/gl.h>
#else
#include <OpenGL/gl.h>
#endif

#if !defined(RFONT_NO_OPENGL) && !defined(RFONT_NO_GRAPHICS)

#if !defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL)
#define GL_GLEXT_PROTOTYPES
#endif

#ifndef GL_PERSPECTIVE_CORRECTION_HINT
#define GL_PERSPECTIVE_CORRECTION_HINT		0x0C50
#endif

#ifndef GL_TEXTURE_SWIZZLE_RGBA
#define GL_TEXTURE_SWIZZLE_RGBA           0x8E46
#endif

#ifndef GL_TEXTURE0
#define GL_TEXTURE0				0x84C0
#endif

#ifndef GL_CLAMP_TO_EDGE
#define GL_CLAMP_TO_EDGE			0x812F
#endif

#ifdef RFONT_DEBUG

#ifndef GL_DEBUG_TYPE_ERROR
#define GL_DEBUG_TYPE_ERROR               0x824C
#define GL_DEBUG_OUTPUT                   0x92E0
#define GL_DEBUG_OUTPUT_SYNCHRONOUS       0x8242
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_INFO_LOG_LENGTH                0x8B84 
#endif

void RFont_debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char* message, const void* userParam) {
    RFONT_UNUSED(source) RFONT_UNUSED(id) RFONT_UNUSED(severity) RFONT_UNUSED(length) RFONT_UNUSED(userParam)

    if (type != GL_DEBUG_TYPE_ERROR)
        return;

    printf("OpenGL Debug Message: %s\n", message);
}

void RFont_opengl_getError(void) {
    GLenum err;
    while ((err = glGetError()) != GL_NO_ERROR) {
         switch (err) {
            case GL_INVALID_ENUM:
                  printf("OpenGL error: GL_INVALID_ENUM\n");
                  break;
            case GL_INVALID_VALUE:
                  printf("OpenGL error: GL_INVALID_VALUE\n");
                  break;
            case GL_INVALID_OPERATION:
                  printf("OpenGL error: GL_INVALID_OPERATION\n");
                  break;
            case GL_STACK_OVERFLOW:
                  printf("OpenGL error: GL_STACK_OVERFLOW\n");
                  break;
            case GL_STACK_UNDERFLOW:
                  printf("OpenGL error: GL_STACK_UNDERFLOW\n");
                  break;	
            default:
                  printf("OpenGL error: Unknown error code 0x%x\n", err);
                  break;
         }
         exit(1);
    }
}

#endif

u32 RFont_create_atlas(u32 atlasWidth, u32 atlasHeight) {
 #if defined(RFONT_DEBUG) && !defined(RFONT_RENDER_LEGACY)
   glEnable(GL_DEBUG_OUTPUT);
   #endif
   
   u32 id = 0;
   glEnable(GL_TEXTURE_2D);
   
   glBindTexture(GL_TEXTURE_2D, 0);
   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
   glGenTextures(1, &id);

   glBindTexture(GL_TEXTURE_2D, id);

   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
   
   u8* data = (u8*)calloc(atlasWidth * atlasHeight * 4, sizeof(u8));

   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, atlasWidth, atlasHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

   free(data);

   glBindTexture(GL_TEXTURE_2D, id);
	static GLint swizzleRgbaParams[4] = {GL_ONE, GL_ONE, GL_ONE, GL_RED};
	glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzleRgbaParams);

   glBindTexture(GL_TEXTURE_2D, 0);
   return id;
}

#ifndef GL_UNPACK_ROW_LENGTH
#define GL_UNPACK_ROW_LENGTH 0x0CF2
#define GL_UNPACK_SKIP_PIXELS 0x0CF4
#define GL_UNPACK_SKIP_ROWS 0x0CF3
#endif


void RFont_push_pixel_values(GLint alignment, GLint rowLength, GLint skipPixels, GLint skipRows);
void RFont_push_pixel_values(GLint alignment, GLint rowLength, GLint skipPixels, GLint skipRows) {
	glPixelStorei(GL_UNPACK_ALIGNMENT, alignment);
	glPixelStorei(GL_UNPACK_ROW_LENGTH, rowLength);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS, skipPixels);
	glPixelStorei(GL_UNPACK_SKIP_ROWS, skipRows);
}

void RFont_bitmap_to_atlas(u32 atlas, u8* bitmap, float x, float y, float w, float h) {
   glEnable(GL_TEXTURE_2D);
   
	GLint alignment, rowLength, skipPixels, skipRows;
   glGetIntegerv(GL_UNPACK_ALIGNMENT, &alignment);
	glGetIntegerv(GL_UNPACK_ROW_LENGTH, &rowLength);
	glGetIntegerv(GL_UNPACK_SKIP_PIXELS, &skipPixels);
	glGetIntegerv(GL_UNPACK_SKIP_ROWS, &skipRows);
   
   #if !defined(RFONT_RENDER_LEGACY)
   glActiveTexture(GL_TEXTURE0 + atlas - 1);
   #endif

	glBindTexture(GL_TEXTURE_2D, atlas);

	RFont_push_pixel_values(1, w, 0, 0);

	glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, w, h, GL_RED, GL_UNSIGNED_BYTE, bitmap);

	RFont_push_pixel_values(alignment, rowLength, skipPixels, skipRows);

   glBindTexture(GL_TEXTURE_2D, 0);
}

#if defined(RFONT_RENDER_RGL) && !defined(RFONT_CUSTOM_GL)

void RFont_render_set_color(float r, float g, float b, float a) {
   rglColor4f(r, g, b, a);
}

void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
   glEnable(GL_TEXTURE_2D);
   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
   glShadeModel(GL_SMOOTH);

   rglMatrixMode(RGL_MODELVIEW);
   rglLoadIdentity();
	rglPushMatrix();

   glDisable(GL_DEPTH_TEST);
   glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_CULL_FACE);    

   glEnable(GL_BLEND);
   glEnable(GL_TEXTURE_2D);
   
   glActiveTexture(GL_TEXTURE0);

   rglSetTexture(atlas);
   
	rglBegin(RGL_TRIANGLES_2D);

	size_t i;
   size_t tIndex = 0;

	for (i = 0; i < (nverts * 3); i += 3) {
		rglTexCoord2f(tcoords[tIndex], tcoords[tIndex + 1]);
      tIndex += 2;
		
      rglVertex2f(verts[i], verts[i + 1]);
	}
	rglEnd();
	rglPopMatrix();
   
   rglSetTexture(0);
   glBindTexture(GL_TEXTURE_2D, 0);
   glEnable(GL_DEPTH_TEST);
}

void RFont_render_free(u32 atlas) { glDeleteTextures(1, &atlas); }
void RFont_render_legacy(u8 legacy) { rglLegacy(legacy); }
void RFont_render_init() {}
#endif /* RFONT_RENDER_RGL */

#if defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL) && !defined(RFONT_CUSTOM_GL)

void RFont_render_set_color(float r, float g, float b, float a) {
   glColor4f(r, g, b, a);
}

void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
   glEnable(GL_TEXTURE_2D);
   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
   glShadeModel(GL_SMOOTH);

   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   glDisable(GL_DEPTH_TEST);
   glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_CULL_FACE);    

   glEnable(GL_BLEND);
   glEnable(GL_TEXTURE_2D);
   #if !defined(RFONT_RENDER_LEGACY)
   glActiveTexture(GL_TEXTURE0 + atlas - 1);
   #endif

   glBindTexture(GL_TEXTURE_2D, atlas);

	glPushMatrix();

	glBegin(GL_TRIANGLES);

	size_t i;
   size_t tIndex = 0;

	for (i = 0; i < (nverts * 3); i += 3) {
		glTexCoord2f(tcoords[tIndex], tcoords[tIndex + 1]);
		tIndex += 2;

      glVertex2f(verts[i], verts[i + 1]);
	}
	glEnd();
	glPopMatrix();

   glBindTexture(GL_TEXTURE_2D, 0);
   glEnable(GL_DEPTH_TEST);
}

void RFont_render_free(u32 atlas) { glDeleteTextures(1, &atlas); }
void RFont_render_legacy(u8 legacy) { RFONT_UNUSED(legacy) }
void RFont_render_init() {}
#endif /* defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL)  */

#if !defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL)
typedef struct {
   GLuint vao, vbo, tbo, cbo, ebo,
            program, vShader, fShader;
   
   u8 legacy;
} RFont_gl_info;

RFont_gl_info RFont_gl = { 0 };

float RFont_color[4] = {0, 0, 0, 1};

#ifdef RFONT_DEBUG
inline void RFont_debug_shader(u32 src, const char* shader, const char* action);
void RFont_debug_shader(u32 src, const char* shader, const char* action) {
    GLint status;
    if (action[0] == 'l')
        glGetProgramiv(src, GL_LINK_STATUS, &status);
    else
        glGetShaderiv(src, GL_COMPILE_STATUS, &status);

    if (status == GL_TRUE) 
        printf("%s Shader %s successfully.\n", shader, action);
    else {
        printf("%s Shader failed to %s.\n", shader, action);

        if (action[0] == 'c') {
            GLint infoLogLength;
            glGetShaderiv(src, GL_INFO_LOG_LENGTH, &infoLogLength);

            if (infoLogLength > 0) {
                GLchar* infoLog = (GLchar*)malloc(infoLogLength);
                glGetShaderInfoLog(src, infoLogLength, NULL, infoLog);
                printf("%s Shader info log:\n%s\n", shader, infoLog);
                free(infoLog);
            }
        }
        
        RFont_opengl_getError();
    }
}
#endif

#define RFONT_MULTILINE_STR(...) #__VA_ARGS__

void RFont_render_set_color(float r, float g, float b, float a) {
   if (RFont_gl.legacy)
      return glColor4f(r, g, b, a);
   
   RFont_color[0] = r;
   RFont_color[1] = g;
   RFont_color[2] = b;
   RFont_color[3] = a;
}

void RFont_render_init() {
   if (RFont_gl.vao != 0 || RFont_gl.legacy)
      return;

   static const char* defaultVShaderCode = RFONT_MULTILINE_STR(
      \x23version 330 core       \n
      layout (location = 0) in vec3 vertexPosition;
      layout (location = 1) in vec2 vertexTexCoord;
      layout (location = 2) in vec4 inColor;
      out vec2 fragTexCoord;
      out vec4 fragColor;

      uniform mat4 mvp;          \n
      void main() {
         fragColor = inColor;
         gl_Position = vec4(vertexPosition, 1.0);
         fragTexCoord = vertexTexCoord;
      }
   );

   static const char* defaultFShaderCode = RFONT_MULTILINE_STR(
      \x23version 330 core                \n
      out vec4 FragColor;
      
      in vec4 fragColor;
      in vec2 fragTexCoord;

      uniform sampler2D texture0;

      void main() {
         FragColor = texture(texture0, fragTexCoord) * fragColor;
      }
   );
   
   glGenVertexArrays(1, &RFont_gl.vao);
   glBindVertexArray(RFont_gl.vao);

   glGenBuffers(1, &RFont_gl.vbo);
   glGenBuffers(1, &RFont_gl.tbo);
   glGenBuffers(1, &RFont_gl.cbo);
   glGenBuffers(1, &RFont_gl.ebo);
   /* compile vertex shader */
   RFont_gl.vShader = glCreateShader(GL_VERTEX_SHADER);
   glShaderSource(RFont_gl.vShader, 1, &defaultVShaderCode, NULL);
   glCompileShader(RFont_gl.vShader);

   #ifdef RFONT_DEBUG
   RFont_debug_shader(RFont_gl.vShader, "Vertex", "compile");
   #endif

   /* compile fragment shader */
   RFont_gl.fShader = glCreateShader(GL_FRAGMENT_SHADER);
   glShaderSource(RFont_gl.fShader, 1, &defaultFShaderCode, NULL);
   glCompileShader(RFont_gl.fShader);


   #ifdef RFONT_DEBUG
   RFont_debug_shader(RFont_gl.fShader, "Fragment", "compile");
   #endif

   /* create program and link vertex and fragment shaders */
   RFont_gl.program = glCreateProgram();

   glAttachShader(RFont_gl.program, RFont_gl.vShader);
   glAttachShader(RFont_gl.program, RFont_gl.fShader);

   glBindAttribLocation(RFont_gl.program, 0, "vertexPosition");
   glBindAttribLocation(RFont_gl.program, 1, "vertexTexCoord");
   glBindAttribLocation(RFont_gl.program, 2, "inColor");

   glLinkProgram(RFont_gl.program);

   #ifdef RFONT_DEBUG
   RFont_debug_shader(RFont_gl.program, "Both", "link to the program");
   #endif
}
     
void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
   glEnable(GL_TEXTURE_2D);
   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

   glDisable(GL_DEPTH_TEST);
   glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_CULL_FACE);    

   glEnable(GL_BLEND);
   glShadeModel(GL_SMOOTH);

   if (RFont_gl.legacy) {
      glMatrixMode(GL_MODELVIEW);
      glLoadIdentity();

      glBindTexture(GL_TEXTURE_2D, atlas);
      glPushMatrix();

      glBegin(GL_TRIANGLES);

      size_t i;
      size_t tIndex = 0;

      for (i = 0; i < (nverts * 3); i += 3) {
         glTexCoord2f(tcoords[tIndex], tcoords[tIndex + 1]);
         tIndex += 2;
         
         glVertex2f(verts[i], verts[i + 1]);
      }
      glEnd();
      glPopMatrix();
   } else {
      glBindVertexArray(RFont_gl.vao);

      glUseProgram(RFont_gl.program);

      glEnableVertexAttribArray(0);
      glBindBuffer(GL_ARRAY_BUFFER, RFont_gl.vbo);
      glBufferData(GL_ARRAY_BUFFER, nverts * 3 * sizeof(float), verts, GL_DYNAMIC_DRAW);
      glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL);

      glEnableVertexAttribArray(1);
      glBindBuffer(GL_ARRAY_BUFFER, RFont_gl.tbo);
      glBufferData(GL_ARRAY_BUFFER, nverts * 2 * sizeof(float), tcoords, GL_DYNAMIC_DRAW);
      glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, NULL);

      float* colors = malloc(sizeof(float) * nverts * 4);

      u32 i = 0;
      for (i = 0; i < (nverts * 4); i += 4) {
         colors[i] = RFont_color[0];
         colors[i + 1] = RFont_color[1];
         colors[i + 2] = RFont_color[2];
         colors[i + 3] = RFont_color[3];
      }

      glEnableVertexAttribArray(2);
      glBindBuffer(GL_ARRAY_BUFFER, RFont_gl.cbo);
      glBufferData(GL_ARRAY_BUFFER, nverts * 4 * sizeof(float), colors, GL_DYNAMIC_DRAW);
      glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, 0, NULL);

      free(colors);

      GLushort* indices = malloc(sizeof(GLushort) * 6 * nverts);
      int k = 0;

      u32 j;
      for (j = 0; j < (6 * nverts); j += 6) {
         indices[j] = 4*  k;
         indices[j + 1] = 4*k + 1;
         indices[j + 2] = 4*k + 2;
         indices[j + 3] = 4*k;
         indices[j + 4] = 4*k + 2;
         indices[j + 5] = 4*k + 3;

         k++;
      }

      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, RFont_gl.ebo);
      glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLushort) * 6 * nverts, indices, GL_STATIC_DRAW);

      free(indices);

      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, atlas);

      glDrawArrays(GL_TRIANGLES, 0, nverts);   
      glUseProgram(0);
   }

   glBindTexture(GL_TEXTURE_2D, 0);
	glDisable(GL_TEXTURE_2D);
   glEnable(GL_DEPTH_TEST);
}

void RFont_render_free(u32 atlas) {
   glDeleteTextures(1, &atlas);

   if (RFont_gl.vao == 0 || RFont_gl.legacy)
      return;
   
   /* free vertex array */
   glDeleteVertexArrays(1, &RFont_gl.vao);
   RFont_gl.vao = 0;

   /* free buffers */
   glDeleteBuffers(1, &RFont_gl.tbo);
   glDeleteBuffers(1, &RFont_gl.vbo);

   /* free program data */
   glDeleteShader(RFont_gl.vShader);
   glDeleteShader(RFont_gl.fShader);
   glDeleteProgram(RFont_gl.program);
}

void RFont_render_legacy(u8 legacy) { RFont_gl.legacy = legacy; }

#endif /* !defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL) */
#endif /*  !defined(RFONT_NO_OPENGL) && !defined(RFONT_NO_GRAPHICS) */

/* 
stb_truetype defines and source code required by RFont

you probably don't care about this part if you're reading just the RFont code
*/

#ifndef RFONT_EXTERNAL_STB
   typedef char stbtt__check_size32[sizeof(i32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(i16)==2 ? 1 : -1];

   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
   #ifndef STBTT_malloc
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

#ifdef __cplusplus
extern "C" {
#endif

// as above, but takes one or more glyph indices for greater efficiency

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
                   // (we share this with other code at RAD)
   #define stbtt_vertex_type short // can't use i16 because that's not visible in the header file
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);

// @TODO: don't expose this structure
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

// rasterize a shape with quadratic beziers into a bitmap
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
                               float flatness_in_pixels,     // allowable error of curve in pixels
                               stbtt_vertex *vertices,       // array of vertices defining shape
                               int num_verts,                // number of vertices in above array
                               float scale_x, float scale_y, // scale applied to input vertices
                               float shift_x, float shift_y, // translation applied to input vertices
                               int x_off, int y_off,         // another translation applied to input
                               int invert,                   // if non-zero, vertically flip shape
                               void *userdata);              // context for to STBTT_MALLOC

enum { // platformID
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { // languageID for STBTT_PLATFORM_ID_MAC
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

STBTT_DEF u8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

STBTT_DEF u8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

STBTT_DEF void stbtt__buf_seek(stbtt__buf *b, int o)
{
   assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

STBTT_DEF void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

STBTT_DEF u32 stbtt__buf_get(stbtt__buf *b, int n)
{
   u32 v = 0;
   int i;
   assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

STBTT_DEF stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   assert(size < 0x40000000);
   r.data = (u8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

STBTT_DEF stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

STBTT_DEF stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

STBTT_DEF u32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   assert(0);
   return 0;
}

STBTT_DEF void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

STBTT_DEF stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

STBTT_DEF void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, u32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

STBTT_DEF int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

STBTT_DEF stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   assert(i >= 0 && i < count);
   assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

#define ttBYTE(p)     (* (u8 *) (p))
#define ttCHAR(p)     (* (i8 *) (p))
#define ttFixed(p)    ttLONG(p)

STBTT_DEF i16 ttSHORT(u8 *p)   { return p[0]*256 + p[1]; }
STBTT_DEF u16 ttUSHORT(u8 *p) { return p[0]*256 + p[1]; }
STBTT_DEF u32 ttULONG(u8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)          stbtt_tag4(p,str[0],str[1],str[2],str[3])

// @OPTIMIZE: binary search
STBTT_DEF u32 stbtt__find_table(u8 *data, u32 fontstart, const char *tag)
{
   i32 num_tables = ttUSHORT(data+fontstart+4);
   u32 tabledir = fontstart + 12;
   i32 i;
   for (i=0; i < num_tables; ++i) {
      u32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

STBTT_DEF stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   u32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

STBTT_DEF void stbtt_setvertex(stbtt_vertex *v, u8 type, i32 x, i32 y, i32 cx, i32 cy)
{
   v->type = type;
   v->x = (i16) x;
   v->y = (i16) y;
   v->cx = (i16) cx;
   v->cy = (i16) cy;
}

STBTT_DEF int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    i32 sx, i32 sy, i32 scx, i32 scy, i32 cx, i32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

STBTT_DEF int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index);

STBTT_DEF int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   i16 numberOfContours;
   u8 *endPtsOfContours;
   u8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      u8 flags=0,flagcount;
      i32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      i32 x,y,cx,cy,sx,sy, scx,scy;
      u8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

      // first load flags

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      // now load x coordinates
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            i16 dx = *points++;
            x += (flags & 16) ? dx : -dx; // ???
         } else {
            if (!(flags & 16)) {
               x = x + (i16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (i16) x;
      }

      // now load y coordinates
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            i16 dy = *points++;
            y += (flags & 32) ? dy : -dy; // ???
         } else {
            if (!(flags & 32)) {
               y = y + (i16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (i16) y;
      }

      // now convert them to our format
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (i16) vertices[off+i].x;
         y     = (i16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            // now start the new one
            start_off = !(flags & 1);
            if (start_off) {
               // if we start off with an off-curve point, then when we need to find a point on the curve
               // where we can start, and we need to save some state for when we wraparound.
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  // next point is also a curve point, so interpolate an on-point curve
                  sx = (x + (i32) vertices[off+i+1].x) >> 1;
                  sy = (y + (i32) vertices[off+i+1].y) >> 1;
               } else {
                  // otherwise just use the next point as our start point
                  sx = (i32) vertices[off+i+1].x;
                  sy = (i32) vertices[off+i+1].y;
                  ++i; // we're using point i+1 as the starting point, so skip it
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { // if it's a curve
               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours < 0) {
      // Compound shapes.
      int more = 1;
      u8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         u16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;

         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { // XY values
            if (flags & 1) { // shorts
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            // @TODO handle matching point
            assert(0);
         }
         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }

         // Find transformation scales.
         m = (float) sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         // Get indexed glyph.
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            // Transform vertices.
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            // Append vertices.
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0) memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
            memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         // More components ?
         more = flags & (1<<5);
      }
   } else {
      // numberOfCounters == 0, do nothing
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   i32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

STBTT_DEF void stbtt__track_vertex(stbtt__csctx *c, i32 x, i32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

STBTT_DEF void stbtt__csctx_v(stbtt__csctx *c, u8 type, i32 x, i32 y, i32 cx, i32 cy, i32 cx1, i32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (i16) cx1;
      c->pvertices[c->num_vertices].cy1 = (i16) cy1;
   }
   c->num_vertices++;
}

STBTT_DEF void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

STBTT_DEF void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

STBTT_DEF void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

STBTT_DEF void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

STBTT_DEF stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

STBTT_DEF stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      // untested
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) stbtt__new_buf(NULL, 0);
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

STBTT_DEF int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   // this currently ignores the initial width value, which isn't needed if we have hmtx
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      // @TODO implement hinting
      case 0x13: // hintmask
      case 0x14: // cntrmask
         if (in_header)
            maskbits += (sp / 2); // implicit "vstem"
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: // hstem
      case 0x03: // vstem
      case 0x12: // hstemhm
      case 0x17: // vstemhm
         maskbits += (sp / 2);
         break;

      case 0x15: // rmoveto
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: // vmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: // hmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: // rlineto
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
      // starting from a different place.

      case 0x07: // vlineto
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: // hlineto
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: // hvcurveto
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: // vhcurveto
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: // rrcurveto
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: // rcurveline
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: // rlinecurve
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: // vvcurveto
      case 0x1B: // hhcurveto
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: // callsubr
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         // fallthrough
      case 0x1D: // callgsubr
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: // return
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: // endchar
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { // two-byte escape
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         // @TODO These "flex" implementations ignore the flex-depth and resolution,
         // and always draw beziers.
         case 0x22: // hflex
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: // flex
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            //fd is s[12]
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: // hflex1
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: // flex1
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (fabs(dx) > fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254))
            return STBTT__CSERR("reserved operator");

         // push immediate
         if (b0 == 255) {
            f = (float)(i32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(i16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

STBTT_DEF int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   // runs the charstring twice, once to count and once to output (to avoid realloc)
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   u8 *data = info->data + info->kern;
   u32 needle, straw;
   int l, r, m;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); // note: unaligned read
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

STBTT_DEF i32  stbtt__GetCoverageIndex(u8 *coverageTable, int glyph)
{
    u16 coverageFormat = ttUSHORT(coverageTable);
    switch(coverageFormat) {
        case 1: {
            u16 glyphCount = ttUSHORT(coverageTable + 2);

            // Binary search.
            i32 l=0, r=glyphCount-1, m;
            int straw, needle=glyph;
            while (l <= r) {
                u8 *glyphArray = coverageTable + 4;
                u16 glyphID;
                m = (l + r) >> 1;
                glyphID = ttUSHORT(glyphArray + 2 * m);
                straw = glyphID;
                if (needle < straw)
                    r = m - 1;
                else if (needle > straw)
                    l = m + 1;
                else {
                     return m;
                }
            }
        } break;

        case 2: {
            u16 rangeCount = ttUSHORT(coverageTable + 2);
            u8 *rangeArray = coverageTable + 4;

            // Binary search.
            i32 l=0, r=rangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                u8 *rangeRecord;
                m = (l + r) >> 1;
                rangeRecord = rangeArray + 6 * m;
                strawStart = ttUSHORT(rangeRecord);
                strawEnd = ttUSHORT(rangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else {
                    u16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
                    return startCoverageIndex + glyph - strawStart;
                }
            }
        } break;

        default: {
            // There are no other cases.
            assert(0);
        } break;
    }

    return -1;
}

STBTT_DEF i32  stbtt__GetGlyphClass(u8 *classDefTable, int glyph)
{
    u16 classDefFormat = ttUSHORT(classDefTable);
    switch(classDefFormat)
    {
        case 1: {
            u16 startGlyphID = ttUSHORT(classDefTable + 2);
            u16 glyphCount = ttUSHORT(classDefTable + 4);
            u8 *classDef1ValueArray = classDefTable + 6;

            if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
                return (i32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));

            classDefTable = classDef1ValueArray + 2 * glyphCount;
        } break;

        case 2: {
            u16 classRangeCount = ttUSHORT(classDefTable + 2);
            u8 *classRangeRecords = classDefTable + 4;

            // Binary search.
            i32 l=0, r=classRangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                u8 *classRangeRecord;
                m = (l + r) >> 1;
                classRangeRecord = classRangeRecords + 6 * m;
                strawStart = ttUSHORT(classRangeRecord);
                strawEnd = ttUSHORT(classRangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else
                    return (i32)ttUSHORT(classRangeRecord + 4);
            }

            classDefTable = classRangeRecords + 6 * classRangeCount;
        } break;

        default: {
            // There are no other cases.
            assert(0);
        } break;
    }

    return -1;
}

// Define to assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x) assert(x)

STBTT_DEF i32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
    u16 lookupListOffset;
    u8 *lookupList;
    u16 lookupCount;
    u8 *data;
    i32 i;

    if (!info->gpos) return 0;

    data = info->data + info->gpos;

    if (ttUSHORT(data+0) != 1) return 0; // Major version 1
    if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

    lookupListOffset = ttUSHORT(data+8);
    lookupList = data + lookupListOffset;
    lookupCount = ttUSHORT(lookupList);

    for (i=0; i<lookupCount; ++i) {
        u16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
        u8 *lookupTable = lookupList + lookupOffset;

        u16 lookupType = ttUSHORT(lookupTable);
        u16 subTableCount = ttUSHORT(lookupTable + 4);
        u8 *subTableOffsets = lookupTable + 6;
        switch(lookupType) {
            case 2: { // Pair Adjustment Positioning Subtable
                i32 sti;
                for (sti=0; sti<subTableCount; sti++) {
                    u16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
                    u8 *table = lookupTable + subtableOffset;
                    u16 posFormat = ttUSHORT(table);
                    u16 coverageOffset = ttUSHORT(table + 2);
                    i32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
                    if (coverageIndex == -1) continue;

                    switch (posFormat) {
                        case 1: {
                            i32 l, r, m;
                            int straw, needle;
                            u16 valueFormat1 = ttUSHORT(table + 4);
                            u16 valueFormat2 = ttUSHORT(table + 6);
                            i32 valueRecordPairSizeInBytes = 2;
                            u16 pairSetCount = ttUSHORT(table + 8);
                            u16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                            u8 *pairValueTable = table + pairPosOffset;
                            u16 pairValueCount = ttUSHORT(pairValueTable);
                            u8 *pairValueArray = pairValueTable + 2;
                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            assert(coverageIndex < pairSetCount);
                            STBTT__NOTUSED(pairSetCount);

                            needle=glyph2;
                            r=pairValueCount-1;
                            l=0;

                            // Binary search.
                            while (l <= r) {
                                u16 secondGlyph;
                                u8 *pairValue;
                                m = (l + r) >> 1;
                                pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                                secondGlyph = ttUSHORT(pairValue);
                                straw = secondGlyph;
                                if (needle < straw)
                                    r = m - 1;
                                else if (needle > straw)
                                    l = m + 1;
                                else {
                                    i16 xAdvance = ttSHORT(pairValue + 2);
                                    return xAdvance;
                                }
                            }
                        } break;

                        case 2: {
                            u16 valueFormat1 = ttUSHORT(table + 4);
                            u16 valueFormat2 = ttUSHORT(table + 6);

                            u16 classDef1Offset = ttUSHORT(table + 8);
                            u16 classDef2Offset = ttUSHORT(table + 10);
                            int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                            int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                            u16 class1Count = ttUSHORT(table + 12);
                            u16 class2Count = ttUSHORT(table + 14);
                            assert(glyph1class < class1Count);
                            assert(glyph2class < class2Count);

                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {
                                u8 *class1Records = table + 16;
                                u8 *class2Records = class1Records + 2 * (glyph1class * class2Count);
                                i16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                                return xAdvance;
                            }
                        } break;

                        default: {
                            // There are no other cases.
                            assert(0);
                            break;
                        };
                    }
                }
                break;
            };

            default:
                // TODO: Implement other stuff.
                break;
        }
    }

    return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);
   else if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

STBTT_DEF void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

STBTT_DEF void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

STBTT_DEF void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

STBTT_DEF stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   assert(z != NULL);
   if (!z) return z;

   // round dx down to avoid overshooting
   if (dxdy < 0)
      z->dx = -floor(STBTT_FIX * -dxdy);
   else
      z->dx = floor(STBTT_FIX * dxdy);

   z->x = floor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
STBTT_DEF stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   assert(z != NULL);
   //assert(e->y0 <= start_point);
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1

STBTT_DEF void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   // non-zero winding fill
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         // if we're currently at zero, we need to record the edge start point
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         // if we went to zero, we need to draw
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  // x0,x1 are the same pixel, so compute combined coverage
                  scanline[i] = scanline[i] + (u8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) // add antialiasing for x0
                     scanline[i] = scanline[i] + (u8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; // clip

                  if (j < len) // add antialiasing for x1
                     scanline[j] = scanline[j] + (u8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; // clip

                  for (++i; i < j; ++i) // fill pixels between x0 and x1
                     scanline[i] = scanline[i] + (u8) max_weight;
               }
            }
         }
      }

      e = e->next;
   }
}

STBTT_DEF void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  // weight per vertical scanline
   int s; // vertical subsample index
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         // find center of pixel for this scanline
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         // update all active edges;
         // remove all active edges that terminate before the center of this scanline
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; // delete from list
               assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; // advance to position for current scanline
               step = &((*step)->next); // advance through list
            }
         }

         // resort the list if needed
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  // find insertion point
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     // insert at front
                     z->next = active;
                     active = z;
                  } else {
                     // find thing to insert AFTER
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     // at this point, p->next->x is NOT < z->x
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         // now process all active edges in XOR fashion
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

STBTT_DEF void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   assert(y0 < y1);
   assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      assert(x1 <= x+1);
   else if (x0 == x+1)
      assert(x1 >= x);
   else if (x0 <= x)
      assert(x1 <= x);
   else if (x0 >= x+1)
      assert(x1 >= x+1);
   else
      assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
   }
}

STBTT_DEF void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      // brute force every pixel

      // compute intersection points with top & bottom
      assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         assert(e->sy <= y_bottom && e->ey >= y_top);

         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            // from here on, we don't have to range check x values

            if ((int) x_top == (int) x_bottom) {
               float height;
               // simple case, only spans one pixel
               int x = (int) x_top;
               height = sy1 - sy0;
               assert(x >= 0 && x < len);
               scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;
               scanline_fill[x] += e->direction * height; // everything right of this pixel is filled
            } else {
               int x,x1,x2;
               float y_crossing, step, sign, area;
               // covers 2+ pixels
               if (x_top > x_bottom) {
                  // flip scanline vertically; signed area is the same
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
               }

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               // compute intersection with y axis at x1+1
               y_crossing = (x1+1 - x0) * dy + y_top;

               sign = e->direction;
               // area of the rectangle covered from y0..y_crossing
               area = sign * (y_crossing-sy0);
               // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
               scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

               step = sign * dy;
               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2;
                  area += step;
               }
               y_crossing += dy * (x2 - (x1+1));

               assert(fabs(area) <= 1.01f);

               scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            int x;
            for (x=0; x < len; ++x) {

               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  // one segment
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

// directly AA rasterize edges w/o supersampling
STBTT_DEF void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      // find center of pixel for this scanline
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      memset(scanline , 0, result->w*sizeof(scanline[0]));
      memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      // update all active edges;
      // remove all active edges that terminate before the top of this scanline
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; // delete from list
            assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); // advance through list
         }
      }

      // insert all edges that start before the bottom of this scanline
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               if (j == 0 && off_y != 0) {
                  if (z->ey < scan_y_top) {
                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
                     z->ey = scan_y_top;
                  }
               }
               assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
               // insert at front
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      // now process all active edges
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;
            result->pixels[j*result->stride + i] = (unsigned char) m;
         }
      }
      // advance all the edges
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; // advance to position for current scanline
         step = &((*step)->next); // advance through list
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

STBTT_DEF void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

STBTT_DEF void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

STBTT_DEF void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

STBTT_DEF void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity

   // now we have to blow out the windings into explicit edge lists
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         // skip the edge if horizontal
         if (p[j].y == p[k].y)
            continue;
         // add edge from j to k to the list
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   // now sort the edges by their highest point (should snap to integer, and then by x)
   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
   stbtt__sort_edges(e, n);

   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

STBTT_DEF void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; // during first pass, it's unallocated
   points[n].x = x;
   points[n].y = y;
}

// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
STBTT_DEF int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   // midpoint
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   // versus directly drawn line
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) // 65536 segments on one curve better be enough!
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

STBTT_DEF void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (sqrt(dx0*dx0+dy0*dy0)+sqrt(dx1*dx1+dy1*dy1)+sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) // 65536 segments on one curve better be enough!
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

// returns number of contours
STBTT_DEF stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   // count how many "moves" there are to get the contour count
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   // make two passes through the points so we don't need to realloc
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               // start the next contour
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      // e.g. space character
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
      if (ix0) *ix0 = floor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = floor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = ceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = ceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   // now we get the size
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; // in case we error

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}


STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char* const_data, int fontstart)
{
   unsigned char* data = (unsigned char*)const_data;

   u32 cmap, t;
   i32 i,numTables;

   info->data = (unsigned char*)data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
   info->head = stbtt__find_table(data, fontstart, "head"); // required
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      // required for truetype
      if (!info->loca) return 0;
   } else {
      // initialization for CFF / Type2 fonts (OTF)
      stbtt__buf b, topdict, topdictidx;
      u32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      u32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      // @TODO this should use size from table (not 512MB)
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      // read the header
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

      // @TODO the name INDEX could list multiple fonts,
      // but we just use the first one.
      stbtt__cff_get_index(&b);  // name INDEX
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  // string INDEX
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      // we only support Type 2 charstrings
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         // looks like a CID font
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   info->svg = -1;

   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      u32 encoding_record = cmap + 4 + 8 * i;
      // find an encoding we understand:
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  // MS/Unicode
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            // Mac/iOS has these
            // all the encodingIDs are unicode, so we don't bother to check it
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT((unsigned char*)data + info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint) {
   u8 *data = info->data;
   u32 index_map = info->index_map;

   u16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { // apple byte encoding
      i32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      u32 first = ttUSHORT(data + index_map + 6);
      u32 count = ttUSHORT(data + index_map + 8);
      if ((u32) unicode_codepoint >= first && (u32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      return 0;
   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
      u16 segcount = ttUSHORT(data+index_map+6) >> 1;
      u16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      u16 entrySelector = ttUSHORT(data+index_map+10);
      u16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      // do a binary search of the segments
      u32 endCount = index_map + 14;
      u32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      // they lie from endCount .. endCount + segCount
      // but searchRange is the nearest power of two, so...
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      // now decrement to bias correctly to find smallest
      search -= 2;
      while (entrySelector) {
         u16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         u16 offset, start;
         u16 item = (u16) ((search - endCount) >> 1);

         assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));
         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         if (unicode_codepoint < start)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (u16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      u32 ngroups = ttULONG(data+index_map+12);
      i32 low,high;
      low = 0; high = (i32)ngroups;
      // Binary search the right group.
      while (low < high) {
         i32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
         u32 start_char = ttULONG(data+index_map+16+mid*12);
         u32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((u32) unicode_codepoint < start_char)
            high = mid;
         else if ((u32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            u32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else // format == 13
               return start_glyph;
         }
      }
      return 0; // not found
   }
   // @TODO
   assert(0);
   return 0;
}

STBTT_DEF int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; // if length is 0, return -1
}

STBTT_DEF int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
#endif /* n RFONT_EXTERNAL_STB */

/* 
END of stb_truetype defines and source code required by RFont
*/

#endif /* RFONT_IMPLEMENTATION */
/*
* Copyright (C) 2023-24 ColleagueRiley
*
* libpng license
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not
*    claim that you wrote the original software. If you use this software
*    in a product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*
*
*/

/*
	(MAKE SURE RGFW_IMPLEMENTATION is in exactly one header or you use -D RGFW_IMPLEMENTATION)
	#define RGFW_IMPLEMENTATION - makes it so source code is included with header
*/

/*
	#define RGFW_IMPLEMENTATION - (required) makes it so the source code is included
	#define RGFW_PRINT_ERRORS - (optional) makes it so RGFW prints errors when they're found
	#define RGFW_OSMESA - (optional) use OSmesa as backend (instead of system's opengl api + regular opengl)
	#define RGFW_BUFFER - (optional) just draw directly to (RGFW) window pixel buffer that is drawn to screen (the buffer is in the RGBA format)
	#define RGFW_EGL - (optional) use EGL for loading an OpenGL context (instead of the system's opengl api)
	#define RGFW_OPENGL_ES1 - (optional) use EGL to load and use Opengl ES (version 1) for backend rendering (instead of the system's opengl api)
									This version doesn't work for desktops (I'm pretty sure)
	#define RGFW_OPENGL_ES2 - (optional) use OpenGL ES (version 2)
	#define RGFW_OPENGL_ES3 - (optional) use OpenGL ES (version 3)
	#define RGFW_DIRECTX - (optional) use directX for the rendering backend (rather than opengl) (windows only, defaults to opengl for unix)
	#define RGFW_NO_API - (optional) don't use any rendering API (no opengl, no vulkan, no directX)

	#define RGFW_LINK_EGL (optional) (windows only) if EGL is being used, if EGL functions should be defined dymanically (using GetProcAddress)
	#define RGFW_LINK_OSMESA (optional) (windows only) if EGL is being used, if OS Mesa functions should be defined dymanically  (using GetProcAddress)

	#define RGFW_X11 (optional) (unix only) if X11 should be used. This option is turned on by default by unix systems except for MacOS
	#define RGFW_WGL_LOAD (optional) (windows only) if WGL should be loaded dynamically during runtime
	#define RGFW_NO_X11_CURSOR (optional) (unix only) don't use XCursor
	#define RGFW_NO_X11_CURSOR_PRELOAD (optional) (unix only) Use XCursor, but don't link it in code, (you'll have to link it with -lXcursor)

	#define RGFW_NO_DPI - Do not include calculate DPI (no XRM nor libShcore included)

	#define RGFW_ALLOC_DROPFILES (optional) if room should be allocating for drop files (by default it's global data)
	#define RGFW_MALLOC x - choose what function to use to allocate, by default the standard malloc is used
	#define RGFW_CALLOC x - choose what function to use to allocate (calloc), by default the standard calloc is used
	#define RGFW_FREE x - choose what function to use to allocated memory, by default the standard free is used

 	#define RGFW_EXPORT - Use when building RGFW 
    #define RGFW_IMPORT - Use when linking with RGFW (not as a single-header)
	
	#define RGFW_STD_INT - force the use stdint.h (for systems that might not have stdint.h (msvc)) 
*/

/*
	Credits :
		EimaMei/Sacode : Much of the code for creating windows using winapi, Wrote the Silicon library, helped with MacOS Support, siliapp.h -> referencing 

		stb - This project is heavily inspired by the stb single header files

		GLFW:
			certain parts of winapi and X11 are very poorly documented,
			GLFW's source code was referenced and used throughout the project (used code is marked in some way),
			this mainly includes, code for drag and drops, code for setting the icon to a bitmap and the code for managing the clipboard for X11 (as these parts are not documented very well)

			GLFW Copyright, https::/github.com/GLFW/GLFW

			Copyright (c) 2002-2006 Marcus Geelnard
			Copyright (c) 2006-2019 Camilla Lwy

		contributors : (feel free to put yourself here if you contribute)
		krisvers -> code review
		EimaMei (SaCode) -> code review
		Code-Nycticebus -> bug fixes
		Rob Rohan -> X11 bugs and missing features, MacOS/Cocoa fixing memory issues/bugs 
		AICDG (@THISISAGOODNAME) -> vulkan support (example)
		@Easymode -> support, testing/debugging, bug fixes and reviews
*/

#if _MSC_VER
	#pragma comment(lib, "gdi32")
	#pragma comment(lib, "shell32")
	#pragma comment(lib, "opengl32")
	#pragma comment(lib, "winmm")
	#pragma comment(lib, "user32")
#endif

#ifndef RGFW_MALLOC
	#include <stdlib.h>

	#ifndef __USE_POSIX199309
	#define __USE_POSIX199309
	#endif

	#include <time.h>
	#define RGFW_MALLOC malloc
	#define RGFW_CALLOC calloc
	#define RGFW_FREE free
#endif

#if !_MSC_VER
	#ifndef inline
		#ifndef __APPLE__
			#define inline __inline
		#endif
	#endif
#endif

#ifdef RGFW_WIN95 /* for windows 95 testing (not that it really works) */
	#define RGFW_NO_MONITOR
	#define RGFW_NO_PASSTHROUGH
#endif

#if defined(RGFW_EXPORT) ||  defined(RGFW_IMPORT)
	#if defined(_WIN32)
		#if defined(__TINYC__) && (defined(RGFW_EXPORT) ||  defined(RGFW_IMPORT))
			#define __declspec(x) __attribute__((x))
		#endif

		#if defined(RGFW_EXPORT)
			#define RGFWDEF __declspec(dllexport)
		#else 
			#define RGFWDEF __declspec(dllimport)
		#endif
	#else
		#if defined(RGFW_EXPORT)
			#define RGFWDEF __attribute__((visibility("default")))
		#endif
	#endif
#endif 

#ifndef RGFWDEF
	#ifdef __clang__
		#define RGFWDEF static inline
	#else
		#define RGFWDEF inline
	#endif
#endif

#ifndef RGFW_ENUM
	#define RGFW_ENUM(type, name) type name; enum
#endif

#ifndef RGFW_UNUSED
	#define RGFW_UNUSED(x) (void)(x);
#endif

#if defined(__cplusplus) && !defined(__EMSCRIPTEN__)
	extern "C" {
#endif

	/* makes sure the header file part is only defined once by default */
#ifndef RGFW_HEADER

#define RGFW_HEADER

#if !defined(u8)
	#if ((defined(_MSC_VER) || defined(__SYMBIAN32__)) && !defined(RGFW_STD_INT)) /* MSVC might not have stdint.h */
		typedef unsigned char 	u8;
		typedef signed char		i8;
		typedef unsigned short  u16;
		typedef signed short 	i16;
		typedef unsigned int 	u32;
		typedef signed int		i32;
		typedef unsigned long	u64;
		typedef signed long		i64;
	#else /* use stdint standard types instead of c ""standard"" types */
		#include <stdint.h>

		typedef uint8_t     u8;
		typedef int8_t      i8;
		typedef uint16_t   u16;
		typedef int16_t    i16;
		typedef uint32_t   u32;
		typedef int32_t    i32;
		typedef uint64_t   u64;
		typedef int64_t    i64;
	#endif
#endif

#if !defined(b8) /* RGFW bool type */
	typedef u8 b8;
	typedef u32 b32;
#endif

#define RGFW_TRUE 1
#define RGFW_FALSE 0

/* thse OS macros looks better & are standardized */
/* plus it helps with cross-compiling */

#ifdef __EMSCRIPTEN__
	#define RGFW_WEBASM

	#ifndef RGFW_NO_API
		#define RGFW_OPENGL
	#endif

	#ifdef RGFW_EGL
		#undef RGFW_EGL
	#endif

	#include <emscripten/html5.h>
	#include <emscripten/key_codes.h>
#endif

#if defined(RGFW_X11) && defined(__APPLE__)
	#define RGFW_MACOS_X11
	#undef __APPLE__
#endif

#if defined(_WIN32) && !defined(RGFW_X11) && !defined(RGFW_WEBASM) /* (if you're using X11 on windows some how) */
	#define RGFW_WINDOWS

	/* make sure the correct architecture is defined */
	#if defined(_WIN64)
		#define _AMD64_
		#undef _X86_
	#else
		#undef _AMD64_
		#ifndef _X86_
			#define _X86_
		#endif
	#endif

	#ifndef RGFW_NO_XINPUT
		#ifdef __MINGW32__ /* try to find the right header */
			#include <xinput.h>
		#else
			#include <XInput.h>
		#endif
	#endif

	#if defined(RGFW_DIRECTX)
		#include <d3d11.h>
		#include <dxgi.h>
		#include <dxgi.h>
		#include <d3dcompiler.h>

		#ifndef __cplusplus
			#define __uuidof(T) IID_##T
		#endif
	#endif

#elif defined(RGFW_WAYLAND)
    #if !defined(RGFW_NO_API) && (!defined(RGFW_BUFFER) || defined(RGFW_OPENGL))
		#define RGFW_EGL
		#define RGFW_OPENGL
		#include <wayland-egl.h>
	#endif

	#include <wayland-client.h>
#elif (defined(__unix__) || defined(RGFW_MACOS_X11) || defined(RGFW_X11))  && !defined(RGFW_WEBASM)
	#define RGFW_MACOS_X11
	#define RGFW_X11
	#include <X11/Xlib.h>
#elif defined(__APPLE__) && !defined(RGFW_MACOS_X11) && !defined(RGFW_X11)  && !defined(RGFW_WEBASM)
	#define RGFW_MACOS
#endif

#if (defined(RGFW_OPENGL_ES1) || defined(RGFW_OPENGL_ES2) || defined(RGFW_OPENGL_ES3)) && !defined(RGFW_EGL)
	#define RGFW_EGL
#endif

#if !defined(RGFW_OSMESA) && !defined(RGFW_EGL) && !defined(RGFW_OPENGL) && !defined(RGFW_DIRECTX) && !defined(RGFW_BUFFER) && !defined(RGFW_NO_API)
	#define RGFW_OPENGL
#endif

#ifdef RGFW_EGL
	#if defined(__APPLE__)
		#warning  EGL is not supported for Cocoa, switching back to the native opengl api
		#undef RGFW_EGL
	#endif

	#include <EGL/egl.h>
#elif defined(RGFW_OSMESA)
	#ifndef __APPLE__
		#include <GL/osmesa.h>
	#else
		#include <OpenGL/osmesa.h>
	#endif
#endif

#if defined(RGFW_OPENGL) && defined(RGFW_X11)
	#ifndef GLX_MESA_swap_control
		#define  GLX_MESA_swap_control
	#endif
	#include <GL/glx.h> /* GLX defs, xlib.h, gl.h */
#endif

#ifndef RGFW_ALPHA
	#define RGFW_ALPHA 128 /* alpha value for RGFW_TRANSPARENT_WINDOW (WINAPI ONLY, macOS + linux don't need this) */
#endif

/*! Optional arguments for making a windows */
#define RGFW_TRANSPARENT_WINDOW		(1L<<9) /*!< the window is transparent (only properly works on X11 and MacOS, although it's although for windows) */
#define RGFW_NO_BORDER		(1L<<3) /*!< the window doesn't have border */
#define RGFW_NO_RESIZE		(1L<<4) /*!< the window cannot be resized  by the user */
#define RGFW_ALLOW_DND     (1L<<5) /*!< the window supports drag and drop*/
#define RGFW_HIDE_MOUSE (1L<<6) /*! the window should hide the mouse or not (can be toggled later on) using `RGFW_window_mouseShow*/
#define RGFW_FULLSCREEN (1L<<8) /* the window is fullscreen by default or not */
#define RGFW_CENTER (1L<<10) /*! center the window on the screen */
#define RGFW_OPENGL_SOFTWARE (1L<<11) /*! use OpenGL software rendering */
#define RGFW_COCOA_MOVE_TO_RESOURCE_DIR (1L << 12) /* (cocoa only), move to resource folder */
#define RGFW_SCALE_TO_MONITOR (1L << 13) /* scale the window to the screen */
#define RGFW_NO_INIT_API (1L << 2) /* DO not init an API (mostly for bindings, you should use `#define RGFW_NO_API` in C */

#define RGFW_NO_GPU_RENDER (1L<<14) /* don't render (using the GPU based API)*/
#define RGFW_NO_CPU_RENDER (1L<<15) /* don't render (using the CPU based buffer rendering)*/
#define RGFW_WINDOW_HIDE (1L <<  16)/* the window is hidden */

typedef RGFW_ENUM(u8, RGFW_event_types) {
	/*! event codes */
 	RGFW_keyPressed = 1, /* a key has been pressed */
	RGFW_keyReleased, /*!< a key has been released*/
	/*! key event note
		the code of the key pressed is stored in
		RGFW_Event.keyCode
		!!Keycodes defined at the bottom of the RGFW_HEADER part of this file!!

		while a string version is stored in
		RGFW_Event.KeyString

		RGFW_Event.lockState holds the current lockState
		this means if CapsLock, NumLock are active or not
	*/
	RGFW_mouseButtonPressed, /*!< a mouse button has been pressed (left,middle,right)*/
	RGFW_mouseButtonReleased, /*!< a mouse button has been released (left,middle,right)*/
	RGFW_mousePosChanged, /*!< the position of the mouse has been changed*/
	/*! mouse event note
		the x and y of the mouse can be found in the vector, RGFW_Event.point

		RGFW_Event.button holds which mouse button was pressed
	*/
	RGFW_jsButtonPressed, /*!< a joystick button was pressed */
	RGFW_jsButtonReleased, /*!< a joystick button was released */
	RGFW_jsAxisMove, /*!< an axis of a joystick was moved*/
	/*! joystick event note
		RGFW_Event.joystick holds which joystick was altered, if any
		RGFW_Event.button holds which joystick button was pressed

		RGFW_Event.axis holds the data of all the axis
		RGFW_Event.axisCount says how many axis there are
	*/
	RGFW_windowMoved, /*!< the window was moved (by the user) */
	RGFW_windowResized, /*!< the window was resized (by the user), [on webASM this means the browser was resized] */
	RGFW_focusIn, /*!< window is in focus now */
	RGFW_focusOut, /*!< window is out of focus now */
	RGFW_mouseEnter, /* mouse entered the window */
	RGFW_mouseLeave, /* mouse left the window */
	RGFW_windowRefresh, /* The window content needs to be refreshed */

	/* attribs change event note
		The event data is sent straight to the window structure
		with win->r.x, win->r.y, win->r.w and win->r.h
	*/
	RGFW_quit, /*!< the user clicked the quit button*/ 
	RGFW_dnd, /*!< a file has been dropped into the window*/
	RGFW_dnd_init /*!< the start of a dnd event, when the place where the file drop is known */
	/* dnd data note
		The x and y coords of the drop are stored in the vector RGFW_Event.point

		RGFW_Event.droppedFilesCount holds how many files were dropped

		This is also the size of the array which stores all the dropped file string,
		RGFW_Event.droppedFiles
	*/
};

/*! mouse button codes (RGFW_Event.button) */
#define RGFW_mouseLeft  1 /*!< left mouse button is pressed*/
#define RGFW_mouseMiddle  2 /*!< mouse-wheel-button is pressed*/
#define RGFW_mouseRight  3 /*!< right mouse button is pressed*/
#define RGFW_mouseScrollUp  4 /*!< mouse wheel is scrolling up*/
#define RGFW_mouseScrollDown  5 /*!< mouse wheel is scrolling down*/

#ifndef RGFW_MAX_PATH
#define RGFW_MAX_PATH 260 /* max length of a path (for dnd) */
#endif
#ifndef RGFW_MAX_DROPS
#define RGFW_MAX_DROPS 260 /* max items you can drop at once */
#endif


/* for RGFW_Event.lockstate */
#define RGFW_CAPSLOCK (1L << 1)
#define RGFW_NUMLOCK (1L << 2)

/*! joystick button codes (based on xbox/playstation), you may need to change these values per controller */
#ifndef RGFW_joystick_codes
	typedef RGFW_ENUM(u8, RGFW_joystick_codes) {
		RGFW_JS_A = 0, /*!< or PS X button */
		RGFW_JS_B = 1, /*!< or PS circle button */
		RGFW_JS_Y = 2, /*!< or PS triangle button */
		RGFW_JS_X = 3, /*!< or PS square button */
		RGFW_JS_START = 9, /*!< start button */
		RGFW_JS_SELECT = 8, /*!< select button */
		RGFW_JS_HOME = 10, /*!< home button */
		RGFW_JS_UP = 13, /*!< dpad up */
		RGFW_JS_DOWN = 14, /*!< dpad down*/
		RGFW_JS_LEFT = 15, /*!< dpad left */
		RGFW_JS_RIGHT = 16, /*!< dpad right */
		RGFW_JS_L1 = 4, /*!< left bump */
		RGFW_JS_L2 = 5, /*!< left trigger*/
		RGFW_JS_R1 = 6, /*!< right bumper */
		RGFW_JS_R2 = 7, /*!< right trigger */
	};
#endif

/*! basic vector type, if there's not already a point/vector type of choice */
#ifndef RGFW_point
	typedef struct { i32 x, y; } RGFW_point;
#endif

/*! basic rect type, if there's not already a rect type of choice */
#ifndef RGFW_rect
	typedef struct { i32 x, y, w, h; } RGFW_rect;
#endif

/*! basic area type, if there's not already a area type of choice */
#ifndef RGFW_area
	typedef struct { u32 w, h; } RGFW_area;
#endif

#ifndef __cplusplus
#define RGFW_POINT(x, y) (RGFW_point){(i32)(x), (i32)(y)}
#define RGFW_RECT(x, y, w, h) (RGFW_rect){(i32)(x), (i32)(y), (i32)(w), (i32)(h)}
#define RGFW_AREA(w, h) (RGFW_area){(u32)(w), (u32)(h)}
#else
#define RGFW_POINT(x, y) {(i32)(x), (i32)(y)}
#define RGFW_RECT(x, y, w, h) {(i32)(x), (i32)(y), (i32)(w), (i32)(h)}
#define RGFW_AREA(w, h) {(u32)(w), (u32)(h)}
#endif

#ifndef RGFW_NO_MONITOR
	/*! structure for monitor data */
	typedef struct RGFW_monitor {
		char name[128]; /*!< monitor name */
		RGFW_rect rect; /*!< monitor Workarea */
		float scaleX, scaleY; /*!< monitor content scale*/
		float physW, physH; /*!< monitor physical size */
	} RGFW_monitor;

	/*
		NOTE : Monitor functions should be ran only as many times as needed (not in a loop)
	*/

	/*! get an array of all the monitors (max 6) */
	RGFWDEF RGFW_monitor* RGFW_getMonitors(void);
	/*! get the primary monitor */
	RGFWDEF RGFW_monitor RGFW_getPrimaryMonitor(void);
#endif

/* NOTE: some parts of the data can represent different things based on the event (read comments in RGFW_Event struct) */
/*! Event structure for checking/getting events */
typedef struct RGFW_Event {
	char keyName[16]; /*!< key name of event*/

	/*! drag and drop data */
	/* 260 max paths with a max length of 260 */
#ifdef RGFW_ALLOC_DROPFILES
	char** droppedFiles;
#else
	char droppedFiles[RGFW_MAX_DROPS][RGFW_MAX_PATH]; /*!< dropped files*/
#endif
	u32 droppedFilesCount; /*!< house many files were dropped */

	u32 type; /*!< which event has been sent?*/
	RGFW_point point; /*!< mouse x, y of event (or drop point) */
	
	u8 keyCode; /*!< keycode of event 	!!Keycodes defined at the bottom of the RGFW_HEADER part of this file!! */	
	
	b8 repeat; /*!< key press event repeated (the key is being held) */
	b8 inFocus;  /*!< if the window is in focus or not (this is always true for MacOS windows due to the api being weird) */

	u8 lockState;
	
	u8 button; /* !< which mouse button was pressed */
	double scroll; /*!< the raw mouse scroll value */

	u16 joystick; /*! which joystick this event applies to (if applicable to any) */
	u8 axisesCount; /*!< number of axises */
	RGFW_point axis[2]; /*!< x, y of axises (-100 to 100) */

	u64 frameTime, frameTime2; /*!< this is used for counting the fps */
} RGFW_Event;

/*! source data for the window (used by the APIs) */
typedef struct RGFW_window_src {
#ifdef RGFW_WINDOWS
	HWND window; /*!< source window */
	HDC hdc; /*!< source HDC */
	u32 hOffset; /*!< height offset for window */
	#if (defined(RGFW_OPENGL)) && !defined(RGFW_OSMESA) && !defined(RGFW_EGL)
		HGLRC ctx; /*!< source graphics context */
	#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
	#elif defined(RGFW_DIRECTX)
		IDXGISwapChain* swapchain;
		ID3D11RenderTargetView* renderTargetView;
		ID3D11DepthStencilView* pDepthStencilView;
	#elif defined(RGFW_EGL)
		EGLSurface EGL_surface;
		EGLDisplay EGL_display;
		EGLContext EGL_context;
	#endif

	#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
		HDC hdcMem;
		HBITMAP bitmap;
	#endif
	RGFW_area maxSize, minSize; /*!< for setting max/min resize (RGFW_WINDOWS) */
#elif defined(RGFW_X11)
	Display* display; /*!< source display */
	Window window; /*!< source window */
	#if (defined(RGFW_OPENGL)) && !defined(RGFW_OSMESA) && !defined(RGFW_EGL)
		GLXContext ctx; /*!< source graphics context */
	#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
	#elif defined(RGFW_EGL)
		EGLSurface EGL_surface;
		EGLDisplay EGL_display;
		EGLContext EGL_context;
	#endif

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
		XImage* bitmap;
		GC gc;
#endif
#elif defined(RGFW_WAYLAND)
	struct wl_display* display;
	struct wl_surface* surface;
	struct wl_buffer* wl_buffer;
	struct wl_keyboard* keyboard;

	struct xdg_surface* xdg_surface;
	struct xdg_toplevel* xdg_toplevel;
	struct zxdg_toplevel_decoration_v1* decoration;
	RGFW_Event events[20];
		i32 eventLen;
		size_t eventIndex;
	#if defined(RGFW_EGL)
			struct wl_egl_window* window;
			EGLSurface EGL_surface;
			EGLDisplay EGL_display;
			EGLContext EGL_context;
	#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
	#endif
#elif defined(RGFW_MACOS)
	u32 display;
	void* displayLink;
	void* window;
	b8 dndPassed;
#if (defined(RGFW_OPENGL)) && !defined(RGFW_OSMESA) && !defined(RGFW_EGL)
		void* ctx; /*!< source graphics context */
#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
#elif defined(RGFW_EGL)
		EGLSurface EGL_surface;
		EGLDisplay EGL_display;
		EGLContext EGL_context;
#endif

	void* view; /*apple viewpoint thingy*/

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
		void* bitmap; /*!< API's bitmap for storing or managing */
		void* image;
#endif
#elif defined(RGFW_WEBASM)
	EMSCRIPTEN_WEBGL_CONTEXT_HANDLE ctx;
#endif
} RGFW_window_src;



typedef struct RGFW_window {
	RGFW_window_src src; /*!< src window data */

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
	u8* buffer; /*!< buffer for non-GPU systems (OSMesa, basic software rendering) */
	/* when rendering using RGFW_BUFFER, the buffer is in the RGBA format */
#endif
	void* userPtr; /* ptr for usr data */
	
	RGFW_Event event; /*!< current event */

	RGFW_rect r; /*!< the x, y, w and h of the struct */
	
	RGFW_point _lastMousePoint; /*!< last cusor point (for raw mouse data) */
	
	u32 _winArgs; /*!< windows args (for RGFW to check) */
} RGFW_window; /*!< Window structure for managing the window */

#if defined(RGFW_X11) || defined(RGFW_MACOS)
	typedef u64 RGFW_thread; /*!< thread type unix */
#else
	typedef void* RGFW_thread; /*!< thread type for window */
#endif

/** * @defgroup Window_management
* @{ */ 


/*! 
 * the class name for X11 and WinAPI. apps with the same class will be grouped by the WM
 * by default the class name will == the root window's name
*/
RGFWDEF void RGFW_setClassName(char* name);

/*! this has to be set before createWindow is called, else the fulscreen size is used */
RGFWDEF void RGFW_setBufferSize(RGFW_area size); /*!< the buffer cannot be resized (by RGFW) */

RGFW_window* RGFW_createWindow(
	const char* name, /* name of the window */
	RGFW_rect rect, /* rect of window */
	u16 args /* extra arguments (NULL / (u16)0 means no args used)*/
); /*!< function to create a window struct */

/*! get the size of the screen to an area struct */
RGFWDEF RGFW_area RGFW_getScreenSize(void);

/*!
	this function checks an *individual* event (and updates window structure attributes)
	this means, using this function without a while loop may cause event lag

	ex.

	while (RGFW_window_checkEvent(win) != NULL) [this keeps checking events until it reaches the last one]

	this function is optional if you choose to use event callbacks, 
	although you still need some way to tell RGFW to process events eg. `RGFW_window_checkEvents`
*/

RGFW_Event* RGFW_window_checkEvent(RGFW_window* win); /*!< check current event (returns a pointer to win->event or NULL if there is no event)*/

/*!
	for RGFW_window_eventWait and RGFW_window_checkEvents
	waitMS -> Allows th	e function to keep checking for events even after `RGFW_window_checkEvent == NULL`
			  if waitMS == 0, the loop will not wait for events
			  if waitMS == a positive integer, the loop will wait that many miliseconds after there are no more events until it returns
			  if waitMS == a negative integer, the loop will not return until it gets another event
*/
typedef RGFW_ENUM(i32, RGFW_eventWait) {
	RGFW_NEXT = -1,
	RGFW_NO_WAIT = 0
};

/*! sleep until RGFW gets an event or the timer ends (defined by OS) */
RGFWDEF void RGFW_window_eventWait(RGFW_window* win, i32 waitMS);

/*!
	check all the events until there are none left, 
	this should only be used if you're using callbacks only
*/
RGFWDEF void RGFW_window_checkEvents(RGFW_window* win, i32 waitMS);

/*! 
	Tell RGFW_window_eventWait to stop waiting, to be ran from another thread
*/
RGFWDEF void RGFW_stopCheckEvents(void);

/*! window managment functions*/
RGFWDEF void RGFW_window_close(RGFW_window* win); /*!< close the window and free leftover data */

/*! moves window to a given point */
RGFWDEF void RGFW_window_move(RGFW_window* win,
	RGFW_point v/*!< new pos*/
);

#ifndef RGFW_NO_MONITOR
	/*! move to a specific monitor */
	RGFWDEF void RGFW_window_moveToMonitor(RGFW_window* win, RGFW_monitor m /* monitor */);
#endif

/*! resize window to a current size/area */
RGFWDEF void RGFW_window_resize(RGFW_window* win, /*!< source window */
	RGFW_area a/*!< new size*/
);

/*! set the minimum size a user can shrink a window to a given size/area */
RGFWDEF void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a);
/*! set the minimum size a user can extend a window to a given size/area */
RGFWDEF void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a);

RGFWDEF void RGFW_window_maximize(RGFW_window* win); /*!< maximize the window size */
RGFWDEF void RGFW_window_minimize(RGFW_window* win); /*!< minimize the window (in taskbar (per OS))*/
RGFWDEF void RGFW_window_restore(RGFW_window* win); /*!< restore the window from minimized (per OS)*/

/*! if the window should have a border or not (borderless) based on bool value of `border` */
RGFWDEF void RGFW_window_setBorder(RGFW_window* win, b8 border);

/*! turn on / off dnd (RGFW_ALLOW_DND stil must be passed to the window)*/
RGFWDEF void RGFW_window_setDND(RGFW_window* win, b8 allow);

#ifndef RGFW_NO_PASSTHROUGH
	/*!! turn on / off mouse passthrough */
	RGFWDEF void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough);
#endif 

/*! rename window to a given string */
RGFWDEF void RGFW_window_setName(RGFW_window* win,
	char* name
);

void RGFW_window_setIcon(RGFW_window* win, /*!< source window */
	u8* icon /*!< icon bitmap */,
	RGFW_area a /*!< width and height of the bitmap*/,
	i32 channels /*!< how many channels the bitmap has (rgb : 3, rgba : 4) */
); /*!< image resized by default */

/*!< sets mouse to bitmap (very simular to RGFW_window_setIcon), image NOT resized by default*/
RGFWDEF void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels);

/*!< sets the mouse to a standard API cursor (based on RGFW_MOUSE, as seen at the end of the RGFW_HEADER part of this file) */
RGFWDEF	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse);

RGFWDEF void RGFW_window_setMouseDefault(RGFW_window* win); /*!< sets the mouse to the default mouse icon */
/*
	Locks cursor at the center of the window
	win->event.point become raw mouse movement data 

	this is useful for a 3D camera
*/
RGFWDEF void RGFW_window_mouseHold(RGFW_window* win, RGFW_area area);
/*! stop holding the mouse and let it move freely */
RGFWDEF void RGFW_window_mouseUnhold(RGFW_window* win);

/*! hide the window */
RGFWDEF void RGFW_window_hide(RGFW_window* win);
/*! show the window */
RGFWDEF void RGFW_window_show(RGFW_window* win);

/*
	makes it so `RGFW_window_shouldClose` returns true
	by setting the window event.type to RGFW_quit
*/
RGFWDEF void RGFW_window_setShouldClose(RGFW_window* win);

/*! where the mouse is on the screen */
RGFWDEF RGFW_point RGFW_getGlobalMousePoint(void);

/*! where the mouse is on the window */
RGFWDEF RGFW_point RGFW_window_getMousePoint(RGFW_window* win);

/*! show the mouse or hide the mouse*/
RGFWDEF void RGFW_window_showMouse(RGFW_window* win, i8 show);
/*! move the mouse to a set x, y pos*/
RGFWDEF void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v);

/*! if the window should close (RGFW_close was sent or escape was pressed) */
RGFWDEF b8 RGFW_window_shouldClose(RGFW_window* win);
/*! if window is fullscreen'd */
RGFWDEF b8 RGFW_window_isFullscreen(RGFW_window* win);
/*! if window is hidden */
RGFWDEF b8 RGFW_window_isHidden(RGFW_window* win);
/*! if window is minimized */
RGFWDEF b8 RGFW_window_isMinimized(RGFW_window* win);
/*! if window is maximized */
RGFWDEF b8 RGFW_window_isMaximized(RGFW_window* win);

/** @} */ 

/** * @defgroup Monitor
* @{ */ 

#ifndef RGFW_NO_MONITOR
/*
scale the window to the monitor,
this is run by default if the user uses the arg `RGFW_SCALE_TO_MONITOR` during window creation
*/
RGFWDEF void RGFW_window_scaleToMonitor(RGFW_window* win);
/*! get the struct of the window's monitor  */
RGFWDEF RGFW_monitor RGFW_window_getMonitor(RGFW_window* win);
#endif

/** @} */ 

/** * @defgroup Input
* @{ */ 

/*error handling*/
RGFWDEF b8 RGFW_Error(void); /*!< returns true if an error has occurred (doesn't print errors itself) */

/*! returns true if the key should be shifted */
RGFWDEF b8 RGFW_shouldShift(u32 keycode, u8 lockState);

/*! get char from RGFW keycode (using a LUT), uses shift'd version if shift = true */
RGFWDEF char RGFW_keyCodeToChar(u32 keycode, b8 shift);
/*! get char from RGFW keycode (using a LUT), uses lockState for shouldShift) */
RGFWDEF char RGFW_keyCodeToCharAuto(u32 keycode, u8 lockState);

/*! if window == NULL, it checks if the key is pressed globally. Otherwise, it checks only if the key is pressed while the window in focus.*/
RGFWDEF b8 RGFW_isPressed(RGFW_window* win, u8 key); /*!< if key is pressed (key code)*/

RGFWDEF b8 RGFW_wasPressed(RGFW_window* win, u8 key); /*!< if key was pressed (checks previous state only) (key code)*/

RGFWDEF b8 RGFW_isHeld(RGFW_window* win, u8 key); /*!< if key is held (key code)*/
RGFWDEF b8 RGFW_isReleased(RGFW_window* win, u8 key); /*!< if key is released (key code)*/

/* if a key is pressed and then released, pretty much the same as RGFW_isReleased */
RGFWDEF b8 RGFW_isClicked(RGFW_window* win, u8 key /*!< key code*/);

/*! if a mouse button is pressed */
RGFWDEF b8 RGFW_isMousePressed(RGFW_window* win, u8 button /*!< mouse button code */ );
/*! if a mouse button is held */
RGFWDEF b8 RGFW_isMouseHeld(RGFW_window* win, u8 button /*!< mouse button code */ );
/*! if a mouse button was released */
RGFWDEF b8 RGFW_isMouseReleased(RGFW_window* win, u8 button /*!< mouse button code */ );
/*! if a mouse button was pressed (checks previous state only) */
RGFWDEF b8 RGFW_wasMousePressed(RGFW_window* win, u8 button /*!< mouse button code */ );
/** @} */ 

/** * @defgroup Clipboard
* @{ */ 
RGFWDEF char* RGFW_readClipboard(size_t* size); /*!< read clipboard data */
RGFWDEF void RGFW_clipboardFree(char* str); /*!< the string returned from RGFW_readClipboard must be freed */

RGFWDEF void RGFW_writeClipboard(const char* text, u32 textLen); /*!< write text to the clipboard */
/** @} */ 

/**
	
	
	Event callbacks, 
	these are completely optional, you can use the normal 
	RGFW_checkEvent() method if you prefer that

* @defgroup Callbacks
* @{ 
*/

/*! RGFW_windowMoved, the window and its new rect value  */
typedef void (* RGFW_windowmovefunc)(RGFW_window* win, RGFW_rect r);
/*! RGFW_windowResized, the window and its new rect value  */
typedef void (* RGFW_windowresizefunc)(RGFW_window* win, RGFW_rect r);
/*! RGFW_quit, the window that was closed */
typedef void (* RGFW_windowquitfunc)(RGFW_window* win);
/*! RGFW_focusIn / RGFW_focusOut, the window who's focus has changed and if its inFocus */
typedef void (* RGFW_focusfunc)(RGFW_window* win, b8 inFocus);
/*! RGFW_mouseEnter / RGFW_mouseLeave, the window that changed, the point of the mouse (enter only) and if the mouse has entered */
typedef void (* RGFW_mouseNotifyfunc)(RGFW_window* win, RGFW_point point, b8 status);
/*! RGFW_mousePosChanged, the window that the move happened on and the new point of the mouse  */
typedef void (* RGFW_mouseposfunc)(RGFW_window* win, RGFW_point point);
/*! RGFW_dnd_init, the window, the point of the drop on the windows */
typedef void (* RGFW_dndInitfunc)(RGFW_window* win, RGFW_point point);
/*! RGFW_windowRefresh, the window that needs to be refreshed */
typedef void (* RGFW_windowrefreshfunc)(RGFW_window* win);
/*! RGFW_keyPressed / RGFW_keyReleased, the window that got the event, the keycode, the string version, the state of mod keys, if it was a press (else it's a release) */
typedef void (* RGFW_keyfunc)(RGFW_window* win, u32 keycode, char keyName[16], u8 lockState, b8 pressed);
/*! RGFW_mouseButtonPressed / RGFW_mouseButtonReleased, the window that got the event, the button that was pressed, the scroll value, if it was a press (else it's a release)  */
typedef void (* RGFW_mousebuttonfunc)(RGFW_window* win, u8 button, double scroll, b8 pressed);
/*! RGFW_jsButtonPressed / RGFW_jsButtonReleased, the window that got the event, the button that was pressed, the scroll value, if it was a press (else it's a release) */
typedef void (* RGFW_jsButtonfunc)(RGFW_window* win, u16 joystick, u8 button, b8 pressed);
/*! RGFW_jsAxisMove, the window that got the event, the joystick in question, the axis values and the amount of axises */
typedef void (* RGFW_jsAxisfunc)(RGFW_window* win, u16 joystick, RGFW_point axis[2], u8 axisesCount);


/*!  RGFW_dnd, the window that had the drop, the drop data and the amount files dropped returns previous callback function (if it was set) */
#ifdef RGFW_ALLOC_DROPFILES
	typedef void (* RGFW_dndfunc)(RGFW_window* win, char** droppedFiles, u32 droppedFilesCount);
#else
	typedef void (* RGFW_dndfunc)(RGFW_window* win, char droppedFiles[RGFW_MAX_DROPS][RGFW_MAX_PATH], u32 droppedFilesCount);
#endif
/*! set callback for a window move event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowmovefunc RGFW_setWindowMoveCallback(RGFW_windowmovefunc func);
/*! set callback for a window resize event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowresizefunc RGFW_setWindowResizeCallback(RGFW_windowresizefunc func);
/*! set callback for a window quit event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowquitfunc RGFW_setWindowQuitCallback(RGFW_windowquitfunc func);
/*! set callback for a mouse move event returns previous callback function (if it was set)  */
RGFWDEF RGFW_mouseposfunc RGFW_setMousePosCallback(RGFW_mouseposfunc func);
/*! set callback for a window refresh event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowrefreshfunc RGFW_setWindowRefreshCallback(RGFW_windowrefreshfunc func);
/*! set callback for a window focus change event returns previous callback function (if it was set)  */
RGFWDEF RGFW_focusfunc RGFW_setFocusCallback(RGFW_focusfunc func);
/*! set callback for a mouse notify event returns previous callback function (if it was set)  */
RGFWDEF RGFW_mouseNotifyfunc RGFW_setMouseNotifyCallBack(RGFW_mouseNotifyfunc func);
/*! set callback for a drop event event returns previous callback function (if it was set)  */
RGFWDEF RGFW_dndfunc RGFW_setDndCallback(RGFW_dndfunc func);
/*! set callback for a start of a drop event returns previous callback function (if it was set)  */
RGFWDEF RGFW_dndInitfunc RGFW_setDndInitCallback(RGFW_dndInitfunc func);
/*! set callback for a key (press / release ) event returns previous callback function (if it was set)  */
RGFWDEF RGFW_keyfunc RGFW_setKeyCallback(RGFW_keyfunc func);
/*! set callback for a mouse button (press / release ) event returns previous callback function (if it was set)  */
RGFWDEF RGFW_mousebuttonfunc RGFW_setMouseButtonCallback(RGFW_mousebuttonfunc func);
/*! set callback for a controller button (press / release ) event returns previous callback function (if it was set)  */
RGFWDEF RGFW_jsButtonfunc RGFW_setjsButtonCallback(RGFW_jsButtonfunc func);
/*! set callback for a joystick axis mov event returns previous callback function (if it was set)  */
RGFWDEF RGFW_jsAxisfunc RGFW_setjsAxisCallback(RGFW_jsAxisfunc func);

/** @} */ 

/** * @defgroup Threads
* @{ */ 

#ifndef RGFW_NO_THREADS
	/*! threading functions*/

	/*! NOTE! (for X11/linux) : if you define a window in a thread, it must be run after the original thread's window is created or else there will be a memory error */
	/*
		I'd suggest you use sili's threading functions instead
		if you're going to use sili
		which is a good idea generally
	*/

	#if defined(__unix__) || defined(__APPLE__) || defined(RGFW_WEBASM) 
		typedef void* (* RGFW_threadFunc_ptr)(void*);
	#else
		typedef DWORD (__stdcall *RGFW_threadFunc_ptr) (LPVOID lpThreadParameter);  
	#endif

	RGFWDEF RGFW_thread RGFW_createThread(RGFW_threadFunc_ptr ptr, void* args); /*!< create a thread*/
	RGFWDEF void RGFW_cancelThread(RGFW_thread thread); /*!< cancels a thread*/
	RGFWDEF void RGFW_joinThread(RGFW_thread thread); /*!< join thread to current thread */
	RGFWDEF void RGFW_setThreadPriority(RGFW_thread thread, u8 priority); /*!< sets the priority priority  */
#endif

/** @} */ 

/** * @defgroup joystick
* @{ */ 

/*! joystick count starts at 0*/
/*!< register joystick to window based on a number (the number is based on when it was connected eg. /dev/js0)*/
RGFWDEF u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber);
RGFWDEF u16 RGFW_registerJoystickF(RGFW_window* win, char* file);

RGFWDEF u32 RGFW_isPressedJS(RGFW_window* win, u16 controller, u8 button);

/** @} */ 

/** * @defgroup graphics_API
* @{ */ 

/*!< make the window the current opengl drawing context

	NOTE:
 	if you want to switch the graphics context's thread, 
	you have to run RGFW_window_makeCurrent(NULL); on the old thread
	then RGFW_window_makeCurrent(valid_window) on the new thread
*/
RGFWDEF void RGFW_window_makeCurrent(RGFW_window* win);

/*< updates fps / sets fps to cap (must by ran manually by the user at the end of a frame), returns current fps */
RGFWDEF u32 RGFW_window_checkFPS(RGFW_window* win, u32 fpsCap);

/* supports openGL, directX, OSMesa, EGL and software rendering */
RGFWDEF void RGFW_window_swapBuffers(RGFW_window* win); /*!< swap the rendering buffer */
RGFWDEF void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval);

RGFWDEF void RGFW_window_setGPURender(RGFW_window* win, i8 set);
RGFWDEF void RGFW_window_setCPURender(RGFW_window* win, i8 set);

/*! native API functions */
#if defined(RGFW_OPENGL) || defined(RGFW_EGL)
	/*! OpenGL init hints */
	RGFWDEF void RGFW_setGLStencil(i32 stencil); /*!< set stencil buffer bit size (8 by default) */
	RGFWDEF void RGFW_setGLSamples(i32 samples); /*!< set number of sampiling buffers (4 by default) */
	RGFWDEF void RGFW_setGLStereo(i32 stereo); /*!< use GL_STEREO (GL_FALSE by default) */
	RGFWDEF void RGFW_setGLAuxBuffers(i32 auxBuffers); /*!< number of aux buffers (0 by default) */

	/*! which profile to use for the opengl verion */
	typedef RGFW_ENUM(u8, RGFW_GL_profile)  { RGFW_GL_CORE = 0,  RGFW_GL_COMPATIBILITY  };
	/*! Set OpenGL version hint (core or compatibility profile)*/
	RGFWDEF void RGFW_setGLVersion(RGFW_GL_profile profile, i32 major, i32 minor);
	RGFWDEF void RGFW_setDoubleBuffer(b8 useDoubleBuffer); 
    RGFWDEF void* RGFW_getProcAddress(const char* procname); /*!< get native opengl proc address */
    RGFWDEF void RGFW_window_makeCurrent_OpenGL(RGFW_window* win); /*!< to be called by RGFW_window_makeCurrent */
#elif defined(RGFW_DIRECTX)
	typedef struct {
		IDXGIFactory* pFactory;
		IDXGIAdapter* pAdapter;
		ID3D11Device* pDevice;
		ID3D11DeviceContext* pDeviceContext;
	} RGFW_directXinfo;

	/*
		RGFW stores a global instance of RGFW_directXinfo,
		you can use this function to get a pointer the instance
	*/
	RGFWDEF RGFW_directXinfo* RGFW_getDirectXInfo(void);
#endif

/** @} */ 

/** * @defgroup Supporting
* @{ */ 
RGFWDEF u64 RGFW_getTime(void); /*!< get time in seconds */
RGFWDEF u64 RGFW_getTimeNS(void); /*!< get time in nanoseconds */
RGFWDEF void RGFW_sleep(u64 milisecond); /*!< sleep for a set time */

/*!
	key codes and mouse icon enums
*/

typedef RGFW_ENUM(u8, RGFW_Key) {
	RGFW_KEY_NULL = 0,
	RGFW_Escape,
	RGFW_F1,
	RGFW_F2,
	RGFW_F3,
	RGFW_F4,
	RGFW_F5,
	RGFW_F6,
	RGFW_F7,
	RGFW_F8,
	RGFW_F9,
	RGFW_F10,
	RGFW_F11,
	RGFW_F12,

	RGFW_Backtick,

	RGFW_0,
	RGFW_1,
	RGFW_2,
	RGFW_3,
	RGFW_4,
	RGFW_5,
	RGFW_6,
	RGFW_7,
	RGFW_8,
	RGFW_9,

	RGFW_Minus,
	RGFW_Equals,
	RGFW_BackSpace,
	RGFW_Tab,
	RGFW_CapsLock,
	RGFW_ShiftL,
	RGFW_ControlL,
	RGFW_AltL,
	RGFW_SuperL,
	RGFW_ShiftR,
	RGFW_ControlR,
	RGFW_AltR,
	RGFW_SuperR,
	RGFW_Space,

	RGFW_a,
	RGFW_b,
	RGFW_c,
	RGFW_d,
	RGFW_e,
	RGFW_f,
	RGFW_g,
	RGFW_h,
	RGFW_i,
	RGFW_j,
	RGFW_k,
	RGFW_l,
	RGFW_m,
	RGFW_n,
	RGFW_o,
	RGFW_p,
	RGFW_q,
	RGFW_r,
	RGFW_s,
	RGFW_t,
	RGFW_u,
	RGFW_v,
	RGFW_w,
	RGFW_x,
	RGFW_y,
	RGFW_z,

	RGFW_Period,
	RGFW_Comma,
	RGFW_Slash,
	RGFW_Bracket,
	RGFW_CloseBracket,
	RGFW_Semicolon,
	RGFW_Return,
	RGFW_Quote,
	RGFW_BackSlash,

	RGFW_Up,
	RGFW_Down,
	RGFW_Left,
	RGFW_Right,

	RGFW_Delete,
	RGFW_Insert,
	RGFW_End,
	RGFW_Home,
	RGFW_PageUp,
	RGFW_PageDown,

	RGFW_Numlock,
	RGFW_KP_Slash,
	RGFW_Multiply,
	RGFW_KP_Minus,
	RGFW_KP_1,
	RGFW_KP_2,
	RGFW_KP_3,
	RGFW_KP_4,
	RGFW_KP_5,
	RGFW_KP_6,
	RGFW_KP_7,
	RGFW_KP_8,
	RGFW_KP_9,
	RGFW_KP_0,
	RGFW_KP_Period,
	RGFW_KP_Return,

	final_key,
};


typedef RGFW_ENUM(u8, RGFW_mouseIcons) {
	RGFW_MOUSE_NORMAL = 0,
	RGFW_MOUSE_ARROW,
	RGFW_MOUSE_IBEAM,
	RGFW_MOUSE_CROSSHAIR,
	RGFW_MOUSE_POINTING_HAND,
	RGFW_MOUSE_RESIZE_EW,
	RGFW_MOUSE_RESIZE_NS,
	RGFW_MOUSE_RESIZE_NWSE,
	RGFW_MOUSE_RESIZE_NESW,
	RGFW_MOUSE_RESIZE_ALL,
	RGFW_MOUSE_NOT_ALLOWED,
};

/** @} */ 

#endif /* RGFW_HEADER */

/*
Example to get you started :

linux : gcc main.c -lX11 -lXcursor -lGL
windows : gcc main.c -lopengl32 -lshell32 -lgdi32
macos : gcc main.c -framework Foundation -framework AppKit -framework OpenGL -framework CoreVideo

#define RGFW_IMPLEMENTATION
#include "RGFW.h"

u8 icon[4 * 3 * 3] = {0xFF, 0x00, 0x00, 0xFF,    0xFF, 0x00, 0x00, 0xFF,     0xFF, 0x00, 0x00, 0xFF,   0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF,     0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF};

int main() {
	RGFW_window* win = RGFW_createWindow("name", RGFW_RECT(500, 500, 500, 500), (u64)0);

	RGFW_window_setIcon(win, icon, RGFW_AREA(3, 3), 4);

	for (;;) {
		RGFW_window_checkEvent(win); // NOTE: checking events outside of a while loop may cause input lag
		if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape))
			break;

		RGFW_window_swapBuffers(win);

		glClearColor(0xFF, 0XFF, 0xFF, 0xFF);
		glClear(GL_COLOR_BUFFER_BIT);
	}

	RGFW_window_close(win);
}

	compiling :

	if you wish to compile the library all you have to do is create a new file with this in it

	rgfw.c
	#define RGFW_IMPLEMENTATION
	#include "RGFW.h"

	then you can use gcc (or whatever compile you wish to use) to compile the library into object file

	ex. gcc -c RGFW.c -fPIC

	after you compile the library into an object file, you can also turn the object file into an static or shared library

	(commands ar and gcc can be replaced with whatever equivalent your system uses)
	static : ar rcs RGFW.a RGFW.o
	shared :
		windows:
			gcc -shared RGFW.o -lopengl32 -lshell32 -lgdi32 -o RGFW.dll
		linux:
			gcc -shared RGFW.o -lX11 -lXcursor -lGL -o RGFW.so
		macos:
			gcc -shared RGFW.o -framework Foundation -framework AppKit -framework OpenGL -framework CoreVideo
*/

#ifdef RGFW_X11
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) l
#elif defined(RGFW_WINDOWS)
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) w
#elif defined(RGFW_MACOS)
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) m
#elif defined(RGFW_WEBASM)
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) h
#elif defined(RGFW_WAYLAND)
    #define RGFW_OS_BASED_VALUE(l, w, m, h, ww) ww  
#endif


#ifdef RGFW_IMPLEMENTATION

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <assert.h>

/*
RGFW_IMPLEMENTATION starts with generic RGFW defines

This is the start of keycode data

	Why not use macros instead of the numbers itself?
	Windows -> Not all virtual keys are macros (VK_0 - VK_1, VK_a - VK_z)
	Linux -> Only symcodes are values, (XK_0 - XK_1, XK_a - XK_z) are larger than 0xFF00, I can't find any way to work with them without making the array an unreasonable size
	MacOS -> windows and linux already don't have keycodes as macros, so there's no point
*/



/* 
	the c++ compiler doesn't support setting up an array like, 
	we'll have to do it during runtime using a function & this messy setup
*/
#ifndef __cplusplus
#define RGFW_NEXT ,
#define RGFW_MAP
#else 
#define RGFW_NEXT ;
#define RGFW_MAP RGFW_keycodes
#endif

#ifdef RGFW_WAYLAND
#include <linux/input-event-codes.h>
#endif

u8 RGFW_keycodes [RGFW_OS_BASED_VALUE(136, 337, 128, DOM_VK_WIN_OEM_CLEAR + 1, 130)] = {
#ifdef __cplusplus
	0
};
void RGFW_init_keys(void) {
#endif
	RGFW_MAP [RGFW_OS_BASED_VALUE(49, 192, 50, DOM_VK_BACK_QUOTE, KEY_GRAVE)] = RGFW_Backtick 		RGFW_NEXT

	RGFW_MAP [RGFW_OS_BASED_VALUE(19, 0x30, 29, DOM_VK_0, KEY_0)] = RGFW_0 					RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(10, 0x31, 18, DOM_VK_1, KEY_1)] = RGFW_1						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(11, 0x32, 19, DOM_VK_2, KEY_2)] = RGFW_2						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(12, 0x33, 20, DOM_VK_3, KEY_3)] = RGFW_3						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(13, 0x34, 21, DOM_VK_4, KEY_4)] = RGFW_4						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(14, 0x35, 23, DOM_VK_5, KEY_5)] = RGFW_5                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(15, 0x36, 22, DOM_VK_6, KEY_6)] = RGFW_6                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(16, 0x37, 26, DOM_VK_7, KEY_7)] = RGFW_7                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(17, 0x38, 28, DOM_VK_8, KEY_8)] = RGFW_8                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(18, 0x39, 25, DOM_VK_9, KEY_9)] = RGFW_9,

	RGFW_MAP [RGFW_OS_BASED_VALUE(65, 0x20, 49, DOM_VK_SPACE, KEY_SPACE)] = RGFW_Space,

	RGFW_MAP [RGFW_OS_BASED_VALUE(38, 0x41, 0, DOM_VK_A, KEY_A)] = RGFW_a                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(56, 0x42, 11, DOM_VK_B, KEY_B)] = RGFW_b                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(54, 0x43, 8, DOM_VK_C, KEY_C)] = RGFW_c                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(40, 0x44, 2, DOM_VK_D, KEY_D)] = RGFW_d                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(26, 0x45, 14, DOM_VK_E, KEY_E)] = RGFW_e                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(41, 0x46, 3, DOM_VK_F, KEY_F)] = RGFW_f                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(42, 0x47, 5, DOM_VK_G, KEY_G)] = RGFW_g                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(43, 0x48, 4, DOM_VK_H, KEY_H)] = RGFW_h                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(31, 0x49, 34, DOM_VK_I, KEY_I)] = RGFW_i                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(44, 0x4A, 38, DOM_VK_J, KEY_J)] = RGFW_j                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(45, 0x4B, 40, DOM_VK_K, KEY_K)] = RGFW_k                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(46, 0x4C, 37, DOM_VK_L, KEY_L)] = RGFW_l                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(58, 0x4D, 46, DOM_VK_M, KEY_M)] = RGFW_m                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(57, 0x4E, 45, DOM_VK_N, KEY_N)] = RGFW_n                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(32, 0x4F, 31, DOM_VK_O, KEY_O)] = RGFW_o                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(33, 0x50, 35, DOM_VK_P, KEY_P)] = RGFW_p                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(24, 0x51, 12, DOM_VK_Q, KEY_Q)] = RGFW_q                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(27, 0x52, 15, DOM_VK_R, KEY_R)] = RGFW_r                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(39, 0x53, 1, DOM_VK_S, KEY_S)] = RGFW_s                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(28, 0x54, 17, DOM_VK_T, KEY_T)] = RGFW_t                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(30, 0x55, 32, DOM_VK_U, KEY_U)] = RGFW_u                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(55, 0x56, 9, DOM_VK_V, KEY_V)] = RGFW_v                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(25, 0x57, 13, DOM_VK_W, KEY_W)] = RGFW_w                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(53, 0x58, 7, DOM_VK_X, KEY_X)] = RGFW_x                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(29, 0x59, 16, DOM_VK_Y, KEY_Y)] = RGFW_y                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(52, 0x5A, 6, DOM_VK_Z, KEY_Z)] = RGFW_z,

	RGFW_MAP [RGFW_OS_BASED_VALUE(60, 190, 47, DOM_VK_PERIOD, KEY_DOT)] = RGFW_Period             			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(59, 188, 43, DOM_VK_COMMA, KEY_COMMA)] = RGFW_Comma               			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(61, 191, 44, DOM_VK_SLASH, KEY_SLASH)] = RGFW_Slash               			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(34, 219, 33, DOM_VK_OPEN_BRACKET, KEY_LEFTBRACE)] = RGFW_Bracket      			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(35, 221, 30, DOM_VK_CLOSE_BRACKET, KEY_RIGHTBRACE)] = RGFW_CloseBracket             RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(47, 186, 41, DOM_VK_SEMICOLON, KEY_SEMICOLON)] = RGFW_Semicolon                 RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(48, 222, 39, DOM_VK_QUOTE, KEY_APOSTROPHE)] = RGFW_Quote                 			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(51, 322, 42, DOM_VK_BACK_SLASH, KEY_BACKSLASH)] = RGFW_BackSlash,
	
	RGFW_MAP [RGFW_OS_BASED_VALUE(36, 0x0D, 36, DOM_VK_RETURN, KEY_ENTER)] = RGFW_Return              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(119, 0x2E, 118, DOM_VK_DELETE, KEY_DELETE)] = RGFW_Delete                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(77, 0x90, 72, DOM_VK_NUM_LOCK, KEY_NUMLOCK)] = RGFW_Numlock               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(106, 0x6F, 82, DOM_VK_DIVIDE, KEY_KPSLASH)] = RGFW_KP_Slash               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(63, 0x6A, 76, DOM_VK_MULTIPLY, KEY_KPASTERISK)] = RGFW_Multiply              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(82, 0x6D, 67, DOM_VK_SUBTRACT, KEY_KPMINUS)] = RGFW_KP_Minus              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(87, 0x61, 84, DOM_VK_NUMPAD1, KEY_KP1)] = RGFW_KP_1               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(88, 0x62, 85, DOM_VK_NUMPAD2, KEY_KP2)] = RGFW_KP_2               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(89, 0x63, 86, DOM_VK_NUMPAD3, KEY_KP3)] = RGFW_KP_3               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(83, 0x64, 87, DOM_VK_NUMPAD4, KEY_KP4)] = RGFW_KP_4               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(84, 0x65, 88, DOM_VK_NUMPAD5, KEY_KP5)] = RGFW_KP_5               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(85, 0x66, 89, DOM_VK_NUMPAD6, KEY_KP6)] = RGFW_KP_6               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(79, 0x67, 90, DOM_VK_NUMPAD7, KEY_KP7)] = RGFW_KP_7               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(80, 0x68, 92, DOM_VK_NUMPAD8, KEY_KP8)] = RGFW_KP_8               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(81, 0x69, 93, DOM_VK_NUMPAD9, KEY_KP9)] = RGFW_KP_9               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(90, 0x60, 83, DOM_VK_NUMPAD0, KEY_KP0)] = RGFW_KP_0               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(91, 0x6E, 65, DOM_VK_DECIMAL, KEY_KPDOT)] = RGFW_KP_Period              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(104, 0x92, 77, 0, KEY_KPENTER)] = RGFW_KP_Return,
	
	RGFW_MAP [RGFW_OS_BASED_VALUE(20, 189, 27, DOM_VK_HYPHEN_MINUS, KEY_MINUS)] = RGFW_Minus              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(21, 187, 24, DOM_VK_EQUALS, KEY_EQUAL)] = RGFW_Equals               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(22, 8, 51, DOM_VK_BACK_SPACE, KEY_BACKSPACE)] = RGFW_BackSpace              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(23, 0x09, 48, DOM_VK_TAB, KEY_TAB)] = RGFW_Tab                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(66, 20, 57, DOM_VK_CAPS_LOCK, KEY_CAPSLOCK)] = RGFW_CapsLock               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(50, 0x10, 56, DOM_VK_SHIFT, KEY_LEFTSHIFT)] = RGFW_ShiftL               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(37, 0x11, 59, DOM_VK_CONTROL, KEY_LEFTCTRL)] = RGFW_ControlL               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(64,0x12, 58, DOM_VK_ALT, KEY_LEFTALT)] = RGFW_AltL                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(133, 0x5B, 55, DOM_VK_WIN, KEY_LEFTMETA)] = RGFW_SuperL,
	
	#if !defined(RGFW_WINDOWS) && !defined(RGFW_MACOS) && !defined(RGFW_WEBASM)
	RGFW_MAP [RGFW_OS_BASED_VALUE(105, 0x11, 59, 0, KEY_RIGHTCTRL)] = RGFW_ControlR               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(135, 0xA4, 55, 0, KEY_RIGHTMETA)] = RGFW_SuperR,
	RGFW_MAP [RGFW_OS_BASED_VALUE(62, 0x5C, 56, 0, KEY_RIGHTSHIFT)] = RGFW_ShiftR              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(108, 165, 58, 0, KEY_RIGHTALT)] = RGFW_AltR,
	#endif

	RGFW_MAP [RGFW_OS_BASED_VALUE(67, 0x70, 127, DOM_VK_F1, KEY_F1)] = RGFW_F1                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(68, 0x71, 121, DOM_VK_F2, KEY_F2)] = RGFW_F2                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(69, 0x72, 100, DOM_VK_F3, KEY_F3)] = RGFW_F3                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(70, 0x73, 119, DOM_VK_F4, KEY_F4)] = RGFW_F4                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(71, 0x74, 97, DOM_VK_F5, KEY_F5)] = RGFW_F5              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(72, 0x75, 98, DOM_VK_F6, KEY_F6)] = RGFW_F6              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(73, 0x76, 99, DOM_VK_F7, KEY_F7)] = RGFW_F7              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(74, 0x77, 101, DOM_VK_F8, KEY_F8)] = RGFW_F8                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(75, 0x78, 102, DOM_VK_F9, KEY_F9)] = RGFW_F9                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(76, 0x79, 110, DOM_VK_F10, KEY_F10)] = RGFW_F10               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(95, 0x7A, 104, DOM_VK_F11, KEY_F11)] = RGFW_F11               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(96, 0x7B, 112, DOM_VK_F12, KEY_F12)] = RGFW_F12               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(111, 0x26, 126, DOM_VK_UP, KEY_UP)] = RGFW_Up                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(116, 0x28, 125, DOM_VK_DOWN, KEY_DOWN)] = RGFW_Down                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(113, 0x25, 123, DOM_VK_LEFT, KEY_LEFT)] = RGFW_Left                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(114, 0x27, 124, DOM_VK_RIGHT, KEY_RIGHT)] = RGFW_Right              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(118, 0x2D, 115, DOM_VK_INSERT, KEY_INSERT)] = RGFW_Insert                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(115, 0x23, 120, DOM_VK_END, KEY_END)] = RGFW_End                  		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(112, 336, 117, DOM_VK_PAGE_UP, KEY_PAGEUP)] = RGFW_PageUp                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(117, 325, 122, DOM_VK_PAGE_DOWN, KEY_PAGEDOWN)] = RGFW_PageDown            RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(9, 0x1B, 53, DOM_VK_ESCAPE, KEY_ESC)] = RGFW_Escape                   		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(110, 0x24, 116, DOM_VK_HOME, KEY_HOME)] = RGFW_Home                    		RGFW_NEXT
#ifndef __cplusplus
};
#else 
}
#endif

#undef RGFW_NEXT
#undef RGFW_MAP

typedef struct {
	b8 current  : 1;
	b8 prev  : 1;
} RGFW_keyState;

RGFW_keyState RGFW_keyboard[final_key] = { {0, 0} };

RGFWDEF u32 RGFW_apiKeyCodeToRGFW(u32 keycode);

u32 RGFW_apiKeyCodeToRGFW(u32 keycode) {
	#ifdef __cplusplus
	if (RGFW_OS_BASED_VALUE(49, 192, 50, DOM_VK_BACK_QUOTE, KEY_GRAVE) != RGFW_Backtick) {
		RGFW_init_keys();
	}
	#endif

	/* make sure the key isn't out of bounds */
	if (keycode > sizeof(RGFW_keycodes) / sizeof(u8))
		return 0;
	
	return RGFW_keycodes[keycode];
}

RGFWDEF void RGFW_resetKey(void);
void RGFW_resetKey(void) {
	size_t len = final_key; /*!< last_key == length */
	
	size_t i; /*!< reset each previous state  */
	for (i = 0; i < len; i++)
		RGFW_keyboard[i].prev = 0;
}

b8 RGFW_shouldShift(u32 keycode, u8 lockState) {
    #define RGFW_xor(x, y) (( (x) && (!(y)) ) ||  ((y) && (!(x)) ))
    b8 caps4caps = (lockState & RGFW_CAPSLOCK) && ((keycode >= RGFW_a) && (keycode <= RGFW_z));
    b8 shouldShift = RGFW_xor((RGFW_isPressed(NULL, RGFW_ShiftL) || RGFW_isPressed(NULL, RGFW_ShiftR)), caps4caps);
    #undef RGFW_xor

	return shouldShift;
}	

char RGFW_keyCodeToChar(u32 keycode, b8 shift) {
    static const char map[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '`', '0', '1', '2', '3', '4', '5', '6', '7', '8', 
        '9', '-', '=', 0, '\t',  0, 0, 0, 0, 0, 0, 0, 0, 0, ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
        'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '.', ',', '/', '[', ']',  ';', '\n', '\'', '\\', 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  '/', '*', '-', '1', '2', '3',  '3', '5', '6', '7', '8',  '9', '0', '\n'
    };

    static const char mapCaps[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '~', ')', '!', '@', '#', '$', '%', '^', '&', '*', 
        '(', '_', '+', 0, '0',  0, 0, 0, 0, 0, 0, 0, 0, 0, ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
        'X', 'Y', 'Z', '>', '<', '?', '{', '}',  ':', '\n', '"', '|', 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '?', '*', '-', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    if (shift == RGFW_FALSE)
        return map[keycode]; 
    return mapCaps[keycode];
}

char RGFW_keyCodeToCharAuto(u32 keycode, u8 lockState) { return RGFW_keyCodeToChar(keycode, RGFW_shouldShift(keycode, lockState)); }

/*
	this is the end of keycode data
*/

/* joystick data */
u8 RGFW_jsPressed[4][16]; /*!< if a key is currently pressed or not (per joystick) */

i32 RGFW_joysticks[4]; /*!< limit of 4 joysticks at a time */
u16 RGFW_joystickCount; /*!< the actual amount of joysticks */

/* 
	event callback defines start here
*/


/*
	These exist to avoid the 
	if (func == NULL) check 
	for (allegedly) better performance
*/
void RGFW_windowmovefuncEMPTY(RGFW_window* win, RGFW_rect r) { RGFW_UNUSED(win); RGFW_UNUSED(r); }
void RGFW_windowresizefuncEMPTY(RGFW_window* win, RGFW_rect r) { RGFW_UNUSED(win); RGFW_UNUSED(r); }
void RGFW_windowquitfuncEMPTY(RGFW_window* win) { RGFW_UNUSED(win); }
void RGFW_focusfuncEMPTY(RGFW_window* win, b8 inFocus) {RGFW_UNUSED(win); RGFW_UNUSED(inFocus);}
void RGFW_mouseNotifyfuncEMPTY(RGFW_window* win, RGFW_point point, b8 status) {RGFW_UNUSED(win); RGFW_UNUSED(point); RGFW_UNUSED(status);}
void RGFW_mouseposfuncEMPTY(RGFW_window* win, RGFW_point point) {RGFW_UNUSED(win); RGFW_UNUSED(point);}
void RGFW_dndInitfuncEMPTY(RGFW_window* win, RGFW_point point) {RGFW_UNUSED(win); RGFW_UNUSED(point);}
void RGFW_windowrefreshfuncEMPTY(RGFW_window* win) {RGFW_UNUSED(win); }
void RGFW_keyfuncEMPTY(RGFW_window* win, u32 keycode, char keyName[16], u8 lockState, b8 pressed) {RGFW_UNUSED(win); RGFW_UNUSED(keycode); RGFW_UNUSED(keyName); RGFW_UNUSED(lockState); RGFW_UNUSED(pressed);}
void RGFW_mousebuttonfuncEMPTY(RGFW_window* win, u8 button, double scroll, b8 pressed) {RGFW_UNUSED(win); RGFW_UNUSED(button); RGFW_UNUSED(scroll); RGFW_UNUSED(pressed);}
void RGFW_jsButtonfuncEMPTY(RGFW_window* win, u16 joystick, u8 button, b8 pressed){RGFW_UNUSED(win); RGFW_UNUSED(joystick); RGFW_UNUSED(button); RGFW_UNUSED(pressed); }
void RGFW_jsAxisfuncEMPTY(RGFW_window* win, u16 joystick, RGFW_point axis[2], u8 axisesCount){RGFW_UNUSED(win); RGFW_UNUSED(joystick); RGFW_UNUSED(axis); RGFW_UNUSED(axisesCount); }

#ifdef RGFW_ALLOC_DROPFILES
void RGFW_dndfuncEMPTY(RGFW_window* win, char** droppedFiles, u32 droppedFilesCount) {RGFW_UNUSED(win); RGFW_UNUSED(droppedFiles); RGFW_UNUSED(droppedFilesCount);}
#else
void RGFW_dndfuncEMPTY(RGFW_window* win, char droppedFiles[RGFW_MAX_DROPS][RGFW_MAX_PATH], u32 droppedFilesCount) {RGFW_UNUSED(win); RGFW_UNUSED(droppedFiles); RGFW_UNUSED(droppedFilesCount);}
#endif

RGFW_windowmovefunc RGFW_windowMoveCallback = RGFW_windowmovefuncEMPTY;
RGFW_windowresizefunc RGFW_windowResizeCallback = RGFW_windowresizefuncEMPTY;
RGFW_windowquitfunc RGFW_windowQuitCallback = RGFW_windowquitfuncEMPTY;
RGFW_mouseposfunc RGFW_mousePosCallback = RGFW_mouseposfuncEMPTY;
RGFW_windowrefreshfunc RGFW_windowRefreshCallback = RGFW_windowrefreshfuncEMPTY;
RGFW_focusfunc RGFW_focusCallback = RGFW_focusfuncEMPTY;
RGFW_mouseNotifyfunc RGFW_mouseNotifyCallBack = RGFW_mouseNotifyfuncEMPTY;
RGFW_dndfunc RGFW_dndCallback = RGFW_dndfuncEMPTY;
RGFW_dndInitfunc RGFW_dndInitCallback = RGFW_dndInitfuncEMPTY;
RGFW_keyfunc RGFW_keyCallback = RGFW_keyfuncEMPTY;
RGFW_mousebuttonfunc RGFW_mouseButtonCallback = RGFW_mousebuttonfuncEMPTY;
RGFW_jsButtonfunc RGFW_jsButtonCallback = RGFW_jsButtonfuncEMPTY;
RGFW_jsAxisfunc RGFW_jsAxisCallback = RGFW_jsAxisfuncEMPTY;

void RGFW_window_checkEvents(RGFW_window* win, i32 waitMS) { 
	RGFW_window_eventWait(win, waitMS);

	while (RGFW_window_checkEvent(win) != NULL && RGFW_window_shouldClose(win) == 0) { 
		if (win->event.type == RGFW_quit) return; 
	}
	
	#ifdef RGFW_WEBASM /* webasm needs to run the sleep function for asyncify */
		RGFW_sleep(0);
	#endif
}

RGFW_windowmovefunc RGFW_setWindowMoveCallback(RGFW_windowmovefunc func) { 
	RGFW_windowmovefunc	prev =  (RGFW_windowMoveCallback == RGFW_windowmovefuncEMPTY) ? NULL : RGFW_windowMoveCallback;
	RGFW_windowMoveCallback = func;
	return prev;
}
RGFW_windowresizefunc RGFW_setWindowResizeCallback(RGFW_windowresizefunc func) {
    RGFW_windowresizefunc prev = (RGFW_windowResizeCallback == RGFW_windowresizefuncEMPTY) ? NULL : RGFW_windowResizeCallback;
    RGFW_windowResizeCallback = func;
    return prev;
}
RGFW_windowquitfunc RGFW_setWindowQuitCallback(RGFW_windowquitfunc func) {
    RGFW_windowquitfunc prev = (RGFW_windowQuitCallback == RGFW_windowquitfuncEMPTY) ? NULL : RGFW_windowQuitCallback;
    RGFW_windowQuitCallback = func;
    return prev;
}

RGFW_mouseposfunc RGFW_setMousePosCallback(RGFW_mouseposfunc func) {
    RGFW_mouseposfunc prev = (RGFW_mousePosCallback == RGFW_mouseposfuncEMPTY) ? NULL : RGFW_mousePosCallback;
    RGFW_mousePosCallback = func;
    return prev;
}
RGFW_windowrefreshfunc RGFW_setWindowRefreshCallback(RGFW_windowrefreshfunc func) {
    RGFW_windowrefreshfunc prev = (RGFW_windowRefreshCallback == RGFW_windowrefreshfuncEMPTY) ? NULL : RGFW_windowRefreshCallback;
    RGFW_windowRefreshCallback = func;
    return prev;
}
RGFW_focusfunc RGFW_setFocusCallback(RGFW_focusfunc func) {
    RGFW_focusfunc prev = (RGFW_focusCallback == RGFW_focusfuncEMPTY) ? NULL : RGFW_focusCallback;
    RGFW_focusCallback = func;
    return prev;
}

RGFW_mouseNotifyfunc RGFW_setMouseNotifyCallBack(RGFW_mouseNotifyfunc func) {
    RGFW_mouseNotifyfunc prev = (RGFW_mouseNotifyCallBack == RGFW_mouseNotifyfuncEMPTY) ? NULL : RGFW_mouseNotifyCallBack;
    RGFW_mouseNotifyCallBack = func;
    return prev;
}
RGFW_dndfunc RGFW_setDndCallback(RGFW_dndfunc func) {
    RGFW_dndfunc prev = (RGFW_dndCallback == RGFW_dndfuncEMPTY) ? NULL : RGFW_dndCallback;
    RGFW_dndCallback = func;
    return prev;
}
RGFW_dndInitfunc RGFW_setDndInitCallback(RGFW_dndInitfunc func) {
    RGFW_dndInitfunc prev = (RGFW_dndInitCallback == RGFW_dndInitfuncEMPTY) ? NULL : RGFW_dndInitCallback;
    RGFW_dndInitCallback = func;
    return prev;
}
RGFW_keyfunc RGFW_setKeyCallback(RGFW_keyfunc func) {
    RGFW_keyfunc prev = (RGFW_keyCallback == RGFW_keyfuncEMPTY) ? NULL : RGFW_keyCallback;
    RGFW_keyCallback = func;
    return prev;
}
RGFW_mousebuttonfunc RGFW_setMouseButtonCallback(RGFW_mousebuttonfunc func) {
    RGFW_mousebuttonfunc prev = (RGFW_mouseButtonCallback == RGFW_mousebuttonfuncEMPTY) ? NULL : RGFW_mouseButtonCallback;
    RGFW_mouseButtonCallback = func;
    return prev;
}
RGFW_jsButtonfunc RGFW_setjsButtonCallback(RGFW_jsButtonfunc func) {
    RGFW_jsButtonfunc prev = (RGFW_jsButtonCallback == RGFW_jsButtonfuncEMPTY) ? NULL : RGFW_jsButtonCallback;
    RGFW_jsButtonCallback = func;
    return prev;
}
RGFW_jsAxisfunc RGFW_setjsAxisCallback(RGFW_jsAxisfunc func) {
    RGFW_jsAxisfunc prev = (RGFW_jsAxisCallback == RGFW_jsAxisfuncEMPTY) ? NULL : RGFW_jsAxisCallback;
    RGFW_jsAxisCallback = func;
    return prev;
}
/* 
no more event call back defines
*/

#define RGFW_ASSERT(check, str) {\
	if (!(check)) { \
		printf(str); \
		assert(check); \
	} \
}

b8 RGFW_error = 0;
b8 RGFW_Error(void) { return RGFW_error; }

#define SET_ATTRIB(a, v) { \
    assert(((size_t) index + 1) < sizeof(attribs) / sizeof(attribs[0])); \
    attribs[index++] = a; \
    attribs[index++] = v; \
}
	
RGFW_area RGFW_bufferSize = {0, 0};
void RGFW_setBufferSize(RGFW_area size) {
	RGFW_bufferSize = size;
}


RGFWDEF RGFW_window* RGFW_window_basic_init(RGFW_rect rect, u16 args);

/* do a basic initialization for RGFW_window, this is to standard it for each OS */
RGFW_window* RGFW_window_basic_init(RGFW_rect rect, u16 args) {
	RGFW_window* win = (RGFW_window*) RGFW_MALLOC(sizeof(RGFW_window)); /*!< make a new RGFW struct */

	/* clear out dnd info */
#ifdef RGFW_ALLOC_DROPFILES
	win->event.droppedFiles = (char**) RGFW_MALLOC(sizeof(char*) * RGFW_MAX_DROPS);
	u32 i;
	for (i = 0; i < RGFW_MAX_DROPS; i++)
		win->event.droppedFiles[i] = (char*) RGFW_CALLOC(RGFW_MAX_PATH, sizeof(char));
#endif

	/* X11 requires us to have a display to get the screen size */
	#ifndef RGFW_X11 
	RGFW_area screenR = RGFW_getScreenSize();
	#else
	win->src.display = XOpenDisplay(NULL);
	assert(win->src.display != NULL);

	Screen* scrn = DefaultScreenOfDisplay((Display*)win->src.display);
	RGFW_area screenR = RGFW_AREA((u32)scrn->width, (u32)scrn->height);
	#endif
	
	/* rect based the requested args */
	if (args & RGFW_FULLSCREEN)
		rect = RGFW_RECT(0, 0, screenR.w, screenR.h);

	if (args & RGFW_CENTER)
		rect = RGFW_RECT((screenR.w - rect.w) / 2, (screenR.h - rect.h) / 2, rect.w, rect.h);

	/* set and init the new window's data */
	win->r = rect;
	win->event.inFocus = 1;
	win->event.droppedFilesCount = 0;
	RGFW_joystickCount = 0;
	win->_winArgs = 0;
	win->event.lockState = 0;

	return win;
}

#ifndef RGFW_NO_MONITOR
void RGFW_window_scaleToMonitor(RGFW_window* win) {
	RGFW_monitor monitor = RGFW_window_getMonitor(win);
	
	RGFW_window_resize(win, RGFW_AREA(((u32) monitor.scaleX) * win->r.w, ((u32) monitor.scaleX) * win->r.h));
}
#endif

RGFW_window* RGFW_root = NULL;


#define RGFW_HOLD_MOUSE			(1L<<2) /*!< hold the moues still */
#define RGFW_MOUSE_LEFT 		(1L<<3) /* if mouse left the window */

char* RGFW_className = NULL;
void RGFW_setClassName(char* name) {
	RGFW_className = name;
}

void RGFW_clipboardFree(char* str) { RGFW_FREE(str); }

RGFW_keyState RGFW_mouseButtons[5] = { {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0} };

b8 RGFW_isMousePressed(RGFW_window* win, u8 button) {
	assert(win != NULL);
	return RGFW_mouseButtons[button].current && (win != NULL) && win->event.inFocus; 
}
b8 RGFW_wasMousePressed(RGFW_window* win, u8 button) {
	assert(win != NULL); 
	return RGFW_mouseButtons[button].prev && (win != NULL) && win->event.inFocus; 
}
b8 RGFW_isMouseHeld(RGFW_window* win, u8 button) {
	return (RGFW_isMousePressed(win, button) && RGFW_wasMousePressed(win, button));
}
b8 RGFW_isMouseReleased(RGFW_window* win, u8 button) {
	return (!RGFW_isMousePressed(win, button) && RGFW_wasMousePressed(win, button));	
}

b8 RGFW_isPressed(RGFW_window* win, u8 key) {
	return RGFW_keyboard[key].current && (win == NULL || win->event.inFocus);
}

b8 RGFW_wasPressed(RGFW_window* win, u8 key) {
	return RGFW_keyboard[key].prev && (win == NULL || win->event.inFocus);
}

b8 RGFW_isHeld(RGFW_window* win, u8 key) {
	return (RGFW_isPressed(win, key) && RGFW_wasPressed(win, key));
}

b8 RGFW_isClicked(RGFW_window* win, u8 key) {
	return (RGFW_wasPressed(win, key) && !RGFW_isPressed(win, key));
}

b8 RGFW_isReleased(RGFW_window* win, u8 key) {
	return (!RGFW_isPressed(win, key) && RGFW_wasPressed(win, key));	
}

#if defined(RGFW_WINDOWS)  && defined(RGFW_DIRECTX) /* defines for directX context*/
	RGFW_directXinfo RGFW_dxInfo;
	RGFW_directXinfo* RGFW_getDirectXInfo(void) { return &RGFW_dxInfo; }
#endif

void RGFW_window_makeCurrent(RGFW_window* win) {
#if defined(RGFW_WINDOWS) && defined(RGFW_DIRECTX)
	if (win == NULL)
		RGFW_dxInfo.pDeviceContext->lpVtbl->OMSetRenderTargets(RGFW_dxInfo.pDeviceContext, 1, NULL, NULL);
	else
		RGFW_dxInfo.pDeviceContext->lpVtbl->OMSetRenderTargets(RGFW_dxInfo.pDeviceContext, 1, &win->src.renderTargetView, NULL);
#elif defined(RGFW_OPENGL)
	RGFW_window_makeCurrent_OpenGL(win);
#else
	RGFW_UNUSED(win)
#endif
}

void RGFW_window_setGPURender(RGFW_window* win, i8 set) {
	if (!set && !(win->_winArgs & RGFW_NO_GPU_RENDER))
		win->_winArgs |= RGFW_NO_GPU_RENDER;
		
	else if (set && win->_winArgs & RGFW_NO_GPU_RENDER)
		win->_winArgs ^= RGFW_NO_GPU_RENDER;
}

void RGFW_window_setCPURender(RGFW_window* win, i8 set) {
	if (!set && !(win->_winArgs & RGFW_NO_CPU_RENDER))
		win->_winArgs |= RGFW_NO_CPU_RENDER;

	else if (set && win->_winArgs & RGFW_NO_CPU_RENDER)
		win->_winArgs ^= RGFW_NO_CPU_RENDER;
}

void RGFW_window_maximize(RGFW_window* win) {
	assert(win != NULL);

	RGFW_area screen = RGFW_getScreenSize();

	RGFW_window_move(win, RGFW_POINT(0, 0));
	RGFW_window_resize(win, screen);
}

b8 RGFW_window_shouldClose(RGFW_window* win) {
	assert(win != NULL);
	return (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape));
}

void RGFW_window_setShouldClose(RGFW_window* win) { win->event.type = RGFW_quit; RGFW_windowQuitCallback(win); }

#ifndef RGFW_NO_MONITOR
	void RGFW_window_moveToMonitor(RGFW_window* win, RGFW_monitor m) {
		RGFW_window_move(win, RGFW_POINT(m.rect.x + win->r.x, m.rect.y + win->r.y));
	}
#endif

RGFWDEF void RGFW_captureCursor(RGFW_window* win, RGFW_rect);
RGFWDEF void RGFW_releaseCursor(RGFW_window* win);

void RGFW_window_mouseHold(RGFW_window* win, RGFW_area area) {
	if ((win->_winArgs & RGFW_HOLD_MOUSE))
		return;
	

	if (!area.w && !area.h)
		area = RGFW_AREA(win->r.w / 2, win->r.h / 2);
		
	win->_winArgs |= RGFW_HOLD_MOUSE;
	RGFW_captureCursor(win, win->r);
	RGFW_window_moveMouse(win, RGFW_POINT(win->r.x + (win->r.w / 2), win->r.y + (win->r.h / 2)));
}

void RGFW_window_mouseUnhold(RGFW_window* win) {
	if ((win->_winArgs & RGFW_HOLD_MOUSE)) {
		win->_winArgs ^= RGFW_HOLD_MOUSE;

		RGFW_releaseCursor(win);
	}
}

u32 RGFW_window_checkFPS(RGFW_window* win, u32 fpsCap) {
	u64 deltaTime = RGFW_getTimeNS() - win->event.frameTime;

	u32 output_fps = 0;
	u64 fps = round(1e+9 / deltaTime);
	output_fps= fps;

	if (fpsCap && fps > fpsCap) {
		u64 frameTimeNS = 1e+9 / fpsCap;
		u64 sleepTimeMS = (frameTimeNS - deltaTime) / 1e6;

		if (sleepTimeMS > 0) {
			RGFW_sleep(sleepTimeMS);
			win->event.frameTime = 0;
		}
	}

	win->event.frameTime = RGFW_getTimeNS();
	
	if (fpsCap == 0) 
		return (u32) output_fps;
	
	deltaTime = RGFW_getTimeNS() - win->event.frameTime2;
	output_fps = round(1e+9 / deltaTime);
	win->event.frameTime2 = RGFW_getTimeNS();

	return output_fps;
}

u32 RGFW_isPressedJS(RGFW_window* win, u16 c, u8 button) { 
	RGFW_UNUSED(win);
	return RGFW_jsPressed[c][button]; 
}

#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
	void RGFW_window_showMouse(RGFW_window* win, i8 show) {
		static u8 RGFW_blk[] = { 0, 0, 0, 0 };
		if (show == 0)
			RGFW_window_setMouse(win, RGFW_blk, RGFW_AREA(1, 1), 4);
		else
			RGFW_window_setMouseDefault(win);
	}
#endif

RGFWDEF void RGFW_updateLockState(RGFW_window* win, b8 capital, b8 numlock);	
void RGFW_updateLockState(RGFW_window* win, b8 capital, b8 numlock) {
	if (capital && !(win->event.lockState & RGFW_CAPSLOCK))
		win->event.lockState |= RGFW_CAPSLOCK;
	else if (!capital && (win->event.lockState & RGFW_CAPSLOCK))			
		win->event.lockState ^= RGFW_CAPSLOCK;
	
	if (numlock && !(win->event.lockState & RGFW_NUMLOCK))
		win->event.lockState |= RGFW_NUMLOCK;
	else if (!numlock && (win->event.lockState & RGFW_NUMLOCK))
		win->event.lockState ^= RGFW_NUMLOCK;
}

#if defined(RGFW_X11) || defined(RGFW_MACOS) || defined(RGFW_WEBASM) || defined(RGFW_WAYLAND)
	struct timespec;

	int nanosleep(const struct timespec* duration, struct timespec* rem);
	int clock_gettime(clockid_t clk_id, struct timespec* tp);
	int setenv(const char *name, const char *value, int overwrite);

	void RGFW_window_setDND(RGFW_window* win, b8 allow) {
		if (allow && !(win->_winArgs & RGFW_ALLOW_DND))
			win->_winArgs |= RGFW_ALLOW_DND;

		else if (!allow && (win->_winArgs & RGFW_ALLOW_DND))
			win->_winArgs ^= RGFW_ALLOW_DND;
	}
#endif

/*
	graphics API specific code (end of generic code)
	starts here 
*/


/* 
	OpenGL defines start here   (Normal, EGL, OSMesa)
*/

#if defined(RGFW_OPENGL) || defined(RGFW_EGL) || defined(RGFW_OSMESA)
	#ifdef RGFW_WINDOWS
		#define WIN32_LEAN_AND_MEAN
		#define OEMRESOURCE
		#include <windows.h>
	#endif

	#if !defined(__APPLE__) && !defined(RGFW_NO_GL_HEADER)
		#include <GL/gl.h>
	#elif defined(__APPLE__)
		#ifndef GL_SILENCE_DEPRECATION
			#define GL_SILENCE_DEPRECATION
		#endif
		#include <OpenGL/gl.h>
		#include <OpenGL/OpenGL.h>
	#endif

/* EGL, normal OpenGL only */
#if !defined(RGFW_OSMESA) 
	i32 RGFW_majorVersion = 0, RGFW_minorVersion = 0;
	b8 RGFW_profile = RGFW_GL_CORE;
	
	#ifndef RGFW_EGL
	i32 RGFW_STENCIL = 8, RGFW_SAMPLES = 4, RGFW_STEREO = 0, RGFW_AUX_BUFFERS = 0, RGFW_DOUBLE_BUFFER = 1;
	#else
	i32 RGFW_STENCIL = 0, RGFW_SAMPLES = 0, RGFW_STEREO = 0, RGFW_AUX_BUFFERS = 0, RGFW_DOUBLE_BUFFER = 1;
	#endif


	void RGFW_setGLStencil(i32 stencil) { RGFW_STENCIL = stencil; }
	void RGFW_setGLSamples(i32 samples) { RGFW_SAMPLES = samples; }
	void RGFW_setGLStereo(i32 stereo) { RGFW_STEREO = stereo; }
	void RGFW_setGLAuxBuffers(i32 auxBuffers) { RGFW_AUX_BUFFERS = auxBuffers; }
	void RGFW_setDoubleBuffer(b8 useDoubleBuffer) { RGFW_DOUBLE_BUFFER = useDoubleBuffer; }

	void RGFW_setGLVersion(b8 profile, i32 major, i32 minor) {
        RGFW_profile = profile;
		RGFW_majorVersion = major;
		RGFW_minorVersion = minor;
	}

/* OPENGL normal only (no EGL / OSMesa) */
#ifndef RGFW_EGL

#define RGFW_GL_RENDER_TYPE 		RGFW_OS_BASED_VALUE(GLX_X_VISUAL_TYPE,    	0x2003,		73, 0, 0)
	#define RGFW_GL_ALPHA_SIZE 		RGFW_OS_BASED_VALUE(GLX_ALPHA_SIZE,       	0x201b,		11,     0, 0)
	#define RGFW_GL_DEPTH_SIZE 		RGFW_OS_BASED_VALUE(GLX_DEPTH_SIZE,       	0x2022,		12,     0, 0)
	#define RGFW_GL_DOUBLEBUFFER 		RGFW_OS_BASED_VALUE(GLX_DOUBLEBUFFER,     	0x2011, 	5,  0, 0)   
	#define RGFW_GL_STENCIL_SIZE 		RGFW_OS_BASED_VALUE(GLX_STENCIL_SIZE,	 	0x2023,	13,     0, 0)
	#define RGFW_GL_SAMPLES			RGFW_OS_BASED_VALUE(GLX_SAMPLES, 		 	0x2042,	    55,     0, 0)
	#define RGFW_GL_STEREO 			RGFW_OS_BASED_VALUE(GLX_STEREO,	 		 	0x2012,			6,  0, 0)
	#define RGFW_GL_AUX_BUFFERS		RGFW_OS_BASED_VALUE(GLX_AUX_BUFFERS,	    0x2024,	7, 		    0, 0)

#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
	#define RGFW_GL_DRAW 			RGFW_OS_BASED_VALUE(GLX_X_RENDERABLE,	 	0x2001,					0, 0, 0)
	#define RGFW_GL_DRAW_TYPE 		RGFW_OS_BASED_VALUE(GLX_RENDER_TYPE,     	0x2013,						0, 0, 0)
	#define RGFW_GL_FULL_FORMAT		RGFW_OS_BASED_VALUE(GLX_TRUE_COLOR,   	 	0x2027,						0, 0, 0)
	#define RGFW_GL_RED_SIZE		RGFW_OS_BASED_VALUE(GLX_RED_SIZE,         	0x2015,						0, 0, 0)
	#define RGFW_GL_GREEN_SIZE		RGFW_OS_BASED_VALUE(GLX_GREEN_SIZE,       	0x2017,						0, 0, 0)
	#define RGFW_GL_BLUE_SIZE		RGFW_OS_BASED_VALUE(GLX_BLUE_SIZE, 	 		0x2019,						0, 0, 0)
	#define RGFW_GL_USE_RGBA		RGFW_OS_BASED_VALUE(GLX_RGBA_BIT,   	 	0x202B,						0, 0, 0)
#endif

#ifdef RGFW_WINDOWS
	#define WGL_SUPPORT_OPENGL_ARB                    0x2010
	#define WGL_COLOR_BITS_ARB                        0x2014
	#define WGL_NUMBER_PIXEL_FORMATS_ARB 			0x2000
	#define WGL_CONTEXT_MAJOR_VERSION_ARB             0x2091
	#define WGL_CONTEXT_MINOR_VERSION_ARB             0x2092
	#define WGL_CONTEXT_PROFILE_MASK_ARB              0x9126
	#define WGL_CONTEXT_CORE_PROFILE_BIT_ARB 0x00000001
	#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
	#define WGL_SAMPLE_BUFFERS_ARB               0x2041
	#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB 0x20a9
	#define WGL_PIXEL_TYPE_ARB                        0x2013
	#define WGL_TYPE_RGBA_ARB                         0x202B

	#define WGL_TRANSPARENT_ARB   					  0x200A
#endif
	
/*  The window'ing api needs to know how to render the data we (or opengl) give it 
	MacOS and Windows do this using a structure called a "pixel format" 
	X11 calls it a "Visual"
	This function returns the attributes for the format we want */
	static u32* RGFW_initFormatAttribs(u32 useSoftware) {
		RGFW_UNUSED(useSoftware);
		static u32 attribs[] = {
								#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
								RGFW_GL_RENDER_TYPE,
								RGFW_GL_FULL_FORMAT,
								#endif
								RGFW_GL_ALPHA_SIZE      , 8,
								RGFW_GL_DEPTH_SIZE      , 24,
								#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
								RGFW_GL_DRAW, 1,
								RGFW_GL_RED_SIZE        , 8,
								RGFW_GL_GREEN_SIZE      , 8,
								RGFW_GL_BLUE_SIZE       , 8,
								RGFW_GL_DRAW_TYPE     , RGFW_GL_USE_RGBA,
								#endif 

								#ifdef RGFW_X11
								GLX_DRAWABLE_TYPE   , GLX_WINDOW_BIT,
								#endif	

								#ifdef RGFW_MACOS
								72,
								8, 24,
								#endif

								#ifdef RGFW_WINDOWS
								WGL_SUPPORT_OPENGL_ARB,		1,
								WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
								WGL_COLOR_BITS_ARB,	 32,
								#endif

								0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
		};

		size_t index = (sizeof(attribs) / sizeof(attribs[0])) - 13;

#define RGFW_GL_ADD_ATTRIB(attrib, attVal) \
		if (attVal) { \
			attribs[index] = attrib;\
			attribs[index + 1] = attVal;\
			index += 2;\
		}
         
        RGFW_GL_ADD_ATTRIB(RGFW_GL_DOUBLEBUFFER, 1);
        
        RGFW_GL_ADD_ATTRIB(RGFW_GL_STENCIL_SIZE, RGFW_STENCIL);
		RGFW_GL_ADD_ATTRIB(RGFW_GL_STEREO, RGFW_STEREO);
		RGFW_GL_ADD_ATTRIB(RGFW_GL_AUX_BUFFERS, RGFW_AUX_BUFFERS);

#ifndef RGFW_X11
		RGFW_GL_ADD_ATTRIB(RGFW_GL_SAMPLES, RGFW_SAMPLES);
#endif 

#ifdef RGFW_MACOS
		if (useSoftware) {
			RGFW_GL_ADD_ATTRIB(70, kCGLRendererGenericFloatID);
		} else {
			attribs[index] = RGFW_GL_RENDER_TYPE;
			index += 1;
		}
#endif

#ifdef RGFW_MACOS
		/* macOS has the surface attribs and the opengl attribs connected for some reason
			maybe this is to give macOS more control to limit openGL/the opengl version? */

		attribs[index] = 99;
		attribs[index + 1] = 0x1000;

		if (RGFW_majorVersion >= 4 || RGFW_majorVersion >= 3) {
			attribs[index + 1] = (u32) ((RGFW_majorVersion >= 4) ? 0x4100 : 0x3200);
		}
#endif

		RGFW_GL_ADD_ATTRIB(0, 0);

		return attribs;
	}

/* EGL only (no OSMesa nor normal OPENGL) */
#elif defined(RGFW_EGL)

#include <EGL/egl.h>

#if defined(RGFW_LINK_EGL)
	typedef EGLBoolean(EGLAPIENTRY* PFN_eglInitialize)(EGLDisplay, EGLint*, EGLint*);

	PFNEGLINITIALIZEPROC eglInitializeSource;
	PFNEGLGETCONFIGSPROC eglGetConfigsSource;
	PFNEGLCHOOSECONFIGPROC eglChooseConfigSource;
	PFNEGLCREATEWINDOWSURFACEPROC eglCreateWindowSurfaceSource;
	PFNEGLCREATECONTEXTPROC eglCreateContextSource;
	PFNEGLMAKECURRENTPROC eglMakeCurrentSource;
	PFNEGLGETDISPLAYPROC eglGetDisplaySource;
	PFNEGLSWAPBUFFERSPROC eglSwapBuffersSource;
	PFNEGLSWAPINTERVALPROC eglSwapIntervalSource;
	PFNEGLBINDAPIPROC eglBindAPISource;
	PFNEGLDESTROYCONTEXTPROC eglDestroyContextSource;
	PFNEGLTERMINATEPROC eglTerminateSource;
	PFNEGLDESTROYSURFACEPROC eglDestroySurfaceSource;

#define eglInitialize eglInitializeSource
#define eglGetConfigs eglGetConfigsSource
#define eglChooseConfig eglChooseConfigSource
#define eglCreateWindowSurface eglCreateWindowSurfaceSource
#define eglCreateContext eglCreateContextSource
#define eglMakeCurrent eglMakeCurrentSource
#define eglGetDisplay eglGetDisplaySource
#define eglSwapBuffers eglSwapBuffersSource
#define eglSwapInterval eglSwapIntervalSource
#define eglBindAPI eglBindAPISource
#define eglDestroyContext eglDestroyContextSource
#define eglTerminate eglTerminateSource
#define eglDestroySurface eglDestroySurfaceSource;
#endif


#define EGL_SURFACE_MAJOR_VERSION_KHR 0x3098
#define EGL_SURFACE_MINOR_VERSION_KHR 0x30fb

#ifndef RGFW_GL_ADD_ATTRIB
#define RGFW_GL_ADD_ATTRIB(attrib, attVal) \
	if (attVal) { \
		attribs[index] = attrib;\
		attribs[index + 1] = attVal;\
		index += 2;\
	}
#endif


	void RGFW_createOpenGLContext(RGFW_window* win) {
#if defined(RGFW_LINK_EGL)
		eglInitializeSource = (PFNEGLINITIALIZEPROC) eglGetProcAddress("eglInitialize");
		eglGetConfigsSource = (PFNEGLGETCONFIGSPROC) eglGetProcAddress("eglGetConfigs");
		eglChooseConfigSource = (PFNEGLCHOOSECONFIGPROC) eglGetProcAddress("eglChooseConfig");
		eglCreateWindowSurfaceSource = (PFNEGLCREATEWINDOWSURFACEPROC) eglGetProcAddress("eglCreateWindowSurface");
		eglCreateContextSource = (PFNEGLCREATECONTEXTPROC) eglGetProcAddress("eglCreateContext");
		eglMakeCurrentSource = (PFNEGLMAKECURRENTPROC) eglGetProcAddress("eglMakeCurrent");
		eglGetDisplaySource = (PFNEGLGETDISPLAYPROC) eglGetProcAddress("eglGetDisplay");
		eglSwapBuffersSource = (PFNEGLSWAPBUFFERSPROC) eglGetProcAddress("eglSwapBuffers");
		eglSwapIntervalSource = (PFNEGLSWAPINTERVALPROC) eglGetProcAddress("eglSwapInterval");
		eglBindAPISource = (PFNEGLBINDAPIPROC) eglGetProcAddress("eglBindAPI");
		eglDestroyContextSource = (PFNEGLDESTROYCONTEXTPROC) eglGetProcAddress("eglDestroyContext");
		eglTerminateSource = (PFNEGLTERMINATEPROC) eglGetProcAddress("eglTerminate");
		eglDestroySurfaceSource = (PFNEGLDESTROYSURFACEPROC) eglGetProcAddress("eglDestroySurface");
#endif /* RGFW_LINK_EGL */

		#ifdef RGFW_WINDOWS
		win->src.EGL_display = eglGetDisplay((EGLNativeDisplayType) win->src.hdc);
		#else
		win->src.EGL_display = eglGetDisplay((EGLNativeDisplayType) win->src.display);
		#endif

		EGLint major, minor;

		eglInitialize(win->src.EGL_display, &major, &minor);

		#ifndef EGL_OPENGL_ES1_BIT
		#define EGL_OPENGL_ES1_BIT 0x1
		#endif

		EGLint egl_config[] = {
			EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
			EGL_RENDERABLE_TYPE,
			#ifdef RGFW_OPENGL_ES1
			EGL_OPENGL_ES1_BIT,
			#elif defined(RGFW_OPENGL_ES3)
			EGL_OPENGL_ES3_BIT,
			#elif defined(RGFW_OPENGL_ES2)
			EGL_OPENGL_ES2_BIT,
			#else
			EGL_OPENGL_BIT,
			#endif
			EGL_NONE, EGL_NONE
		};

		EGLConfig config;
		EGLint numConfigs;
		eglChooseConfig(win->src.EGL_display, egl_config, &config, 1, &numConfigs);


		win->src.EGL_surface = eglCreateWindowSurface(win->src.EGL_display, config, (EGLNativeWindowType) win->src.window, NULL);

		EGLint attribs[] = {
			EGL_CONTEXT_CLIENT_VERSION,
			#ifdef RGFW_OPENGL_ES1
			1,
			#else
			2,
			#endif
			EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE
		};

		size_t index = 4;
		RGFW_GL_ADD_ATTRIB(EGL_STENCIL_SIZE, RGFW_STENCIL);
		RGFW_GL_ADD_ATTRIB(EGL_SAMPLES, RGFW_SAMPLES);

        if (RGFW_DOUBLE_BUFFER)
            RGFW_GL_ADD_ATTRIB(EGL_RENDER_BUFFER, EGL_BACK_BUFFER);

		if (RGFW_majorVersion) {
			attribs[1] = RGFW_majorVersion;
	
			RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_MAJOR_VERSION, RGFW_majorVersion);
			RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_MINOR_VERSION, RGFW_minorVersion);

			if (RGFW_profile == RGFW_GL_CORE) {
				RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT);
			}
			else {
				RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT);
			}

		}

		#if defined(RGFW_OPENGL_ES1) || defined(RGFW_OPENGL_ES2) || defined(RGFW_OPENGL_ES3)
		eglBindAPI(EGL_OPENGL_ES_API);
		#else
		eglBindAPI(EGL_OPENGL_API);		
		#endif
      		
		win->src.EGL_context = eglCreateContext(win->src.EGL_display, config, EGL_NO_CONTEXT, attribs);
		
		if (win->src.EGL_context == NULL)
			fprintf(stderr, "failed to create an EGL opengl context\n");

		eglMakeCurrent(win->src.EGL_display, win->src.EGL_surface, win->src.EGL_surface, win->src.EGL_context);
		eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
	}

	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		eglMakeCurrent(win->src.EGL_display, win->src.EGL_surface, win->src.EGL_surface, win->src.EGL_context);
	}

	#ifdef RGFW_APPLE
	void* RGFWnsglFramework = NULL;
	#elif defined(RGFW_WINDOWS)
	static HMODULE wglinstance = NULL;
	#endif

	void* RGFW_getProcAddress(const char* procname) { 
		#if defined(RGFW_WINDOWS)
			void* proc = (void*) GetProcAddress(wglinstance, procname); 

			if (proc)
				return proc;
		#endif

		return (void*) eglGetProcAddress(procname); 
	}

	void RGFW_closeEGL(RGFW_window* win) {
		eglDestroySurface(win->src.EGL_display, win->src.EGL_surface);
		eglDestroyContext(win->src.EGL_display, win->src.EGL_context);

		eglTerminate(win->src.EGL_display);
	}
	
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);
		
		eglSwapInterval(win->src.EGL_display, swapInterval);

	}
#endif /* RGFW_EGL */

/* 
	end of RGFW_EGL defines
*/

/* OPENGL Normal / EGL defines only (no OS MESA)  Ends here */

#elif defined(RGFW_OSMESA) /* OSmesa only */
RGFWDEF void RGFW_OSMesa_reorganize(void);

/* reorganize buffer for osmesa */
void RGFW_OSMesa_reorganize(void) {
	u8* row = (u8*) RGFW_MALLOC(win->r.w * 3);

	i32 half_height = win->r.h / 2;
	i32 stride = win->r.w * 3;

	i32 y;
	for (y = 0; y < half_height; ++y) {
		i32 top_offset = y * stride;
		i32 bottom_offset = (win->r.h - y - 1) * stride;
		memcpy(row, win->buffer + top_offset, stride);
		memcpy(win->buffer + top_offset, win->buffer + bottom_offset, stride);
		memcpy(win->buffer + bottom_offset, row, stride);
	}

	RGFW_FREE(row);
}
#endif /* RGFW_OSMesa */

#endif /* RGFW_GL (OpenGL, EGL, OSMesa )*/

/*
This is where OS specific stuff starts
*/


#if defined(RGFW_WAYLAND) || defined(RGFW_X11)
	int RGFW_eventWait_forceStop[] = {0, 0, 0}; /* for wait events */

	#ifdef __linux__
		#include <linux/joystick.h>
		#include <fcntl.h>
		#include <unistd.h>
		
		RGFW_Event* RGFW_linux_updateJoystick(RGFW_window* win) {
			static int xAxis = 0, yAxis = 0;
			u8 i;
			for (i = 0; i < RGFW_joystickCount; i++) {
				struct js_event e;


				if (RGFW_joysticks[i] == 0)
					continue;

				i32 flags = fcntl(RGFW_joysticks[i], F_GETFL, 0);
				fcntl(RGFW_joysticks[i], F_SETFL, flags | O_NONBLOCK);

				ssize_t bytes;
				while ((bytes = read(RGFW_joysticks[i], &e, sizeof(e))) > 0) {
					switch (e.type) {
					case JS_EVENT_BUTTON:
						win->event.type = e.value ? RGFW_jsButtonPressed : RGFW_jsButtonReleased;
						win->event.button = e.number;
						RGFW_jsPressed[i][e.number] = e.value;
						RGFW_jsButtonCallback(win, i, e.number, e.value);
						return &win->event;
					case JS_EVENT_AXIS:
						ioctl(RGFW_joysticks[i], JSIOCGAXES, &win->event.axisesCount);

						if ((e.number == 0 || e.number % 2) && e.number != 1)
							xAxis = e.value;
						else
							yAxis = e.value;

						win->event.axis[e.number / 2].x = xAxis;
						win->event.axis[e.number / 2].y = yAxis;
						win->event.type = RGFW_jsAxisMove;
						win->event.joystick = i;
						RGFW_jsAxisCallback(win, i, win->event.axis, win->event.axisesCount);
						return &win->event;

						default: break;
					}
				}
			}

			return NULL;
		}

	#endif
#endif

/*


Start of Linux / Unix defines


*/

#ifdef RGFW_X11
#ifndef RGFW_NO_X11_CURSOR
#include <X11/Xcursor/Xcursor.h>
#endif
#include <dlfcn.h>

#ifndef RGFW_NO_DPI
#include <X11/extensions/Xrandr.h>
#include <X11/Xresource.h>
#endif

#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/keysymdef.h>
#include <unistd.h>

#include <X11/XKBlib.h> /* for converting keycode to string */
#include <X11/cursorfont.h> /* for hiding */
#include <X11/extensions/shapeconst.h>
#include <X11/extensions/shape.h>
#include <X11/extensions/XInput2.h>

#include <limits.h> /* for data limits (mainly used in drag and drop functions) */
#include <poll.h>


#ifdef __linux__
#include <linux/joystick.h>
#endif

	u8 RGFW_mouseIconSrc[] = { XC_arrow, XC_left_ptr, XC_xterm, XC_crosshair, XC_hand2, XC_sb_h_double_arrow, XC_sb_v_double_arrow, XC_bottom_left_corner, XC_bottom_right_corner, XC_fleur, XC_X_cursor};  
	/*atoms needed for drag and drop*/
	Atom XdndAware, XdndTypeList, XdndSelection, XdndEnter, XdndPosition, XdndStatus, XdndLeave, XdndDrop, XdndFinished, XdndActionCopy, XtextPlain, XtextUriList;

	Atom wm_delete_window = 0;

#if !defined(RGFW_NO_X11_CURSOR) && !defined(RGFW_NO_X11_CURSOR_PRELOAD)
	typedef XcursorImage* (*PFN_XcursorImageCreate)(int, int);
	typedef void (*PFN_XcursorImageDestroy)(XcursorImage*);
	typedef Cursor(*PFN_XcursorImageLoadCursor)(Display*, const XcursorImage*);
#endif
#ifdef RGFW_OPENGL
	typedef GLXContext(*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);
#endif

#if !defined(RGFW_NO_X11_XI_PRELOAD)
	typedef int (* PFN_XISelectEvents)(Display*,Window,XIEventMask*,int);
	PFN_XISelectEvents XISelectEventsSrc = NULL;
	#define XISelectEvents XISelectEventsSrc

	void* X11Xihandle = NULL;
#endif

#if !defined(RGFW_NO_X11_CURSOR) && !defined(RGFW_NO_X11_CURSOR_PRELOAD)
	PFN_XcursorImageLoadCursor XcursorImageLoadCursorSrc = NULL;
	PFN_XcursorImageCreate XcursorImageCreateSrc = NULL;
	PFN_XcursorImageDestroy XcursorImageDestroySrc = NULL;

#define XcursorImageLoadCursor XcursorImageLoadCursorSrc
#define XcursorImageCreate XcursorImageCreateSrc
#define XcursorImageDestroy XcursorImageDestroySrc

	void* X11Cursorhandle = NULL;
#endif

	u32 RGFW_windowsOpen = 0;

#ifdef RGFW_OPENGL
	void* RGFW_getProcAddress(const char* procname) { return (void*) glXGetProcAddress((GLubyte*) procname); }
#endif

	RGFWDEF void RGFW_init_buffer(RGFW_window* win, XVisualInfo* vi);
	void RGFW_init_buffer(RGFW_window* win, XVisualInfo* vi) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
		if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
			RGFW_bufferSize = RGFW_getScreenSize();
		
		win->buffer = (u8*)RGFW_MALLOC(RGFW_bufferSize.w * RGFW_bufferSize.h * 4);

		#ifdef RGFW_OSMESA
				win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
				OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
		#endif

		win->src.bitmap = XCreateImage(
			win->src.display, XDefaultVisual(win->src.display, vi->screen),
			vi->depth,
			ZPixmap, 0, NULL, RGFW_bufferSize.w, RGFW_bufferSize.h,
			32, 0
		);

		win->src.gc = XCreateGC(win->src.display, win->src.window, 0, NULL);

		#else
		RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
		RGFW_UNUSED(vi)
		#endif
	}



	void RGFW_window_setBorder(RGFW_window* win, u8 border) {
		static Atom _MOTIF_WM_HINTS = 0;
		if (_MOTIF_WM_HINTS == 0 )
			_MOTIF_WM_HINTS = XInternAtom(win->src.display, "_MOTIF_WM_HINTS", False);
		
		struct __x11WindowHints {
			unsigned long flags, functions, decorations, status;
			long input_mode;
		} hints;
		hints.flags = (1L << 1);
		hints.decorations = border;

		XChangeProperty(
			win->src.display, win->src.window,
			_MOTIF_WM_HINTS, _MOTIF_WM_HINTS,
			32, PropModeReplace, (u8*)&hints, 5
		);
	}
	
	void RGFW_releaseCursor(RGFW_window* win) {
		XUngrabPointer(win->src.display, CurrentTime);

		/* disable raw input */
		unsigned char mask[] = { 0 };
		XIEventMask em;
		em.deviceid = XIAllMasterDevices;
		em.mask_len = sizeof(mask);
		em.mask = mask;

		XISelectEvents(win->src.display, XDefaultRootWindow(win->src.display), &em, 1);
	}
	
	void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) { 
		/* enable raw input */
		unsigned char mask[XIMaskLen(XI_RawMotion)] = { 0 };
		XISetMask(mask, XI_RawMotion);

		XIEventMask em;
		em.deviceid = XIAllMasterDevices;
		em.mask_len = sizeof(mask);
		em.mask = mask;
		
		XISelectEvents(win->src.display, XDefaultRootWindow(win->src.display), &em, 1);

		XGrabPointer(win->src.display, win->src.window, True, PointerMotionMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);

		RGFW_window_moveMouse(win, RGFW_POINT(win->r.x + (i32)(r.w / 2), win->r.y + (i32)(r.h / 2)));
	}

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
#if !defined(RGFW_NO_X11_CURSOR) && !defined(RGFW_NO_X11_CURSOR_PRELOAD)
		if (X11Cursorhandle == NULL) {
#if defined(__CYGWIN__)
			X11Cursorhandle = dlopen("libXcursor-1.so", RTLD_LAZY | RTLD_LOCAL);
#elif defined(__OpenBSD__) || defined(__NetBSD__)
			X11Cursorhandle = dlopen("libXcursor.so", RTLD_LAZY | RTLD_LOCAL);
#else
			X11Cursorhandle = dlopen("libXcursor.so.1", RTLD_LAZY | RTLD_LOCAL);
#endif

			XcursorImageCreateSrc = (PFN_XcursorImageCreate) dlsym(X11Cursorhandle, "XcursorImageCreate");
			XcursorImageDestroySrc = (PFN_XcursorImageDestroy) dlsym(X11Cursorhandle, "XcursorImageDestroy");
			XcursorImageLoadCursorSrc = (PFN_XcursorImageLoadCursor) dlsym(X11Cursorhandle, "XcursorImageLoadCursor");
		}
#endif

#if !defined(RGFW_NO_X11_XI_PRELOAD)
		if (X11Xihandle == NULL) {
#if defined(__CYGWIN__)
			X11Xihandle = dlopen("libXi-6.so", RTLD_LAZY | RTLD_LOCAL);
#elif defined(__OpenBSD__) || defined(__NetBSD__)
			X11Xihandle = dlopen("libXi.so", RTLD_LAZY | RTLD_LOCAL);
#else
			X11Xihandle = dlopen("libXi.so.6", RTLD_LAZY | RTLD_LOCAL);
#endif

			XISelectEventsSrc = (PFN_XISelectEvents) dlsym(X11Xihandle, "XISelectEvents");
		}
#endif

		XInitThreads(); /*!< init X11 threading*/

		if (args & RGFW_OPENGL_SOFTWARE)
			setenv("LIBGL_ALWAYS_SOFTWARE", "1", 1);

		RGFW_window* win = RGFW_window_basic_init(rect, args);

		u64 event_mask = KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask | PointerMotionMask | StructureNotifyMask | FocusChangeMask | LeaveWindowMask | EnterWindowMask | ExposureMask; /*!< X11 events accepted*/

#ifdef RGFW_OPENGL
		u32* visual_attribs = RGFW_initFormatAttribs(args & RGFW_OPENGL_SOFTWARE);
		i32 fbcount;
		GLXFBConfig* fbc = glXChooseFBConfig((Display*) win->src.display, DefaultScreen(win->src.display), (i32*) visual_attribs, &fbcount);

		i32 best_fbc = -1;

		if (fbcount == 0) {
			printf("Failed to find any valid GLX visual configs\n");
			return NULL;
		}

		u32 i;
		for (i = 0; i < (u32)fbcount; i++) {
			XVisualInfo* vi = glXGetVisualFromFBConfig((Display*) win->src.display, fbc[i]);
                        if (vi == NULL)
				continue;
                        
			XFree(vi);

			i32 samp_buf, samples;
			glXGetFBConfigAttrib((Display*) win->src.display, fbc[i], GLX_SAMPLE_BUFFERS, &samp_buf);
			glXGetFBConfigAttrib((Display*) win->src.display, fbc[i], GLX_SAMPLES, &samples);
			
			if ((best_fbc < 0 || samp_buf) && (samples == RGFW_SAMPLES || best_fbc == -1)) {
				best_fbc = i;
			}
		}

		if (best_fbc == -1) {
			printf("Failed to get a valid GLX visual\n");
			return NULL;
		}

		GLXFBConfig bestFbc = fbc[best_fbc];

		/* Get a visual */
		XVisualInfo* vi = glXGetVisualFromFBConfig((Display*) win->src.display, bestFbc);
		
		XFree(fbc);
		
		if (args & RGFW_TRANSPARENT_WINDOW) {
			XMatchVisualInfo((Display*) win->src.display, DefaultScreen((Display*) win->src.display), 32, TrueColor, vi); /*!< for RGBA backgrounds*/
		}
		
#else
		XVisualInfo viNorm;

		viNorm.visual = DefaultVisual((Display*) win->src.display, DefaultScreen((Display*) win->src.display));
		
		viNorm.depth = 0;
		XVisualInfo* vi = &viNorm;
		
		XMatchVisualInfo((Display*) win->src.display, DefaultScreen((Display*) win->src.display), 32, TrueColor, vi); /*!< for RGBA backgrounds*/
#endif
		/* make X window attrubutes*/
		XSetWindowAttributes swa;
		Colormap cmap;

		swa.colormap = cmap = XCreateColormap((Display*) win->src.display,
			DefaultRootWindow(win->src.display),
			vi->visual, AllocNone);

		swa.background_pixmap = None;
		swa.border_pixel = 0;
		swa.event_mask = event_mask;
		
		swa.background_pixel = 0;

		/* create the window*/
		win->src.window = XCreateWindow((Display*) win->src.display, DefaultRootWindow((Display*) win->src.display), win->r.x, win->r.y, win->r.w, win->r.h,
			0, vi->depth, InputOutput, vi->visual,
			CWColormap | CWBorderPixel | CWBackPixel | CWEventMask, &swa);

		XFreeColors((Display*) win->src.display, cmap, NULL, 0, 0);

		#ifdef RGFW_OPENGL
		XFree(vi);
		#endif

		// In your .desktop app, if you set the property
		// StartupWMClass=RGFW that will assoicate the launcher icon
		// with your application - robrohan 
		
		if (RGFW_className == NULL)
			RGFW_className = (char*)name;

		XClassHint *hint = XAllocClassHint();
		assert(hint != NULL);
		hint->res_class = (char*)RGFW_className;
		hint->res_name = (char*)name; // just use the window name as the app name
		XSetClassHint((Display*) win->src.display, win->src.window, hint);
		XFree(hint);

		if ((args & RGFW_NO_INIT_API) == 0) {
#ifdef RGFW_OPENGL /* This is the second part of setting up opengl. This is where we ask OpenGL for a specific version. */ 
		i32 context_attribs[7] = { 0, 0, 0, 0, 0, 0, 0 };
		context_attribs[0] = GLX_CONTEXT_PROFILE_MASK_ARB;
		if (RGFW_profile == RGFW_GL_CORE) 
			context_attribs[1] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB;
		else 
			context_attribs[1] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;
		
		if (RGFW_majorVersion || RGFW_minorVersion) {
			context_attribs[2] = GLX_CONTEXT_MAJOR_VERSION_ARB;
			context_attribs[3] = RGFW_majorVersion;
			context_attribs[4] = GLX_CONTEXT_MINOR_VERSION_ARB;
			context_attribs[5] = RGFW_minorVersion;
		}

		glXCreateContextAttribsARBProc glXCreateContextAttribsARB = 0;
		glXCreateContextAttribsARB = (glXCreateContextAttribsARBProc)
			glXGetProcAddressARB((GLubyte*) "glXCreateContextAttribsARB");

		GLXContext ctx = NULL;

		if (RGFW_root != NULL)
			ctx = RGFW_root->src.ctx;

		win->src.ctx = glXCreateContextAttribsARB((Display*) win->src.display, bestFbc, ctx, True, context_attribs);
#endif
		if (RGFW_root == NULL)
			RGFW_root = win;

		RGFW_init_buffer(win, vi);
		}
		

		#ifndef RGFW_NO_MONITOR
		if (args & RGFW_SCALE_TO_MONITOR)
			RGFW_window_scaleToMonitor(win);
		#endif

		if (args & RGFW_NO_RESIZE) { /* make it so the user can't resize the window*/
			XSizeHints* sh = XAllocSizeHints();
			sh->flags = (1L << 4) | (1L << 5);
			sh->min_width = sh->max_width = win->r.w;
			sh->min_height = sh->max_height = win->r.h;

			XSetWMSizeHints((Display*) win->src.display, (Drawable) win->src.window, sh, XA_WM_NORMAL_HINTS);
			XFree(sh);
		}

		if (args & RGFW_NO_BORDER) {
			RGFW_window_setBorder(win, 0);
		}

		XSelectInput((Display*) win->src.display, (Drawable) win->src.window, event_mask); /*!< tell X11 what events we want*/

		/* make it so the user can't close the window until the program does*/
		if (wm_delete_window == 0)
			wm_delete_window = XInternAtom((Display*) win->src.display, "WM_DELETE_WINDOW", False);

		XSetWMProtocols((Display*) win->src.display, (Drawable) win->src.window, &wm_delete_window, 1);

		/* connect the context to the window*/
#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0)
			glXMakeCurrent((Display*) win->src.display, (Drawable) win->src.window, (GLXContext) win->src.ctx);
#endif

		/* set the background*/
		XStoreName((Display*) win->src.display, (Drawable) win->src.window, name); /*!< set the name*/

		XMapWindow((Display*) win->src.display, (Drawable) win->src.window);						  /* draw the window*/
		XMoveWindow((Display*) win->src.display, (Drawable) win->src.window, win->r.x, win->r.y); /*!< move the window to it's proper cords*/

		if (args & RGFW_ALLOW_DND) { /* init drag and drop atoms and turn on drag and drop for this window */
			win->_winArgs |= RGFW_ALLOW_DND;

			XdndTypeList = XInternAtom((Display*) win->src.display, "XdndTypeList", False);
			XdndSelection = XInternAtom((Display*) win->src.display, "XdndSelection", False);

			/* client messages */
			XdndEnter = XInternAtom((Display*) win->src.display, "XdndEnter", False);
			XdndPosition = XInternAtom((Display*) win->src.display, "XdndPosition", False);
			XdndStatus = XInternAtom((Display*) win->src.display, "XdndStatus", False);
			XdndLeave = XInternAtom((Display*) win->src.display, "XdndLeave", False);
			XdndDrop = XInternAtom((Display*) win->src.display, "XdndDrop", False);
			XdndFinished = XInternAtom((Display*) win->src.display, "XdndFinished", False);

			/* actions */
			XdndActionCopy = XInternAtom((Display*) win->src.display, "XdndActionCopy", False);

			XtextUriList = XInternAtom((Display*) win->src.display, "text/uri-list", False); 
			XtextPlain = XInternAtom((Display*) win->src.display, "text/plain", False);

			XdndAware = XInternAtom((Display*) win->src.display, "XdndAware", False);
			const u8 version = 5;

			XChangeProperty((Display*) win->src.display, (Window) win->src.window,
				XdndAware, 4, 32,
				PropModeReplace, &version, 1); /*!< turns on drag and drop */
		}

		#ifdef RGFW_EGL
			if ((args & RGFW_NO_INIT_API) == 0)
				RGFW_createOpenGLContext(win);
		#endif

		RGFW_window_setMouseDefault(win);

		RGFW_windowsOpen++;

		return win; /*return newly created window*/
	}

	RGFW_area RGFW_getScreenSize(void) {
		assert(RGFW_root != NULL);

		Screen* scrn = DefaultScreenOfDisplay((Display*) RGFW_root->src.display);
		return RGFW_AREA(scrn->width, scrn->height);
	}

	RGFW_point RGFW_getGlobalMousePoint(void) {
		assert(RGFW_root != NULL);

		RGFW_point RGFWMouse;

		i32 x, y;
		u32 z;
		Window window1, window2;
		XQueryPointer((Display*) RGFW_root->src.display, XDefaultRootWindow((Display*) RGFW_root->src.display), &window1, &window2, &RGFWMouse.x, &RGFWMouse.y, &x, &y, &z);
 
		return RGFWMouse;
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		assert(win != NULL);

		RGFW_point RGFWMouse;

		i32 x, y;
		u32 z;
		Window window1, window2;
		XQueryPointer((Display*) win->src.display, win->src.window, &window1, &window2, &x, &y, &RGFWMouse.x, &RGFWMouse.y, &z);

		return RGFWMouse;
	}

	int xAxis = 0, yAxis = 0;

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		assert(win != NULL);

		static struct {
			long source, version;
			i32 format;
		} xdnd;

		if (win->event.type == 0) 
			RGFW_resetKey();

		if (win->event.type == RGFW_quit) {
			return NULL;
		}

		win->event.type = 0;

#ifdef __linux__
	RGFW_Event* event = RGFW_linux_updateJoystick(win);
	if (event != NULL)
		return event;
#endif

		XPending(win->src.display);

		XEvent E; /*!< raw X11 event */

		/* if there is no unread qued events, get a new one */
		if ((QLength(win->src.display) || XEventsQueued((Display*) win->src.display, QueuedAlready) + XEventsQueued((Display*) win->src.display, QueuedAfterReading)) 
			&& win->event.type != RGFW_quit
		)
			XNextEvent((Display*) win->src.display, &E);
		else {
			return NULL;
		}

		u32 i;
		win->event.type = 0;


		switch (E.type) {
		case KeyPress:
		case KeyRelease: {
			win->event.repeat = RGFW_FALSE;
			/* check if it's a real key release */
			if (E.type == KeyRelease && XEventsQueued((Display*) win->src.display, QueuedAfterReading)) { /* get next event if there is one*/
				XEvent NE;
				XPeekEvent((Display*) win->src.display, &NE);

				if (E.xkey.time == NE.xkey.time && E.xkey.keycode == NE.xkey.keycode) /* check if the current and next are both the same*/
					win->event.repeat = RGFW_TRUE;
			}

			/* set event key data */
			KeySym sym = (KeySym)XkbKeycodeToKeysym((Display*) win->src.display, E.xkey.keycode, 0, E.xkey.state & ShiftMask ? 1 : 0);
			win->event.keyCode = RGFW_apiKeyCodeToRGFW(E.xkey.keycode);
			
			char* str = (char*)XKeysymToString(sym);
			if (str != NULL)
				strncpy(win->event.keyName, str, 16);

			win->event.keyName[15] = '\0';		

			RGFW_keyboard[win->event.keyCode].prev = RGFW_isPressed(win, win->event.keyCode);
			
			/* get keystate data */
			win->event.type = (E.type == KeyPress) ? RGFW_keyPressed : RGFW_keyReleased;

			XKeyboardState keystate;
			XGetKeyboardControl((Display*) win->src.display, &keystate);

			RGFW_updateLockState(win, (keystate.led_mask & 1), (keystate.led_mask & 2));
			RGFW_keyboard[win->event.keyCode].current = (E.type == KeyPress);
			RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, (E.type == KeyPress));
			break;
		}
		case ButtonPress:
		case ButtonRelease:
			win->event.type = RGFW_mouseButtonPressed + (E.type == ButtonRelease); // the events match 
			
			switch(win->event.button) {
				case RGFW_mouseScrollUp:
					win->event.scroll = 1;
					break;
				case RGFW_mouseScrollDown:
					win->event.scroll = -1;
					break;
				default: break;
			}

			win->event.button = E.xbutton.button;
			RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;

			if (win->event.repeat == RGFW_FALSE)
				win->event.repeat = RGFW_isPressed(win, win->event.keyCode);

			RGFW_mouseButtons[win->event.button].current = (E.type == ButtonPress);
			RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, (E.type == ButtonPress));
			break;

		case MotionNotify:	
			win->event.point.x = E.xmotion.x;
			win->event.point.y = E.xmotion.y;
			
			if ((win->_winArgs & RGFW_HOLD_MOUSE)) {
				win->event.point.y = E.xmotion.y;

				win->event.point.x = win->_lastMousePoint.x - abs(win->event.point.x);
				win->event.point.y = win->_lastMousePoint.y - abs(win->event.point.y);
			}

			win->_lastMousePoint = RGFW_POINT(E.xmotion.x, E.xmotion.y);

			win->event.type = RGFW_mousePosChanged;
			RGFW_mousePosCallback(win, win->event.point);
			break;

		case GenericEvent: {
			/* MotionNotify is used for mouse events if the mouse isn't held */                
			if (!(win->_winArgs & RGFW_HOLD_MOUSE)) {
            	XFreeEventData(win->src.display, &E.xcookie);
				break;
			}
			
            XGetEventData(win->src.display, &E.xcookie);
            if (E.xcookie.evtype == XI_RawMotion) {
				XIRawEvent *raw = (XIRawEvent *)E.xcookie.data;
				if (raw->valuators.mask_len == 0) {
					XFreeEventData(win->src.display, &E.xcookie);
					break;
				}

                double deltaX = 0.0f; 
				double deltaY = 0.0f;

                /* check if relative motion data exists where we think it does */
				if (XIMaskIsSet(raw->valuators.mask, 0) != 0)
					deltaX += raw->raw_values[0];
				if (XIMaskIsSet(raw->valuators.mask, 1) != 0)
					deltaY += raw->raw_values[1];

				win->event.point = RGFW_POINT((i32)deltaX, (i32)deltaY);
				
				RGFW_window_moveMouse(win, RGFW_POINT(win->r.x + (win->r.w / 2), win->r.y + (win->r.h / 2)));

				win->event.type = RGFW_mousePosChanged;
				RGFW_mousePosCallback(win, win->event.point);
            }

            XFreeEventData(win->src.display, &E.xcookie);
			break;
		}
		
		case Expose:
			win->event.type = RGFW_windowRefresh;
			RGFW_windowRefreshCallback(win);
			break;

		case ClientMessage:
			/* if the client closed the window*/
			if (E.xclient.data.l[0] == (i64) wm_delete_window) {
				win->event.type = RGFW_quit;
				RGFW_windowQuitCallback(win);
				break;
			}
			
			/* reset DND values */
			if (win->event.droppedFilesCount) {
				for (i = 0; i < win->event.droppedFilesCount; i++)
					win->event.droppedFiles[i][0] = '\0';
			}

			win->event.droppedFilesCount = 0;

			if ((win->_winArgs & RGFW_ALLOW_DND) == 0)
				break;

			XEvent reply = { ClientMessage };
			reply.xclient.window = xdnd.source;
			reply.xclient.format = 32;
			reply.xclient.data.l[0] = (long) win->src.window;
			reply.xclient.data.l[1] = 0;
			reply.xclient.data.l[2] = None;

			if (E.xclient.message_type == XdndEnter) {
				unsigned long count;
				Atom* formats;
				Atom real_formats[6];

				Bool list = E.xclient.data.l[1] & 1;

				xdnd.source = E.xclient.data.l[0];
				xdnd.version = E.xclient.data.l[1] >> 24;
				xdnd.format = None;

				if (xdnd.version > 5)
					break;

				if (list) {
					Atom actualType;
					i32 actualFormat;
					unsigned long bytesAfter;

					XGetWindowProperty((Display*) win->src.display,
						xdnd.source,
						XdndTypeList,
						0,
						LONG_MAX,
						False,
						4,
						&actualType,
						&actualFormat,
						&count,
						&bytesAfter,
						(u8**) &formats);
				} else {
					count = 0;

					if (E.xclient.data.l[2] != None)
						real_formats[count++] = E.xclient.data.l[2];
					if (E.xclient.data.l[3] != None)
						real_formats[count++] = E.xclient.data.l[3];
					if (E.xclient.data.l[4] != None)
						real_formats[count++] = E.xclient.data.l[4];
					
					formats = real_formats;
				}

				unsigned long i;
				for (i = 0; i < count; i++) {
				    if (formats[i] == XtextUriList || formats[i] == XtextPlain) {
						xdnd.format = formats[i];
						break;
					}
				}

				if (list) {
					XFree(formats);
				}

				break;
			}
			if (E.xclient.message_type == XdndPosition) {
				const i32 xabs = (E.xclient.data.l[2] >> 16) & 0xffff;
				const i32 yabs = (E.xclient.data.l[2]) & 0xffff;
				Window dummy;
				i32 xpos, ypos;

				if (xdnd.version > 5)
					break;

				XTranslateCoordinates((Display*) win->src.display,
					XDefaultRootWindow((Display*) win->src.display),
					(Window) win->src.window,
					xabs, yabs,
					&xpos, &ypos,
					&dummy);

				win->event.point.x = xpos;
				win->event.point.y = ypos;

				reply.xclient.window = xdnd.source;
				reply.xclient.message_type = XdndStatus;

				if (xdnd.format) {
					reply.xclient.data.l[1] = 1;
					if (xdnd.version >= 2)
						reply.xclient.data.l[4] = XdndActionCopy;
				}

				XSendEvent((Display*) win->src.display, xdnd.source, False, NoEventMask, &reply);
				XFlush((Display*) win->src.display);
				break;
			}

			if (E.xclient.message_type != XdndDrop)
				break;

			if (xdnd.version > 5)
				break;

			win->event.type = RGFW_dnd_init;

			if (xdnd.format) {
				Time time = CurrentTime;

				if (xdnd.version >= 1)
					time = E.xclient.data.l[2];

				XConvertSelection((Display*) win->src.display,
					XdndSelection,
					xdnd.format,
					XdndSelection,
					(Window) win->src.window,
					time);
			} else if (xdnd.version >= 2) {
				XEvent reply = { ClientMessage };

				XSendEvent((Display*) win->src.display, xdnd.source,
					False, NoEventMask, &reply);
				XFlush((Display*) win->src.display);
			}

			RGFW_dndInitCallback(win, win->event.point);
			break;
		case SelectionNotify: {
			/* this is only for checking for xdnd drops */
			if (E.xselection.property != XdndSelection || !(win->_winArgs | RGFW_ALLOW_DND))
				break;

			char* data;
			unsigned long result;

			Atom actualType;
			i32 actualFormat;
			unsigned long bytesAfter;

			XGetWindowProperty((Display*) win->src.display, E.xselection.requestor, E.xselection.property, 0, LONG_MAX, False, E.xselection.target, &actualType, &actualFormat, &result, &bytesAfter, (u8**) &data);

			if (result == 0)
				break;

			/*
			SOURCED FROM GLFW _glfwParseUriList
			Copyright (c) 2002-2006 Marcus Geelnard
			Copyright (c) 2006-2019 Camilla Lwy
			*/

			const char* prefix = (const char*)"file://";

			char* line;

			win->event.droppedFilesCount = 0;

			win->event.type = RGFW_dnd;

			while ((line = strtok(data, "\r\n"))) {
				char path[RGFW_MAX_PATH];

				data = NULL;

				if (line[0] == '#')
					continue;

				char* l;
				for (l = line; 1; l++) {
					if ((l - line) > 7)
						break;
					else if (*l != prefix[(l - line)])
						break;
					else if (*l == '\0' && prefix[(l - line)] == '\0') {
						line += 7;
						while (*line != '/')
							line++;
						break;
					} else if (*l == '\0')
						break;
				}

				win->event.droppedFilesCount++;

				size_t index = 0;
				while (*line) {
					if (line[0] == '%' && line[1] && line[2]) {
						const char digits[3] = { line[1], line[2], '\0' };
						path[index] = (char) strtol(digits, NULL, 16);
						line += 2;
					} else
						path[index] = *line;

					index++;
					line++;
				}
				path[index] = '\0';
				strncpy(win->event.droppedFiles[win->event.droppedFilesCount - 1], path, index + 1);
			}

			if (data)
				XFree(data);

			if (xdnd.version >= 2) {
				reply.xclient.message_type = XdndFinished;
				reply.xclient.data.l[1] = result;
				reply.xclient.data.l[2] = XdndActionCopy;

				XSendEvent((Display*) win->src.display, xdnd.source, False, NoEventMask, &reply);
				XFlush((Display*) win->src.display);
			}

			RGFW_dndCallback(win, win->event.droppedFiles, win->event.droppedFilesCount);
			break;
		}
		case FocusIn:
			win->event.inFocus = 1;
			win->event.type = RGFW_focusIn;
			RGFW_focusCallback(win, 1);
			break;

			break;
		case FocusOut:
			win->event.inFocus = 0;
			win->event.type = RGFW_focusOut;
			RGFW_focusCallback(win, 0);
			break;
		
		case EnterNotify: {
			win->event.type = RGFW_mouseEnter;
			win->event.point.x = E.xcrossing.x;
			win->event.point.y = E.xcrossing.y;
			RGFW_mouseNotifyCallBack(win, win->event.point, 1);
			break;
		}

		case LeaveNotify: {
			win->event.type = RGFW_mouseLeave;
			RGFW_mouseNotifyCallBack(win, win->event.point, 0);
			break;
		}

		case ConfigureNotify: {
				/* detect resize */
      			if (E.xconfigure.width != win->r.w || E.xconfigure.height != win->r.h) {
					win->event.type = RGFW_windowResized;
					win->r = RGFW_RECT(win->r.x, win->r.y, E.xconfigure.width, E.xconfigure.height);
					RGFW_windowResizeCallback(win, win->r);
					break;
      			}  
      
      			/* detect move */
      			if (E.xconfigure.x != win->r.x || E.xconfigure.y != win->r.y) {
					win->event.type = RGFW_windowMoved;
					win->r = RGFW_RECT(E.xconfigure.x, E.xconfigure.y, win->r.w, win->r.h);
					RGFW_windowMoveCallback(win, win->r);
					break;
				} 

				break;
		}
		default: {
			break;
		}
		}

		XFlush((Display*) win->src.display);

		if (win->event.type)
			return &win->event;
		else
			return NULL;
	}

	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);
		win->r.x = v.x;
		win->r.y = v.y;

		XMoveWindow((Display*) win->src.display, (Window) win->src.window, v.x, v.y);
	}


	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);
		win->r.w = a.w;
		win->r.h = a.h;

		XResizeWindow((Display*) win->src.display, (Window) win->src.window, a.w, a.h);
	}

	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		if (a.w == 0 && a.h == 0)
			return;

		XSizeHints hints;
		long flags;

		XGetWMNormalHints(win->src.display, (Window) win->src.window, &hints, &flags);

		hints.flags |= PMinSize;
		
		hints.min_width = a.w;
		hints.min_height = a.h;

		XSetWMNormalHints(win->src.display, (Window) win->src.window, &hints);
	}

	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		if (a.w == 0 && a.h == 0)
			return;

		XSizeHints hints;
		long flags;

		XGetWMNormalHints(win->src.display, (Window) win->src.window, &hints, &flags);

		hints.flags |= PMaxSize;

		hints.max_width = a.w;
		hints.max_height = a.h;

		XSetWMNormalHints(win->src.display, (Window) win->src.window, &hints);
	}


	void RGFW_window_minimize(RGFW_window* win) {
		assert(win != NULL);

		XIconifyWindow(win->src.display, (Window) win->src.window, DefaultScreen(win->src.display));
		XFlush(win->src.display);
	}

	void RGFW_window_restore(RGFW_window* win) {
		assert(win != NULL);

		XMapWindow(win->src.display, (Window) win->src.window);
		XFlush(win->src.display);
	}	

	void RGFW_window_setName(RGFW_window* win, char* name) {
		assert(win != NULL);

		XStoreName((Display*) win->src.display, (Window) win->src.window, name);
	}
	
	void* RGFW_libxshape = NULL;

	#ifndef RGFW_NO_PASSTHROUGH
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		assert(win != NULL);
		
		#if defined(__CYGWIN__)
			RGFW_libxshape = dlopen("libXext-6.so", RTLD_LAZY | RTLD_LOCAL);
		#elif defined(__OpenBSD__) || defined(__NetBSD__)
			RGFW_libxshape = dlopen("libXext.so", RTLD_LAZY | RTLD_LOCAL);
		#else
    		RGFW_libxshape = dlopen("libXext.so.6", RTLD_LAZY | RTLD_LOCAL);
		#endif
		
		typedef void (* PFN_XShapeCombineMask)(Display*,Window,int,int,int,Pixmap,int);
		static PFN_XShapeCombineMask XShapeCombineMask;
		
		typedef void (* PFN_XShapeCombineRegion)(Display*,Window,int,int,int,Region,int);
		static PFN_XShapeCombineRegion XShapeCombineRegion;
		
		if (XShapeCombineMask != NULL)
			XShapeCombineMask = (PFN_XShapeCombineMask) dlsym(RGFW_libxshape, "XShapeCombineMask");

		if (XShapeCombineRegion != NULL)
			XShapeCombineRegion = (PFN_XShapeCombineRegion) dlsym(RGFW_libxshape, "XShapeCombineMask");

		if (passthrough) {
			Region region = XCreateRegion();
			XShapeCombineRegion(win->src.display, win->src.window, ShapeInput, 0, 0, region, ShapeSet);
			XDestroyRegion(region);

			return;
		}

		XShapeCombineMask(win->src.display, win->src.window, ShapeInput, 0, 0, None, ShapeSet);
	}
	#endif

	/*
		the majority function is sourced from GLFW
	*/

	void RGFW_window_setIcon(RGFW_window* win, u8* icon, RGFW_area a, i32 channels) {
		assert(win != NULL);

		i32 longCount = 2 + a.w * a.h;

		u64* X11Icon = (u64*) RGFW_MALLOC(longCount * sizeof(u64));
		u64* target = X11Icon;

		*target++ = a.w;
		*target++ = a.h;

		u32 i;

		for (i = 0; i < a.w * a.h; i++) {
			if (channels == 3)
				*target++ = ((icon[i * 3 + 0]) << 16) |
				((icon[i * 3 + 1]) << 8) |
				((icon[i * 3 + 2]) << 0) |
				(0xFF << 24);

			else if (channels == 4)
				*target++ = ((icon[i * 4 + 0]) << 16) |
				((icon[i * 4 + 1]) << 8) |
				((icon[i * 4 + 2]) << 0) |
				((icon[i * 4 + 3]) << 24);
		}

		static Atom NET_WM_ICON = 0;
		if (NET_WM_ICON == 0)
			NET_WM_ICON = XInternAtom((Display*) win->src.display, "_NET_WM_ICON", False);

		XChangeProperty((Display*) win->src.display, (Window) win->src.window,
			NET_WM_ICON,
			6, 32,
			PropModeReplace,
			(u8*) X11Icon,
			longCount);

		RGFW_FREE(X11Icon);

		XFlush((Display*) win->src.display);
	}

	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		assert(win != NULL);

#ifndef RGFW_NO_X11_CURSOR
		XcursorImage* native = XcursorImageCreate(a.w, a.h);
		native->xhot = 0;
		native->yhot = 0;

		u8* source = (u8*) image;
		XcursorPixel* target = native->pixels;

		u32 i;
		for (i = 0; i < a.w * a.h; i++, target++, source += 4) {
			u8 alpha = 0xFF;
			if (channels == 4)
				alpha = source[3];

			*target = (alpha << 24) | (((source[0] * alpha) / 255) << 16) | (((source[1] * alpha) / 255) << 8) | (((source[2] * alpha) / 255) << 0);
		}

		Cursor cursor = XcursorImageLoadCursor((Display*) win->src.display, native);
		XDefineCursor((Display*) win->src.display, (Window) win->src.window, (Cursor) cursor);

		XFreeCursor((Display*) win->src.display, (Cursor) cursor);
		XcursorImageDestroy(native);
#else
	RGFW_UNUSED(image) RGFW_UNUSED(a.w) RGFW_UNUSED(channels)
#endif
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);

		XEvent event;
		XQueryPointer(win->src.display, DefaultRootWindow(win->src.display),
			&event.xbutton.root, &event.xbutton.window,
			&event.xbutton.x_root, &event.xbutton.y_root,
			&event.xbutton.x, &event.xbutton.y,
			&event.xbutton.state);

		if (event.xbutton.x == v.x && event.xbutton.y == v.y)
			return;

		XWarpPointer(win->src.display, None, win->src.window, 0, 0, 0, 0, (int) v.x - win->r.x, (int) v.y - win->r.y);
	}

	RGFWDEF void RGFW_window_disableMouse(RGFW_window* win) {
		RGFW_UNUSED(win);
	}

	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_ARROW);
	}

	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
		assert(win != NULL);
		 
		if (mouse > (sizeof(RGFW_mouseIconSrc) / sizeof(u8)))
			return;
		
		mouse = RGFW_mouseIconSrc[mouse];

		Cursor cursor = XCreateFontCursor((Display*) win->src.display, mouse);
		XDefineCursor((Display*) win->src.display, (Window) win->src.window, (Cursor) cursor);

		XFreeCursor((Display*) win->src.display, (Cursor) cursor);
	}

	void RGFW_window_hide(RGFW_window* win) {
		XMapWindow(win->src.display, win->src.window);
	}

	void RGFW_window_show(RGFW_window* win) {
		XUnmapWindow(win->src.display, win->src.window);
	}

	/*
		the majority function is sourced from GLFW
	*/
	char* RGFW_readClipboard(size_t* size) {
		static Atom UTF8 = 0;
		if (UTF8 == 0)
			UTF8 = XInternAtom(RGFW_root->src.display, "UTF8_STRING", True);

		XEvent event;
		int format;
		unsigned long N, sizeN;
		char* data, * s = NULL;
		Atom target;
		Atom CLIPBOARD = 0, XSEL_DATA = 0;

		if (CLIPBOARD == 0) {
			CLIPBOARD = XInternAtom(RGFW_root->src.display, "CLIPBOARD", 0);
			XSEL_DATA = XInternAtom(RGFW_root->src.display, "XSEL_DATA", 0);
		}

		XConvertSelection(RGFW_root->src.display, CLIPBOARD, UTF8, XSEL_DATA, RGFW_root->src.window, CurrentTime);
		XSync(RGFW_root->src.display, 0);
		XNextEvent(RGFW_root->src.display, &event);

		if (event.type != SelectionNotify || event.xselection.selection != CLIPBOARD || event.xselection.property == 0)
			return NULL;

		XGetWindowProperty(event.xselection.display, event.xselection.requestor,
			event.xselection.property, 0L, (~0L), 0, AnyPropertyType, &target,
			&format, &sizeN, &N, (unsigned char**) &data);

		if (target == UTF8 || target == XA_STRING) {
			s = (char*)RGFW_MALLOC(sizeof(char) * sizeN);
			strncpy(s, data, sizeN);
			s[sizeN] = '\0';
			XFree(data);
		}

		XDeleteProperty(event.xselection.display, event.xselection.requestor, event.xselection.property);

		if (s != NULL && size != NULL)
			*size = sizeN;

		return s;
	}

	/*
		almost all of this function is sourced from GLFW
	*/
	void RGFW_writeClipboard(const char* text, u32 textLen) {
		static Atom CLIPBOARD = 0,
			UTF8_STRING = 0,
			SAVE_TARGETS = 0,
			TARGETS = 0,
			MULTIPLE = 0,
			ATOM_PAIR = 0,
			CLIPBOARD_MANAGER = 0;

		if (CLIPBOARD == 0) {
			CLIPBOARD = XInternAtom((Display*) RGFW_root->src.display, "CLIPBOARD", False);
			UTF8_STRING = XInternAtom((Display*) RGFW_root->src.display, "UTF8_STRING", False);
			SAVE_TARGETS = XInternAtom((Display*) RGFW_root->src.display, "SAVE_TARGETS", False);
			TARGETS = XInternAtom((Display*) RGFW_root->src.display, "TARGETS", False);
			MULTIPLE = XInternAtom((Display*) RGFW_root->src.display, "MULTIPLE", False);
			ATOM_PAIR = XInternAtom((Display*) RGFW_root->src.display, "ATOM_PAIR", False);
			CLIPBOARD_MANAGER = XInternAtom((Display*) RGFW_root->src.display, "CLIPBOARD_MANAGER", False);
		}
		
		XSetSelectionOwner((Display*) RGFW_root->src.display, CLIPBOARD, (Window) RGFW_root->src.window, CurrentTime);

		XConvertSelection((Display*) RGFW_root->src.display, CLIPBOARD_MANAGER, SAVE_TARGETS, None, (Window) RGFW_root->src.window, CurrentTime);
		for (;;) {
			XEvent event;

			XNextEvent((Display*) RGFW_root->src.display, &event);
			if (event.type != SelectionRequest) {
				break;
			}

			const XSelectionRequestEvent* request = &event.xselectionrequest;

			XEvent reply = { SelectionNotify };
			reply.xselection.property = 0;

			if (request->target == TARGETS) {
				const Atom targets[] = { TARGETS,
										MULTIPLE,
										UTF8_STRING,
										XA_STRING };

				XChangeProperty((Display*) RGFW_root->src.display,
					request->requestor,
					request->property,
					4,
					32,
					PropModeReplace,
					(u8*) targets,
					sizeof(targets) / sizeof(targets[0]));

				reply.xselection.property = request->property;
			}

			if (request->target == MULTIPLE) {
				Atom* targets = NULL;

				Atom actualType = 0;
				int actualFormat = 0;
				unsigned long count = 0, bytesAfter = 0;

				XGetWindowProperty((Display*) RGFW_root->src.display, request->requestor, request->property, 0, LONG_MAX, False, ATOM_PAIR, &actualType, &actualFormat, &count, &bytesAfter, (u8**) &targets);

				unsigned long i;
				for (i = 0; i < (u32)count; i += 2) {
					if (targets[i] == UTF8_STRING || targets[i] == XA_STRING) {
						XChangeProperty((Display*) RGFW_root->src.display,
							request->requestor,
							targets[i + 1],
							targets[i],
							8,
							PropModeReplace,
							(u8*) text,
							textLen);
						XFlush(RGFW_root->src.display);
					} else {
						targets[i + 1] = None;
					}
				}

				XChangeProperty((Display*) RGFW_root->src.display,
					request->requestor,
					request->property,
					ATOM_PAIR,
					32,
					PropModeReplace,
					(u8*) targets,
					count);

				XFlush(RGFW_root->src.display);
				XFree(targets);

				reply.xselection.property = request->property;
			}

			reply.xselection.display = request->display;
			reply.xselection.requestor = request->requestor;
			reply.xselection.selection = request->selection;
			reply.xselection.target = request->target;
			reply.xselection.time = request->time;

			XSendEvent((Display*) RGFW_root->src.display, request->requestor, False, 0, &reply);
			XFlush(RGFW_root->src.display);
		}
	}

	u8 RGFW_window_isFullscreen(RGFW_window* win) {
		assert(win != NULL);

		XWindowAttributes windowAttributes;
		XGetWindowAttributes(win->src.display, (Window) win->src.window, &windowAttributes);

		/* check if the window is visable */
		if (windowAttributes.map_state != IsViewable)
			return 0;

		/* check if the window covers the full screen */
		return (windowAttributes.x == 0 && windowAttributes.y == 0 &&
			windowAttributes.width == XDisplayWidth(win->src.display, DefaultScreen(win->src.display)) &&
			windowAttributes.height == XDisplayHeight(win->src.display, DefaultScreen(win->src.display)));
	}

	u8 RGFW_window_isHidden(RGFW_window* win) {
		assert(win != NULL);

		XWindowAttributes windowAttributes;
		XGetWindowAttributes(win->src.display, (Window) win->src.window, &windowAttributes);

		return (windowAttributes.map_state == IsUnmapped && !RGFW_window_isMinimized(win));
	}

	u8 RGFW_window_isMinimized(RGFW_window* win) {
		assert(win != NULL);

		static Atom prop = 0;
		if (prop == 0)
			prop = XInternAtom(win->src.display, "WM_STATE", False);

		Atom actual_type;
		i32 actual_format;
		unsigned long nitems, bytes_after;
		unsigned char* prop_data;

		i16 status = XGetWindowProperty(win->src.display, (Window) win->src.window, prop, 0, 2, False,
			AnyPropertyType, &actual_type, &actual_format,
			&nitems, &bytes_after, &prop_data);

		if (status == Success && nitems >= 1 && *((int*) prop_data) == IconicState) {
			XFree(prop_data);
			return 1;
		}

		if (prop_data != NULL)
			XFree(prop_data);

		return 0;
	}

	u8 RGFW_window_isMaximized(RGFW_window* win) {
		assert(win != NULL);

		static Atom net_wm_state = 0;
		static Atom net_wm_state_maximized_horz = 0;
		static Atom net_wm_state_maximized_vert = 0;

		if (net_wm_state == 0) {
			net_wm_state = XInternAtom(win->src.display, "_NET_WM_STATE", False);
			net_wm_state_maximized_vert = XInternAtom(win->src.display, "_NET_WM_STATE_MAXIMIZED_VERT", False);
			net_wm_state_maximized_horz = XInternAtom(win->src.display, "_NET_WM_STATE_MAXIMIZED_HORZ", False);
		}

		Atom actual_type;
		i32 actual_format;
		unsigned long nitems, bytes_after;
		unsigned char* prop_data;

		i16 status = XGetWindowProperty(win->src.display, (Window) win->src.window, net_wm_state, 0, 1024, False,
			XA_ATOM, &actual_type, &actual_format,
			&nitems, &bytes_after, &prop_data);

		if (status != Success) {
			if (prop_data != NULL)
				XFree(prop_data);

			return 0;
		}

		Atom* atoms = (Atom*) prop_data;
		u64 i;
		for (i = 0; i < nitems; ++i) {
			if (atoms[i] == net_wm_state_maximized_horz ||
				atoms[i] == net_wm_state_maximized_vert) {
				XFree(prop_data);
				return 1;
			}
		}

		return 0;
	}

	static void XGetSystemContentScale(Display* display, float* xscale, float* yscale) {
		float xdpi = 96.f, ydpi = 96.f;

#ifndef RGFW_NO_DPI
		char* rms = XResourceManagerString(display);
		XrmDatabase db = NULL;

		if (rms && db)
			db = XrmGetStringDatabase(rms);

		if (db == 0) {
			*xscale = xdpi / 96.f;
			*yscale = ydpi / 96.f;
			return;
		}

		XrmValue value;
		char* type = NULL;

		if (XrmGetResource(db, "Xft.dpi", "Xft.Dpi", &type, &value) && type && strncmp(type, "String", 7) == 0)
			xdpi = ydpi = atof(value.addr);
		XrmDestroyDatabase(db);
#endif

		* xscale = xdpi / 96.f;
		*yscale = ydpi / 96.f;
	}

	RGFW_monitor RGFW_XCreateMonitor(i32 screen) {
		RGFW_monitor monitor;

		Display* display = XOpenDisplay(NULL);

		monitor.rect = RGFW_RECT(0, 0, DisplayWidth(display, screen), DisplayHeight(display, screen));
		monitor.physW = (monitor.rect.w * 25.4f / 96.f);
		monitor.physH = (monitor.rect.h * 25.4f / 96.f);

		strncpy(monitor.name, DisplayString(display), 128);

		XGetSystemContentScale(display, &monitor.scaleX, &monitor.scaleY);

		XRRScreenResources* sr = XRRGetScreenResourcesCurrent(display, RootWindow(display, screen));

		XRRCrtcInfo* ci = NULL;
		int crtc = 0;

		if (sr->ncrtc > crtc) {
			ci = XRRGetCrtcInfo(display, sr, sr->crtcs[crtc]);
		}

		if (ci == NULL) {
			XRRFreeScreenResources(sr);
			XCloseDisplay(display);
			return monitor;
		}

		monitor.rect.x = ci->x;
		monitor.rect.y = ci->y;

		XRRFreeCrtcInfo(ci);
		XRRFreeScreenResources(sr);

		XCloseDisplay(display);

		return monitor;
	}

	RGFW_monitor RGFW_monitors[6];
	RGFW_monitor* RGFW_getMonitors(void) {
		size_t i;
		for (i = 0; i < (size_t)ScreenCount(RGFW_root->src.display) && i < 6; i++)
			RGFW_monitors[i] = RGFW_XCreateMonitor(i);

		return RGFW_monitors;
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
		assert(RGFW_root != NULL);

		i32 primary = -1;
		Window root = DefaultRootWindow(RGFW_root->src.display);
		XRRScreenResources* res = XRRGetScreenResources(RGFW_root->src.display, root);

		for (int i = 0; i < res->noutput; i++) {
			XRROutputInfo* output_info = XRRGetOutputInfo(RGFW_root->src.display, res, res->outputs[i]);
			if (output_info->connection == RR_Connected && output_info->crtc) {
				XRRCrtcInfo* crtc_info = XRRGetCrtcInfo(RGFW_root->src.display, res, output_info->crtc);
				if (crtc_info->mode != None && crtc_info->x == 0 && crtc_info->y == 0) {
					primary = i;
					XRRFreeCrtcInfo(crtc_info);
					XRRFreeOutputInfo(output_info);
					break;
				}
				XRRFreeCrtcInfo(crtc_info);
			}
			XRRFreeOutputInfo(output_info);
		}

		XRRFreeScreenResources(res);

		return RGFW_XCreateMonitor(primary);
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		return RGFW_XCreateMonitor(DefaultScreen(win->src.display));
	}

	#ifdef RGFW_OPENGL
	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		if (win == NULL)
			glXMakeCurrent((Display*) NULL, (Drawable)NULL, (GLXContext) NULL);
		else
			glXMakeCurrent((Display*) win->src.display, (Drawable) win->src.window, (GLXContext) win->src.ctx);
	}
	#endif


	void RGFW_window_swapBuffers(RGFW_window* win) {
		assert(win != NULL);

		/* clear the window*/
		if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			#ifdef RGFW_OSMESA
			RGFW_OSMesa_reorganize();
			#endif
			RGFW_area area = RGFW_bufferSize;

#ifndef RGFW_X11_DONT_CONVERT_BGR
			win->src.bitmap->data = (char*) win->buffer;
			u32 x, y;
			for (y = 0; y < (u32)win->r.h; y++) {
				for (x = 0; x < (u32)win->r.w; x++) {
					u32 index = (y * 4 * area.w) + x * 4;

					u8 red = win->src.bitmap->data[index];
					win->src.bitmap->data[index] = win->buffer[index + 2];
					win->src.bitmap->data[index + 2] = red;

				}
			}
#endif	
			XPutImage(win->src.display, (Window) win->src.window, win->src.gc, win->src.bitmap, 0, 0, 0, 0, RGFW_bufferSize.w, RGFW_bufferSize.h);
#endif
		}

		if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) {
			#ifdef RGFW_EGL
					eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
			#elif defined(RGFW_OPENGL)
					glXSwapBuffers((Display*) win->src.display, (Window) win->src.window);
			#endif
		}
	}

	#if !defined(RGFW_EGL)	
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);

		#if defined(RGFW_OPENGL)	
		((PFNGLXSWAPINTERVALEXTPROC) glXGetProcAddress((GLubyte*) "glXSwapIntervalEXT"))((Display*) win->src.display, (Window) win->src.window, swapInterval);
		#else
		RGFW_UNUSED(swapInterval);
		#endif
	}
	#endif


	void RGFW_window_close(RGFW_window* win) {
		/* ungrab pointer if it was grabbed */
		if (win->_winArgs & RGFW_HOLD_MOUSE) 
			XUngrabPointer(win->src.display, CurrentTime);
			
		assert(win != NULL);
#ifdef RGFW_EGL
		RGFW_closeEGL(win);
#endif

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
		if (win->buffer != NULL) {
			XDestroyImage((XImage*) win->src.bitmap);
			XFreeGC(win->src.display, win->src.gc);
		}
#endif

		if ((Display*) win->src.display) {
#ifdef RGFW_OPENGL
			glXDestroyContext((Display*) win->src.display, win->src.ctx);
#endif

			if (win == RGFW_root)
				RGFW_root = NULL;

			if ((Drawable) win->src.window)
				XDestroyWindow((Display*) win->src.display, (Drawable) win->src.window); /*!< close the window*/
			
			XCloseDisplay((Display*) win->src.display); /*!< kill the display*/
		}

#ifdef RGFW_ALLOC_DROPFILES
		{
			u32 i;
			for (i = 0; i < RGFW_MAX_DROPS; i++)
				RGFW_FREE(win->event.droppedFiles[i]);


			RGFW_FREE(win->event.droppedFiles);
		}
#endif

		RGFW_windowsOpen--;
#if !defined(RGFW_NO_X11_CURSOR_PRELOAD) && !defined(RGFW_NO_X11_CURSOR)
		if (X11Cursorhandle != NULL && RGFW_windowsOpen <= 0) {
			dlclose(X11Cursorhandle);

			X11Cursorhandle = NULL;
		}
#endif
#if !defined(RGFW_NO_X11_XI_PRELOAD)
		if (X11Xihandle != NULL && RGFW_windowsOpen <= 0) {
			dlclose(X11Xihandle);

			X11Xihandle = NULL;
		}
#endif

		if (RGFW_libxshape != NULL && RGFW_windowsOpen <= 0) {
			dlclose(RGFW_libxshape);
			RGFW_libxshape = NULL;
		}

		if (RGFW_windowsOpen <= 0) {
			if (RGFW_eventWait_forceStop[0] || RGFW_eventWait_forceStop[1]){
				close(RGFW_eventWait_forceStop[0]);
				close(RGFW_eventWait_forceStop[1]);
			}

			u8 i;
			for (i = 0; i < RGFW_joystickCount; i++)
				close(RGFW_joysticks[i]);
		}

		/* set cleared display / window to NULL for error checking */
		win->src.display = (Display*) 0;
		win->src.window = (Window) 0;

		RGFW_FREE(win); /*!< free collected window data */
	}
	

/* 
	End of X11 linux / unix defines
*/

#endif /* RGFW_X11 */


/* wayland or X11 defines*/
#if defined(RGFW_WAYLAND) || defined(RGFW_X11)
#include <fcntl.h>
#include <poll.h>
#include <unistd.h>
	u16 RGFW_registerJoystickF(RGFW_window* win, char* file) {
		assert(win != NULL);

#ifdef __linux__

		i32 js = open(file, O_RDONLY);

		if (js && RGFW_joystickCount < 4) {
			RGFW_joystickCount++;

			RGFW_joysticks[RGFW_joystickCount - 1] = open(file, O_RDONLY);

			u8 i;
			for (i = 0; i < 16; i++)
				RGFW_jsPressed[RGFW_joystickCount - 1][i] = 0;

		}

		else {
#ifdef RGFW_PRINT_ERRORS
			RGFW_error = 1;
			fprintf(stderr, "Error RGFW_registerJoystickF : Cannot open file %s\n", file);
#endif
		}

		return RGFW_joystickCount - 1;
#endif
	}
	
	u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber) {
		assert(win != NULL);

#ifdef __linux__
		char file[15];
		sprintf(file, "/dev/input/js%i", jsNumber);

		return RGFW_registerJoystickF(win, file);
#endif
	}
	
	void RGFW_stopCheckEvents(void) { 
		RGFW_eventWait_forceStop[2] = 1;
		while (1) {
			const char byte = 0;
			const ssize_t result = write(RGFW_eventWait_forceStop[1], &byte, 1);
			if (result == 1 || result == -1)
				break;
		}
	}

	void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
		if (waitMS == 0)
			return;
		
		u8 i;

		if (RGFW_eventWait_forceStop[0] == 0 || RGFW_eventWait_forceStop[1] == 0) {
			if (pipe(RGFW_eventWait_forceStop) != -1) {
				fcntl(RGFW_eventWait_forceStop[0], F_GETFL, 0);
				fcntl(RGFW_eventWait_forceStop[0], F_GETFD, 0);
				fcntl(RGFW_eventWait_forceStop[1], F_GETFL, 0);
				fcntl(RGFW_eventWait_forceStop[1], F_GETFD, 0);
			}
		}

		struct pollfd fds[] = {
			#ifdef RGFW_WAYLAND
			{ wl_display_get_fd(win->src.display), POLLIN, 0 },
			#else
			{ ConnectionNumber(win->src.display), POLLIN, 0 },
			#endif
			{ RGFW_eventWait_forceStop[0], POLLIN, 0 },
			#ifdef __linux__ /* blank space for 4 joystick files*/
			{ -1, POLLIN, 0 }, {-1, POLLIN, 0 }, {-1, POLLIN, 0 },  {-1, POLLIN, 0} 
			#endif
		};

		u8 index = 2;
		
		#if defined(__linux__)
			for (i = 0; i < RGFW_joystickCount; i++) {
				if (RGFW_joysticks[i] == 0)
					continue;

				fds[index].fd = RGFW_joysticks[i];
				index++;
			}
		#endif


		u64 start = RGFW_getTimeNS();

		#ifdef RGFW_WAYLAND
		while (wl_display_dispatch(win->src.display) <= 0 && waitMS >= -1) {
		#else
		while (XPending(win->src.display) == 0 && waitMS >= -1) {
		#endif
			if (poll(fds, index, waitMS) <= 0)
				break;

			if (waitMS > 0) {
				waitMS -= (RGFW_getTimeNS() - start) / 1e+6;
			}
		}

		/* drain any data in the stop request */
		if (RGFW_eventWait_forceStop[2]) {	
			char data[64];
			(void)!read(RGFW_eventWait_forceStop[0], data, sizeof(data));
			
			RGFW_eventWait_forceStop[2] = 0;
		}
	}

	u64 RGFW_getTimeNS(void) { 
		struct timespec ts = { 0 };
		clock_gettime(1, &ts);
		unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;

		return nanoSeconds;
	}

	u64 RGFW_getTime(void) {
		struct timespec ts = { 0 };
		clock_gettime(1, &ts);
		unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;

		return (double)(nanoSeconds) * 1e-9;
	}
#endif /* end of wayland or X11 time defines*/


/*

	Start of Wayland defines


*/

#ifdef RGFW_WAYLAND
/*
Wayland TODO:
- fix RGFW_keyPressed lock state

	RGFW_windowMoved, 		the window was moved (by the user)
	RGFW_windowResized  	the window was resized (by the user), [on webASM this means the browser was resized]
	RGFW_windowRefresh	 	The window content needs to be refreshed

	RGFW_dnd 				a file has been dropped into the window
	RGFW_dnd_init

- window args:
	#define RGFW_NO_RESIZE	 			the window cannot be resized  by the user
	#define RGFW_ALLOW_DND     			the window supports drag and drop
	#define RGFW_SCALE_TO_MONITOR 			scale the window to the screen 

- other missing functions functions ("TODO wayland") (~30 functions)
- fix buffer rendering weird behavior
*/
	#include <errno.h>
	#include <unistd.h>
	#include <sys/mman.h>
	#include <xkbcommon/xkbcommon.h>
	#include <xkbcommon/xkbcommon-keysyms.h>
	#include <dirent.h>
	#include <linux/kd.h> 
	#include <wayland-cursor.h>

RGFW_window* RGFW_key_win = NULL;

void RGFW_eventPipe_push(RGFW_window* win, RGFW_Event event) {
	if (win == NULL) {
		win = RGFW_key_win;

		if (win == NULL) return;
	}
	
	if (win->src.eventLen >= (i32)(sizeof(win->src.events) / sizeof(win->src.events[0])))
		return;

	win->src.events[win->src.eventLen] = event;
	win->src.eventLen += 1;
}

RGFW_Event RGFW_eventPipe_pop(RGFW_window* win) {
	RGFW_Event ev;
	ev.type = 0;
	
	if (win->src.eventLen > -1)
		win->src.eventLen -= 1;
	
	if (win->src.eventLen >= 0)  
		ev = win->src.events[win->src.eventLen];
	else {
		printf("H2\n");
	}

	return ev;	
}

/* wayland global garbage (wayland bad, X11 is fine (ish) (not really)) */
#include "xdg-shell.h"
#include "xdg-decoration-unstable-v1.h"

struct xdg_wm_base *xdg_wm_base;
struct wl_compositor* RGFW_compositor = NULL;
struct wl_shm* shm = NULL;
struct wl_shell* RGFW_shell = NULL;
static struct wl_seat *seat = NULL;
static struct xkb_context *xkb_context;
static struct xkb_keymap *keymap = NULL;
static struct xkb_state *xkb_state = NULL;
enum zxdg_toplevel_decoration_v1_mode client_preferred_mode, RGFW_current_mode;
static struct zxdg_decoration_manager_v1 *decoration_manager = NULL;

struct wl_cursor_theme* RGFW_wl_cursor_theme = NULL;
struct wl_surface* RGFW_cursor_surface = NULL;
struct wl_cursor_image* RGFW_cursor_image = NULL;

static void xdg_wm_base_ping_handler(void *data,
        struct xdg_wm_base *wm_base, uint32_t serial)
{
	RGFW_UNUSED(data);
    xdg_wm_base_pong(wm_base, serial);
}

static const struct xdg_wm_base_listener xdg_wm_base_listener = {
    .ping = xdg_wm_base_ping_handler,
};

b8 RGFW_wl_configured = 0;

static void xdg_surface_configure_handler(void *data,
        struct xdg_surface *xdg_surface, uint32_t serial)
{	
	RGFW_UNUSED(data);
    xdg_surface_ack_configure(xdg_surface, serial);
	#ifdef RGFW_DEBUG
	printf("Surface configured\n");
	#endif
	RGFW_wl_configured = 1;
}

static const struct xdg_surface_listener xdg_surface_listener = {
    .configure = xdg_surface_configure_handler,
};

static void xdg_toplevel_configure_handler(void *data,
        struct xdg_toplevel *toplevel, int32_t width, int32_t height,
        struct wl_array *states)
{
	RGFW_UNUSED(data); RGFW_UNUSED(toplevel); RGFW_UNUSED(states)
    fprintf(stderr, "XDG toplevel configure: %dx%d\n", width, height);
}

static void xdg_toplevel_close_handler(void *data,
        struct xdg_toplevel *toplevel)
{
	RGFW_UNUSED(data);
	RGFW_window* win = (RGFW_window*)xdg_toplevel_get_user_data(toplevel);
	if (win == NULL)
		win = RGFW_key_win;
	
	RGFW_Event ev;
	ev.type = RGFW_quit;

	RGFW_eventPipe_push(win, ev); 	

	RGFW_windowQuitCallback(win);
}

static void shm_format_handler(void *data,
        struct wl_shm *shm, uint32_t format)
{
	RGFW_UNUSED(data); RGFW_UNUSED(shm);
    fprintf(stderr, "Format %d\n", format);
}

static const struct wl_shm_listener shm_listener = {
    .format = shm_format_handler,
};

static const struct xdg_toplevel_listener xdg_toplevel_listener = {
    .configure = xdg_toplevel_configure_handler,
    .close = xdg_toplevel_close_handler,
};

RGFW_window* RGFW_mouse_win = NULL;

static void pointer_enter(void *data, struct wl_pointer *pointer, uint32_t serial, struct wl_surface *surface, wl_fixed_t surface_x, wl_fixed_t surface_y) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(serial); RGFW_UNUSED(surface_x); RGFW_UNUSED(surface_y);
	RGFW_window* win = (RGFW_window*)wl_surface_get_user_data(surface);
	RGFW_mouse_win = win;

	RGFW_Event ev;
	ev.type = RGFW_mouseEnter;
	ev.point = win->event.point;

	RGFW_eventPipe_push(win, ev); 	

	RGFW_mouseNotifyCallBack(win, win->event.point, RGFW_TRUE);
}
static void pointer_leave(void *data, struct wl_pointer *pointer, uint32_t serial, struct wl_surface *surface) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(serial); RGFW_UNUSED(surface);
	RGFW_window* win = (RGFW_window*)wl_surface_get_user_data(surface);
	if (RGFW_mouse_win == win)
		RGFW_mouse_win = NULL;
	
	RGFW_Event ev;
	ev.type = RGFW_mouseLeave;
	ev.point = win->event.point;
	RGFW_eventPipe_push(win, ev);

	RGFW_mouseNotifyCallBack(win,  win->event.point, RGFW_FALSE);
}
static void pointer_motion(void *data, struct wl_pointer *pointer, uint32_t time, wl_fixed_t x, wl_fixed_t y) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(time); RGFW_UNUSED(x); RGFW_UNUSED(y);

	assert(RGFW_mouse_win != NULL);
	
	RGFW_Event ev;
	ev.type = RGFW_mousePosChanged;
	ev.point = RGFW_POINT(wl_fixed_to_double(x), wl_fixed_to_double(y));
	RGFW_eventPipe_push(RGFW_mouse_win, ev);
	
	RGFW_mousePosCallback(RGFW_mouse_win, RGFW_POINT(wl_fixed_to_double(x), wl_fixed_to_double(y)));
}
static void pointer_button(void *data, struct wl_pointer *pointer, uint32_t serial, uint32_t time, uint32_t button, uint32_t state) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(time); RGFW_UNUSED(serial);
	assert(RGFW_mouse_win != NULL);

	u32 b = (button - 0x110) + 1;

	/* flip right and middle button codes */
	if (b == 2) b = 3;
	else if (b == 3) b = 2;
	
	RGFW_mouseButtons[b].prev = RGFW_mouseButtons[b].current;
	RGFW_mouseButtons[b].current = state;

	RGFW_Event ev;
	ev.type = RGFW_mouseButtonPressed + state;
	ev.button = b;
	RGFW_eventPipe_push(RGFW_mouse_win, ev);

	RGFW_mouseButtonCallback(RGFW_mouse_win, b, 0, state);
}
static void pointer_axis(void *data, struct wl_pointer *pointer, uint32_t time, uint32_t axis, wl_fixed_t value) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(time);  RGFW_UNUSED(axis);
	assert(RGFW_mouse_win != NULL); 

	double scroll = wl_fixed_to_double(value);

	RGFW_Event ev;
	ev.type = RGFW_mouseButtonPressed;
	ev.button = RGFW_mouseScrollUp + (scroll < 0);
	RGFW_eventPipe_push(RGFW_mouse_win, ev);

	RGFW_mouseButtonCallback(RGFW_mouse_win, RGFW_mouseScrollUp + (scroll < 0), scroll, 1);
}

void RGFW_doNothing(void) { }
static struct wl_pointer_listener pointer_listener = (struct wl_pointer_listener){&pointer_enter, &pointer_leave, &pointer_motion, &pointer_button, &pointer_axis, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing};

static void keyboard_keymap (void *data, struct wl_keyboard *keyboard, uint32_t format, int32_t fd, uint32_t size) {
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(format);

	char *keymap_string = mmap (NULL, size, PROT_READ, MAP_SHARED, fd, 0);
	xkb_keymap_unref (keymap);
	keymap = xkb_keymap_new_from_string (xkb_context, keymap_string, XKB_KEYMAP_FORMAT_TEXT_V1, XKB_KEYMAP_COMPILE_NO_FLAGS);
	
	munmap (keymap_string, size);
	close (fd);
	xkb_state_unref (xkb_state);
	xkb_state = xkb_state_new (keymap);
}
static void keyboard_enter (void *data, struct wl_keyboard *keyboard, uint32_t serial, struct wl_surface *surface, struct wl_array *keys) { 
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial); RGFW_UNUSED(keys);

	RGFW_key_win = (RGFW_window*)wl_surface_get_user_data(surface);

	RGFW_Event ev;
	ev.type = RGFW_focusIn;
	ev.inFocus = RGFW_TRUE;
	RGFW_key_win->event.inFocus = RGFW_TRUE;

	RGFW_eventPipe_push((RGFW_window*)RGFW_mouse_win, ev);

	RGFW_focusCallback(RGFW_key_win, RGFW_TRUE);
}
static void keyboard_leave (void *data, struct wl_keyboard *keyboard, uint32_t serial, struct wl_surface *surface) { 
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial);

	RGFW_window* win = (RGFW_window*)wl_surface_get_user_data(surface);
	if (RGFW_key_win == win)
		RGFW_key_win = NULL;	

	RGFW_Event ev;
	ev.type = RGFW_focusOut;
	ev.inFocus = RGFW_FALSE;
	win->event.inFocus = RGFW_FALSE;
	RGFW_eventPipe_push(win, ev);

	RGFW_focusCallback(win, RGFW_FALSE);
}
static void keyboard_key (void *data, struct wl_keyboard *keyboard, uint32_t serial, uint32_t time, uint32_t key, uint32_t state) {
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial); RGFW_UNUSED(time); 

	assert(RGFW_key_win != NULL);

	xkb_keysym_t keysym = xkb_state_key_get_one_sym (xkb_state, key+8);
	char name[16];
	xkb_keysym_get_name(keysym, name, 16);

	u32 RGFW_key = RGFW_apiKeyCodeToRGFW(key);
	RGFW_keyboard[RGFW_key].prev = RGFW_keyboard[RGFW_key].current;
	RGFW_keyboard[RGFW_key].current = state;
	RGFW_Event ev;
	ev.type = RGFW_keyPressed + state;
	ev.keyCode = RGFW_key;
	strcpy(ev.keyName, name);
	ev.repeat = RGFW_isHeld(RGFW_key_win, RGFW_key);
	RGFW_eventPipe_push(RGFW_key_win, ev);
	
	RGFW_updateLockState(RGFW_key_win, xkb_keymap_mod_get_index(keymap, "Lock"), xkb_keymap_mod_get_index(keymap, "Mod2"));

	RGFW_keyCallback(RGFW_key_win, RGFW_key, name, RGFW_key_win->event.lockState, state);
}
static void keyboard_modifiers (void *data, struct wl_keyboard *keyboard, uint32_t serial, uint32_t mods_depressed, uint32_t mods_latched, uint32_t mods_locked, uint32_t group) {
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial); RGFW_UNUSED(time); 
	xkb_state_update_mask (xkb_state, mods_depressed, mods_latched, mods_locked, 0, 0, group);
}
static struct wl_keyboard_listener keyboard_listener = {&keyboard_keymap, &keyboard_enter, &keyboard_leave, &keyboard_key, &keyboard_modifiers, (void*)&RGFW_doNothing};

static void seat_capabilities (void *data, struct wl_seat *seat, uint32_t capabilities) {
	RGFW_UNUSED(data);

	if (capabilities & WL_SEAT_CAPABILITY_POINTER) {
		struct wl_pointer *pointer = wl_seat_get_pointer (seat);
		wl_pointer_add_listener (pointer, &pointer_listener, NULL);
	}
	if (capabilities & WL_SEAT_CAPABILITY_KEYBOARD) {
		struct wl_keyboard *keyboard = wl_seat_get_keyboard (seat);
		wl_keyboard_add_listener (keyboard, &keyboard_listener, NULL);
	}
}
static struct wl_seat_listener seat_listener = {&seat_capabilities, (void*)&RGFW_doNothing};

static void wl_global_registry_handler(void *data,
		struct wl_registry *registry, uint32_t id, const char *interface,
		uint32_t version)
{
	RGFW_UNUSED(data); RGFW_UNUSED(version);

    if (strcmp(interface, "wl_compositor") == 0) {
		RGFW_compositor = wl_registry_bind(registry,
			id, &wl_compositor_interface, 4);
	} else if (strcmp(interface, "xdg_wm_base") == 0) {
	xdg_wm_base = wl_registry_bind(registry,
		id, &xdg_wm_base_interface, 1);
	} else if (strcmp(interface, zxdg_decoration_manager_v1_interface.name) == 0) {
		decoration_manager = wl_registry_bind(registry, id, &zxdg_decoration_manager_v1_interface, 1);
    } else if (strcmp(interface, "wl_shm") == 0) {
        shm = wl_registry_bind(registry,
            id, &wl_shm_interface, 1);
        wl_shm_add_listener(shm, &shm_listener, NULL);
	} else if (strcmp(interface,"wl_seat") == 0) {
		seat = wl_registry_bind(registry, id, &wl_seat_interface, 1);
		wl_seat_add_listener(seat, &seat_listener, NULL);
	}

	else {
		#ifdef RGFW_DEBUG
		printf("did not register %s\n", interface);
		return;
		#endif
	}

		#ifdef RGFW_DEBUG
		printf("registered %s\n", interface);
		#endif
}

static void wl_global_registry_remove(void *data, struct wl_registry *registry, uint32_t name) { RGFW_UNUSED(data); RGFW_UNUSED(registry); RGFW_UNUSED(name); }
static const struct wl_registry_listener registry_listener = {
	.global = wl_global_registry_handler,
	.global_remove = wl_global_registry_remove,
};

static const char *get_mode_name(enum zxdg_toplevel_decoration_v1_mode mode) {
	switch (mode) {
	case ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE:
		return "client-side decorations";
	case ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE:
		return "server-side decorations";
	}
	abort();
}


static void decoration_handle_configure(void *data,
		struct zxdg_toplevel_decoration_v1 *decoration,
		enum zxdg_toplevel_decoration_v1_mode mode) {
	RGFW_UNUSED(data); RGFW_UNUSED(decoration);
	printf("Using %s\n", get_mode_name(mode));
	RGFW_current_mode = mode;
}

static const struct zxdg_toplevel_decoration_v1_listener decoration_listener = {
	.configure = decoration_handle_configure,
};

static void randname(char *buf) {
	struct timespec ts;
	clock_gettime(CLOCK_REALTIME, &ts);
	long r = ts.tv_nsec;
	for (int i = 0; i < 6; ++i) {
		buf[i] = 'A'+(r&15)+(r&16)*2;
		r >>= 5;
	}
}

static int anonymous_shm_open(void) {
	char name[] = "/RGFW-wayland-XXXXXX";
	int retries = 100;

	do {
		randname(name + strlen(name) - 6);

		--retries;
		// shm_open guarantees that O_CLOEXEC is set
		int fd = shm_open(name, O_RDWR | O_CREAT | O_EXCL, 0600);
		if (fd >= 0) {
			shm_unlink(name);
			return fd;
		}
	} while (retries > 0 && errno == EEXIST);

	return -1;
}

int create_shm_file(off_t size) {
	int fd = anonymous_shm_open();
	if (fd < 0) {
		return fd;
	}

	if (ftruncate(fd, size) < 0) {
		close(fd);
		return -1;
	}

	return fd;
}

static void wl_surface_frame_done(void *data, struct wl_callback *cb, uint32_t time) {
	#ifdef RGFW_BUFFER
		RGFW_window* win = (RGFW_window*)data;
		if ((win->_winArgs & RGFW_NO_CPU_RENDER))
			return;	
		
		#ifndef RGFW_X11_DONT_CONVERT_BGR
			u32 x, y;
			for (y = 0; y < (u32)win->r.h; y++) {
				for (x = 0; x < (u32)win->r.w; x++) {
					u32 index = (y * 4 * win->r.w) + x * 4;

					u8 red = win->buffer[index];
					win->buffer[index] = win->buffer[index + 2];
					win->buffer[index + 2] = red;

				}
			}
		#endif	
	
		wl_surface_attach(win->src.surface, win->src.wl_buffer, 0, 0);
		wl_surface_damage_buffer(win->src.surface, 0, 0, win->r.w, win->r.h);
		wl_surface_commit(win->src.surface);
	#endif
}

static const struct wl_callback_listener wl_surface_frame_listener = {
	.done = wl_surface_frame_done,
};


	/* normal wayland RGFW stuff */
	
	RGFW_area RGFW_getScreenSize(void) {
		RGFW_area area = {};

		if (RGFW_root != NULL)
			/* this isn't right but it's here for buffers */
			area = RGFW_AREA(RGFW_root->r.w, RGFW_root->r.h);
		
		/* TODO wayland */
		return area;
	}
	
	void RGFW_releaseCursor(RGFW_window* win) {
		RGFW_UNUSED(win);
	}

	void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) {
		RGFW_UNUSED(win); RGFW_UNUSED(r);

		/* TODO wayland */
	}


	RGFWDEF void RGFW_init_buffer(RGFW_window* win);
	void RGFW_init_buffer(RGFW_window* win) {
		#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)	
			size_t size = win->r.w * win->r.h * 4;
			int fd = create_shm_file(size);
			if (fd < 0) {
				fprintf(stderr, "Failed to create a buffer. size: %ld\n", size);
				exit(1);
			}

			win->buffer = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
			if (win->buffer == MAP_FAILED) {
				fprintf(stderr, "mmap failed!\n");
				close(fd);
				exit(1);
			}

			struct wl_shm_pool* pool = wl_shm_create_pool(shm, fd, size);
			win->src.wl_buffer = wl_shm_pool_create_buffer(pool, 0, win->r.w, win->r.h, win->r.w * 4,
				WL_SHM_FORMAT_ARGB8888);
			wl_shm_pool_destroy(pool);

			close(fd);
			
			wl_surface_attach(win->src.surface, win->src.wl_buffer, 0, 0);
			wl_surface_commit(win->src.surface);

			u8 color[] = {0x00, 0x00, 0x00, 0xFF};

			size_t i;
			for (i = 0; i < size; i += 4) {
				memcpy(&win->buffer[i], color, 4);
			}
	
			#if defined(RGFW_OSMESA)
					win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
					OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
			#endif
		#else
		RGFW_UNUSED(win);
		#endif
	}
   

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
		RGFW_window* win = RGFW_window_basic_init(rect, args);
		
		fprintf(stderr, "Warning: RGFW Wayland support is experimental\n");
		
		win->src.display = wl_display_connect(NULL);
		if (win->src.display == NULL) {
			#ifdef RGFW_DEBUG
				fprintf(stderr, "Failed to load Wayland display\n");
			#endif
			return NULL;
		}
		
		struct wl_registry *registry = wl_display_get_registry(win->src.display);
		wl_registry_add_listener(registry, &registry_listener, NULL);
			
		wl_display_dispatch(win->src.display);
		wl_display_roundtrip(win->src.display);

		if (RGFW_compositor == NULL) {
			#ifdef RGFW_DEBUG
				fprintf(stderr, "Can't find compositor.\n");
			#endif
			
			return NULL;
		}
		
		if (RGFW_wl_cursor_theme == NULL) {
			RGFW_wl_cursor_theme = wl_cursor_theme_load(NULL, 24, shm);
			RGFW_cursor_surface = wl_compositor_create_surface(RGFW_compositor); 
			
			struct wl_cursor* cursor = wl_cursor_theme_get_cursor(RGFW_wl_cursor_theme, "left_ptr");
			RGFW_cursor_image = cursor->images[0];
			struct wl_buffer* cursor_buffer	= wl_cursor_image_get_buffer(RGFW_cursor_image);

			wl_surface_attach(RGFW_cursor_surface, cursor_buffer, 0, 0);
			wl_surface_commit(RGFW_cursor_surface); 
		}

		if (RGFW_root == NULL)
			xdg_wm_base_add_listener(xdg_wm_base, &xdg_wm_base_listener, NULL);
		
		xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);

		win->src.surface = wl_compositor_create_surface(RGFW_compositor);
		wl_surface_set_user_data(win->src.surface, win);

		win->src.xdg_surface = xdg_wm_base_get_xdg_surface(xdg_wm_base, win->src.surface);
		xdg_surface_add_listener(win->src.xdg_surface, &xdg_surface_listener, NULL);
	
		xdg_wm_base_set_user_data(xdg_wm_base, win);

		win->src.xdg_toplevel = xdg_surface_get_toplevel(win->src.xdg_surface);
		xdg_toplevel_set_user_data(win->src.xdg_toplevel, win);
		xdg_toplevel_set_title(win->src.xdg_toplevel, name);
		xdg_toplevel_add_listener(win->src.xdg_toplevel, &xdg_toplevel_listener, NULL);

		xdg_surface_set_window_geometry(win->src.xdg_surface, 0, 0, win->r.w, win->r.h);
		
		if (!(args & RGFW_NO_BORDER)) {
			win->src.decoration = zxdg_decoration_manager_v1_get_toplevel_decoration(
						decoration_manager, win->src.xdg_toplevel);
		}


		if (args & RGFW_OPENGL_SOFTWARE)
			setenv("LIBGL_ALWAYS_SOFTWARE", "1", 1);

		wl_display_roundtrip(win->src.display);

		wl_surface_commit(win->src.surface);
		
		/* wait for the surface to be configured */
		while (wl_display_dispatch(win->src.display) != -1 && !RGFW_wl_configured) { }
		
		
		#ifdef RGFW_OPENGL
			if ((args & RGFW_NO_INIT_API) == 0) {
				win->src.window = wl_egl_window_create(win->src.surface, win->r.w, win->r.h);
				RGFW_createOpenGLContext(win);
			}
		#endif	

		RGFW_init_buffer(win);

		struct wl_callback* callback = wl_surface_frame(win->src.surface);
   		wl_callback_add_listener(callback, &wl_surface_frame_listener, win);	
		wl_surface_commit(win->src.surface);

		if (args & RGFW_HIDE_MOUSE) {
			RGFW_window_showMouse(win, 0);
		}
		
		if (RGFW_root == NULL) {
			RGFW_root = win;
		}
		
		win->src.eventIndex = 0;
		win->src.eventLen = 0;
		
		return win;
	}

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		if (win->_winArgs & RGFW_WINDOW_HIDE)
			return NULL;

		if (win->src.eventIndex == 0) {
			if (wl_display_roundtrip(win->src.display) == -1) {
				return NULL;
			}
			RGFW_resetKey();
		}

		#ifdef __linux__
			RGFW_Event* event = RGFW_linux_updateJoystick(win);
			if (event != NULL)
				return event;
		#endif
		
		if (win->src.eventLen == 0) {
				return NULL;
		}

		RGFW_Event ev = RGFW_eventPipe_pop(win);
		
		if (ev.type ==  0 || win->event.type == RGFW_quit) {
			return NULL;
		}
        
		ev.frameTime = win->event.frameTime;
        ev.frameTime2 = win->event.frameTime2;
        ev.inFocus = win->event.inFocus;
        win->event = ev;
		
		return &win->event;
	}


	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		RGFW_UNUSED(win); RGFW_UNUSED(a);

		/* TODO wayland */
	}

	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		RGFW_UNUSED(win); RGFW_UNUSED(v);

		/* TODO wayland */
	}

	void RGFW_window_setIcon(RGFW_window* win, u8* src, RGFW_area a, i32 channels) {
		RGFW_UNUSED(win); RGFW_UNUSED(src); RGFW_UNUSED(a); RGFW_UNUSED(channels)
		/* TODO wayland */
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) {
		RGFW_UNUSED(win); RGFW_UNUSED(v);

		/* TODO wayland */
	}

	void RGFW_window_showMouse(RGFW_window* win, i8 show) {
		RGFW_UNUSED(win);

		if (show) {

		}
		else {
			
		}

		/* TODO wayland */
	}

	b8 RGFW_window_isMaximized(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	b8 RGFW_window_isMinimized(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	b8 RGFW_window_isHidden(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	b8 RGFW_window_isFullscreen(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return RGFW_POINT(0, 0);
	}
			
	RGFW_point RGFW_getGlobalMousePoint(void) {
		/* TODO wayland */
		return RGFW_POINT(0, 0);
	}
			
	void RGFW_window_show(RGFW_window* win) {
		//wl_surface_attach(win->src.surface, win->rc., 0, 0);
        wl_surface_commit(win->src.surface);
		
		if (win->_winArgs & RGFW_WINDOW_HIDE)
			win->_winArgs ^= RGFW_WINDOW_HIDE;
	}
		
	void RGFW_window_hide(RGFW_window* win) {
		wl_surface_attach(win->src.surface, NULL, 0, 0);
        wl_surface_commit(win->src.surface);
		win->_winArgs |= RGFW_WINDOW_HIDE;
	}
		
	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_UNUSED(win);
	
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_NORMAL);
	}
		
	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
		RGFW_UNUSED(win);
		
		static const char* iconStrings[] = { "left_ptr", "left_ptr", "text", "cross", "pointer", "e-resize", "n-resize", "nw-resize", "ne-resize", "all-resize", "not-allowed" };

		struct wl_cursor* cursor = wl_cursor_theme_get_cursor(RGFW_wl_cursor_theme, iconStrings[mouse]);
		RGFW_cursor_image = cursor->images[0];
		struct wl_buffer* cursor_buffer	= wl_cursor_image_get_buffer(RGFW_cursor_image);

		wl_surface_attach(RGFW_cursor_surface, cursor_buffer, 0, 0);
		wl_surface_commit(RGFW_cursor_surface); 
	}
		
	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		RGFW_UNUSED(win); RGFW_UNUSED(image); RGFW_UNUSED(a); RGFW_UNUSED(channels)
		//struct wl_cursor* cursor = wl_cursor_theme_get_cursor(RGFW_wl_cursor_theme, iconStrings[mouse]);
		//RGFW_cursor_image = image;
		struct wl_buffer* cursor_buffer	= wl_cursor_image_get_buffer(RGFW_cursor_image);

		wl_surface_attach(RGFW_cursor_surface, cursor_buffer, 0, 0);
		wl_surface_commit(RGFW_cursor_surface); 
	}
		
	void RGFW_window_setName(RGFW_window* win, char* name) {
		xdg_toplevel_set_title(win->src.xdg_toplevel, name);
	}
		
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		RGFW_UNUSED(win); RGFW_UNUSED(passthrough);

	/* TODO wayland */
	}
		
	void RGFW_window_setBorder(RGFW_window* win, b8 border) {
		RGFW_UNUSED(win); RGFW_UNUSED(border);

	/* TODO wayland */
	}
		
	void RGFW_window_restore(RGFW_window* win) {
		RGFW_UNUSED(win);

	/* TODO wayland */
	}
		
	void RGFW_window_minimize(RGFW_window* win) {
		RGFW_UNUSED(win);

	/* TODO wayland */
	}
		
	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		RGFW_UNUSED(win); RGFW_UNUSED(a);

	/* TODO wayland */
	}
		
	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		RGFW_UNUSED(win); RGFW_UNUSED(a);

	/* TODO wayland */
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		RGFW_monitor m = {};
		RGFW_UNUSED(win);
		RGFW_UNUSED(m);
		/* TODO wayland */

		return m;
	}


	#ifndef RGFW_EGL
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) { RGFW_UNUSED(win); RGFW_UNUSED(swapInterval); }
	#endif

	void RGFW_window_swapBuffers(RGFW_window* win) {
		assert(win != NULL);

		/* clear the window*/
		#ifdef RGFW_BUFFER	
			wl_surface_frame_done(win, NULL, 0);
			if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) 
		#endif
		{
		#ifdef RGFW_OPENGL
			eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
		#endif
		}
		
		wl_display_flush(win->src.display);
	}

	void RGFW_window_close(RGFW_window* win) {
		#ifdef RGFW_EGL
			RGFW_closeEGL(win);
		#endif

		if (RGFW_root == win) {
			RGFW_root = NULL;
		}

		xdg_toplevel_destroy(win->src.xdg_toplevel);
		xdg_surface_destroy(win->src.xdg_surface);
		wl_surface_destroy(win->src.surface);

		#ifdef RGFW_BUFFER
		wl_buffer_destroy(win->src.wl_buffer);
		#endif
		
		wl_display_disconnect(win->src.display);
		RGFW_FREE(win);
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
		/* TODO wayland */

		return (RGFW_monitor){};
	}
						
	RGFW_monitor* RGFW_getMonitors(void) {
		/* TODO wayland */

		return NULL;
	}

	void RGFW_writeClipboard(const char* text, u32 textLen) {
		RGFW_UNUSED(text); RGFW_UNUSED(textLen);

		/* TODO wayland */
	}

	char* RGFW_readClipboard(size_t* size) {
		RGFW_UNUSED(size);

		/* TODO wayland */

		return NULL;
	}
#endif /* RGFW_WAYLAND */

/* 
	End of Wayland defines
*/


/*

	Start of Windows defines


*/

#ifdef RGFW_WINDOWS
	#define WIN32_LEAN_AND_MEAN
	#define OEMRESOURCE
	#include <windows.h>
	
	#include <processthreadsapi.h>
	#include <wchar.h>
	#include <locale.h>
	#include <windowsx.h>
	#include <shellapi.h>
	#include <shellscalingapi.h>

	#include <winuser.h>

	__declspec(dllimport) int __stdcall WideCharToMultiByte( UINT CodePage, DWORD dwFlags, const WCHAR* lpWideCharStr, int cchWideChar,  LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
	
	#ifndef RGFW_NO_XINPUT
	typedef DWORD (WINAPI * PFN_XInputGetState)(DWORD,XINPUT_STATE*);
	PFN_XInputGetState XInputGetStateSRC = NULL;
	#define XInputGetState XInputGetStateSRC

	typedef DWORD (WINAPI * PFN_XInputGetKeystroke)(DWORD, DWORD, PXINPUT_KEYSTROKE);
	PFN_XInputGetKeystroke XInputGetKeystrokeSRC = NULL;
	#define XInputGetKeystroke XInputGetKeystrokeSRC

	static HMODULE RGFW_XInput_dll = NULL;
	#endif

	u32 RGFW_mouseIconSrc[] = {OCR_NORMAL, OCR_NORMAL, OCR_IBEAM, OCR_CROSS, OCR_HAND, OCR_SIZEWE, OCR_SIZENS, OCR_SIZENWSE, OCR_SIZENESW, OCR_SIZEALL, OCR_NO};

	char* createUTF8FromWideStringWin32(const WCHAR* source);

#define GL_FRONT				0x0404
#define GL_BACK					0x0405
#define GL_LEFT					0x0406
#define GL_RIGHT				0x0407

#if defined(RGFW_OSMESA) && defined(RGFW_LINK_OSMESA)

	typedef void (GLAPIENTRY* PFN_OSMesaDestroyContext)(OSMesaContext);
	typedef i32(GLAPIENTRY* PFN_OSMesaMakeCurrent)(OSMesaContext, void*, int, int, int);
	typedef OSMesaContext(GLAPIENTRY* PFN_OSMesaCreateContext)(GLenum, OSMesaContext);

	PFN_OSMesaMakeCurrent OSMesaMakeCurrentSource;
	PFN_OSMesaCreateContext OSMesaCreateContextSource;
	PFN_OSMesaDestroyContext OSMesaDestroyContextSource;

#define OSMesaCreateContext OSMesaCreateContextSource
#define OSMesaMakeCurrent OSMesaMakeCurrentSource
#define OSMesaDestroyContext OSMesaDestroyContextSource
#endif

	typedef int (*PFN_wglGetSwapIntervalEXT)(void);
	PFN_wglGetSwapIntervalEXT wglGetSwapIntervalEXTSrc = NULL;
#define wglGetSwapIntervalEXT wglGetSwapIntervalEXTSrc


	void* RGFWjoystickApi = NULL;

	/* these two wgl functions need to be preloaded */
	typedef HGLRC (WINAPI *PFNWGLCREATECONTEXTATTRIBSARBPROC)(HDC hdc, HGLRC hglrc, const int *attribList);
	PFNWGLCREATECONTEXTATTRIBSARBPROC wglCreateContextAttribsARB = NULL;

	/* defines for creating ARB attributes */
#define WGL_NUMBER_PIXEL_FORMATS_ARB 0x2000
#define WGL_CONTEXT_MAJOR_VERSION_ARB             0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB             0x2092
#define WGL_DRAW_TO_WINDOW_ARB                    0x2001
#define WGL_ACCELERATION_ARB                      0x2003
#define WGL_NO_ACCELERATION_ARB 0x2025
#define WGL_DOUBLE_BUFFER_ARB                     0x2011
#define WGL_COLOR_BITS_ARB                        0x2014
#define WGL_RED_BITS_ARB 0x2015
#define WGL_RED_SHIFT_ARB 0x2016
#define WGL_GREEN_BITS_ARB 0x2017
#define WGL_GREEN_SHIFT_ARB 0x2018
#define WGL_BLUE_BITS_ARB 0x2019
#define WGL_BLUE_SHIFT_ARB 0x201a
#define WGL_ALPHA_BITS_ARB 0x201b
#define WGL_ALPHA_SHIFT_ARB 0x201c
#define WGL_ACCUM_BITS_ARB 0x201d
#define WGL_ACCUM_RED_BITS_ARB 0x201e
#define WGL_ACCUM_GREEN_BITS_ARB 0x201f
#define WGL_ACCUM_BLUE_BITS_ARB 0x2020
#define WGL_ACCUM_ALPHA_BITS_ARB 0x2021
#define WGL_DEPTH_BITS_ARB 0x2022
#define WGL_AUX_BUFFERS_ARB 0x2024
#define WGL_STEREO_ARB 0x2012
#define WGL_DEPTH_BITS_ARB                        0x2022
#define WGL_STENCIL_BITS_ARB 					  0x2023
#define WGL_FULL_ACCELERATION_ARB                 0x2027
#define WGL_CONTEXT_FLAGS_ARB                     0x2094
#define WGL_CONTEXT_PROFILE_MASK_ARB              0x9126
#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
#define WGL_SAMPLE_BUFFERS_ARB               0x2041
#define WGL_SAMPLES_ARB 0x2042
#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB 0x20a9

#ifndef RGFW_EGL
static HMODULE wglinstance = NULL;
#endif

#ifdef RGFW_WGL_LOAD
	typedef HGLRC(WINAPI* PFN_wglCreateContext)(HDC);
	typedef BOOL(WINAPI* PFN_wglDeleteContext)(HGLRC);
	typedef PROC(WINAPI* PFN_wglGetProcAddress)(LPCSTR);
	typedef BOOL(WINAPI* PFN_wglMakeCurrent)(HDC, HGLRC);
	typedef HDC(WINAPI* PFN_wglGetCurrentDC)();
	typedef HGLRC(WINAPI* PFN_wglGetCurrentContext)();

	PFN_wglCreateContext wglCreateContextSRC;
	PFN_wglDeleteContext wglDeleteContextSRC;
	PFN_wglGetProcAddress wglGetProcAddressSRC;
	PFN_wglMakeCurrent wglMakeCurrentSRC;
	PFN_wglGetCurrentDC wglGetCurrentDCSRC;
	PFN_wglGetCurrentContext wglGetCurrentContextSRC;

	#define wglCreateContext wglCreateContextSRC
	#define wglDeleteContext wglDeleteContextSRC
	#define wglGetProcAddress wglGetProcAddressSRC
	#define wglMakeCurrent wglMakeCurrentSRC

	#define wglGetCurrentDC wglGetCurrentDCSRC
	#define wglGetCurrentContext wglGetCurrentContextSRC
#endif

#ifdef RGFW_OPENGL
	void* RGFW_getProcAddress(const char* procname) { 
		void* proc = (void*) wglGetProcAddress(procname);
		if (proc)
			return proc;

		return (void*) GetProcAddress(wglinstance, procname); 
	}

	typedef HRESULT (APIENTRY* PFNWGLCHOOSEPIXELFORMATARBPROC)(HDC hdc, const int* piAttribIList, const FLOAT* pfAttribFList, UINT nMaxFormats, int* piFormats, UINT* nNumFormats);
	static PFNWGLCHOOSEPIXELFORMATARBPROC wglChoosePixelFormatARB = NULL;
#endif

	RGFW_window RGFW_eventWindow;

	LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
		switch (message) {
		case WM_MOVE:
			RGFW_eventWindow.r.x = LOWORD(lParam);
			RGFW_eventWindow.r.y = HIWORD(lParam);
			RGFW_eventWindow.src.window = hWnd;
			return DefWindowProcA(hWnd, message, wParam, lParam);
		case WM_SIZE:
			RGFW_eventWindow.r.w = LOWORD(lParam);
			RGFW_eventWindow.r.h = HIWORD(lParam);
			RGFW_eventWindow.src.window = hWnd;
			return DefWindowProcA(hWnd, message, wParam, lParam); // Call DefWindowProc after handling
		default:
			return DefWindowProcA(hWnd, message, wParam, lParam);
		}
	}
	
	#ifndef RGFW_NO_DPI
	static HMODULE RGFW_Shcore_dll = NULL;
	typedef HRESULT (WINAPI * PFN_GetDpiForMonitor)(HMONITOR,MONITOR_DPI_TYPE,UINT*,UINT*);
	PFN_GetDpiForMonitor GetDpiForMonitorSRC = NULL;
	#define GetDpiForMonitor GetDpiForMonitorSRC
	#endif

	__declspec(dllimport) u32 __stdcall timeBeginPeriod(u32 uPeriod);
	
	#ifndef RGFW_NO_XINPUT
	void RGFW_loadXInput(void) {
		u32 i;
		static const char* names[] = { 
			"xinput1_4.dll",
			"xinput1_3.dll",
			"xinput9_1_0.dll",
			"xinput1_2.dll",
			"xinput1_1.dll"
		};

		for (i = 0; i < sizeof(names) / sizeof(const char*);  i++) {
			RGFW_XInput_dll = LoadLibraryA(names[i]);

			if (RGFW_XInput_dll) {
				XInputGetStateSRC = (PFN_XInputGetState)(void*)GetProcAddress(RGFW_XInput_dll, "XInputGetState");
			
				if (XInputGetStateSRC == NULL)
					printf("Failed to load XInputGetState");
			}
		}
	}
	#endif

	RGFWDEF void RGFW_init_buffer(RGFW_window* win);
	void RGFW_init_buffer(RGFW_window* win) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
	if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
		RGFW_bufferSize = RGFW_getScreenSize();
	
	BITMAPV5HEADER bi = { 0 };
	ZeroMemory(&bi, sizeof(bi));
	bi.bV5Size = sizeof(bi);
	bi.bV5Width = RGFW_bufferSize.w;
	bi.bV5Height = -((LONG) RGFW_bufferSize.h);
	bi.bV5Planes = 1;
	bi.bV5BitCount = 32;
	bi.bV5Compression = BI_BITFIELDS;
	bi.bV5BlueMask = 0x00ff0000;
	bi.bV5GreenMask = 0x0000ff00;
	bi.bV5RedMask = 0x000000ff;
	bi.bV5AlphaMask = 0xff000000;

	win->src.bitmap = CreateDIBSection(win->src.hdc,
		(BITMAPINFO*) &bi,
		DIB_RGB_COLORS,
		(void**) &win->buffer,
		NULL,
		(DWORD) 0);
	
	win->src.hdcMem = CreateCompatibleDC(win->src.hdc);

	#if defined(RGFW_OSMESA)
	win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
	OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
	#endif
#else
RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
#endif
	}

	void RGFW_window_setDND(RGFW_window* win, b8 allow) {
		DragAcceptFiles(win->src.window, allow);
	}

	void RGFW_releaseCursor(RGFW_window* win) {
		RGFW_UNUSED(win);
		ClipCursor(NULL);
    	const RAWINPUTDEVICE id = { 0x01, 0x02, RIDEV_REMOVE, NULL };
    	RegisterRawInputDevices(&id, 1, sizeof(id));	
	}

	void RGFW_captureCursor(RGFW_window* win, RGFW_rect rect) {
		RGFW_UNUSED(win)
		
		RECT clipRect;
		GetClientRect(win->src.window, &clipRect);
		ClientToScreen(win->src.window, (POINT*) &clipRect.left);
		ClientToScreen(win->src.window, (POINT*) &clipRect.right);
		ClipCursor(&clipRect);

	    const RAWINPUTDEVICE id = { 0x01, 0x02, 0, win->src.window };
		RegisterRawInputDevices(&id, 1, sizeof(id));
	}

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
		#ifndef RGFW_NO_XINPUT
		if (RGFW_XInput_dll == NULL)
			RGFW_loadXInput();
		#endif

		#ifndef RGFW_NO_DPI
		if (RGFW_Shcore_dll == NULL) {
			RGFW_Shcore_dll = LoadLibraryA("shcore.dll");
			GetDpiForMonitorSRC = (PFN_GetDpiForMonitor)(void*)GetProcAddress(RGFW_Shcore_dll, "GetDpiForMonitor");
		}
		#endif

		if (wglinstance == NULL) {
			wglinstance = LoadLibraryA("opengl32.dll");
#ifdef RGFW_WGL_LOAD
			wglCreateContextSRC = (PFN_wglCreateContext) GetProcAddress(wglinstance, "wglCreateContext");
			wglDeleteContextSRC = (PFN_wglDeleteContext) GetProcAddress(wglinstance, "wglDeleteContext");
			wglGetProcAddressSRC = (PFN_wglGetProcAddress) GetProcAddress(wglinstance, "wglGetProcAddress");
			wglMakeCurrentSRC = (PFN_wglMakeCurrent) GetProcAddress(wglinstance, "wglMakeCurrent");
			wglGetCurrentDCSRC = (PFN_wglGetCurrentDC) GetProcAddress(wglinstance, "wglGetCurrentDC");
			wglGetCurrentContextSRC = (PFN_wglGetCurrentContext) GetProcAddress(wglinstance, "wglGetCurrentContext");
#endif
		}
	
		if (name[0] == 0) name = (char*) " ";

		RGFW_eventWindow.r = RGFW_RECT(-1, -1, -1, -1);
		RGFW_eventWindow.src.window = NULL;

		RGFW_window* win = RGFW_window_basic_init(rect, args);

		win->src.maxSize = RGFW_AREA(0, 0);
		win->src.minSize = RGFW_AREA(0, 0);


		HINSTANCE inh = GetModuleHandleA(NULL);

		#ifndef __cplusplus
		WNDCLASSA Class = { 0 }; /*!< Setup the Window class. */
		#else
		WNDCLASSA Class = { };
		#endif

		if (RGFW_className == NULL)
			RGFW_className = (char*)name;

		Class.lpszClassName = RGFW_className;
		Class.hInstance = inh;
		Class.hCursor = LoadCursor(NULL, IDC_ARROW);
		Class.lpfnWndProc = WndProc;

		RegisterClassA(&Class);

		DWORD window_style = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;

		RECT windowRect, clientRect;

		if (!(args & RGFW_NO_BORDER)) {
			window_style |= WS_CAPTION | WS_SYSMENU | WS_BORDER | WS_MINIMIZEBOX;

			if (!(args & RGFW_NO_RESIZE))
				window_style |= WS_SIZEBOX | WS_MAXIMIZEBOX | WS_THICKFRAME;
		} else
			window_style |= WS_POPUP | WS_VISIBLE | WS_SYSMENU | WS_MINIMIZEBOX;

		HWND dummyWin = CreateWindowA(Class.lpszClassName, name, window_style, win->r.x, win->r.y, win->r.w, win->r.h, 0, 0, inh, 0);

		GetWindowRect(dummyWin, &windowRect);
		GetClientRect(dummyWin, &clientRect);

		win->src.hOffset = (windowRect.bottom - windowRect.top) - (clientRect.bottom - clientRect.top);
		win->src.window = CreateWindowA(Class.lpszClassName, name, window_style, win->r.x, win->r.y, win->r.w, win->r.h + win->src.hOffset, 0, 0, inh, 0);

		if (args & RGFW_ALLOW_DND) {
			win->_winArgs |= RGFW_ALLOW_DND;
			RGFW_window_setDND(win, 1);
		}
		win->src.hdc = GetDC(win->src.window);

		if ((args & RGFW_NO_INIT_API) == 0) {
#ifdef RGFW_DIRECTX
		assert(FAILED(CreateDXGIFactory(&__uuidof(IDXGIFactory), (void**) &RGFW_dxInfo.pFactory)) == 0);

		if (FAILED(RGFW_dxInfo.pFactory->lpVtbl->EnumAdapters(RGFW_dxInfo.pFactory, 0, &RGFW_dxInfo.pAdapter))) {
			fprintf(stderr, "Failed to enumerate DXGI adapters\n");
			RGFW_dxInfo.pFactory->lpVtbl->Release(RGFW_dxInfo.pFactory);
			return NULL;
		}

		D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_11_0 };

		if (FAILED(D3D11CreateDevice(RGFW_dxInfo.pAdapter, D3D_DRIVER_TYPE_UNKNOWN, NULL, 0, featureLevels, 1, D3D11_SDK_VERSION, &RGFW_dxInfo.pDevice, NULL, &RGFW_dxInfo.pDeviceContext))) {
			fprintf(stderr, "Failed to create Direct3D device\n");
			RGFW_dxInfo.pAdapter->lpVtbl->Release(RGFW_dxInfo.pAdapter);
			RGFW_dxInfo.pFactory->lpVtbl->Release(RGFW_dxInfo.pFactory);
			return NULL;
		}

		DXGI_SWAP_CHAIN_DESC swapChainDesc = { 0 };
		swapChainDesc.BufferCount = 1;
		swapChainDesc.BufferDesc.Width = win->r.w;
		swapChainDesc.BufferDesc.Height = win->r.h;
		swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		swapChainDesc.OutputWindow = win->src.window;
		swapChainDesc.SampleDesc.Count = 1;
		swapChainDesc.SampleDesc.Quality = 0;
		swapChainDesc.Windowed = TRUE;
		RGFW_dxInfo.pFactory->lpVtbl->CreateSwapChain(RGFW_dxInfo.pFactory, (IUnknown*) RGFW_dxInfo.pDevice, &swapChainDesc, &win->src.swapchain);

		ID3D11Texture2D* pBackBuffer;
		win->src.swapchain->lpVtbl->GetBuffer(win->src.swapchain, 0, &__uuidof(ID3D11Texture2D), (LPVOID*) &pBackBuffer);
		RGFW_dxInfo.pDevice->lpVtbl->CreateRenderTargetView(RGFW_dxInfo.pDevice, (ID3D11Resource*) pBackBuffer, NULL, &win->src.renderTargetView);
		pBackBuffer->lpVtbl->Release(pBackBuffer);

		D3D11_TEXTURE2D_DESC depthStencilDesc = { 0 };
		depthStencilDesc.Width = win->r.w;
		depthStencilDesc.Height = win->r.h;
		depthStencilDesc.MipLevels = 1;
		depthStencilDesc.ArraySize = 1;
		depthStencilDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
		depthStencilDesc.SampleDesc.Count = 1;
		depthStencilDesc.SampleDesc.Quality = 0;
		depthStencilDesc.Usage = D3D11_USAGE_DEFAULT;
		depthStencilDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;

		ID3D11Texture2D* pDepthStencilTexture = NULL;
		RGFW_dxInfo.pDevice->lpVtbl->CreateTexture2D(RGFW_dxInfo.pDevice, &depthStencilDesc, NULL, &pDepthStencilTexture);

		D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc = { 0 };
		depthStencilViewDesc.Format = depthStencilDesc.Format;
		depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
		depthStencilViewDesc.Texture2D.MipSlice = 0;

		RGFW_dxInfo.pDevice->lpVtbl->CreateDepthStencilView(RGFW_dxInfo.pDevice, (ID3D11Resource*) pDepthStencilTexture, &depthStencilViewDesc, &win->src.pDepthStencilView);

		pDepthStencilTexture->lpVtbl->Release(pDepthStencilTexture);

		RGFW_dxInfo.pDeviceContext->lpVtbl->OMSetRenderTargets(RGFW_dxInfo.pDeviceContext, 1, &win->src.renderTargetView, win->src.pDepthStencilView);
#endif

#ifdef RGFW_OPENGL 
		HDC dummy_dc = GetDC(dummyWin);
        
        u32 pfd_flags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL; 
        
        //if (RGFW_DOUBLE_BUFFER)    
             pfd_flags |= PFD_DOUBLEBUFFER;
		
        PIXELFORMATDESCRIPTOR pfd = {
			sizeof(pfd),
			1, /* version */
			pfd_flags,
		    PFD_TYPE_RGBA, /* ipixel type */
			24, /* color bits */
			0, 0, 0, 0, 0, 0,
			8, /* alpha bits */
			0, 0, 0, 0, 0, 0,
			32, /* depth bits */
			8, /* stencil bits */ 
			0,
			PFD_MAIN_PLANE, /* Layer type */
			0, 0, 0, 0
		};

		int pixel_format = ChoosePixelFormat(dummy_dc, &pfd);
		SetPixelFormat(dummy_dc, pixel_format, &pfd);

		HGLRC dummy_context = wglCreateContext(dummy_dc);
		wglMakeCurrent(dummy_dc, dummy_context);

		if (wglChoosePixelFormatARB == NULL) {
			wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC) (void*) wglGetProcAddress("wglCreateContextAttribsARB");
			wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC) (void*)wglGetProcAddress("wglChoosePixelFormatARB");
		}

		wglMakeCurrent(dummy_dc, 0);
		wglDeleteContext(dummy_context);
		ReleaseDC(dummyWin, dummy_dc);
		
		/* try to create the pixel format we want for opengl and then try to create an opengl context for the specified version */ 
		if (wglCreateContextAttribsARB != NULL) {
			PIXELFORMATDESCRIPTOR pfd = {sizeof(pfd), 1, pfd_flags, PFD_TYPE_RGBA, 32, 8, PFD_MAIN_PLANE, 24, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

			if (args & RGFW_OPENGL_SOFTWARE)
				pfd.dwFlags |= PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED;

			if (wglChoosePixelFormatARB != NULL) {
				i32* pixel_format_attribs = (i32*)RGFW_initFormatAttribs(args & RGFW_OPENGL_SOFTWARE);

				int pixel_format;
				UINT num_formats;
				wglChoosePixelFormatARB(win->src.hdc, pixel_format_attribs, 0, 1, &pixel_format, &num_formats);
				if (!num_formats) {
					printf("Failed to create a pixel format for WGL.\n");
				}

				DescribePixelFormat(win->src.hdc, pixel_format, sizeof(pfd), &pfd);
				if (!SetPixelFormat(win->src.hdc, pixel_format, &pfd)) {
					printf("Failed to set the WGL pixel format.\n");
				}
			}
			
			/* create opengl/WGL context for the specified version */ 
			u32 index = 0;
			i32 attribs[40];

			if (RGFW_profile == RGFW_GL_CORE) {
				SET_ATTRIB(WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB);
			}
			else {
				SET_ATTRIB(WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB);
			}
			
			if (RGFW_majorVersion || RGFW_minorVersion) {
				SET_ATTRIB(WGL_CONTEXT_MAJOR_VERSION_ARB, RGFW_majorVersion);
				SET_ATTRIB(WGL_CONTEXT_MINOR_VERSION_ARB, RGFW_minorVersion);
			}

			SET_ATTRIB(0, 0);

			win->src.ctx = (HGLRC)wglCreateContextAttribsARB(win->src.hdc, NULL, attribs);
		} else { /* fall back to a default context (probably opengl 2 or something) */
			fprintf(stderr, "Failed to create an accelerated OpenGL Context\n");

			int pixel_format = ChoosePixelFormat(win->src.hdc, &pfd);
			SetPixelFormat(win->src.hdc, pixel_format, &pfd);

			win->src.ctx = wglCreateContext(win->src.hdc);
		}
		
		wglMakeCurrent(win->src.hdc, win->src.ctx);
#endif
	}

#ifdef RGFW_OSMESA
#ifdef RGFW_LINK_OSM ESA
		OSMesaMakeCurrentSource = (PFN_OSMesaMakeCurrent) GetProcAddress(win->src.hdc, "OSMesaMakeCurrent");
		OSMesaCreateContextSource = (PFN_OSMesaCreateContext) GetProcAddress(win->src.hdc, "OSMesaCreateContext");
		OSMesaDestroyContextSource = (PFN_OSMesaDestroyContext) GetProcAddress(win->src.hdc, "OSMesaDestroyContext");
#endif
#endif

#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0) {
			ReleaseDC(win->src.window, win->src.hdc);
			win->src.hdc = GetDC(win->src.window);
			wglMakeCurrent(win->src.hdc, win->src.ctx);
		}
#endif

		DestroyWindow(dummyWin);
		RGFW_init_buffer(win);


		#ifndef RGFW_NO_MONITOR
		if (args & RGFW_SCALE_TO_MONITOR)
			RGFW_window_scaleToMonitor(win);
		#endif

#ifdef RGFW_EGL
		if ((args & RGFW_NO_INIT_API) == 0)
			RGFW_createOpenGLContext(win);
#endif

		if (args & RGFW_HIDE_MOUSE)
			RGFW_window_showMouse(win, 0);

		if (args & RGFW_TRANSPARENT_WINDOW) {
			SetWindowLong(win->src.window, GWL_EXSTYLE, GetWindowLong(win->src.window, GWL_EXSTYLE) | WS_EX_LAYERED);
			SetLayeredWindowAttributes(win->src.window, RGB(255, 255, 255), RGFW_ALPHA, LWA_ALPHA);
		}

		ShowWindow(win->src.window, SW_SHOWNORMAL);
		
		if (RGFW_root == NULL)
			RGFW_root = win;
		
		#ifdef RGFW_OPENGL
		else 
			wglShareLists(RGFW_root->src.ctx, win->src.ctx);
		#endif

		return win;
	}

	void RGFW_window_setBorder(RGFW_window* win, u8 border) {
		DWORD style = GetWindowLong(win->src.window, GWL_STYLE);

		if (border == 0) {
			SetWindowLong(win->src.window, GWL_STYLE, style & ~WS_OVERLAPPEDWINDOW);
			SetWindowPos(
				win->src.window, HWND_TOP, 0, 0, 0, 0,
				SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE
			);
		}
		else {
			SetWindowLong(win->src.window, GWL_STYLE, style | WS_OVERLAPPEDWINDOW);
			SetWindowPos(
				win->src.window, HWND_TOP, 0, 0, 0, 0,
				SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE
			);
		}
	}


	RGFW_area RGFW_getScreenSize(void) {
		return RGFW_AREA(GetDeviceCaps(GetDC(NULL), HORZRES), GetDeviceCaps(GetDC(NULL), VERTRES));
	}

	RGFW_point RGFW_getGlobalMousePoint(void) {
		POINT p;
		GetCursorPos(&p);

		return RGFW_POINT(p.x, p.y);
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		POINT p;
		GetCursorPos(&p);
		ScreenToClient(win->src.window, &p);

		return RGFW_POINT(p.x, p.y);
	}

	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);
		win->src.minSize = a;
	}

	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);
		win->src.maxSize = a;
	}


	void RGFW_window_minimize(RGFW_window* win) {
		assert(win != NULL);

		ShowWindow(win->src.window, SW_MINIMIZE);
	}

	void RGFW_window_restore(RGFW_window* win) {
		assert(win != NULL);

		ShowWindow(win->src.window, SW_RESTORE);
	}


	u8 RGFW_xinput2RGFW[] = {
		RGFW_JS_A, /* or PS X button */
		RGFW_JS_B, /* or PS circle button */
		RGFW_JS_X, /* or PS square button */
		RGFW_JS_Y, /* or PS triangle button */
		RGFW_JS_R1, /* right bumper */
		RGFW_JS_L1, /* left bump */
		RGFW_JS_L2, /* left trigger*/
		RGFW_JS_R2, /* right trigger */
		0, 0, 0, 0, 0, 0, 0, 0,
		RGFW_JS_UP, /* dpad up */
		RGFW_JS_DOWN, /* dpad down*/
		RGFW_JS_LEFT, /* dpad left */
		RGFW_JS_RIGHT, /* dpad right */
		RGFW_JS_START, /* start button */
		RGFW_JS_SELECT/* select button */
	};

	static i32 RGFW_checkXInput(RGFW_window* win, RGFW_Event* e) {
		RGFW_UNUSED(win)
		
		size_t i;
		for (i = 0; i < 4; i++) {
			XINPUT_KEYSTROKE keystroke;

			if (XInputGetKeystroke == NULL)
				return 0;

			DWORD result = XInputGetKeystroke((DWORD)i, 0, &keystroke);

			if ((keystroke.Flags & XINPUT_KEYSTROKE_REPEAT) == 0 && result != ERROR_EMPTY) {
				if (result != ERROR_SUCCESS)
					return 0;

				if (keystroke.VirtualKey > VK_PAD_BACK)
					continue;

				// RGFW_jsButtonPressed + 1 = RGFW_jsButtonReleased
				e->type = RGFW_jsButtonPressed + !(keystroke.Flags & XINPUT_KEYSTROKE_KEYDOWN);
				e->button = RGFW_xinput2RGFW[keystroke.VirtualKey - 0x5800];
				RGFW_jsPressed[i][e->button] = !(keystroke.Flags & XINPUT_KEYSTROKE_KEYDOWN);

				return 1;
			}

			XINPUT_STATE state;
			if (XInputGetState == NULL ||
				XInputGetState((DWORD) i, &state) == ERROR_DEVICE_NOT_CONNECTED
			)
				return 0;
#define INPUT_DEADZONE  ( 0.24f * (float)(0x7FFF) )  // Default to 24% of the +/- 32767 range.   This is a reasonable default value but can be altered if needed.

			if ((state.Gamepad.sThumbLX < INPUT_DEADZONE &&
				state.Gamepad.sThumbLX > -INPUT_DEADZONE) &&
				(state.Gamepad.sThumbLY < INPUT_DEADZONE &&
					state.Gamepad.sThumbLY > -INPUT_DEADZONE))
			{
				state.Gamepad.sThumbLX = 0;
				state.Gamepad.sThumbLY = 0;
			}

			if ((state.Gamepad.sThumbRX < INPUT_DEADZONE &&
				state.Gamepad.sThumbRX > -INPUT_DEADZONE) &&
				(state.Gamepad.sThumbRY < INPUT_DEADZONE &&
					state.Gamepad.sThumbRY > -INPUT_DEADZONE))
			{
				state.Gamepad.sThumbRX = 0;
				state.Gamepad.sThumbRY = 0;
			}

			e->axisesCount = 2;
			RGFW_point axis1 = RGFW_POINT(state.Gamepad.sThumbLX, state.Gamepad.sThumbLY);
			RGFW_point axis2 = RGFW_POINT(state.Gamepad.sThumbRX, state.Gamepad.sThumbRY);

			if (axis1.x != e->axis[0].x || axis1.y != e->axis[0].y || axis2.x != e->axis[1].x || axis2.y != e->axis[1].y) {
				e->type = RGFW_jsAxisMove;

				e->axis[0] = axis1;
				e->axis[1] = axis2;

				return 1;
			}

			e->axis[0] = axis1;
			e->axis[1] = axis2;
		}

		return 0;
	}

	void RGFW_stopCheckEvents(void) { 
		PostMessageW(RGFW_root->src.window, WM_NULL, 0, 0);
	}

	void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
		RGFW_UNUSED(win);

		MsgWaitForMultipleObjects(0, NULL, FALSE, (DWORD) (waitMS * 1e3), QS_ALLINPUT);
	}

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		assert(win != NULL);

		if (win->event.type == RGFW_quit) {
			return NULL;
		}

		MSG msg;

		if (RGFW_eventWindow.src.window == win->src.window) {
			if (RGFW_eventWindow.r.x != -1) {
				win->r.x = RGFW_eventWindow.r.x;
				win->r.y = RGFW_eventWindow.r.y;
				win->event.type = RGFW_windowMoved;
				RGFW_windowMoveCallback(win, win->r);
			}

			if (RGFW_eventWindow.r.w != -1) {
				win->r.w = RGFW_eventWindow.r.w;
				win->r.h = RGFW_eventWindow.r.h;
				win->event.type = RGFW_windowResized;
				RGFW_windowResizeCallback(win, win->r);
			}

			RGFW_eventWindow.src.window = NULL;
			RGFW_eventWindow.r = RGFW_RECT(-1, -1, -1, -1);

			return &win->event;
		}


		static HDROP drop;
		
		if (win->event.type == RGFW_dnd_init) {
			if (win->event.droppedFilesCount) {
				u32 i;
				for (i = 0; i < win->event.droppedFilesCount; i++)
					win->event.droppedFiles[i][0] = '\0';
			}

			win->event.droppedFilesCount = 0;
			win->event.droppedFilesCount = DragQueryFileW(drop, 0xffffffff, NULL, 0);
			//win->event.droppedFiles = (char**)RGFW_CALLOC(win->event.droppedFilesCount, sizeof(char*));

			u32 i;
			for (i = 0; i < win->event.droppedFilesCount; i++) {
				const UINT length = DragQueryFileW(drop, i, NULL, 0);
				WCHAR* buffer = (WCHAR*) RGFW_CALLOC((size_t) length + 1, sizeof(WCHAR));

				DragQueryFileW(drop, i, buffer, length + 1);
				strncpy(win->event.droppedFiles[i], createUTF8FromWideStringWin32(buffer), RGFW_MAX_PATH);
				win->event.droppedFiles[i][RGFW_MAX_PATH - 1] = '\0';
				RGFW_FREE(buffer);
			}

			DragFinish(drop);
			RGFW_dndCallback(win, win->event.droppedFiles, win->event.droppedFilesCount);
			
			win->event.type = RGFW_dnd;
			return &win->event;
		}

		win->event.inFocus = (GetForegroundWindow() == win->src.window);

		if (RGFW_checkXInput(win, &win->event))
			return &win->event;

		static BYTE keyboardState[256];

		if (PeekMessageA(&msg, win->src.window, 0u, 0u, PM_REMOVE)) {
			switch (msg.message) {
			case WM_CLOSE:
			case WM_QUIT:
				RGFW_windowQuitCallback(win);
				win->event.type = RGFW_quit;
				break;

			case WM_ACTIVATE:
				win->event.inFocus = (LOWORD(msg.wParam) == WA_INACTIVE);

				if (win->event.inFocus) {
					win->event.type = RGFW_focusIn;
					RGFW_focusCallback(win, 1);
				}
				else {
					win->event.type = RGFW_focusOut;
					RGFW_focusCallback(win, 0);
				}

				break;
			
			case WM_PAINT:
				win->event.type = RGFW_windowRefresh;
				RGFW_windowRefreshCallback(win);
				break;
			
			case WM_MOUSELEAVE:
				win->event.type = RGFW_mouseLeave;
				win->_winArgs |= RGFW_MOUSE_LEFT;
				RGFW_mouseNotifyCallBack(win, win->event.point, 0);
				break;
			
			case WM_KEYUP: {
				win->event.keyCode = RGFW_apiKeyCodeToRGFW((u32) msg.wParam);
								
				RGFW_keyboard[win->event.keyCode].prev = RGFW_isPressed(win, win->event.keyCode);

				static char keyName[16];
				
				{
					GetKeyNameTextA((LONG) msg.lParam, keyName, 16);

					if ((!(GetKeyState(VK_CAPITAL) & 0x0001) && !(GetKeyState(VK_SHIFT) & 0x8000)) ||
						((GetKeyState(VK_CAPITAL) & 0x0001) && (GetKeyState(VK_SHIFT) & 0x8000))) {
						CharLowerBuffA(keyName, 16);
					}
				}

				RGFW_updateLockState(win, (GetKeyState(VK_CAPITAL) & 0x0001), (GetKeyState(VK_NUMLOCK) & 0x0001));

				strncpy(win->event.keyName, keyName, 16);

				if (RGFW_isPressed(win, RGFW_ShiftL)) {
					ToAscii((UINT) msg.wParam, MapVirtualKey((UINT) msg.wParam, MAPVK_VK_TO_CHAR),
						keyboardState, (LPWORD) win->event.keyName, 0);
				}

				win->event.type = RGFW_keyReleased;
				RGFW_keyboard[win->event.keyCode].current = 0;
				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 0);
				break;
			}
			case WM_KEYDOWN: {
				win->event.keyCode = RGFW_apiKeyCodeToRGFW((u32) msg.wParam);

				RGFW_keyboard[win->event.keyCode].prev = RGFW_isPressed(win, win->event.keyCode);

				static char keyName[16];
				
				{
					GetKeyNameTextA((LONG) msg.lParam, keyName, 16);

					if ((!(GetKeyState(VK_CAPITAL) & 0x0001) && !(GetKeyState(VK_SHIFT) & 0x8000)) ||
						((GetKeyState(VK_CAPITAL) & 0x0001) && (GetKeyState(VK_SHIFT) & 0x8000))) {
						CharLowerBuffA(keyName, 16);
					}
				}
				
				RGFW_updateLockState(win, (GetKeyState(VK_CAPITAL) & 0x0001), (GetKeyState(VK_NUMLOCK) & 0x0001));

				strncpy(win->event.keyName, keyName, 16);

				if (RGFW_isPressed(win, RGFW_ShiftL) & 0x8000) {
					ToAscii((UINT) msg.wParam, MapVirtualKey((UINT) msg.wParam, MAPVK_VK_TO_CHAR),
						keyboardState, (LPWORD) win->event.keyName, 0);
				}

				win->event.type = RGFW_keyPressed;
				win->event.repeat = RGFW_isPressed(win, win->event.keyCode);
				RGFW_keyboard[win->event.keyCode].current = 1;
				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 1);
				break;
			}

			case WM_MOUSEMOVE:
				if ((win->_winArgs & RGFW_HOLD_MOUSE))
					break;

				win->event.type = RGFW_mousePosChanged;

				win->event.point.x = GET_X_LPARAM(msg.lParam);
				win->event.point.y = GET_Y_LPARAM(msg.lParam);
				
				RGFW_mousePosCallback(win, win->event.point);

				if (win->_winArgs & RGFW_MOUSE_LEFT) {
					win->_winArgs ^= RGFW_MOUSE_LEFT;
					win->event.type = RGFW_mouseEnter;
					RGFW_mouseNotifyCallBack(win, win->event.point, 1);
				}

				break;

			case WM_INPUT: {
				if (!(win->_winArgs & RGFW_HOLD_MOUSE))
					break;
				
				unsigned size = sizeof(RAWINPUT);
				static RAWINPUT raw[sizeof(RAWINPUT)];
				GetRawInputData((HRAWINPUT)msg.lParam, RID_INPUT, raw, &size, sizeof(RAWINPUTHEADER));

				if (raw->header.dwType != RIM_TYPEMOUSE || (raw->data.mouse.lLastX == 0 && raw->data.mouse.lLastY == 0) )
					break;
				
				win->event.type = RGFW_mousePosChanged;
				win->event.point.x = raw->data.mouse.lLastX;
				win->event.point.y = raw->data.mouse.lLastY;
				break;
			}

			case WM_LBUTTONDOWN:
				win->event.button = RGFW_mouseLeft;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;
			case WM_RBUTTONDOWN:
				win->event.button = RGFW_mouseRight;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;
			case WM_MBUTTONDOWN:
				win->event.button = RGFW_mouseMiddle;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case WM_MOUSEWHEEL:
				if (msg.wParam > 0)
					win->event.button = RGFW_mouseScrollUp;
				else
					win->event.button = RGFW_mouseScrollDown;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;

				win->event.scroll = (SHORT) HIWORD(msg.wParam) / (double) WHEEL_DELTA;

				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case WM_LBUTTONUP:
			
				win->event.button = RGFW_mouseLeft;
				win->event.type = RGFW_mouseButtonReleased;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;
			case WM_RBUTTONUP:
				win->event.button = RGFW_mouseRight;
				win->event.type = RGFW_mouseButtonReleased;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;
			case WM_MBUTTONUP:
				win->event.button = RGFW_mouseMiddle;
				win->event.type = RGFW_mouseButtonReleased;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

				/*
					much of this event is source from glfw
				*/
			case WM_DROPFILES: {				
				win->event.type = RGFW_dnd_init;

				drop = (HDROP) msg.wParam;
				POINT pt;

				/* Move the mouse to the position of the drop */
				DragQueryPoint(drop, &pt);

				win->event.point.x = pt.x;
				win->event.point.y = pt.y;

				RGFW_dndInitCallback(win, win->event.point);
			}
				break;
			case WM_GETMINMAXINFO:
			{
				if (win->src.maxSize.w == 0 && win->src.maxSize.h == 0)
					break;

				MINMAXINFO* mmi = (MINMAXINFO*) msg.lParam;
				mmi->ptMinTrackSize.x = win->src.minSize.w;
				mmi->ptMinTrackSize.y = win->src.minSize.h;
				mmi->ptMaxTrackSize.x = win->src.maxSize.w;
				mmi->ptMaxTrackSize.y = win->src.maxSize.h;
				return 0;
			}
			default:
				win->event.type = 0;
				break;
			}

			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}

		else
			win->event.type = 0;

		if (!IsWindow(win->src.window)) {
			win->event.type = RGFW_quit;
			RGFW_windowQuitCallback(win);
		}

		if (win->event.type)
			return &win->event;
		else
			return NULL;
	}

	u8 RGFW_window_isFullscreen(RGFW_window* win) {
		assert(win != NULL);

		#ifndef __cplusplus
		WINDOWPLACEMENT placement = { 0 };
		#else
		WINDOWPLACEMENT placement = {  };
		#endif
		GetWindowPlacement(win->src.window, &placement);
		return placement.showCmd == SW_SHOWMAXIMIZED;
	}

	u8 RGFW_window_isHidden(RGFW_window* win) {
		assert(win != NULL);

		return IsWindowVisible(win->src.window) == 0 && !RGFW_window_isMinimized(win);
	}

	u8 RGFW_window_isMinimized(RGFW_window* win) {
		assert(win != NULL);

		#ifndef __cplusplus
		WINDOWPLACEMENT placement = { 0 };
		#else
		WINDOWPLACEMENT placement = {  };
		#endif
		GetWindowPlacement(win->src.window, &placement);
		return placement.showCmd == SW_SHOWMINIMIZED;
	}

	u8 RGFW_window_isMaximized(RGFW_window* win) {
		assert(win != NULL);

		#ifndef __cplusplus
		WINDOWPLACEMENT placement = { 0 };
		#else
		WINDOWPLACEMENT placement = {  };
		#endif
		GetWindowPlacement(win->src.window, &placement);
		return placement.showCmd == SW_SHOWMAXIMIZED;
	}

	typedef struct { int iIndex; HMONITOR hMonitor; } RGFW_mInfo;
	BOOL CALLBACK GetMonitorByHandle(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {
		RGFW_UNUSED(hdcMonitor)
		RGFW_UNUSED(lprcMonitor)

		RGFW_mInfo* info = (RGFW_mInfo*) dwData;
		if (info->hMonitor == hMonitor)
			return FALSE;

		info->iIndex++;
		return TRUE;
	}
	
	#ifndef RGFW_NO_MONITOR
	RGFW_monitor win32CreateMonitor(HMONITOR src) {
		RGFW_monitor monitor;
		MONITORINFO monitorInfo;

		monitorInfo.cbSize = sizeof(MONITORINFO);
		GetMonitorInfoA(src, &monitorInfo);

		RGFW_mInfo info;
		info.iIndex = 0;
		info.hMonitor = src;

		/* get the monitor's index */
		if (EnumDisplayMonitors(NULL, NULL, GetMonitorByHandle, (LPARAM) &info)) {
			DISPLAY_DEVICEA dd;
			dd.cb = sizeof(dd);

			/* loop through the devices until you find a device with the monitor's index */
			size_t deviceIndex;
			for (deviceIndex = 0; EnumDisplayDevicesA(0, (DWORD) deviceIndex, &dd, 0); deviceIndex++) {
				char* deviceName = dd.DeviceName;
				if (EnumDisplayDevicesA(deviceName, info.iIndex, &dd, 0)) {
					strncpy(monitor.name, dd.DeviceString, 128); /*!< copy the monitor's name */
					break;
				}
			}
		}

		monitor.rect.x = monitorInfo.rcWork.left;
		monitor.rect.y = monitorInfo.rcWork.top;
		monitor.rect.w = monitorInfo.rcWork.right - monitorInfo.rcWork.left;
		monitor.rect.h = monitorInfo.rcWork.bottom - monitorInfo.rcWork.top;

#ifndef RGFW_NO_DPI
		#ifndef USER_DEFAULT_SCREEN_DPI
		#define USER_DEFAULT_SCREEN_DPI 96
		#endif

		if (GetDpiForMonitor != NULL) {
			u32 x, y;
			GetDpiForMonitor(src, MDT_ANGULAR_DPI, &x, &y);
			monitor.scaleX = (float) (x) / (float) USER_DEFAULT_SCREEN_DPI;
			monitor.scaleY = (float) (y) / (float) USER_DEFAULT_SCREEN_DPI;
		}
#endif

		HDC hdc = GetDC(NULL);
		/* get pixels per inch */
		i32 ppiX = GetDeviceCaps(hdc, LOGPIXELSX);
		i32 ppiY = GetDeviceCaps(hdc, LOGPIXELSY);
		ReleaseDC(NULL, hdc);

		/* Calculate physical height in inches */
		monitor.physW = GetSystemMetrics(SM_CYSCREEN) / (float) ppiX;
		monitor.physH = GetSystemMetrics(SM_CXSCREEN) / (float) ppiY;

		return monitor;
	}
	#endif /* RGFW_NO_MONITOR */
	

	#ifndef RGFW_NO_MONITOR
	RGFW_monitor RGFW_monitors[6];
	BOOL CALLBACK GetMonitorHandle(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {
		RGFW_UNUSED(hdcMonitor)
		RGFW_UNUSED(lprcMonitor)

		RGFW_mInfo* info = (RGFW_mInfo*) dwData;

		if (info->iIndex >= 6)
			return FALSE;

		RGFW_monitors[info->iIndex] = win32CreateMonitor(hMonitor);
		info->iIndex++;

		return TRUE;
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
        #ifdef __cplusplus
        return win32CreateMonitor(MonitorFromPoint({ 0, 0 }, MONITOR_DEFAULTTOPRIMARY));
        #else
		return win32CreateMonitor(MonitorFromPoint((POINT) { 0, 0 }, MONITOR_DEFAULTTOPRIMARY));
	    #endif
    }

	RGFW_monitor* RGFW_getMonitors(void) {
		RGFW_mInfo info;
		info.iIndex = 0;
		while (EnumDisplayMonitors(NULL, NULL, GetMonitorHandle, (LPARAM) &info));

		return RGFW_monitors;
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		HMONITOR src = MonitorFromWindow(win->src.window, MONITOR_DEFAULTTOPRIMARY);
		return win32CreateMonitor(src);
	}
	#endif

	HICON RGFW_loadHandleImage(RGFW_window* win, u8* src, RGFW_area a, BOOL icon) {
		assert(win != NULL);

		u32 i;
		HDC dc;
		HICON handle;
		HBITMAP color, mask;
		BITMAPV5HEADER bi;
		ICONINFO ii;
		u8* target = NULL;
		u8* source = src;

		ZeroMemory(&bi, sizeof(bi));
		bi.bV5Size = sizeof(bi);
		bi.bV5Width = a.w;
		bi.bV5Height = -((LONG) a.h);
		bi.bV5Planes = 1;
		bi.bV5BitCount = 32;
		bi.bV5Compression = BI_BITFIELDS;
		bi.bV5RedMask = 0x00ff0000;
		bi.bV5GreenMask = 0x0000ff00;
		bi.bV5BlueMask = 0x000000ff;
		bi.bV5AlphaMask = 0xff000000;

		dc = GetDC(NULL);
		color = CreateDIBSection(dc,
			(BITMAPINFO*) &bi,
			DIB_RGB_COLORS,
			(void**) &target,
			NULL,
			(DWORD) 0);
		ReleaseDC(NULL, dc);

		mask = CreateBitmap(a.w, a.h, 1, 1, NULL);

		for (i = 0; i < a.w * a.h; i++) {
			target[0] = source[2];
			target[1] = source[1];
			target[2] = source[0];
			target[3] = source[3];
			target += 4;
			source += 4;
		}

		ZeroMemory(&ii, sizeof(ii));
		ii.fIcon = icon;
		ii.xHotspot = 0;
		ii.yHotspot = 0;
		ii.hbmMask = mask;
		ii.hbmColor = color;

		handle = CreateIconIndirect(&ii);

		DeleteObject(color);
		DeleteObject(mask);

		return handle;
	}

	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		assert(win != NULL);
		RGFW_UNUSED(channels)

		HCURSOR cursor = (HCURSOR) RGFW_loadHandleImage(win, image, a, FALSE);
		SetClassLongPtrA(win->src.window, GCLP_HCURSOR, (LPARAM) cursor);
		SetCursor(cursor);
		DestroyCursor(cursor);
	}

	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_ARROW);
	}

	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
		assert(win != NULL);

		if (mouse > (sizeof(RGFW_mouseIconSrc) / sizeof(u32)))
			return;

		char* icon = MAKEINTRESOURCEA(RGFW_mouseIconSrc[mouse]);

		SetClassLongPtrA(win->src.window, GCLP_HCURSOR, (LPARAM) LoadCursorA(NULL, icon));
		SetCursor(LoadCursorA(NULL, icon));
	}

	void RGFW_window_hide(RGFW_window* win) {
		ShowWindow(win->src.window, SW_HIDE);
	}

	void RGFW_window_show(RGFW_window* win) {
		ShowWindow(win->src.window, SW_RESTORE);
	}

	void RGFW_window_close(RGFW_window* win) {
		assert(win != NULL);

#ifdef RGFW_EGL
		RGFW_closeEGL(win);
#endif

		if (win == RGFW_root) {
#ifdef RGFW_DIRECTX
			RGFW_dxInfo.pDeviceContext->lpVtbl->Release(RGFW_dxInfo.pDeviceContext);
			RGFW_dxInfo.pDevice->lpVtbl->Release(RGFW_dxInfo.pDevice);
			RGFW_dxInfo.pAdapter->lpVtbl->Release(RGFW_dxInfo.pAdapter);
			RGFW_dxInfo.pFactory->lpVtbl->Release(RGFW_dxInfo.pFactory);
#endif
		
			if (RGFW_XInput_dll != NULL) {
				FreeLibrary(RGFW_XInput_dll);
				RGFW_XInput_dll = NULL;
			}

			#ifndef RGFW_NO_DPI
			if (RGFW_Shcore_dll != NULL) {
				FreeLibrary(RGFW_Shcore_dll);
				RGFW_Shcore_dll = NULL;
			}
			#endif

			if (wglinstance != NULL) {
				FreeLibrary(wglinstance);
				wglinstance = NULL;
			}

			RGFW_root = NULL;
		}

#ifdef RGFW_DIRECTX
		win->src.swapchain->lpVtbl->Release(win->src.swapchain);
		win->src.renderTargetView->lpVtbl->Release(win->src.renderTargetView);
		win->src.pDepthStencilView->lpVtbl->Release(win->src.pDepthStencilView);
#endif

#ifdef RGFW_BUFFER
		DeleteDC(win->src.hdcMem);
		DeleteObject(win->src.bitmap);
#endif

#ifdef RGFW_OPENGL
		wglDeleteContext((HGLRC) win->src.ctx); /*!< delete opengl context */
#endif
		DeleteDC(win->src.hdc); /*!< delete device context */
		DestroyWindow(win->src.window); /*!< delete window */

#if defined(RGFW_OSMESA)
		if (win->buffer != NULL)
			RGFW_FREE(win->buffer);
#endif

#ifdef RGFW_ALLOC_DROPFILES
		{
			u32 i;
			for (i = 0; i < RGFW_MAX_DROPS; i++)
				RGFW_FREE(win->event.droppedFiles[i]);


			RGFW_FREE(win->event.droppedFiles);
		}
#endif

		RGFW_FREE(win);
	}

	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);

		win->r.x = v.x;
		win->r.y = v.y;
		SetWindowPos(win->src.window, HWND_TOP, win->r.x, win->r.y, 0, 0, SWP_NOSIZE);
	}

	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		win->r.w = a.w;
		win->r.h = a.h;
		SetWindowPos(win->src.window, HWND_TOP, 0, 0, win->r.w, win->r.h + win->src.hOffset, SWP_NOMOVE);
	}


	void RGFW_window_setName(RGFW_window* win, char* name) {
		assert(win != NULL);

		SetWindowTextA(win->src.window, name);
	}

	/* sourced from GLFW */
	#ifndef RGFW_NO_PASSTHROUGH
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		assert(win != NULL);
		
		COLORREF key = 0;
		BYTE alpha = 0;
		DWORD flags = 0;
		DWORD exStyle = GetWindowLongW(win->src.window, GWL_EXSTYLE);
		
		if (exStyle & WS_EX_LAYERED)
			GetLayeredWindowAttributes(win->src.window, &key, &alpha, &flags);

		if (passthrough)
			exStyle |= (WS_EX_TRANSPARENT | WS_EX_LAYERED);
		else
		{
			exStyle &= ~WS_EX_TRANSPARENT;
			// NOTE: Window opacity also needs the layered window style so do not
			//       remove it if the window is alpha blended
			if (exStyle & WS_EX_LAYERED)
			{
				if (!(flags & LWA_ALPHA))
					exStyle &= ~WS_EX_LAYERED;
			}
		}

		SetWindowLongW(win->src.window, GWL_EXSTYLE, exStyle);

		if (passthrough) {
			SetLayeredWindowAttributes(win->src.window, key, alpha, flags);
		}
	}
	#endif

	/* much of this function is sourced from GLFW */
	void RGFW_window_setIcon(RGFW_window* win, u8* src, RGFW_area a, i32 channels) {
		assert(win != NULL);
		#ifndef RGFW_WIN95
		RGFW_UNUSED(channels)

		HICON handle = RGFW_loadHandleImage(win, src, a, TRUE);

		SetClassLongPtrA(win->src.window, GCLP_HICON, (LPARAM) handle);

		DestroyIcon(handle);
		#else
		RGFW_UNUSED(src)
		RGFW_UNUSED(a)
		RGFW_UNUSED(channels)
		#endif
	}

	char* RGFW_readClipboard(size_t* size) {
		/* Open the clipboard */
		if (OpenClipboard(NULL) == 0)
			return (char*) "";

		/* Get the clipboard data as a Unicode string */
		HANDLE hData = GetClipboardData(CF_UNICODETEXT);
		if (hData == NULL) {
			CloseClipboard();
			return (char*) "";
		}

		wchar_t* wstr = (wchar_t*) GlobalLock(hData);

		char* text;

		{
			setlocale(LC_ALL, "en_US.UTF-8");

			size_t textLen = wcstombs(NULL, wstr, 0);
			if (textLen == 0)
				return (char*) "";

			text = (char*) RGFW_MALLOC((textLen * sizeof(char)) + 1);

			wcstombs(text, wstr, (textLen) +1);

			if (size != NULL)
				*size = textLen + 1;

			text[textLen] = '\0';
		}

		/* Release the clipboard data */
		GlobalUnlock(hData);
		CloseClipboard();

		return text;
	}

	void RGFW_writeClipboard(const char* text, u32 textLen) {
		HANDLE object;
		WCHAR* buffer;

		object = GlobalAlloc(GMEM_MOVEABLE, (1 + textLen) * sizeof(WCHAR));
		if (!object)
			return;

		buffer = (WCHAR*) GlobalLock(object);
		if (!buffer) {
			GlobalFree(object);
			return;
		}

		MultiByteToWideChar(CP_UTF8, 0, text, -1, buffer, textLen);
		GlobalUnlock(object);

		if (!OpenClipboard(RGFW_root->src.window)) {
			GlobalFree(object);
			return;
		}

		EmptyClipboard();
		SetClipboardData(CF_UNICODETEXT, object);
		CloseClipboard();
	}

	u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber) {
		assert(win != NULL);

		RGFW_UNUSED(jsNumber)

		return RGFW_registerJoystickF(win, (char*) "");
	}

	u16 RGFW_registerJoystickF(RGFW_window* win, char* file) {
		assert(win != NULL);
		RGFW_UNUSED(file)

		return RGFW_joystickCount - 1;
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point p) {
		assert(win != NULL);

		SetCursorPos(p.x, p.y);
	}

	#ifdef RGFW_OPENGL
	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		if (win == NULL)
			wglMakeCurrent(NULL, NULL);
		else
			wglMakeCurrent(win->src.hdc, (HGLRC) win->src.ctx);
	}
	#endif

	#ifndef RGFW_EGL
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);
		
		#if defined(RGFW_OPENGL)
		typedef BOOL(APIENTRY* PFNWGLSWAPINTERVALEXTPROC)(int interval);
		static PFNWGLSWAPINTERVALEXTPROC wglSwapIntervalEXT = NULL;
		static void* loadSwapFunc = (void*) 1;

		if (loadSwapFunc == NULL) {
			fprintf(stderr, "wglSwapIntervalEXT not supported\n");
			return;
		}

		if (wglSwapIntervalEXT == NULL) {
			loadSwapFunc = (void*) wglGetProcAddress("wglSwapIntervalEXT");
			wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC) loadSwapFunc;
		}

		if (wglSwapIntervalEXT(swapInterval) == FALSE)
			fprintf(stderr, "Failed to set swap interval\n");
		#else
        RGFW_UNUSED(swapInterval);
        #endif

	}
	#endif

	void RGFW_window_swapBuffers(RGFW_window* win) {
		//assert(win != NULL);
		/* clear the window*/

		if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			#ifdef RGFW_OSMESA
			RGFW_OSMesa_reorganize();
			#endif

			HGDIOBJ oldbmp = SelectObject(win->src.hdcMem, win->src.bitmap);
			BitBlt(win->src.hdc, 0, 0, win->r.w, win->r.h, win->src.hdcMem, 0, 0, SRCCOPY);
			SelectObject(win->src.hdcMem, oldbmp);
#endif
		}

		if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) {
			#ifdef RGFW_EGL
					eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
			#elif defined(RGFW_OPENGL)
					SwapBuffers(win->src.hdc);
			#endif

			#if defined(RGFW_WINDOWS) && defined(RGFW_DIRECTX)
					win->src.swapchain->lpVtbl->Present(win->src.swapchain, 0, 0);
			#endif
		}
	}

	char* createUTF8FromWideStringWin32(const WCHAR* source) {
		char* target;
		i32 size;

		size = WideCharToMultiByte(CP_UTF8, 0, source, -1, NULL, 0, NULL, NULL);
		if (!size) {
			return NULL;
		}

		target = (char*) RGFW_CALLOC(size, 1);

		if (!WideCharToMultiByte(CP_UTF8, 0, source, -1, target, size, NULL, NULL)) {
			RGFW_FREE(target);
			return NULL;
		}

		return target;
	}
	
    static inline LARGE_INTEGER RGFW_win32_initTimer(void) {
		static LARGE_INTEGER frequency = {{0, 0}};
		if (frequency.QuadPart == 0) {
			timeBeginPeriod(1);
			QueryPerformanceFrequency(&frequency);
		}

		return frequency;
	}

	u64 RGFW_getTimeNS(void) {
		LARGE_INTEGER frequency = RGFW_win32_initTimer();

		LARGE_INTEGER counter;
		QueryPerformanceCounter(&counter);

		return (u64) ((counter.QuadPart * 1e9) / frequency.QuadPart);
	}

	u64 RGFW_getTime(void) {
		LARGE_INTEGER frequency = RGFW_win32_initTimer();

		LARGE_INTEGER counter;
		QueryPerformanceCounter(&counter);
		return (u64) (counter.QuadPart / (double) frequency.QuadPart);
	}
	
	void RGFW_sleep(u64 ms) {
		Sleep(ms);
	}

#ifndef RGFW_NO_THREADS
	RGFW_thread RGFW_createThread(RGFW_threadFunc_ptr ptr, void* args) { return CreateThread(NULL, 0, ptr, args, 0, NULL); }
	void RGFW_cancelThread(RGFW_thread thread) { CloseHandle((HANDLE) thread); }
	void RGFW_joinThread(RGFW_thread thread) { WaitForSingleObject((HANDLE) thread, INFINITE); }
	void RGFW_setThreadPriority(RGFW_thread thread, u8 priority) { SetThreadPriority((HANDLE) thread, priority); }
#endif
#endif /* RGFW_WINDOWS */

/*
	End of Windows defines
*/



/* 

	Start of MacOS defines


*/

#if defined(RGFW_MACOS)
	/*
		based on silicon.h
		start of cocoa wrapper
	*/

#include <CoreVideo/CVDisplayLink.h>
#include <ApplicationServices/ApplicationServices.h>
#include <objc/runtime.h>
#include <objc/message.h>
#include <mach/mach_time.h>

	typedef CGRect NSRect;
	typedef CGPoint NSPoint;
	typedef CGSize NSSize;

	typedef void NSBitmapImageRep;
	typedef void NSCursor;
	typedef void NSDraggingInfo;
	typedef void NSWindow;
	typedef void NSApplication;
	typedef void NSScreen;
	typedef void NSEvent;
	typedef void NSString;
	typedef void NSOpenGLContext;
	typedef void NSPasteboard;
	typedef void NSColor;
	typedef void NSArray;
	typedef void NSImageRep;
	typedef void NSImage;
	typedef void NSOpenGLView;


	typedef const char* NSPasteboardType;
	typedef unsigned long NSUInteger;
	typedef long NSInteger;
	typedef NSInteger NSModalResponse;

#ifdef __arm64__
	/* ARM just uses objc_msgSend */
#define abi_objc_msgSend_stret objc_msgSend
#define abi_objc_msgSend_fpret objc_msgSend
#else /* __i386__ */ 
	/* x86 just uses abi_objc_msgSend_fpret and (NSColor *)objc_msgSend_id respectively */
#define abi_objc_msgSend_stret objc_msgSend_stret
#define abi_objc_msgSend_fpret objc_msgSend_fpret
#endif

#define NSAlloc(nsclass) objc_msgSend_id((id)nsclass, sel_registerName("alloc"))
#define objc_msgSend_bool			((BOOL (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void			((void (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void_id		((void (*)(id, SEL, id))objc_msgSend)
#define objc_msgSend_uint			((NSUInteger (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void_bool		((void (*)(id, SEL, BOOL))objc_msgSend)
#define objc_msgSend_bool_void		((BOOL (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void_SEL		((void (*)(id, SEL, SEL))objc_msgSend)
#define objc_msgSend_id				((id (*)(id, SEL))objc_msgSend)
#define objc_msgSend_id_id				((id (*)(id, SEL, id))objc_msgSend)
#define objc_msgSend_id_bool			((BOOL (*)(id, SEL, id))objc_msgSend)
#define objc_msgSend_int ((id (*)(id, SEL, int))objc_msgSend)
#define objc_msgSend_arr ((id (*)(id, SEL, int))objc_msgSend)
#define objc_msgSend_ptr ((id (*)(id, SEL, void*))objc_msgSend)
#define objc_msgSend_class ((id (*)(Class, SEL))objc_msgSend)
#define objc_msgSend_class_char ((id (*)(Class, SEL, char*))objc_msgSend)

	NSApplication* NSApp = NULL;

	void NSRelease(id obj) {
		objc_msgSend_void(obj, sel_registerName("release"));
	}

	#define release NSRelease

	NSString* NSString_stringWithUTF8String(const char* str) {	
		return ((id(*)(id, SEL, const char*))objc_msgSend)
			((id)objc_getClass("NSString"), sel_registerName("stringWithUTF8String:"), str);
	}

	const char* NSString_to_char(NSString* str) {
		return ((const char* (*)(id, SEL)) objc_msgSend) (str, sel_registerName("UTF8String"));
	}

	void si_impl_func_to_SEL_with_name(const char* class_name, const char* register_name, void* function) {
		Class selected_class;

		if (strcmp(class_name, "NSView") == 0) {
			selected_class = objc_getClass("ViewClass");
		} else if (strcmp(class_name, "NSWindow") == 0) {
			selected_class = objc_getClass("WindowClass");
		} else {
			selected_class = objc_getClass(class_name);
		}

		class_addMethod(selected_class, sel_registerName(register_name), (IMP) function, 0);
	}

	/* Header for the array. */
	typedef struct siArrayHeader {
		size_t count;
		/* TODO(EimaMei): Add a `type_width` later on. */
	} siArrayHeader;

	/* Gets the header of the siArray. */
#define SI_ARRAY_HEADER(s) ((siArrayHeader*)s - 1)

	void* si_array_init_reserve(size_t sizeof_element, size_t count) {
		siArrayHeader* ptr = malloc(sizeof(siArrayHeader) + (sizeof_element * count));
		void* array = ptr + sizeof(siArrayHeader);

		siArrayHeader* header = SI_ARRAY_HEADER(array);
		header->count = count;

		return array;
	}

#define si_array_len(array) (SI_ARRAY_HEADER(array)->count)
#define si_func_to_SEL(class_name, function) si_impl_func_to_SEL_with_name(class_name, #function":", function)
	/* Creates an Objective-C method (SEL) from a regular C function with the option to set the register name.*/
#define si_func_to_SEL_with_name(class_name, register_name, function) si_impl_func_to_SEL_with_name(class_name, register_name":", function)
	
	unsigned char* NSBitmapImageRep_bitmapData(NSBitmapImageRep* imageRep) {
		return ((unsigned char* (*)(id, SEL))objc_msgSend)
			(imageRep, sel_registerName("bitmapData"));
	}

#define NS_ENUM(type, name) type name; enum

	typedef NS_ENUM(NSUInteger, NSBitmapFormat) {
		NSBitmapFormatAlphaFirst = 1 << 0,       // 0 means is alpha last (RGBA, CMYKA, etc.)
			NSBitmapFormatAlphaNonpremultiplied = 1 << 1,       // 0 means is premultiplied
			NSBitmapFormatFloatingPointSamples = 1 << 2,  // 0 is integer

			NSBitmapFormatSixteenBitLittleEndian API_AVAILABLE(macos(10.10)) = (1 << 8),
			NSBitmapFormatThirtyTwoBitLittleEndian API_AVAILABLE(macos(10.10)) = (1 << 9),
			NSBitmapFormatSixteenBitBigEndian API_AVAILABLE(macos(10.10)) = (1 << 10),
			NSBitmapFormatThirtyTwoBitBigEndian API_AVAILABLE(macos(10.10)) = (1 << 11)
	};

	NSBitmapImageRep* NSBitmapImageRep_initWithBitmapData(unsigned char** planes, NSInteger width, NSInteger height, NSInteger bps, NSInteger spp, bool alpha, bool isPlanar, const char* colorSpaceName, NSBitmapFormat bitmapFormat, NSInteger rowBytes, NSInteger pixelBits) {
		void* func = sel_registerName("initWithBitmapDataPlanes:pixelsWide:pixelsHigh:bitsPerSample:samplesPerPixel:hasAlpha:isPlanar:colorSpaceName:bitmapFormat:bytesPerRow:bitsPerPixel:");

		return (NSBitmapImageRep*) ((id(*)(id, SEL, unsigned char**, NSInteger, NSInteger, NSInteger, NSInteger, bool, bool, const char*, NSBitmapFormat, NSInteger, NSInteger))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSBitmapImageRep")), func, planes, width, height, bps, spp, alpha, isPlanar, NSString_stringWithUTF8String(colorSpaceName), bitmapFormat, rowBytes, pixelBits);
	}

	NSColor* NSColor_colorWithSRGB(CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha) {
		void* nsclass = objc_getClass("NSColor");
		void* func = sel_registerName("colorWithSRGBRed:green:blue:alpha:");
		return ((id(*)(id, SEL, CGFloat, CGFloat, CGFloat, CGFloat))objc_msgSend)
			(nsclass, func, red, green, blue, alpha);
	}

	NSCursor* NSCursor_initWithImage(NSImage* newImage, NSPoint aPoint) {
		void* func = sel_registerName("initWithImage:hotSpot:");
		void* nsclass = objc_getClass("NSCursor");

		return (NSCursor*) ((id(*)(id, SEL, id, NSPoint))objc_msgSend)
			(NSAlloc(nsclass), func, newImage, aPoint);
	}

	void NSImage_addRepresentation(NSImage* image, NSImageRep* imageRep) {
		void* func = sel_registerName("addRepresentation:");
		objc_msgSend_void_id(image, func, imageRep);
	}

	NSImage* NSImage_initWithSize(NSSize size) {
		void* func = sel_registerName("initWithSize:");
		return ((id(*)(id, SEL, NSSize))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSImage")), func, size);
	}
#define NS_OPENGL_ENUM_DEPRECATED(minVers, maxVers) API_AVAILABLE(macos(minVers))
	typedef NS_ENUM(NSInteger, NSOpenGLContextParameter) {
		NSOpenGLContextParameterSwapInterval           NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 222, /* 1 param.  0 -> Don't sync, 1 -> Sync to vertical retrace     */
			NSOpenGLContextParametectxaceOrder           NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 235, /* 1 param.  1 -> Above Window (default), -1 -> Below Window    */
			NSOpenGLContextParametectxaceOpacity         NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 236, /* 1 param.  1-> Surface is opaque (default), 0 -> non-opaque   */
			NSOpenGLContextParametectxaceBackingSize     NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 304, /* 2 params.  Width/height of surface backing size              */
			NSOpenGLContextParameterReclaimResources       NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 308, /* 0 params.                                                    */
			NSOpenGLContextParameterCurrentRendererID      NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 309, /* 1 param.   Retrieves the current renderer ID                 */
			NSOpenGLContextParameterGPUVertexProcessing    NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 310, /* 1 param.   Currently processing vertices with GPU (get)      */
			NSOpenGLContextParameterGPUFragmentProcessing  NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 311, /* 1 param.   Currently processing fragments with GPU (get)     */
			NSOpenGLContextParameterHasDrawable            NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 314, /* 1 param.   Boolean returned if drawable is attached          */
			NSOpenGLContextParameterMPSwapsInFlight        NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 315, /* 1 param.   Max number of swaps queued by the MP GL engine    */

			NSOpenGLContextParameterSwapRectangle API_DEPRECATED("", macos(10.0, 10.14)) = 200, /* 4 params.  Set or get the swap rectangle {x, y, w, h} */
			NSOpenGLContextParameterSwapRectangleEnable API_DEPRECATED("", macos(10.0, 10.14)) = 201, /* Enable or disable the swap rectangle */
			NSOpenGLContextParameterRasterizationEnable API_DEPRECATED("", macos(10.0, 10.14)) = 221, /* Enable or disable all rasterization */
			NSOpenGLContextParameterStateValidation API_DEPRECATED("", macos(10.0, 10.14)) = 301, /* Validate state for multi-screen functionality */
			NSOpenGLContextParametectxaceSurfaceVolatile API_DEPRECATED("", macos(10.0, 10.14)) = 306, /* 1 param.   Surface volatile state */
	};


	void NSOpenGLContext_setValues(NSOpenGLContext* context, const int* vals, NSOpenGLContextParameter param) {
		void* func = sel_registerName("setValues:forParameter:");
		((void (*)(id, SEL, const int*, NSOpenGLContextParameter))objc_msgSend)
			(context, func, vals, param);
	}

	void* NSOpenGLPixelFormat_initWithAttributes(const uint32_t* attribs) {
		void* func = sel_registerName("initWithAttributes:");
		return (void*) ((id(*)(id, SEL, const uint32_t*))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSOpenGLPixelFormat")), func, attribs);
	}

	NSOpenGLView* NSOpenGLView_initWithFrame(NSRect frameRect, uint32_t* format) {
		void* func = sel_registerName("initWithFrame:pixelFormat:");
		return (NSOpenGLView*) ((id(*)(id, SEL, NSRect, uint32_t*))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSOpenGLView")), func, frameRect, format);
	}

	void NSCursor_performSelector(NSCursor* cursor, void* selector) {
		void* func = sel_registerName("performSelector:");
		objc_msgSend_void_SEL(cursor, func, selector);
	}

	NSPasteboard* NSPasteboard_generalPasteboard(void) {
		return (NSPasteboard*) objc_msgSend_id((id)objc_getClass("NSPasteboard"), sel_registerName("generalPasteboard"));
	}

	NSString** cstrToNSStringArray(char** strs, size_t len) {
		static NSString* nstrs[6];
		size_t i;
		for (i = 0; i < len; i++)
			nstrs[i] = NSString_stringWithUTF8String(strs[i]);

		return nstrs;
	}

	const char* NSPasteboard_stringForType(NSPasteboard* pasteboard, NSPasteboardType dataType) {
		void* func = sel_registerName("stringForType:");
		return (const char*) NSString_to_char(((id(*)(id, SEL, const char*))objc_msgSend)(pasteboard, func, NSString_stringWithUTF8String(dataType)));
	}

	NSArray* c_array_to_NSArray(void* array, size_t len) {
		SEL func = sel_registerName("initWithObjects:count:");
		void* nsclass = objc_getClass("NSArray");
		return ((id (*)(id, SEL, void*, NSUInteger))objc_msgSend)
					(NSAlloc(nsclass), func, array, len);
	}
 
	void NSregisterForDraggedTypes(void* view, NSPasteboardType* newTypes, size_t len) {
		NSString** ntypes = cstrToNSStringArray((char**)newTypes, len);

		NSArray* array = c_array_to_NSArray(ntypes, len);
		objc_msgSend_void_id(view, sel_registerName("registerForDraggedTypes:"), array);
		NSRelease(array);
	}

	NSInteger NSPasteBoard_declareTypes(NSPasteboard* pasteboard, NSPasteboardType* newTypes, size_t len, void* owner) {
		NSString** ntypes = cstrToNSStringArray((char**)newTypes, len);

		void* func = sel_registerName("declareTypes:owner:");

		NSArray* array = c_array_to_NSArray(ntypes, len);

		NSInteger output = ((NSInteger(*)(id, SEL, id, void*))objc_msgSend)
			(pasteboard, func, array, owner);
		NSRelease(array);

		return output;
	}

	bool NSPasteBoard_setString(NSPasteboard* pasteboard, const char* stringToWrite, NSPasteboardType dataType) {
		void* func = sel_registerName("setString:forType:");
		return ((bool (*)(id, SEL, id, NSPasteboardType))objc_msgSend)
			(pasteboard, func, NSString_stringWithUTF8String(stringToWrite), NSString_stringWithUTF8String(dataType));
	}

	void NSRetain(id obj) { objc_msgSend_void(obj, sel_registerName("retain")); }

	typedef enum NSApplicationActivationPolicy {
		NSApplicationActivationPolicyRegular,
		NSApplicationActivationPolicyAccessory,
		NSApplicationActivationPolicyProhibited
	} NSApplicationActivationPolicy;

	typedef NS_ENUM(u32, NSBackingStoreType) {
		NSBackingStoreRetained = 0,
			NSBackingStoreNonretained = 1,
			NSBackingStoreBuffered = 2
	};

	typedef NS_ENUM(u32, NSWindowStyleMask) {
		NSWindowStyleMaskBorderless = 0,
			NSWindowStyleMaskTitled = 1 << 0,
			NSWindowStyleMaskClosable = 1 << 1,
			NSWindowStyleMaskMiniaturizable = 1 << 2,
			NSWindowStyleMaskResizable = 1 << 3,
			NSWindowStyleMaskTexturedBackground = 1 << 8, /* deprecated */
			NSWindowStyleMaskUnifiedTitleAndToolbar = 1 << 12,
			NSWindowStyleMaskFullScreen = 1 << 14,
			NSWindowStyleMaskFullSizeContentView = 1 << 15,
			NSWindowStyleMaskUtilityWindow = 1 << 4,
			NSWindowStyleMaskDocModalWindow = 1 << 6,
			NSWindowStyleMaskNonactivatingPanel = 1 << 7,
			NSWindowStyleMaskHUDWindow = 1 << 13
	};

	NSPasteboardType const NSPasteboardTypeString = "public.utf8-plain-text"; // Replaces NSStringPboardType


	typedef NS_ENUM(i32, NSDragOperation) {
		NSDragOperationNone = 0,
			NSDragOperationCopy = 1,
			NSDragOperationLink = 2,
			NSDragOperationGeneric = 4,
			NSDragOperationPrivate = 8,
			NSDragOperationMove = 16,
			NSDragOperationDelete = 32,
			NSDragOperationEvery = ULONG_MAX,

			//NSDragOperationAll_Obsolete	API_DEPRECATED("", macos(10.0,10.10)) = 15, // Use NSDragOperationEvery
			//NSDragOperationAll API_DEPRECATED("", macos(10.0,10.10)) = NSDragOperationAll_Obsolete, // Use NSDragOperationEvery
	};

	void* NSArray_objectAtIndex(NSArray* array, NSUInteger index) {
		void* func = sel_registerName("objectAtIndex:");
		return ((id(*)(id, SEL, NSUInteger))objc_msgSend)(array, func, index);
	}

	const char** NSPasteboard_readObjectsForClasses(NSPasteboard* pasteboard, Class* classArray, size_t len, void* options) {
		void* func = sel_registerName("readObjectsForClasses:options:");

		NSArray* array = c_array_to_NSArray(classArray, len);

		NSArray* output = (NSArray*) ((id(*)(id, SEL, id, void*))objc_msgSend)
			(pasteboard, func, array, options);

		NSRelease(array);
		NSUInteger count = ((NSUInteger(*)(id, SEL))objc_msgSend)(output, sel_registerName("count"));

		const char** res = si_array_init_reserve(sizeof(const char*), count);

		void* path_func = sel_registerName("path");

		for (NSUInteger i = 0; i < count; i++) {
			void* url = NSArray_objectAtIndex(output, i);
			NSString* url_str = ((id(*)(id, SEL))objc_msgSend)(url, path_func);
			res[i] = NSString_to_char(url_str);
		}

		return res;
	}

	void* NSWindow_contentView(NSWindow* window) {
		void* func = sel_registerName("contentView");
		return objc_msgSend_id(window, func);
	}

	/*
		End of cocoa wrapper
	*/

	char* RGFW_mouseIconSrc[] = {"arrowCursor", "arrowCursor", "IBeamCursor", "crosshairCursor", "pointingHandCursor", "resizeLeftRightCursor", "resizeUpDownCursor", "_windowResizeNorthWestSouthEastCursor", "_windowResizeNorthEastSouthWestCursor", "closedHandCursor", "operationNotAllowedCursor"};

	void* RGFWnsglFramework = NULL;

#ifdef RGFW_OPENGL
	void* RGFW_getProcAddress(const char* procname) {
		if (RGFWnsglFramework == NULL)
			RGFWnsglFramework = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.opengl"));

		CFStringRef symbolName = CFStringCreateWithCString(kCFAllocatorDefault, procname, kCFStringEncodingASCII);

		void* symbol = CFBundleGetFunctionPointerForName(RGFWnsglFramework, symbolName);

		CFRelease(symbolName);

		return symbol;
	}
#endif

	CVReturn displayCallback(CVDisplayLinkRef displayLink, const CVTimeStamp* inNow, const CVTimeStamp* inOutputTime, CVOptionFlags flagsIn, CVOptionFlags* flagsOut, void* displayLinkContext) { 
		RGFW_UNUSED(displayLink) RGFW_UNUSED(inNow) RGFW_UNUSED(inOutputTime) RGFW_UNUSED(flagsIn) RGFW_UNUSED(flagsOut) RGFW_UNUSED(displayLinkContext)
		return kCVReturnSuccess; 
	}

	id NSWindow_delegate(RGFW_window* win) {
		return (id) objc_msgSend_id(win->src.window, sel_registerName("delegate"));
	}

	u32 RGFW_OnClose(void* self) {
		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return true;

		win->event.type = RGFW_quit;
		RGFW_windowQuitCallback(win);

		return true;
	}

	/* NOTE(EimaMei): Fixes the constant clicking when the app is running under a terminal. */
	bool acceptsFirstResponder(void) { return true; }
	bool performKeyEquivalent(NSEvent* event) { RGFW_UNUSED(event); return true; }

	NSDragOperation draggingEntered(id self, SEL sel, id sender) { 
		RGFW_UNUSED(sender); RGFW_UNUSED(self); RGFW_UNUSED(sel);  

		return NSDragOperationCopy; 
	}
	NSDragOperation draggingUpdated(id self, SEL sel, id sender) { 
		RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return 0;
		
		if (!(win->_winArgs & RGFW_ALLOW_DND)) {
			return 0;
		}

		win->event.type = RGFW_dnd_init;
		win->src.dndPassed = 0;

		NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(sender, sel_registerName("draggingLocation"));

		win->event.point = RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));
		RGFW_dndInitCallback(win, win->event.point);

		return NSDragOperationCopy; 
	}
	bool prepareForDragOperation(id self) {
		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return true;
		
		if (!(win->_winArgs & RGFW_ALLOW_DND)) {
			return false;
		}

		return true;
	}

	void RGFW__osxDraggingEnded(id self, SEL sel, id sender) { RGFW_UNUSED(sender); RGFW_UNUSED(self); RGFW_UNUSED(sel);  return; }

	/* NOTE(EimaMei): Usually, you never need 'id self, SEL cmd' for C -> Obj-C methods. This isn't the case. */
	bool performDragOperation(id self, SEL sel, id sender) {
		RGFW_UNUSED(sender); RGFW_UNUSED(self); RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);

        if (win == NULL)
			return false;

		// NSPasteboard* pasteBoard = objc_msgSend_id(sender, sel_registerName("draggingPasteboard"));

        /////////////////////////////
        id pasteBoard = objc_msgSend_id(sender, sel_registerName("draggingPasteboard"));

        // Get the types of data available on the pasteboard
        id types = objc_msgSend_id(pasteBoard, sel_registerName("types"));

        // Get the string type for file URLs
        id fileURLsType = objc_msgSend_class_char(objc_getClass("NSString"), sel_registerName("stringWithUTF8String:"), "NSFilenamesPboardType");

        // Check if the pasteboard contains file URLs
        if (objc_msgSend_id_bool(types, sel_registerName("containsObject:"), fileURLsType) == 0) {
		    #ifdef RGFW_DEBUG
            printf("No files found on the pasteboard.\n");
			#endif

			return 0;
		}

		id fileURLs = objc_msgSend_id_id(pasteBoard, sel_registerName("propertyListForType:"), fileURLsType);
		int count = ((int (*)(id, SEL))objc_msgSend)(fileURLs, sel_registerName("count"));

		if (count == 0)
			return 0;

		for (int i = 0; i < count; i++) {
			id fileURL = objc_msgSend_arr(fileURLs, sel_registerName("objectAtIndex:"), i);
			const char *filePath = ((const char* (*)(id, SEL))objc_msgSend)(fileURL, sel_registerName("UTF8String"));
			// printf("File: %s\n", filePath);
			strncpy(win->event.droppedFiles[i], filePath, RGFW_MAX_PATH);
			win->event.droppedFiles[i][RGFW_MAX_PATH - 1] = '\0';
		}
		win->event.droppedFilesCount = count;

		win->event.type = RGFW_dnd;
		win->src.dndPassed = 0;
		
		NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(sender, sel_registerName("draggingLocation"));
		win->event.point = RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));
		
		RGFW_dndCallback(win, win->event.droppedFiles, win->event.droppedFilesCount);
	
    	return false;
	}

	static void NSMoveToResourceDir(void) {
		/* sourced from glfw */
		char resourcesPath[255];

		CFBundleRef bundle = CFBundleGetMainBundle();
		if (!bundle)
			return;

		CFURLRef resourcesURL = CFBundleCopyResourcesDirectoryURL(bundle);
		CFStringRef last = CFURLCopyLastPathComponent(resourcesURL);

		if (
			CFStringCompare(CFSTR("Resources"), last, 0) != kCFCompareEqualTo ||
			CFURLGetFileSystemRepresentation(resourcesURL, true, (u8*) resourcesPath, 255) == 0
			) {
			CFRelease(last);
			CFRelease(resourcesURL);
			return;
		}

		CFRelease(last);
		CFRelease(resourcesURL);

		chdir(resourcesPath);
	}


	NSSize RGFW__osxWindowResize(void* self, SEL sel, NSSize frameSize) {
		RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return frameSize;
		
		win->r.w = frameSize.width;
		win->r.h = frameSize.height;
		win->event.type = RGFW_windowResized;
		RGFW_windowResizeCallback(win, win->r);
		return frameSize;
	}

	void RGFW__osxWindowMove(void* self, SEL sel) {
		RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return;
		
		NSRect frame = ((NSRect(*)(id, SEL))abi_objc_msgSend_stret)(win->src.window, sel_registerName("frame"));
		win->r.x = (i32) frame.origin.x;
		win->r.y = (i32) frame.origin.y;

		win->event.type = RGFW_windowMoved;
		RGFW_windowMoveCallback(win, win->r);
	}

	void RGFW__osxUpdateLayer(void* self, SEL sel) {
		RGFW_UNUSED(sel);

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return;
		
		win->event.type = RGFW_windowRefresh;
		RGFW_windowRefreshCallback(win);
	}

	RGFWDEF void RGFW_init_buffer(RGFW_window* win);
	void RGFW_init_buffer(RGFW_window* win) {
		#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
				RGFW_bufferSize = RGFW_getScreenSize();
				
			win->buffer = RGFW_MALLOC(RGFW_bufferSize.w * RGFW_bufferSize.h * 4);

		#ifdef RGFW_OSMESA
				win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
				OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
		#endif
		#else
		RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
		#endif
	}

	NSPasteboardType const NSPasteboardTypeURL = "public.url";
	NSPasteboardType const NSPasteboardTypeFileURL  = "public.file-url";

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
		static u8 RGFW_loaded = 0;

		/* NOTE(EimaMei): Why does Apple hate good code? Like wtf, who thought of methods being a great idea???
		Imagine a universe, where MacOS had a proper system API (we would probably have like 20% better performance).
		*/
		si_func_to_SEL_with_name("NSObject", "windowShouldClose", RGFW_OnClose);

		/* NOTE(EimaMei): Fixes the 'Boop' sfx from constantly playing each time you click a key. Only a problem when running in the terminal. */
		si_func_to_SEL("NSWindow", acceptsFirstResponder);
		si_func_to_SEL("NSWindow", performKeyEquivalent);

		// RR Create an autorelease pool
		id pool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
		pool = objc_msgSend_id(pool, sel_registerName("init"));

		if (NSApp == NULL) {
			NSApp = objc_msgSend_id((id)objc_getClass("NSApplication"), sel_registerName("sharedApplication"));

			((void (*)(id, SEL, NSUInteger))objc_msgSend)
				(NSApp, sel_registerName("setActivationPolicy:"), NSApplicationActivationPolicyRegular);
		}

		RGFW_window* win = RGFW_window_basic_init(rect, args);
		
		RGFW_window_setMouseDefault(win);

		NSRect windowRect;
		windowRect.origin.x = win->r.x;
		windowRect.origin.y = win->r.y;
		windowRect.size.width = win->r.w;
		windowRect.size.height = win->r.h;

		NSBackingStoreType macArgs = NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable | NSBackingStoreBuffered | NSWindowStyleMaskTitled;

		if (!(args & RGFW_NO_RESIZE))
			macArgs |= NSWindowStyleMaskResizable;
		if (!(args & RGFW_NO_BORDER))
			macArgs |= NSWindowStyleMaskTitled;
		else
			macArgs = NSWindowStyleMaskBorderless;
		{
			void* nsclass = objc_getClass("NSWindow");
			void* func = sel_registerName("initWithContentRect:styleMask:backing:defer:");

			win->src.window = ((id(*)(id, SEL, NSRect, NSWindowStyleMask, NSBackingStoreType, bool))objc_msgSend)
				(NSAlloc(nsclass), func, windowRect, macArgs, macArgs, false);
		}

		NSString* str = NSString_stringWithUTF8String(name);
		objc_msgSend_void_id(win->src.window, sel_registerName("setTitle:"), str);

#ifdef RGFW_OPENGL
	if ((args & RGFW_NO_INIT_API) == 0) {
		void* attrs = RGFW_initFormatAttribs(args & RGFW_OPENGL_SOFTWARE);
		void* format = NSOpenGLPixelFormat_initWithAttributes(attrs);

		if (format == NULL) {
			printf("Failed to load pixel format for OpenGL\n");

			void* attrs = RGFW_initFormatAttribs(1);
			format = NSOpenGLPixelFormat_initWithAttributes(attrs);
			if (format == NULL)
				printf("and loading software rendering OpenGL failed\n");
			else
				printf("Switching to software rendering\n");
		}
		
		/* the pixel format can be passed directly to opengl context creation to create a context 
			this is because the format also includes information about the opengl version (which may be a bad thing) */
		win->src.view = NSOpenGLView_initWithFrame((NSRect){{0, 0}, {win->r.w, win->r.h}}, format);
		objc_msgSend_void(win->src.view, sel_registerName("prepareOpenGL"));
		win->src.ctx = objc_msgSend_id(win->src.view, sel_registerName("openGLContext"));
	} else
#endif
	{
		NSRect contentRect = (NSRect){{0, 0}, {win->r.w, win->r.h}};
		win->src.view = ((id(*)(id, SEL, NSRect))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSView")), sel_registerName("initWithFrame:"),
				contentRect);
	}

		void* contentView = NSWindow_contentView(win->src.window);
		objc_msgSend_void_bool(contentView, sel_registerName("setWantsLayer:"), true);

		objc_msgSend_void_id(win->src.window, sel_registerName("setContentView:"), win->src.view);

#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0)
			objc_msgSend_void(win->src.ctx, sel_registerName("makeCurrentContext"));
#endif
		if (args & RGFW_TRANSPARENT_WINDOW) {
#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0) {
			i32 opacity = 0;
			#define NSOpenGLCPSurfaceOpacity 236
			NSOpenGLContext_setValues(win->src.ctx, &opacity, NSOpenGLCPSurfaceOpacity);
		}
#endif

			objc_msgSend_void_bool(win->src.window, sel_registerName("setOpaque:"), false);

			objc_msgSend_void_id(win->src.window, sel_registerName("setBackgroundColor:"),
				NSColor_colorWithSRGB(0, 0, 0, 0));
		}

		win->src.display = CGMainDisplayID();
		CVDisplayLinkCreateWithCGDisplay(win->src.display, (CVDisplayLinkRef*)&win->src.displayLink);
		CVDisplayLinkSetOutputCallback(win->src.displayLink, displayCallback, win);
		CVDisplayLinkStart(win->src.displayLink);

		RGFW_init_buffer(win);

		#ifndef RGFW_NO_MONITOR
		if (args & RGFW_SCALE_TO_MONITOR)
			RGFW_window_scaleToMonitor(win);
		#endif

		if (args & RGFW_HIDE_MOUSE)
			RGFW_window_showMouse(win, 0);

		if (args & RGFW_COCOA_MOVE_TO_RESOURCE_DIR)
			NSMoveToResourceDir();

		Class delegateClass = objc_allocateClassPair(objc_getClass("NSObject"), "WindowDelegate", 0);

		class_addIvar(
			delegateClass, "RGFW_window",
			sizeof(RGFW_window*), rint(log2(sizeof(RGFW_window*))),
			"L"
		);

		class_addMethod(delegateClass, sel_registerName("windowWillResize:toSize:"), (IMP) RGFW__osxWindowResize, "{NSSize=ff}@:{NSSize=ff}");
		class_addMethod(delegateClass, sel_registerName("updateLayer:"), (IMP) RGFW__osxUpdateLayer, "");
		class_addMethod(delegateClass, sel_registerName("windowWillMove:"), (IMP) RGFW__osxWindowMove, "");
		class_addMethod(delegateClass, sel_registerName("windowDidMove:"), (IMP) RGFW__osxWindowMove, "");
		class_addMethod(delegateClass, sel_registerName("draggingEntered:"), (IMP)draggingEntered, "l@:@");
		class_addMethod(delegateClass, sel_registerName("draggingUpdated:"), (IMP)draggingUpdated, "l@:@");
		class_addMethod(delegateClass, sel_registerName("draggingExited:"), (IMP)RGFW__osxDraggingEnded, "v@:@");
		class_addMethod(delegateClass, sel_registerName("draggingEnded:"), (IMP)RGFW__osxDraggingEnded, "v@:@");
		class_addMethod(delegateClass, sel_registerName("prepareForDragOperation:"), (IMP)prepareForDragOperation, "B@:@");
		class_addMethod(delegateClass, sel_registerName("performDragOperation:"), (IMP)performDragOperation, "B@:@");

		id delegate = objc_msgSend_id(NSAlloc(delegateClass), sel_registerName("init"));

		object_setInstanceVariable(delegate, "RGFW_window", win);

		objc_msgSend_void_id(win->src.window, sel_registerName("setDelegate:"), delegate);

		if (args & RGFW_ALLOW_DND) {
			win->_winArgs |= RGFW_ALLOW_DND;

			NSPasteboardType types[] = {NSPasteboardTypeURL, NSPasteboardTypeFileURL, NSPasteboardTypeString};
			NSregisterForDraggedTypes(win->src.window, types, 3);
		}

		// Show the window
		objc_msgSend_void_bool(NSApp, sel_registerName("activateIgnoringOtherApps:"), true);
		((id(*)(id, SEL, SEL))objc_msgSend)(win->src.window, sel_registerName("makeKeyAndOrderFront:"), NULL);
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIsVisible:"), true);

		if (!RGFW_loaded) {
			objc_msgSend_void(win->src.window, sel_registerName("makeMainWindow"));

			RGFW_loaded = 1;
		}

		objc_msgSend_void(win->src.window, sel_registerName("makeKeyWindow"));

		objc_msgSend_void(NSApp, sel_registerName("finishLaunching"));

		if (RGFW_root == NULL)
			RGFW_root = win;

		NSRetain(win->src.window);
		NSRetain(NSApp);

		return win;
	}

	void RGFW_window_setBorder(RGFW_window* win, u8 border) {
		NSBackingStoreType storeType = NSWindowStyleMaskBorderless;
		if (!border) {
			storeType = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable;
		}
		if (!(win->_winArgs & RGFW_NO_RESIZE)) {
			storeType |= NSWindowStyleMaskResizable;
		}
		
		((void (*)(id, SEL, NSBackingStoreType))objc_msgSend)(win->src.window, sel_registerName("setStyleMask:"), storeType);

		objc_msgSend_void_bool(win->src.window, sel_registerName("setHasShadow:"), border);
	}

	RGFW_area RGFW_getScreenSize(void) {
		static CGDirectDisplayID display = 0;

		if (display == 0)
			display = CGMainDisplayID();

		return RGFW_AREA(CGDisplayPixelsWide(display), CGDisplayPixelsHigh(display));
	}

	RGFW_point RGFW_getGlobalMousePoint(void) {
		assert(RGFW_root != NULL);

		CGEventRef e = CGEventCreate(NULL);
		CGPoint point = CGEventGetLocation(e);
		CFRelease(e);

		return RGFW_POINT((u32) point.x, (u32) point.y); /*!< the point is loaded during event checks */
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		NSPoint p =  ((NSPoint(*)(id, SEL)) objc_msgSend)(win->src.window, sel_registerName("mouseLocationOutsideOfEventStream"));

		return RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));
	}

	u32 RGFW_keysPressed[10]; /*10 keys at a time*/
	typedef NS_ENUM(u32, NSEventType) {        /* various types of events */
		NSEventTypeLeftMouseDown = 1,
			NSEventTypeLeftMouseUp = 2,
			NSEventTypeRightMouseDown = 3,
			NSEventTypeRightMouseUp = 4,
			NSEventTypeMouseMoved = 5,
			NSEventTypeLeftMouseDragged = 6,
			NSEventTypeRightMouseDragged = 7,
			NSEventTypeMouseEntered = 8,
			NSEventTypeMouseExited = 9,
			NSEventTypeKeyDown = 10,
			NSEventTypeKeyUp = 11,
			NSEventTypeFlagsChanged = 12,
			NSEventTypeAppKitDefined = 13,
			NSEventTypeSystemDefined = 14,
			NSEventTypeApplicationDefined = 15,
			NSEventTypePeriodic = 16,
			NSEventTypeCursorUpdate = 17,
			NSEventTypeScrollWheel = 22,
			NSEventTypeTabletPoint = 23,
			NSEventTypeTabletProximity = 24,
			NSEventTypeOtherMouseDown = 25,
			NSEventTypeOtherMouseUp = 26,
			NSEventTypeOtherMouseDragged = 27,
			/* The following event types are available on some hardware on 10.5.2 and later */
			NSEventTypeGesture API_AVAILABLE(macos(10.5)) = 29,
			NSEventTypeMagnify API_AVAILABLE(macos(10.5)) = 30,
			NSEventTypeSwipe   API_AVAILABLE(macos(10.5)) = 31,
			NSEventTypeRotate  API_AVAILABLE(macos(10.5)) = 18,
			NSEventTypeBeginGesture API_AVAILABLE(macos(10.5)) = 19,
			NSEventTypeEndGesture API_AVAILABLE(macos(10.5)) = 20,

			NSEventTypeSmartMagnify API_AVAILABLE(macos(10.8)) = 32,
			NSEventTypeQuickLook API_AVAILABLE(macos(10.8)) = 33,

			NSEventTypePressure API_AVAILABLE(macos(10.10.3)) = 34,
			NSEventTypeDirectTouch API_AVAILABLE(macos(10.10)) = 37,

			NSEventTypeChangeMode API_AVAILABLE(macos(10.15)) = 38,
	};

	typedef NS_ENUM(unsigned long long, NSEventMask) { /* masks for the types of events */
		NSEventMaskLeftMouseDown = 1ULL << NSEventTypeLeftMouseDown,
			NSEventMaskLeftMouseUp = 1ULL << NSEventTypeLeftMouseUp,
			NSEventMaskRightMouseDown = 1ULL << NSEventTypeRightMouseDown,
			NSEventMaskRightMouseUp = 1ULL << NSEventTypeRightMouseUp,
			NSEventMaskMouseMoved = 1ULL << NSEventTypeMouseMoved,
			NSEventMaskLeftMouseDragged = 1ULL << NSEventTypeLeftMouseDragged,
			NSEventMaskRightMouseDragged = 1ULL << NSEventTypeRightMouseDragged,
			NSEventMaskMouseEntered = 1ULL << NSEventTypeMouseEntered,
			NSEventMaskMouseExited = 1ULL << NSEventTypeMouseExited,
			NSEventMaskKeyDown = 1ULL << NSEventTypeKeyDown,
			NSEventMaskKeyUp = 1ULL << NSEventTypeKeyUp,
			NSEventMaskFlagsChanged = 1ULL << NSEventTypeFlagsChanged,
			NSEventMaskAppKitDefined = 1ULL << NSEventTypeAppKitDefined,
			NSEventMaskSystemDefined = 1ULL << NSEventTypeSystemDefined,
			NSEventMaskApplicationDefined = 1ULL << NSEventTypeApplicationDefined,
			NSEventMaskPeriodic = 1ULL << NSEventTypePeriodic,
			NSEventMaskCursorUpdate = 1ULL << NSEventTypeCursorUpdate,
			NSEventMaskScrollWheel = 1ULL << NSEventTypeScrollWheel,
			NSEventMaskTabletPoint = 1ULL << NSEventTypeTabletPoint,
			NSEventMaskTabletProximity = 1ULL << NSEventTypeTabletProximity,
			NSEventMaskOtherMouseDown = 1ULL << NSEventTypeOtherMouseDown,
			NSEventMaskOtherMouseUp = 1ULL << NSEventTypeOtherMouseUp,
			NSEventMaskOtherMouseDragged = 1ULL << NSEventTypeOtherMouseDragged,
			/* The following event masks are available on some hardware on 10.5.2 and later */
			NSEventMaskGesture API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeGesture,
			NSEventMaskMagnify API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeMagnify,
			NSEventMaskSwipe API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeSwipe,
			NSEventMaskRotate API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeRotate,
			NSEventMaskBeginGesture API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeBeginGesture,
			NSEventMaskEndGesture API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeEndGesture,

			/* Note: You can only use these event masks on 64 bit. In other words, you cannot setup a local, nor global, event monitor for these event types on 32 bit. Also, you cannot search the event queue for them (nextEventMatchingMask:...) on 32 bit.
			 */
			NSEventMaskSmartMagnify API_AVAILABLE(macos(10.8)) = 1ULL << NSEventTypeSmartMagnify,
			NSEventMaskPressure API_AVAILABLE(macos(10.10.3)) = 1ULL << NSEventTypePressure,
			NSEventMaskDirectTouch API_AVAILABLE(macos(10.12.2)) = 1ULL << NSEventTypeDirectTouch,

			NSEventMaskChangeMode API_AVAILABLE(macos(10.15)) = 1ULL << NSEventTypeChangeMode,

			NSEventMaskAny = ULONG_MAX,

	};

	typedef enum NSEventModifierFlags {
		NSEventModifierFlagCapsLock = 1 << 16,
		NSEventModifierFlagShift = 1 << 17,
		NSEventModifierFlagControl = 1 << 18,
		NSEventModifierFlagOption = 1 << 19,
		NSEventModifierFlagCommand = 1 << 20,
		NSEventModifierFlagNumericPad = 1 << 21
	} NSEventModifierFlags;

	void RGFW_stopCheckEvents(void) { 
		id eventPool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
        eventPool = objc_msgSend_id(eventPool, sel_registerName("init"));

		NSEvent* e = (NSEvent*) ((id(*)(id, SEL, NSEventType, NSPoint, NSEventModifierFlags, void*, NSInteger, void**, short, NSInteger, NSInteger))objc_msgSend)
			(NSApp, sel_registerName("otherEventWithType:location:modifierFlags:timestamp:windowNumber:context:subtype:data1:data2:"), 
				NSEventTypeApplicationDefined, (NSPoint){0, 0}, 0, 0, 0, NULL, 0, 0, 0);

		((void (*)(id, SEL, id, bool))objc_msgSend)
			(NSApp, sel_registerName("postEvent:atStart:"), e, 1);

		objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
	}

	void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
		RGFW_UNUSED(win);
		
		id eventPool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
        eventPool = objc_msgSend_id(eventPool, sel_registerName("init"));

		void* date = (void*) ((id(*)(Class, SEL, double))objc_msgSend)
					(objc_getClass("NSDate"), sel_registerName("dateWithTimeIntervalSinceNow:"), waitMS);

		NSEvent* e = (NSEvent*) ((id(*)(id, SEL, NSEventMask, void*, NSString*, bool))objc_msgSend)
			(NSApp, sel_registerName("nextEventMatchingMask:untilDate:inMode:dequeue:"), 
				ULONG_MAX, date, NSString_stringWithUTF8String("kCFRunLoopDefaultMode"), true);


		if (e) {
			objc_msgSend_void_id(NSApp, sel_registerName("sendEvent:"), e);
		}

		objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
	}

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		assert(win != NULL);
		
		if (win->event.type == RGFW_quit)
			return NULL;
		
		if ((win->event.type == RGFW_dnd || win->event.type == RGFW_dnd_init) && win->src.dndPassed == 0) {
			win->src.dndPassed = 1;
			return &win->event;
		}

		id eventPool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
        eventPool = objc_msgSend_id(eventPool, sel_registerName("init"));

		static void* eventFunc = NULL;
		if (eventFunc == NULL) 
			eventFunc = sel_registerName("nextEventMatchingMask:untilDate:inMode:dequeue:");

		if ((win->event.type == RGFW_windowMoved || win->event.type == RGFW_windowResized || win->event.type == RGFW_windowRefresh) && win->event.keyCode != 120) {
			win->event.keyCode = 120;
			objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
			return &win->event;
		}

		void* date = NULL;

		NSEvent* e = (NSEvent*) ((id(*)(id, SEL, NSEventMask, void*, NSString*, bool))objc_msgSend)
			(NSApp, eventFunc, ULONG_MAX, date, NSString_stringWithUTF8String("kCFRunLoopDefaultMode"), true);

		if (e == NULL) {
			objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
			return NULL;
		}
		
		if (objc_msgSend_id(e, sel_registerName("window")) != win->src.window) {
			((void (*)(id, SEL, id, bool))objc_msgSend)
				(NSApp, sel_registerName("postEvent:atStart:"), e, 0);
						
			objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
			return NULL;
		}

		if (win->event.droppedFilesCount) {
			u32 i;
			for (i = 0; i < win->event.droppedFilesCount; i++)
				win->event.droppedFiles[i][0] = '\0';
		}

		win->event.droppedFilesCount = 0;
		win->event.type = 0;
		
		switch (objc_msgSend_uint(e, sel_registerName("type"))) {
			case NSEventTypeMouseEntered: {
				win->event.type = RGFW_mouseEnter;
				NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(e, sel_registerName("locationInWindow"));

				win->event.point = RGFW_POINT((i32) p.x, (i32) (win->r.h - p.y));
				RGFW_mouseNotifyCallBack(win, win->event.point, 1);
				break;
			}
			
			case NSEventTypeMouseExited:
				win->event.type = RGFW_mouseLeave;
				RGFW_mouseNotifyCallBack(win, win->event.point, 0);
				break;

			case NSEventTypeKeyDown: {
				u32 key = (u16) objc_msgSend_uint(e, sel_registerName("keyCode"));
				win->event.keyCode = RGFW_apiKeyCodeToRGFW(key);
				RGFW_keyboard[win->event.keyCode].prev = RGFW_keyboard[win->event.keyCode].current;

				win->event.type = RGFW_keyPressed;
				char* str = (char*)(const char*) NSString_to_char(objc_msgSend_id(e, sel_registerName("characters")));
				strncpy(win->event.keyName, str, 16);
				win->event.repeat = RGFW_isPressed(win, win->event.keyCode);
				RGFW_keyboard[win->event.keyCode].current = 1;

				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 1);
				break;
			}

			case NSEventTypeKeyUp: {
				u32 key = (u16) objc_msgSend_uint(e, sel_registerName("keyCode"));
				win->event.keyCode = RGFW_apiKeyCodeToRGFW(key);;

				RGFW_keyboard[win->event.keyCode].prev = RGFW_keyboard[win->event.keyCode].current;

				win->event.type = RGFW_keyReleased;
				char* str = (char*)(const char*) NSString_to_char(objc_msgSend_id(e, sel_registerName("characters")));
				strncpy(win->event.keyName, str, 16);

				RGFW_keyboard[win->event.keyCode].current = 0;
				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 0);
				break;
			}

			case NSEventTypeFlagsChanged: {
				u32 flags = objc_msgSend_uint(e, sel_registerName("modifierFlags"));
				RGFW_updateLockState(win, ((u32)(flags & NSEventModifierFlagCapsLock) % 255), ((flags & NSEventModifierFlagNumericPad) % 255));
				
				u8 i;
				for (i = 0; i < 9; i++)
					RGFW_keyboard[i + RGFW_CapsLock].prev = 0;
				
				for (i = 0; i < 5; i++) {
					u32 shift = (1 << (i + 16));
					u32 key = i + RGFW_CapsLock;

					if ((flags & shift) && !RGFW_wasPressed(win, key)) {
						RGFW_keyboard[key].current = 1;

						if (key != RGFW_CapsLock)
							RGFW_keyboard[key+ 4].current = 1;
						
						win->event.type = RGFW_keyPressed;
						win->event.keyCode = key;
						break;
					} 
					
					if (!(flags & shift) && RGFW_wasPressed(win, key)) {
						RGFW_keyboard[key].current = 0;
						
						if (key != RGFW_CapsLock)
							RGFW_keyboard[key + 4].current = 0;

						win->event.type = RGFW_keyReleased;
						win->event.keyCode = key;
						break;
					}
				}

				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, win->event.type == RGFW_keyPressed);

				break;
			}
			case NSEventTypeLeftMouseDragged:
			case NSEventTypeOtherMouseDragged:
			case NSEventTypeRightMouseDragged:
			case NSEventTypeMouseMoved:
				win->event.type = RGFW_mousePosChanged;
				NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(e, sel_registerName("locationInWindow"));
				win->event.point = RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));

				if ((win->_winArgs & RGFW_HOLD_MOUSE)) {
					p.x = ((CGFloat(*)(id, SEL))abi_objc_msgSend_fpret)(e, sel_registerName("deltaX"));
					p.y = ((CGFloat(*)(id, SEL))abi_objc_msgSend_fpret)(e, sel_registerName("deltaY"));
					
					win->event.point = RGFW_POINT((i32)p.x, (i32)p.y);
				}

				RGFW_mousePosCallback(win, win->event.point);
				break;

			case NSEventTypeLeftMouseDown:
				win->event.button = RGFW_mouseLeft;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case NSEventTypeOtherMouseDown:
				win->event.button = RGFW_mouseMiddle;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case NSEventTypeRightMouseDown:
				win->event.button = RGFW_mouseRight;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case NSEventTypeLeftMouseUp:
				win->event.button = RGFW_mouseLeft;
				win->event.type = RGFW_mouseButtonReleased;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

			case NSEventTypeOtherMouseUp:
				win->event.button = RGFW_mouseMiddle;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				win->event.type = RGFW_mouseButtonReleased;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

			case NSEventTypeRightMouseUp:
				win->event.button = RGFW_mouseRight;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				win->event.type = RGFW_mouseButtonReleased;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

			case NSEventTypeScrollWheel: {
				double deltaY = ((CGFloat(*)(id, SEL))abi_objc_msgSend_fpret)(e, sel_registerName("deltaY"));

				if (deltaY > 0) {
					win->event.button = RGFW_mouseScrollUp;
				}
				else if (deltaY < 0) {
					win->event.button = RGFW_mouseScrollDown;
				}

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;

				win->event.scroll = deltaY;

				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;
			}

			default:
				break;
		}

		objc_msgSend_void_id(NSApp, sel_registerName("sendEvent:"), e);
		((void(*)(id, SEL))objc_msgSend)(NSApp, sel_registerName("updateWindows"));
				
		objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
		return &win->event;
	}


	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);

		win->r.x = v.x;
		win->r.y = v.y;
		((void(*)(id, SEL, NSRect, bool, bool))objc_msgSend)
			(win->src.window, sel_registerName("setFrame:display:animate:"), (NSRect){{win->r.x, win->r.y}, {win->r.w, win->r.h}}, true, true);
	}

	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		win->r.w = a.w;
		win->r.h = a.h;
		((void(*)(id, SEL, NSRect, bool, bool))objc_msgSend)
			(win->src.window, sel_registerName("setFrame:display:animate:"), (NSRect){{win->r.x, win->r.y}, {win->r.w, win->r.h}}, true, true);
	}

	void RGFW_window_minimize(RGFW_window* win) {
		assert(win != NULL);

		objc_msgSend_void_SEL(win->src.window, sel_registerName("performMiniaturize:"), NULL);
	}

	void RGFW_window_restore(RGFW_window* win) {
		assert(win != NULL);

		objc_msgSend_void_SEL(win->src.window, sel_registerName("deminiaturize:"), NULL);
	}

	void RGFW_window_setName(RGFW_window* win, char* name) {
		assert(win != NULL);

		NSString* str = NSString_stringWithUTF8String(name);
		objc_msgSend_void_id(win->src.window, sel_registerName("setTitle:"), str);
	}

	#ifndef RGFW_NO_PASSTHROUGH
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIgnoresMouseEvents:"), passthrough);
	}
	#endif

	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		if (a.w == 0 && a.h == 0)
			return;

		((void (*)(id, SEL, NSSize))objc_msgSend)
			(win->src.window, sel_registerName("setMinSize:"), (NSSize){a.w, a.h});
	}

	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		if (a.w == 0 && a.h == 0)
			return;

		((void (*)(id, SEL, NSSize))objc_msgSend)
			(win->src.window, sel_registerName("setMaxSize:"), (NSSize){a.w, a.h});
	}

	void RGFW_window_setIcon(RGFW_window* win, u8* data, RGFW_area area, i32 channels) {
		assert(win != NULL);

		/* code by EimaMei  */
		// Make a bitmap representation, then copy the loaded image into it.
		void* representation = NSBitmapImageRep_initWithBitmapData(NULL, area.w, area.h, 8, channels, (channels == 4), false, "NSCalibratedRGBColorSpace", 1 << 1, area.w * channels, 8 * channels);
		memcpy(NSBitmapImageRep_bitmapData(representation), data, area.w * area.h * channels);

		// Add ze representation.
		void* dock_image = NSImage_initWithSize((NSSize){area.w, area.h});
		NSImage_addRepresentation(dock_image, (void*) representation);

		// Finally, set the dock image to it.
		objc_msgSend_void_id(NSApp, sel_registerName("setApplicationIconImage:"), dock_image);
		// Free the garbage.
		release(dock_image);
		release(representation);
	}

	NSCursor* NSCursor_arrowStr(char* str) {
		void* nclass = objc_getClass("NSCursor");
		void* func = sel_registerName(str);
		return (NSCursor*) objc_msgSend_id(nclass, func);
	}

	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		assert(win != NULL);

		if (image == NULL) {
			objc_msgSend_void(NSCursor_arrowStr("arrowCursor"), sel_registerName("set"));
			return;
		}

		/* NOTE(EimaMei): Code by yours truly. */
		// Make a bitmap representation, then copy the loaded image into it.
		void* representation = NSBitmapImageRep_initWithBitmapData(NULL, a.w, a.h, 8, channels, (channels == 4), false, "NSCalibratedRGBColorSpace", 1 << 1, a.w * channels, 8 * channels);
		memcpy(NSBitmapImageRep_bitmapData(representation), image, a.w * a.h * channels);

		// Add ze representation.
		void* cursor_image = NSImage_initWithSize((NSSize){a.w, a.h});
		NSImage_addRepresentation(cursor_image, representation);

		// Finally, set the cursor image.
		void* cursor = NSCursor_initWithImage(cursor_image, (NSPoint){0.0, 0.0});

		objc_msgSend_void(cursor, sel_registerName("set"));

		// Free the garbage.
		release(cursor_image);
		release(representation);
	}

	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_ARROW);
	}

	void RGFW_window_showMouse(RGFW_window* win, i8 show) {
		RGFW_UNUSED(win);

		if (show) {
			CGDisplayShowCursor(kCGDirectMainDisplay);
		}
		else {
			CGDisplayHideCursor(kCGDirectMainDisplay);
		}
	}

	void RGFW_window_setMouseStandard(RGFW_window* win, u8 stdMouses) {
		if (stdMouses > ((sizeof(RGFW_mouseIconSrc)) / (sizeof(char*))))
			return;
		
		char* mouseStr = RGFW_mouseIconSrc[stdMouses];
		void* mouse = NSCursor_arrowStr(mouseStr);

		if (mouse == NULL)
			return;

		RGFW_UNUSED(win);
		CGDisplayShowCursor(kCGDirectMainDisplay);
		objc_msgSend_void(mouse, sel_registerName("set"));
	}
	
	void RGFW_releaseCursor(RGFW_window* win) {
		RGFW_UNUSED(win);
		CGAssociateMouseAndMouseCursorPosition(1);	
	}

	void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) { 
		RGFW_UNUSED(win)

		CGWarpMouseCursorPosition(CGPointMake(r.x + (r.w / 2), r.y + (r.h / 2)));
		CGAssociateMouseAndMouseCursorPosition(0);
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) {
		RGFW_UNUSED(win);
		
		CGWarpMouseCursorPosition(CGPointMake(v.x, v.y));		
	}


	void RGFW_window_hide(RGFW_window* win) {
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIsVisible:"), false);
	}

	void RGFW_window_show(RGFW_window* win) {
		((id(*)(id, SEL, SEL))objc_msgSend)(win->src.window, sel_registerName("makeKeyAndOrderFront:"), NULL);
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIsVisible:"), true);
	}

	u8 RGFW_window_isFullscreen(RGFW_window* win) {
		assert(win != NULL);

		NSWindowStyleMask mask = (NSWindowStyleMask) objc_msgSend_uint(win->src.window, sel_registerName("styleMask"));
		return (mask & NSWindowStyleMaskFullScreen) == NSWindowStyleMaskFullScreen;
	}

	u8 RGFW_window_isHidden(RGFW_window* win) {
		assert(win != NULL);

		bool visible = objc_msgSend_bool(win->src.window, sel_registerName("isVisible"));
		return visible == NO && !RGFW_window_isMinimized(win);
	}

	u8 RGFW_window_isMinimized(RGFW_window* win) {
		assert(win != NULL);

		return objc_msgSend_bool(win->src.window, sel_registerName("isMiniaturized")) == YES;
	}

	u8 RGFW_window_isMaximized(RGFW_window* win) {
		assert(win != NULL);

		return objc_msgSend_bool(win->src.window, sel_registerName("isZoomed"));
	}

	static RGFW_monitor RGFW_NSCreateMonitor(CGDirectDisplayID display) {
		RGFW_monitor monitor;

		CGRect bounds = CGDisplayBounds(display);
		monitor.rect = RGFW_RECT((int) bounds.origin.x, (int) bounds.origin.y, (int) bounds.size.width, (int) bounds.size.height);

		CGSize screenSizeMM = CGDisplayScreenSize(display);
		monitor.physW = screenSizeMM.width / 25.4;
		monitor.physH = screenSizeMM.height / 25.4;

		monitor.scaleX = (monitor.rect.w / (screenSizeMM.width)) / 2.6;
		monitor.scaleY = (monitor.rect.h / (screenSizeMM.height)) / 2.6;

		snprintf(monitor.name, 128, "%i %i %i", CGDisplayModelNumber(display), CGDisplayVendorNumber(display), CGDisplaySerialNumber(display));

		return monitor;
	}


	static RGFW_monitor RGFW_monitors[7];

	RGFW_monitor* RGFW_getMonitors(void) {
		static CGDirectDisplayID displays[7];
		u32 count;

		if (CGGetActiveDisplayList(6, displays, &count) != kCGErrorSuccess)
			return NULL;

		for (u32 i = 0; i < count; i++)
			RGFW_monitors[i] = RGFW_NSCreateMonitor(displays[i]);

		return RGFW_monitors;
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
		CGDirectDisplayID primary = CGMainDisplayID();
		return RGFW_NSCreateMonitor(primary);
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		return RGFW_NSCreateMonitor(win->src.display);
	}

	char* RGFW_readClipboard(size_t* size) {
		char* clip = (char*)NSPasteboard_stringForType(NSPasteboard_generalPasteboard(), NSPasteboardTypeString);
		
		size_t clip_len = 1;

		if (clip != NULL) {
			clip_len = strlen(clip) + 1; 
		}

		char* str = (char*)RGFW_MALLOC(sizeof(char) * clip_len);
		
		if (clip != NULL) {
			strncpy(str, clip, clip_len);
		}

		str[clip_len] = '\0';
		
		if (size != NULL)
			*size = clip_len;
		return str;
	}

	void RGFW_writeClipboard(const char* text, u32 textLen) {
		RGFW_UNUSED(textLen);

		NSPasteboardType array[] = { NSPasteboardTypeString, NULL };
		NSPasteBoard_declareTypes(NSPasteboard_generalPasteboard(), array, 1, NULL);

		NSPasteBoard_setString(NSPasteboard_generalPasteboard(), text, NSPasteboardTypeString);
	}

	u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber) {
		RGFW_UNUSED(jsNumber);

		assert(win != NULL);

		return RGFW_registerJoystickF(win, (char*) "");
	}

	u16 RGFW_registerJoystickF(RGFW_window* win, char* file) {
		RGFW_UNUSED(file);

		assert(win != NULL);

		return RGFW_joystickCount - 1;
	}

	#ifdef RGFW_OPENGL
	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		assert(win != NULL);
		objc_msgSend_void(win->src.ctx, sel_registerName("makeCurrentContext"));
	}
	#endif

	#if !defined(RGFW_EGL)
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);
		#if defined(RGFW_OPENGL)
		
		NSOpenGLContext_setValues(win->src.ctx, &swapInterval, 222);
		#else
		RGFW_UNUSED(swapInterval);
		#endif
	}
	#endif
	
	// Function to create a CGImageRef from an array of bytes
	CGImageRef createImageFromBytes(unsigned char *buffer, int width, int height)
	{
		// Define color space
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        // Create bitmap context
        CGContextRef context = CGBitmapContextCreate(
        		buffer, 
        		width, height,
        		8,
        		RGFW_bufferSize.w * 4, 
        		colorSpace,
        		kCGImageAlphaPremultipliedLast);
        // Create image from bitmap context
        CGImageRef image = CGBitmapContextCreateImage(context);
        // Release the color space and context
        CGColorSpaceRelease(colorSpace);
        CGContextRelease(context);
                         
        return image;
    }

	void RGFW_window_swapBuffers(RGFW_window* win) {
		assert(win != NULL);
		/* clear the window*/

		if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			#ifdef RGFW_OSMESA
			RGFW_OSMesa_reorganize();
			#endif

			void* view = NSWindow_contentView(win->src.window);
			void* layer = objc_msgSend_id(view, sel_registerName("layer"));

			((void(*)(id, SEL, NSRect))objc_msgSend)(layer,
				sel_registerName("setFrame:"),
				(NSRect){{0, 0}, {win->r.w, win->r.h}});

            CGImageRef image = createImageFromBytes(win->buffer, win->r.w, win->r.h);
            // Get the current graphics context
            id graphicsContext = objc_msgSend_class(objc_getClass("NSGraphicsContext"), sel_registerName("currentContext"));
            // Get the CGContext from the current NSGraphicsContext
            id cgContext = objc_msgSend_id(graphicsContext, sel_registerName("graphicsPort"));
			// Draw the image in the context
			NSRect bounds = (NSRect){{0,0}, {win->r.w, win->r.h}};
		    CGContextDrawImage((void*)cgContext, *(CGRect*)&bounds, image);
          	// Flush the graphics context to ensure the drawing is displayed
            objc_msgSend_id(graphicsContext, sel_registerName("flushGraphics"));
            
            objc_msgSend_void_id(layer, sel_registerName("setContents:"), (id)image);
            objc_msgSend_id(layer, sel_registerName("setNeedsDisplay"));
            
            CGImageRelease(image);
#endif
		}

		if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) {
			#ifdef RGFW_EGL
					eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
			#elif defined(RGFW_OPENGL)
					objc_msgSend_void(win->src.ctx, sel_registerName("flushBuffer"));
			#endif
		}
	}

	void RGFW_window_close(RGFW_window* win) {
		assert(win != NULL);
		release(win->src.view);

#ifdef RGFW_ALLOC_DROPFILES
		{
			u32 i;
			for (i = 0; i < RGFW_MAX_DROPS; i++)
				RGFW_FREE(win->event.droppedFiles[i]);


			RGFW_FREE(win->event.droppedFiles);
		}
#endif
	
#ifdef RGFW_BUFFER
		release(win->src.bitmap);
		release(win->src.image);
#endif

		CVDisplayLinkStop(win->src.displayLink);
		CVDisplayLinkRelease(win->src.displayLink);

		RGFW_FREE(win);
	}

	u64 RGFW_getTimeNS(void) {
		static mach_timebase_info_data_t timebase_info;
		if (timebase_info.denom == 0) {
			mach_timebase_info(&timebase_info);
		}
		return mach_absolute_time() * timebase_info.numer / timebase_info.denom;
	}

	u64 RGFW_getTime(void) {
		static mach_timebase_info_data_t timebase_info;
		if (timebase_info.denom == 0) {
			mach_timebase_info(&timebase_info);
		}
		return (double) mach_absolute_time() * (double) timebase_info.numer / ((double) timebase_info.denom * 1e9);
	}
#endif /* RGFW_MACOS */

/*
	End of MaOS defines
*/

/*
	WEBASM defines
*/

#ifdef RGFW_WEBASM
RGFW_Event RGFW_events[20];
size_t RGFW_eventLen = 0;

EM_BOOL Emscripten_on_keydown(int eventType, const EmscriptenKeyboardEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);
	
	RGFW_events[RGFW_eventLen].type = RGFW_keyPressed;
	memcpy(RGFW_events[RGFW_eventLen].keyName, e->key, 16);
	RGFW_events[RGFW_eventLen].keyCode = RGFW_apiKeyCodeToRGFW(e->keyCode);
	RGFW_events[RGFW_eventLen].lockState = 0;
	RGFW_eventLen++;

	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].prev = RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current;
	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current = 1;
	RGFW_keyCallback(RGFW_root, RGFW_apiKeyCodeToRGFW(e->keyCode), RGFW_events[RGFW_eventLen].keyName, 0, 1);
	
    return EM_TRUE;
}

EM_BOOL Emscripten_on_keyup(int eventType, const EmscriptenKeyboardEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_keyReleased;
	memcpy(RGFW_events[RGFW_eventLen].keyName, e->key, 16);
	RGFW_events[RGFW_eventLen].keyCode = RGFW_apiKeyCodeToRGFW(e->keyCode);
	RGFW_events[RGFW_eventLen].lockState = 0;
	RGFW_eventLen++;

	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].prev = RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current;
	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current = 0;

	RGFW_keyCallback(RGFW_root, RGFW_apiKeyCodeToRGFW(e->keyCode), RGFW_events[RGFW_eventLen].keyName, 0, 0);

    return EM_TRUE;
}

EM_BOOL Emscripten_on_resize(int eventType, const EmscriptenUiEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_windowResized;
	RGFW_eventLen++;

	RGFW_windowResizeCallback(RGFW_root, RGFW_RECT(0, 0, e->windowInnerWidth, e->windowInnerHeight));
    return EM_TRUE;
}

EM_BOOL Emscripten_on_fullscreenchange(int eventType, const EmscriptenFullscreenChangeEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_windowResized;
	RGFW_eventLen++;

	RGFW_root->r = RGFW_RECT(0, 0, e->elementWidth, e->elementHeight);
	RGFW_windowResizeCallback(RGFW_root, RGFW_root->r);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_focusin(int eventType, const EmscriptenFocusEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData); RGFW_UNUSED(e);

	RGFW_events[RGFW_eventLen].type = RGFW_focusIn;
	RGFW_eventLen++;

	RGFW_root->event.inFocus = 1;
	RGFW_focusCallback(RGFW_root, 1);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_focusout(int eventType, const EmscriptenFocusEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData); RGFW_UNUSED(e);

	RGFW_events[RGFW_eventLen].type = RGFW_focusOut;
	RGFW_eventLen++;

	RGFW_root->event.inFocus = 0;
	RGFW_focusCallback(RGFW_root, 0);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_mousemove(int eventType, const EmscriptenMouseEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mousePosChanged;

	if ((RGFW_root->_winArgs & RGFW_HOLD_MOUSE)) {
		RGFW_point p = RGFW_POINT(e->movementX, e->movementY);
		RGFW_events[RGFW_eventLen].point = p;
	}
	else
		RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->targetX, e->targetY);
	RGFW_eventLen++;
	
	RGFW_mousePosCallback(RGFW_root, RGFW_events[RGFW_eventLen].point);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_mousedown(int eventType, const EmscriptenMouseEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonPressed;
	RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->targetX, e->targetY);
	RGFW_events[RGFW_eventLen].button = e->button + 1; 
	RGFW_events[RGFW_eventLen].scroll = 0;

	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 1;

	RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 1);
	RGFW_eventLen++;
	
    return EM_TRUE;
}

EM_BOOL Emscripten_on_mouseup(int eventType, const EmscriptenMouseEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonReleased;
	RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->targetX, e->targetY);
	RGFW_events[RGFW_eventLen].button = e->button + 1; 
	RGFW_events[RGFW_eventLen].scroll = 0;

	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 0;

	RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 0);
	RGFW_eventLen++;
    return EM_TRUE;
}

EM_BOOL Emscripten_on_wheel(int eventType, const EmscriptenWheelEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonPressed;
	RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->mouse.targetX, e->mouse.targetY);
	RGFW_events[RGFW_eventLen].button = RGFW_mouseScrollUp + (e->deltaY < 0); 
	RGFW_events[RGFW_eventLen].scroll = e->deltaY;

	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 1;

	RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 1);
	RGFW_eventLen++;

    return EM_TRUE;
}

EM_BOOL Emscripten_on_touchstart(int eventType, const EmscriptenTouchEvent* e, void* userData) { 
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

    size_t i; 
    for (i = 0; i < (size_t)e->numTouches; i++) { 
	    RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonPressed;
	    RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->touches[i].targetX, e->touches[i].targetY);
	    RGFW_events[RGFW_eventLen].button = 1; 
	    RGFW_events[RGFW_eventLen].scroll = 0;


	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 1;

        RGFW_mousePosCallback(RGFW_root, RGFW_events[RGFW_eventLen].point);

	    RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 1);
    	RGFW_eventLen++;
    }

	return EM_TRUE;
}
EM_BOOL Emscripten_on_touchmove(int eventType, const EmscriptenTouchEvent* e, void* userData) { 
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);
    
    size_t i; 
    for (i = 0; i < (size_t)e->numTouches; i++) { 
   	    RGFW_events[RGFW_eventLen].type = RGFW_mousePosChanged;
	    RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->touches[i].targetX, e->touches[i].targetY);

        RGFW_mousePosCallback(RGFW_root, RGFW_events[RGFW_eventLen].point);
	    RGFW_eventLen++;
    }
    return EM_TRUE;
}

EM_BOOL Emscripten_on_touchend(int eventType, const EmscriptenTouchEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);
	
    size_t i; 
    for (i = 0; i < (size_t)e->numTouches; i++) { 
	    RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonReleased;
	    RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->touches[i].targetX, e->touches[i].targetY);
	    RGFW_events[RGFW_eventLen].button = 1; 
	    RGFW_events[RGFW_eventLen].scroll = 0;

	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 0;
        
	    RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 0);
	    RGFW_eventLen++;
    }
	return EM_TRUE;
}

EM_BOOL Emscripten_on_touchcancel(int eventType, const EmscriptenTouchEvent* e, void* userData) { RGFW_UNUSED(eventType); RGFW_UNUSED(userData); RGFW_UNUSED(e); return EM_TRUE; }

EM_BOOL Emscripten_on_gamepad(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData) {	
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	if (gamepadEvent->index >= 4)
		return 0;

	RGFW_joysticks[gamepadEvent->index] = gamepadEvent->connected;

    return 1; // The event was consumed by the callback handler
}

void EMSCRIPTEN_KEEPALIVE Emscripten_onDrop(size_t count) {
	if (!(RGFW_root->_winArgs & RGFW_ALLOW_DND))
		return;

	RGFW_events[RGFW_eventLen].droppedFilesCount = count;	
	RGFW_dndCallback(RGFW_root, RGFW_events[RGFW_eventLen].droppedFiles, count);
	RGFW_eventLen++;
}

b8 RGFW_stopCheckEvents_bool = RGFW_FALSE;
void RGFW_stopCheckEvents(void) { 
	RGFW_stopCheckEvents_bool = RGFW_TRUE;
}

void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
	RGFW_UNUSED(win);

	if (waitMS == 0)
		return;
	
	u32 start = (u32)(((u64)RGFW_getTimeNS()) / 1e+6);

	while ((RGFW_eventLen == 0) && RGFW_stopCheckEvents_bool == RGFW_FALSE && 
		(waitMS < 0 || (RGFW_getTimeNS() / 1e+6) - start < waitMS)
	) {
		emscripten_sleep(0);
	}
	
	RGFW_stopCheckEvents_bool = RGFW_FALSE;
}

RGFWDEF void RGFW_init_buffer(RGFW_window* win);
void RGFW_init_buffer(RGFW_window* win) {
	#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
		if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
			RGFW_bufferSize = RGFW_getScreenSize();
		
		win->buffer = RGFW_MALLOC(RGFW_bufferSize.w * RGFW_bufferSize.h * 4);
	#ifdef RGFW_OSMESA
			win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
			OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
	#endif
	#else
	RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
	#endif
}

void EMSCRIPTEN_KEEPALIVE RGFW_makeSetValue(size_t index, char* file) { 
	/* This seems like a terrible idea, don't replicate this unless you hate yourself or the OS */
	/* TODO: find a better way to do this, 
		strcpy doesn't seem to work, maybe because of asyncio
	*/

	RGFW_events[RGFW_eventLen].type = RGFW_dnd;
	char** arr = (char**)&RGFW_events[RGFW_eventLen].droppedFiles[index];
	*arr = file;
}

#include <sys/stat.h>
#include <sys/types.h>
#include <errno.h>

void EMSCRIPTEN_KEEPALIVE RGFW_mkdir(char* name) { mkdir(name, 0755); }

void EMSCRIPTEN_KEEPALIVE RGFW_writeFile(const char *path, const char *data, size_t len) {
    FILE* file = fopen(path, "w+");
	if (file == NULL)
		return;

    fwrite(data, sizeof(char), len, file);
    fclose(file);
}

RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
	RGFW_UNUSED(name) 

	RGFW_UNUSED(RGFW_initFormatAttribs);
	
    RGFW_window* win = RGFW_window_basic_init(rect, args);

    EmscriptenWebGLContextAttributes attrs;
    attrs.alpha = EM_TRUE;
    attrs.depth = EM_TRUE;
	attrs.alpha = EM_TRUE;
    attrs.stencil = RGFW_STENCIL;
    attrs.antialias = RGFW_SAMPLES;
    attrs.premultipliedAlpha = EM_TRUE;
    attrs.preserveDrawingBuffer = EM_FALSE;
	
    if (RGFW_DOUBLE_BUFFER == 0)
        attrs.renderViaOffscreenBackBuffer = 0;
    else
        attrs.renderViaOffscreenBackBuffer = RGFW_AUX_BUFFERS;
    
    attrs.failIfMajorPerformanceCaveat = EM_FALSE;
	attrs.majorVersion = (RGFW_majorVersion == 0) ? 1 : RGFW_majorVersion;
	attrs.minorVersion = RGFW_minorVersion;
	
    attrs.enableExtensionsByDefault = EM_TRUE;
    attrs.explicitSwapControl = EM_TRUE;

    emscripten_webgl_init_context_attributes(&attrs);
    win->src.ctx = emscripten_webgl_create_context("#canvas", &attrs);
    emscripten_webgl_make_context_current(win->src.ctx);

	#ifdef LEGACY_GL_EMULATION
	EM_ASM("Module.useWebGL = true; GLImmediate.init();");	
	#endif

	emscripten_set_canvas_element_size("#canvas", rect.w, rect.h);
	emscripten_set_window_title(name);

	/* load callbacks */
    emscripten_set_keydown_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_keydown);
    emscripten_set_keyup_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_keyup);
    emscripten_set_resize_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_resize);
    emscripten_set_fullscreenchange_callback(EMSCRIPTEN_EVENT_TARGET_DOCUMENT, NULL, EM_FALSE, Emscripten_on_fullscreenchange);
    emscripten_set_mousemove_callback("#canvas", NULL, EM_FALSE, Emscripten_on_mousemove);
    emscripten_set_touchstart_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchstart);
    emscripten_set_touchend_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchend);
    emscripten_set_touchmove_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchmove);
    emscripten_set_touchcancel_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchcancel);
    emscripten_set_mousedown_callback("#canvas", NULL, EM_FALSE, Emscripten_on_mousedown);
    emscripten_set_mouseup_callback("#canvas", NULL, EM_FALSE, Emscripten_on_mouseup);
    emscripten_set_wheel_callback("#canvas", NULL, EM_FALSE, Emscripten_on_wheel);
    emscripten_set_focusin_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_focusin);
    emscripten_set_focusout_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_focusout);
	emscripten_set_gamepadconnected_callback(NULL, 1, Emscripten_on_gamepad);
	emscripten_set_gamepaddisconnected_callback(NULL, 1, Emscripten_on_gamepad);
	
	if (args & RGFW_ALLOW_DND)  {
		win->_winArgs |= RGFW_ALLOW_DND;
	}

    EM_ASM({
		var canvas = document.getElementById('canvas');
        canvas.addEventListener('drop', function(e) {
            e.preventDefault();
            if (e.dataTransfer.file < 0)
				return;

			var filenamesArray = [];
			var count = e.dataTransfer.files.length;

			/* Read and save the files to emscripten's files */
			var drop_dir = '.rgfw_dropped_files';
			Module._RGFW_mkdir(drop_dir);

			for (var i = 0; i < count; i++) {
				var file = e.dataTransfer.files[i];

				var path = '/' + drop_dir + '/' + file.name.replace("//", '_');
				var reader = new FileReader();
				
				reader.onloadend = (e) => {
					if (reader.readyState != 2) {
						out('failed to read dropped file: '+file.name+': '+reader.error);
					}
					else {
						var data = e.target.result;
						
						_RGFW_writeFile(path, new Uint8Array(data), file.size);
					}
				};

				reader.readAsArrayBuffer(file);		
				// This works weird on modern opengl
				var filename = stringToNewUTF8(path);

				filenamesArray.push(filename);
				
				Module._RGFW_makeSetValue(i, filename);
			}
			
			Module._Emscripten_onDrop(count);
			
			for (var i = 0; i < count; ++i) {
				_free(filenamesArray[i]);
			}
        }, true);

        canvas.addEventListener('dragover', function(e) { e.preventDefault(); return false; }, true);
    });

	RGFW_init_buffer(win);
	glViewport(0, 0, rect.w, rect.h);
	
	RGFW_root = win; 

	if (args & RGFW_HIDE_MOUSE) {
		RGFW_window_showMouse(win, 0);
	}

	if (args & RGFW_FULLSCREEN) {
		RGFW_window_resize(win, RGFW_getScreenSize());
	}

    return win;
}

RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
	static u8 index = 0;
	
	if (index == 0) 
		RGFW_resetKey();

	/* check gamepads */
    for (int i = 0; (i < emscripten_get_num_gamepads()) && (i < 4); i++) {
		if (RGFW_joysticks[i] == 0)
			continue;;
		
        EmscriptenGamepadEvent gamepadState;

        if (emscripten_get_gamepad_status(i, &gamepadState) != EMSCRIPTEN_RESULT_SUCCESS)
			break;

		// Register buttons data for every connected gamepad
		for (int j = 0; (j < gamepadState.numButtons) && (j < 16); j++) {
			u32 map[] = {
				RGFW_JS_A, RGFW_JS_X, RGFW_JS_B, RGFW_JS_Y,
				RGFW_JS_L1, RGFW_JS_R1, RGFW_JS_L2, RGFW_JS_R2,
				RGFW_JS_SELECT, RGFW_JS_START,
				0, 0,
				RGFW_JS_UP, RGFW_JS_DOWN, RGFW_JS_LEFT, RGFW_JS_RIGHT
			};

			u32 button = map[j]; 
			if (RGFW_jsPressed[i][button] != gamepadState.digitalButton[j]) {
				win->event.type = RGFW_jsButtonPressed;
				win->event.joystick = i;
				win->event.button = map[j];
				return &win->event;
			}

			RGFW_jsPressed[i][button] = gamepadState.digitalButton[j];
		}

		for (int j = 0; (j < gamepadState.numAxes) && (j < 4); j += 2) {
			win->event.axisesCount = gamepadState.numAxes;
			if (win->event.axis[j].x != gamepadState.axis[j] || 
				win->event.axis[j].y != gamepadState.axis[j + 1]
			) {
				win->event.axis[j].x = gamepadState.axis[j];
				win->event.axis[j].y = gamepadState.axis[j + 1];
				win->event.type = RGFW_jsAxisMove;
				win->event.joystick = i;
				return &win->event;
			}
		}
    }

	/* check queued events */
	if (RGFW_eventLen == 0)
		return NULL;
	
	RGFW_events[index].frameTime = win->event.frameTime;
	RGFW_events[index].frameTime2 = win->event.frameTime2;
	RGFW_events[index].inFocus = win->event.inFocus;

	win->event = RGFW_events[index];

	RGFW_eventLen--;

	if (RGFW_eventLen)
		index++;
	else
		index = 0;

	return &win->event;
}

void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
	RGFW_UNUSED(win)
	emscripten_set_canvas_element_size("#canvas", a.w, a.h);
}

/* NOTE: I don't know if this is possible */
void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) { RGFW_UNUSED(win); RGFW_UNUSED(v); }
/* this one might be possible but it looks iffy */
void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) { RGFW_UNUSED(win); RGFW_UNUSED(channels) RGFW_UNUSED(a) RGFW_UNUSED(image) }

const char RGFW_CURSORS[11][12] = {
    "default",
    "default",
    "text",
    "crosshair",
    "pointer",
    "ew-resize",
    "ns-resize",
    "nwse-resize",
    "nesw-resize",
    "move",
    "not-allowed"
};

void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
	RGFW_UNUSED(win)
	EM_ASM( { document.getElementById("canvas").style.cursor = UTF8ToString($0); }, RGFW_CURSORS[mouse]);
}

void RGFW_window_setMouseDefault(RGFW_window* win) {
	RGFW_window_setMouseStandard(win, RGFW_MOUSE_NORMAL);
}

void RGFW_window_showMouse(RGFW_window* win, i8 show) {
	if (show)
		RGFW_window_setMouseDefault(win);
	else
		EM_ASM(document.getElementById('canvas').style.cursor = 'none';);
}

RGFW_point RGFW_getGlobalMousePoint(void) {
    RGFW_point point;
    point.x = EM_ASM_INT({
        return window.mouseX || 0;
    });
    point.y = EM_ASM_INT({
        return window.mouseY || 0;
    });
    return point;
}

RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
	RGFW_UNUSED(win);
	
	EmscriptenMouseEvent mouseEvent;
    emscripten_get_mouse_status(&mouseEvent);
	return RGFW_POINT( mouseEvent.targetX,  mouseEvent.targetY);
}

void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
	RGFW_UNUSED(win);

    EM_ASM_({
        var canvas = document.getElementById('canvas');
        if ($0) {
            canvas.style.pointerEvents = 'none';
        } else {
            canvas.style.pointerEvents = 'auto';
        }
    }, passthrough);
}

void RGFW_writeClipboard(const char* text, u32 textLen) {
	RGFW_UNUSED(textLen)
	EM_ASM({ navigator.clipboard.writeText(UTF8ToString($0)); }, text);
}


char* RGFW_readClipboard(size_t* size) {
	/*
		placeholder code for later
		I'm not sure if this is possible do the the async stuff
	*/
	
	if (size != NULL)
		*size = 0;
	
	char* str = (char*)malloc(1);
	str[0] = '\0';

	return str;
}

void RGFW_window_swapBuffers(RGFW_window* win) {
	RGFW_UNUSED(win);
	
	#ifdef RGFW_BUFFER
	if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {		
		glEnable(GL_TEXTURE_2D);

		GLuint texture;
		glGenTextures(1,&texture);

		glBindTexture(GL_TEXTURE_2D,texture);
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, RGFW_bufferSize.w, RGFW_bufferSize.h, 0, GL_RGBA, GL_UNSIGNED_BYTE, win->buffer);
		
		float ratioX = ((float)win->r.w / (float)RGFW_bufferSize.w);
		float ratioY = ((float)win->r.h / (float)RGFW_bufferSize.h);

		// Set up the viewport
		glClear(GL_COLOR_BUFFER_BIT);

		glBegin(GL_TRIANGLES);
			glTexCoord2f(0, ratioY); glColor3f(1, 1, 1); glVertex2f(-1, -1);
			glTexCoord2f(0, 0); glColor3f(1, 1, 1); glVertex2f(-1, 1);
			glTexCoord2f(ratioX, ratioY); glColor3f(1, 1, 1); glVertex2f(1, -1);

			glTexCoord2f(ratioX, 0); glColor3f(1, 1, 1); glVertex2f(1, 1);
			glTexCoord2f(ratioX, ratioY); glColor3f(1, 1, 1); glVertex2f(1, -1);
			glTexCoord2f(0, 0); glColor3f(1, 1, 1); glVertex2f(-1, 1);
		glEnd();

		glDeleteTextures(1, &texture);
	}
	#endif

	emscripten_webgl_commit_frame();
	emscripten_sleep(0);
}


void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
	if (win == NULL)
	    emscripten_webgl_make_context_current(0);
	else
	    emscripten_webgl_make_context_current(win->src.ctx);
}

#ifndef RGFW_EGL
void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) { RGFW_UNUSED(win); RGFW_UNUSED(swapInterval); }
#endif

void RGFW_window_close(RGFW_window* win) {
    emscripten_webgl_destroy_context(win->src.ctx);

    free(win);
}

int RGFW_innerWidth(void) {   return EM_ASM_INT({ return window.innerWidth; });  }
int RGFW_innerHeight(void) {  return EM_ASM_INT({ return window.innerHeight; });  }

RGFW_area RGFW_getScreenSize(void) {
	return RGFW_AREA(RGFW_innerWidth(), RGFW_innerHeight());
}

void* RGFW_getProcAddress(const char* procname) { 
	return emscripten_webgl_get_proc_address(procname);
}

void RGFW_sleep(u64 milisecond) {
	emscripten_sleep(milisecond);
}

u64 RGFW_getTimeNS(void) {
	return emscripten_get_now() * 1e+6;
}

u64 RGFW_getTime(void) {
	return emscripten_get_now() * 1000;
}

void RGFW_releaseCursor(RGFW_window* win) {
	RGFW_UNUSED(win);
	emscripten_exit_pointerlock();
}

void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) { 
	RGFW_UNUSED(win); RGFW_UNUSED(r);

	emscripten_request_pointerlock("#canvas", 1);
}


void RGFW_window_setName(RGFW_window* win, char* name) {
	RGFW_UNUSED(win);
	emscripten_set_window_title(name);
}

/* unsupported functions */
RGFW_monitor* RGFW_getMonitors(void) { return NULL; }
RGFW_monitor RGFW_getPrimaryMonitor(void) { return (RGFW_monitor){}; }
void RGFW_window_move(RGFW_window* win, RGFW_point v) { RGFW_UNUSED(win) RGFW_UNUSED(v) }
void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) { RGFW_UNUSED(win) RGFW_UNUSED(a)  }
void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) { RGFW_UNUSED(win) RGFW_UNUSED(a)  }
void RGFW_window_minimize(RGFW_window* win) { RGFW_UNUSED(win)}
void RGFW_window_restore(RGFW_window* win) { RGFW_UNUSED(win) }
void RGFW_window_setBorder(RGFW_window* win, b8 border) { RGFW_UNUSED(win) RGFW_UNUSED(border)  }
void RGFW_window_setIcon(RGFW_window* win, u8* icon, RGFW_area a, i32 channels) { RGFW_UNUSED(win) RGFW_UNUSED(icon) RGFW_UNUSED(a) RGFW_UNUSED(channels)  }
void RGFW_window_hide(RGFW_window* win) { RGFW_UNUSED(win) }
void RGFW_window_show(RGFW_window* win) {RGFW_UNUSED(win) }
b8 RGFW_window_isHidden(RGFW_window* win) { RGFW_UNUSED(win) return 0; }
b8 RGFW_window_isMinimized(RGFW_window* win) { RGFW_UNUSED(win) return 0; }
b8 RGFW_window_isMaximized(RGFW_window* win) { RGFW_UNUSED(win) return 0; }
RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) { RGFW_UNUSED(win) return (RGFW_monitor){}; }

#endif

/* end of web asm defines */

/* unix (macOS, linux, web asm) only stuff */
#if defined(RGFW_X11) || defined(RGFW_MACOS) || defined(RGFW_WEBASM)  || defined(RGFW_WAYLAND)
/* unix threading */
#ifndef RGFW_NO_THREADS
#include <pthread.h>

	RGFW_thread RGFW_createThread(RGFW_threadFunc_ptr ptr, void* args) {
		RGFW_UNUSED(args);
		
		RGFW_thread t;
		pthread_create((pthread_t*) &t, NULL, *ptr, NULL);
		return t;
	}
	void RGFW_cancelThread(RGFW_thread thread) { pthread_cancel((pthread_t) thread); }
	void RGFW_joinThread(RGFW_thread thread) { pthread_join((pthread_t) thread, NULL); }
#ifdef __linux__
	void RGFW_setThreadPriority(RGFW_thread thread, u8 priority) { pthread_setschedprio((pthread_t)thread, priority); }
#endif
#endif

#ifndef RGFW_WEBASM
/* unix sleep */
	void RGFW_sleep(u64 ms) {
		struct timespec time;
		time.tv_sec = 0;
		time.tv_nsec = ms * 1e+6;

		nanosleep(&time, NULL);
	}
#endif

#endif /* end of unix / mac stuff*/
#endif /*RGFW_IMPLEMENTATION*/

#if defined(__cplusplus) && !defined(__EMSCRIPTEN__)
}
#endif
#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_vector rotateAroundCenter(RSoft_vector v, RSoft_vector center, RSoft_vector player, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_simpleRotateMatrix(m, angle);
	m = RSoft_translateMatrix(m, center);
	m = RSoft_translateMatrix(m, RSOFT_VECTOR3D(-player.x, -player.y, -player.z));
	return RSoft_applyMatrix(m, v);
}

void drawLine(RGFW_window* win, RSoft_vector center, RSoft_vector player, float angle, RSoft_vector v1, RSoft_vector v2) {
	v1 = rotateAroundCenter(v1, center, player, angle);
	v2 = rotateAroundCenter(v2, center, player, angle);

	RSoft_setMatrix(RSoft_initMatrix());

	if (RGFW_isPressed(win, RGFW_Tab)) {
		RSoft_drawLineF(win->buffer, v1, v2, (u8[4]){255, 225, 225, 255});
	} else {
		v1.x = (-(v1.x * 200)) / (v1.y - (center.y));
		v1.y = (v1.z * 200) / (v1.y - (center.y)) + center.y;	

		v2.x = (-(v2.x * 200)) / (v2.y - (center.y));	
		v2.y = (v2.z * 200) / (v2.y - (center.y)) + center.y;	
		
		if (v1.x >= 0 && v1.y >= 0 && v2.x >= 0 && v2.y >= 0) 
			RSoft_drawLineF(win->buffer, v1, v2, (u8[4]){255, 225, 225, 255});
	}
}

u8* buffer = NULL;
int w, h, c;

void drawWall(RGFW_window* win, RSoft_vector center, RSoft_vector player, float angle, RSoft_rectF rect) {
	for (float i = 0; i < rect.h; i += 0.1) {
		RSoft_setTexture(buffer, RSOFT_RECT(0, i, w, h), RSOFT_AREA(w, h));
		drawLine(win, center, player, angle, RSOFT_VECTOR3D(rect.x, rect.y, i), RSOFT_VECTOR3D(rect.x + rect.w, rect.y, i));
	}
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Doom-Like example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));

	buffer = stbi_load("wall2.jpg", &w, &h, &c, 4);

	float angle = 0;
	float fov = 120;

	RSoft_vector center = RSOFT_VECTOR2D(win->r.w / 2, win->r.h / 2);

	RSoft_vector player = RSOFT_VECTOR3D(0, 0, 10);

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        } 
			
		if (RGFW_isPressed(win, RGFW_w)) {
			RSoft_vector next = RSOFT_VECTOR3D(player.x - RSoft_cos(angle + 90), 
											   player.y - RSoft_sin(angle + 90),
											   player.z);

			player = next;
		}
		if (RGFW_isPressed(win, RGFW_s)){
			RSoft_vector next = RSOFT_VECTOR3D(player.x + RSoft_cos(angle + 90), 
											   player.y + RSoft_sin(angle + 90),
											   player.z);
			player = next;
		}

		if (RGFW_isPressed(win, RGFW_a)) {
			RSoft_vector next = RSOFT_VECTOR3D(player.x + RSoft_cos(angle), 
											   player.y + RSoft_sin(angle),
											   player.z);

			player = next;
		}

		if (RGFW_isPressed(win, RGFW_d)) {
			RSoft_vector next = RSOFT_VECTOR3D(player.x - RSoft_cos(angle), 
											   player.y - RSoft_sin(angle),
											   player.z);
			
			player = next;
		}

		if (RGFW_isPressed(win, RGFW_Left))
			angle += 0.5;	
		if (RGFW_isPressed(win, RGFW_Right))
			angle -= 0.5;

		if (RGFW_isPressed(win, RGFW_Up))
			player.z -= 5;	
		if (RGFW_isPressed(win, RGFW_Down))
			player.z += 5;

		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 255});
		RSoft_setMatrix(RSoft_initMatrix());
		
		if (RGFW_isPressed(win, RGFW_Tab)) {
			RSoft_matrix m = RSoft_initMatrix();
			m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
			m = RSoft_simpleRotateMatrix(m, angle - 90);
			m = RSoft_translateMatrix(m, center);
			RSoft_setMatrix(m);
			
			RSoft_drawPolygon(win->buffer, RSOFT_RECT(center.x - 10, center.y - 5, 20, 10), 3, (u8[4]){255, 0, 0, 255});
		}

		drawWall(win, center, player, angle, RSOFT_RECTF(200, 200, 200, 20));

		RGFW_window_swapBuffers(win);
    }
	
	free(buffer);
    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/doom-like.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="doom-like.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_matrix rotateAroundCenter(RSoft_vector center, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_rotateMatrix(m, angle, 1, 1, 1);
	m = RSoft_translateMatrix(m, center);
	return m;
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Raycaster example", RGFW_RECT(0, 0, 1100, 800), RGFW_CENTER);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));

	int w, h, c;
	u8* buffer = stbi_load("wall.jpg", &w, &h, &c, 4);

	const u32 map_width = 20;
	const u32 map_height = 20;
	
	u8 map[] = {
		1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
		1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
		1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	};

	float angle = 0;
	float fov = 120;
	float precision = 64; 

	RSoft_vector player = RSOFT_VECTOR2D(5, 7);

	RGFW_window_mouseHold(win, RGFW_AREA(0, 0));
	RGFW_window_showMouse(win, 0);

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_mousePosChanged) {
				angle += (win->event.point.x / 15);	
				if (angle >= 360)
					angle -= 360;
				if (angle < 0)
					angle += 360;

			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        }
		
		if (RGFW_isPressed(win, RGFW_w)) {
			RSoft_vector next = RSOFT_VECTOR2D(player.x + RSoft_cos(angle) / 20, 
											   player.y + RSoft_sin(angle) / 20);

			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}
		if (RGFW_isPressed(win, RGFW_s)){
			RSoft_vector next = RSOFT_VECTOR2D(player.x - RSoft_cos(angle) / 20, 
											   player.y - RSoft_sin(angle) / 20);
			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}

		if (RGFW_isPressed(win, RGFW_a)) {
			RSoft_vector next = RSOFT_VECTOR2D(player.x - RSoft_cos(angle + 90) / 20, 
											   player.y - RSoft_sin(angle + 90) / 20);

			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}

		if (RGFW_isPressed(win, RGFW_d)) {
			RSoft_vector next = RSOFT_VECTOR2D(player.x + RSoft_cos(angle + 90) / 20, 
											   player.y + RSoft_sin(angle + 90) / 20);

			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}

		if (RGFW_isPressed(win, RGFW_Left)) {
			angle -= 5;
;
			if (angle < 0)
				angle += 360;
		}
		if (RGFW_isPressed(win, RGFW_Right)) {
			angle += 5;
			if (angle >= 360)
				angle -= 360;
		}
	

		RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 1, 1), RSOFT_AREA(w, h));
		RSoft_clear(win->buffer, (u8[4]){30, 130, 180, 255});
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(0, win->r.h / 3, win->r.w, win->r.h), (u8[4]){10, 100, 10, 255});	

		float rayAngle = angle - (fov / 2);
		for (size_t i = 0; i < win->r.w; i++) {
			RSoft_vector ray = player;
			rayAngle += (fov / win->r.w);
			
			while (map[(size_t)((size_t)ray.y * map_width) + (size_t)ray.x] == 0) {
				ray.x += cos(rayAngle * DEG2RAD) / precision;
				ray.y += sin(rayAngle * DEG2RAD) / precision;
			}


			if (RGFW_isPressed(win, RGFW_Tab)) {
				RSoft_drawLineF(win->buffer, RSOFT_VECTOR2D(player.x * 50, player.y * 50), RSOFT_VECTOR2D(ray.x * 50, ray.y * 50),  (u8[4]){200, 100, 20, 255});
				continue;
			}

			float dist = (sqrt(pow(player.x - ray.x, 2) + pow(player.y - ray.y, 2)));
			dist *= cos((rayAngle - angle) * DEG2RAD);
			dist += 1;
			
			float height = (win->r.h / 1) / dist;	
			
			if ((rayAngle >= -(fov / 2) && rayAngle <= (fov / 2)) || (rayAngle >= 300))
				RSoft_setTexture(buffer, RSOFT_RECT(sin(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));
			
			if (rayAngle >= 180 - (fov / 2) && rayAngle <= 180 + (fov / 2))
				RSoft_setTexture(buffer, RSOFT_RECT(-sin(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));

			if (rayAngle >= 90 - (fov / 2) && rayAngle <= 90 + (fov / 2))
				RSoft_setTexture(buffer, RSOFT_RECT(-cos(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));

			if (rayAngle >= 220 && rayAngle <= 300)
				RSoft_setTexture(buffer, RSOFT_RECT(cos(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));

			RSoft_drawRectF(win->buffer, RSOFT_RECTF(i, win->r.h / 3.5, 1, height), (u8[4]){255, 255, 255, 255});	
		}
			

		if (RGFW_isPressed(win, RGFW_Tab)) {
			for (size_t y = 0; y < map_height; y++) {
				for (size_t x = 0; x < map_width; x++) {
					if (map[(y * map_width) + x]) {
						RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 50, 50), RSOFT_AREA(w, h));
						RSoft_drawRect(win->buffer, RSOFT_RECT(x * 50, y * 50, 50, 50), (u8[4]){255, 255, 255, 255});	
					}
				}
			}

			RSoft_drawRect(win->buffer, RSOFT_RECT((player.x * 50) - 10, (player.y * 50) - 10, 20, 20), (u8[4]){255, 0, 0, 255});	
		}

		RGFW_window_swapBuffers(win);
    }
	
	free(buffer);
    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/raycaster.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="raycaster.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_matrix rotateAroundCenter(RSoft_vector center, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_rotateMatrix(m, angle, 1, 1, 1);
	m = RSoft_translateMatrix(m, center);
	return m;
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Shapes example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
	
	float angle = 0;

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        } 
		
		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 15});
		RSoft_vector v1 = RSOFT_VECTOR2D(700, 100);	
		RSoft_vector v2 = RSOFT_VECTOR2D(500, 100);	
		RSoft_vector v3 = RSOFT_VECTOR2D(600, 200);

		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 150), angle));
		RSoft_drawTriangleF(win->buffer, (RSoft_vector[3]){v1, v2, v3}, (u8[4]){0, 255, 0, 255});
	
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(250, 250), angle));
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(150, 150, 200, 200), (u8[4]){0, 255, 0, 255}); 
		
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(200, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(200, 600, 100, 100), 6, (u8[4]){0, 255, 0, 255});
	
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(500, 600, 100, 100), 36, (u8[4]){0, 255, 0, 255});

		angle++;
		RGFW_window_swapBuffers(win);
    }

    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/shapes.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="shapes.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
/* stb_image - v2.27 - public domain image loader - http://nothings.org/stb
                                  no warranty implied; use at your own risk

   Do this:
      #define STB_IMAGE_IMPLEMENTATION
   before you include this file in *one* C or C++ file to create the implementation.

   // i.e. it should look like this:
   #include ...
   #include ...
   #include ...
   #define STB_IMAGE_IMPLEMENTATION
   #include "stb_image.h"

   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free


   QUICK NOTES:
      Primarily of interest to game developers and other people who can
          avoid problematic images and only need the trivial interface

      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
      PNG 1/2/4/8/16-bit-per-channel

      TGA (not sure what subset, if a subset)
      BMP non-1bpp, non-RLE
      PSD (composited view only, no extra channels, 8/16 bit-per-channel)

      GIF (*comp always reports as 4-channel)
      HDR (radiance rgbE format)
      PIC (Softimage PIC)
      PNM (PPM and PGM binary only)

      Animated GIF still needs a proper API, but here's one way to do it:
          http://gist.github.com/urraka/685d9a6340b26b830d49

      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
      - decode from arbitrary I/O callbacks
      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)

   Full documentation under "DOCUMENTATION" below.


LICENSE

  See end of file for license information.

RECENT REVISION HISTORY:

      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes
      2.26  (2020-07-13) many minor fixes
      2.25  (2020-02-02) fix warnings
      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
      2.23  (2019-08-11) fix clang static analysis warning
      2.22  (2019-03-04) gif fixes, fix warnings
      2.21  (2019-02-25) fix typo in comment
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
                         RGB-format JPEG; remove white matting in PSD;
                         allocate large structures on the stack;
                         correct channel count for PNG & BMP
      2.10  (2016-01-22) avoid warning introduced in 2.09
      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED

   See end of file for full revision history.


 ============================    Contributors    =========================

 Image formats                          Extensions, features
    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
    Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
    Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
    github:urraka (animated gif)           Junggon Kim (PNM comments)
    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
                                           socks-the-fox (16-bit PNG)
                                           Jeremy Sawicki (handle all ImageNet JPGs)
 Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)
    John-Mark Allen
    Carmelo J Fdez-Aguera

 Bug & warning fixes
    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko
    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski
    Phil Jordan                                Dave Moore           Roy Eltham
    Hayaki Saito            Nathan Reed        Won Chun
    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community
    Thomas Ruf              Ronny Chevalier                         github:rlyeh
    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou
    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk
    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar
    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex
    Cass Everitt            Ryamond Barbiero                        github:grim210
    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw
    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus
    Josh Tobin                                 Matthew Gregan       github:poppolopoppo
    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji
    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007
                            Brad Weinberger    Matvey Cherevko      github:mosra
    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]
    Ryan C. Gordon          [reserved]                              [reserved]
                     DO NOT ADD YOUR NAME HERE

                     Jacko Dirks

  To add your name to the credits, pick a random blank space in the middle and fill it.
  80% of merge conflicts on stb PRs are due to people adding their name at the end
  of the credits.
*/

#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x                 -- outputs image width in pixels
//    int *y                 -- outputs image height in pixels
//    int *channels_in_file  -- outputs # of image components in image file
//    int desired_channels   -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'desired_channels' if desired_channels is non-zero, or
// *channels_in_file otherwise. If desired_channels is non-zero,
// *channels_in_file has the number of components that _would_ have been
// output otherwise. E.g. if you set desired_channels to 4, you will always
// get RGBA output, but you can check *channels_in_file to see if it's trivially
// opaque because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *channels_in_file will be unchanged. The function
// stbi_failure_reason() can be queried for an extremely brief, end-user
// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// To query the width, height and component count of an image without having to
// decode the full file, you can use the stbi_info family of functions:
//
//   int x,y,n,ok;
//   ok = stbi_info(filename, &x, &y, &n);
//   // returns ok=1 and sets x, y, n if image is a supported format,
//   // 0 otherwise.
//
// Note that stb_image pervasively uses ints in its public API for sizes,
// including sizes of memory buffers. This is now part of the API and thus
// hard to change without causing breakage. As a result, the various image
// loaders all have certain limits on image size; these differ somewhat
// by format but generally boil down to either just under 2GB or just under
// 1GB. When the decoded image would be larger than this, stb_image decoding
// will fail.
//
// Additionally, stb_image will reject image files that have any of their
// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,
// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,
// the only way to have an image with such dimensions load correctly
// is for it to have a rather extreme aspect ratio. Either way, the
// assumption here is that such larger images are likely to be malformed
// or malicious. If you do need to load an image with individual dimensions
// larger than that, and it still fits in the overall size limit, you can
// #define STBI_MAX_DIMENSIONS on your own to be something larger.
//
// ===========================================================================
//
// UNICODE:
//
//   If compiling for Windows and you wish to use Unicode filenames, compile
//   with
//       #define STBI_WINDOWS_UTF8
//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
//   Windows wchar_t filenames to utf8.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy-to-use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// provide more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small source code footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image supports loading HDR images in general, and currently the Radiance
// .HDR file format specifically. You can still load any file through the existing
// interface; if you attempt to load an HDR file, it will be automatically remapped
// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// We optionally support converting iPhone-formatted PNGs (which store
// premultiplied BGRA) back to RGB, even though they're internally encoded
// differently. To enable this conversion, call
// stbi_convert_iphone_png_to_rgb(1).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// ADDITIONAL CONFIGURATION
//
//  - You can suppress implementation of any of the decoders to reduce
//    your code footprint by #defining one or more of the following
//    symbols before creating the implementation.
//
//        STBI_NO_JPEG
//        STBI_NO_PNG
//        STBI_NO_BMP
//        STBI_NO_PSD
//        STBI_NO_TGA
//        STBI_NO_GIF
//        STBI_NO_HDR
//        STBI_NO_PIC
//        STBI_NO_PNM   (.ppm and .pgm)
//
//  - You can request *only* certain decoders and suppress all other ones
//    (this will be more forward-compatible, as addition of new decoders
//    doesn't require you to disable them explicitly):
//
//        STBI_ONLY_JPEG
//        STBI_ONLY_PNG
//        STBI_ONLY_BMP
//        STBI_ONLY_PSD
//        STBI_ONLY_TGA
//        STBI_ONLY_GIF
//        STBI_ONLY_HDR
//        STBI_ONLY_PIC
//        STBI_ONLY_PNM   (.ppm and .pgm)
//
//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
//
//  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater
//    than that size (in either width or height) without further processing.
//    This is to let programs in the wild set an upper bound to prevent
//    denial-of-service attacks on untrusted data, as one could generate a
//    valid image of gigantic dimensions and force stb_image to allocate a
//    huge block of memory and spend disproportionate time decoding it. By
//    default this is set to (1 << 24), which is 16777216, but that's still
//    very big.

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
   STBI_default = 0, // only used for desired_channels

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4
};

#include <stdlib.h>
typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;

#ifdef __cplusplus
extern "C" {
#endif

#ifndef STBIDEF
#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif
#endif

//////////////////////////////////////////////////////////////////////////////
//
// PRIMARY API - works on images of any type
//

//
// load image by filename, open file, or memory buffer
//

typedef struct
{
   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
} stbi_io_callbacks;

////////////////////////////////////
//
// 8-bits-per-channel interface
//

STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
#endif

#ifdef STBI_WINDOWS_UTF8
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
#endif

////////////////////////////////////
//
// 16-bits-per-channel interface
//

STBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
#endif

////////////////////////////////////
//
// float-per-channel interface
//
#ifndef STBI_NO_LINEAR
   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);

   #ifndef STBI_NO_STDIO
   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
   #endif
#endif

#ifndef STBI_NO_HDR
   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
#endif // STBI_NO_HDR

#ifndef STBI_NO_LINEAR
   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_LINEAR

// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename);
STBIDEF int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO


// get a VERY brief reason for failure
// on most compilers (and ALL modern mainstream compilers) this is threadsafe
STBIDEF const char *stbi_failure_reason  (void);

// free the loaded image -- this is just free()
STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);

// get image dimensions & components without fully decoding
STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit          (char const *filename);
STBIDEF int      stbi_is_16_bit_from_file(FILE *f);
#endif



// for image formats that explicitly notate that they have premultiplied alpha,
// we just return the colors as stored in the file. set this flag to force
// unpremultiplication. results are undefined if the unpremultiply overflow.
STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

// indicate whether we should process iphone images back to canonical format,
// or just pass them through "as-is"
STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

// flip the image vertically, so the first pixel in the output array is the bottom left
STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);

// as above, but only applies to images loaded on the thread that calls the function
// this function is only available if your compiler supports thread-local variables;
// calling it will fail to link if your compiler doesn't
STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);
STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);
STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);

// ZLIB client - used by PNG, available for other purposes

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);


#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifdef STB_IMAGE_IMPLEMENTATION

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
   #ifndef STBI_ONLY_JPEG
   #define STBI_NO_JPEG
   #endif
   #ifndef STBI_ONLY_PNG
   #define STBI_NO_PNG
   #endif
   #ifndef STBI_ONLY_BMP
   #define STBI_NO_BMP
   #endif
   #ifndef STBI_ONLY_PSD
   #define STBI_NO_PSD
   #endif
   #ifndef STBI_ONLY_TGA
   #define STBI_NO_TGA
   #endif
   #ifndef STBI_ONLY_GIF
   #define STBI_NO_GIF
   #endif
   #ifndef STBI_ONLY_HDR
   #define STBI_NO_HDR
   #endif
   #ifndef STBI_ONLY_PIC
   #define STBI_NO_PIC
   #endif
   #ifndef STBI_ONLY_PNM
   #define STBI_NO_PNM
   #endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif


#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#ifndef WIN32
#include <math.h>  // ldexp, pow
#endif
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif

#ifdef __cplusplus
#define STBI_EXTERN extern "C"
#else
#define STBI_EXTERN extern
#endif


#ifndef _MSC_VER
   #ifdef __cplusplus
   #define stbi_inline inline
   #else
   #define stbi_inline
   #endif
#else
   #define stbi_inline __forceinline
#endif

#ifndef STBI_NO_THREAD_LOCALS
   #if defined(__cplusplus) &&  __cplusplus >= 201103L
      #define STBI_THREAD_LOCAL       thread_local
   #elif defined(__GNUC__) && __GNUC__ < 5
      #define STBI_THREAD_LOCAL       __thread
   #elif defined(_MSC_VER)
      #define STBI_THREAD_LOCAL       __declspec(thread)
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)
      #define STBI_THREAD_LOCAL       _Thread_local
   #endif

   #ifndef STBI_THREAD_LOCAL
      #if defined(__GNUC__)
        #define STBI_THREAD_LOCAL       __thread
      #endif
   #endif
#endif

#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
   #define stbi_lrot(x,y)  _lrotl(x,y)
#else
   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)           malloc(sz)
#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
#define STBI_FREE(p)              free(p)
#endif

#ifndef STBI_REALLOC_SIZED
#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
#endif

// x86/x64 detection
#if defined(__x86_64__) || defined(_M_X64)
#define STBI__X64_TARGET
#elif defined(__i386) || defined(_M_IX86)
#define STBI__X86_TARGET
#endif

#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
// but previous attempts to provide the SSE2 functions with runtime
// detection caused numerous issues. The way architecture extensions are
// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
// New behavior: if compiled with -msse2, we use SSE2 without any
// detection; if not, we don't use it at all.
#define STBI_NO_SIMD
#endif

#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
//
// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
// simultaneously enabling "-mstackrealign".
//
// See https://github.com/nothings/stb/issues/81 for more information.
//
// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
#define STBI_NO_SIMD
#endif

#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
   int info[4];
   __cpuid(info,1);
   return info[3];
}
#else
static int stbi__cpuid3(void)
{
   int res;
   __asm {
      mov  eax,1
      cpuid
      mov  res,edx
   }
   return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   int info3 = stbi__cpuid3();
   return ((info3 >> 26) & 1) != 0;
}
#endif

#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}
#endif

#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
#ifdef _MSC_VER
#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
#else
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

#ifndef STBI_MAX_DIMENSIONS
#define STBI_MAX_DIMENSIONS (1 << 24)
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
   stbi__uint32 img_x, img_y;
   int img_n, img_out_n;

   stbi_io_callbacks io;
   void *io_user_data;

   int read_from_callbacks;
   int buflen;
   stbi_uc buffer_start[128];
   int callback_already_read;

   stbi_uc *img_buffer, *img_buffer_end;
   stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context *s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}

static void stbi__stdio_skip(void *user, int n)
{
   int ch;
   fseek((FILE*) user, n, SEEK_CUR);
   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
   if (ch != EOF) {
      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
   }
}

static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user) || ferror((FILE *) user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
   STBI_ORDER_RGB,
   STBI_ORDER_BGR
};

typedef struct
{
   int bits_per_channel;
   int num_channels;
   int channel_order;
} stbi__result_info;

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context *s);
static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context *s);
static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__png_is16(stbi__context *s);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context *s);
static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context *s);
static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context *s);
static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__psd_is16(stbi__context *s);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context *s);
static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context *s);
static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context *s);
static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__pnm_is16(stbi__context *s);
#endif

static
#ifdef STBI_THREAD_LOCAL
STBI_THREAD_LOCAL
#endif
const char *stbi__g_failure_reason;

STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}

#ifndef STBI_NO_FAILURE_STRINGS
static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}
#endif

static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}

// stb_image uses ints pervasively, including for offset calculations.
// therefore the largest decoded image size we can support with the
// current code, even on 64-bit targets, is INT_MAX. this is not a
// significant limitation for the intended use case.
//
// we do, however, need to make sure our size calculations don't
// overflow. hence a few helper functions for size calculations that
// multiply integers together, making sure that they're non-negative
// and no overflow occurs.

// return 1 if the sum is valid, 0 on overflow.
// negative terms are considered invalid.
static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And "a + b <= INT_MAX" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}

// returns 1 if the product is valid, 0 on overflow.
// negative factors are considered invalid.
static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}
#endif

// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}

// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}
#endif

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// mallocs with size overflow checking
static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}
#endif

static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}
#endif

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
   #define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
   #define stbi__err(x,y)  stbi__err(y)
#else
   #define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static int stbi__vertically_flip_on_load_global = 0;

STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
#else
static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;

STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}

#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
                                         ? stbi__vertically_flip_on_load_local  \
                                         : stbi__vertically_flip_on_load_global)
#endif // STBI_THREAD_LOCAL

static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   // test the formats with a very explicit header first (at least a FOURCC
   // or distinctive magic number first)
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif

   // then the formats that can end up attempting to load with just 1 or 2
   // bytes matching expectations; these are prone to false positives, so
   // try them later
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}

static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}

static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}

#ifndef STBI_NO_GIF
static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}
#endif

static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 8) {
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}

static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 16) {
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}

#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}
#endif

#ifndef STBI_NO_STDIO

#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
#endif

#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
{
	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
}
#endif

static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
      return 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}


STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   unsigned char *result;
   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}


#endif //!STBI_NO_STDIO

STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
   }

   return result;
}
#endif

#ifndef STBI_NO_LINEAR
static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, "rb");
   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, "rb");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}

STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, SEEK_SET);
   return res;
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}

#ifndef STBI_NO_LINEAR
static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;

STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
   STBI__SCAN_load=0,
   STBI__SCAN_type,
   STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
   if (n == 0) {
      // at end of file, treat same as if from memory, but need to handle case
      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}

stbi_inline static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}

#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
stbi_inline static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      // if feof() is true, check if buffer = end
      // special case: we've only got the special 0 character at the end
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
// nothing
#else
static void stbi__skip(stbi__context *s, int n)
{
   if (n == 0) return;  // already there!
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
// nothing
#else
static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}
#endif

#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
// nothing
#else
static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}
#endif

#ifndef STBI_NO_BMP
static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   z += (stbi__uint32)stbi__get16le(s) << 16;
   return z;
}
#endif

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
      STBI_FREE(data);
      return stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
      STBI_FREE(data);
      return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
   }
   if (n < comp) {
      for (i=0; i < x*y; ++i) {
         output[i*comp + n] = data[i*comp + n]/255.0f;
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
   stbi_uc  fast[1 << FAST_BITS];
   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
   stbi__uint16 code[256];
   stbi_uc  values[256];
   stbi_uc  size[257];
   unsigned int maxcode[18];
   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
   stbi__context *s;
   stbi__huffman huff_dc[4];
   stbi__huffman huff_ac[4];
   stbi__uint16 dequant[4][64];
   stbi__int16 fast_ac[4][1 << FAST_BITS];

// sizes for components, interleaved MCUs
   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;

// definition of jpeg image component
   struct
   {
      int id;
      int h,v;
      int tq;
      int hd,ha;
      int dc_pred;

      int x,y,w2,h2;
      stbi_uc *data;
      void *raw_data, *raw_coeff;
      stbi_uc *linebuf;
      short   *coeff;   // progressive only
      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
   } img_comp[4];

   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
   int            code_bits;   // number of valid bits
   unsigned char  marker;      // marker seen while filling entropy buffer
   int            nomore;      // flag if we saw a marker so must stop

   int            progressive;
   int            spec_start;
   int            spec_end;
   int            succ_high;
   int            succ_low;
   int            eob_run;
   int            jfif;
   int            app14_color_transform; // Adobe APP14 tag
   int            rgb;

   int scan_n, order[4];
   int restart_interval, todo;

// kernels
   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i)
      for (j=0; j < count[i]; ++j)
         h->size[k++] = (stbi_uc) (i+1);
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= FAST_BITS) {
            // magnitude code followed by receive_extend code
            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            // if the result is small enough, we can fit it in fast_ac table
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}

// (1 << n) - 1
static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}

// bias[n] = (-1<<n) + 1
static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & (sgn - 1));
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static const stbi_uc stbi__jpeg_dezigzag[64+15] =
{
    0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
      r = fac[c];
      if (r) { // fast-AC path
         k += (r >> 4) & 15; // run
         s = r & 15; // combined length
         j->code_buffer <<= s;
         j->code_bits -= s;
         // decode into unzigzag'd location
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; // end block
            k += 16;
         } else {
            k += r;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      // first scan for DC coefficient, must be first
      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
      t = stbi__jpeg_huff_decode(j, hdc);
      if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
      diff = t ? stbi__extend_receive(j, t) : 0;

      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      data[0] = (short) (dc * (1 << j->succ_low));
   } else {
      // refinement scan for DC coefficient
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
         r = fac[c];
         if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) * (1 << shift));
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
            }
         }
      } while (k <= j->spec_end);
   } else {
      // refinement scan for these AC coefficients

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; // force end of block
               } else {
                  // r=15 s=0 should write 16 0s, so we just do
                  // a run of 15 0s and then write s (which is 0),
                  // so we don't have to do anything special here
               }
            } else {
               if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
               // sign bit
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            // advance by r
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) * 4096)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      // so we want to round that, which means adding 0.5 * 1<<17,
      // aka 65536. Also, we'll end up with -128 to 127 that we want
      // to encode as 0..255 by adding 128, so we'll add that before the shift
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      // tried computing the shifts into temps, or'ing the temps to see
      // if any were out of range, but that was slower
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by "s" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
      // 16bit 8x8 transpose pass 1
      dct_interleave16(row0, row4);
      dct_interleave16(row1, row5);
      dct_interleave16(row2, row6);
      dct_interleave16(row3, row7);

      // transpose pass 2
      dct_interleave16(row0, row2);
      dct_interleave16(row1, row3);
      dct_interleave16(row4, row6);
      dct_interleave16(row5, row7);

      // transpose pass 3
      dct_interleave16(row0, row1);
      dct_interleave16(row2, row3);
      dct_interleave16(row4, row5);
      dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
      // pack
      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      // 8bit 8x8 transpose pass 1
      dct_interleave8(p0, p2); // a0e0a1e1...
      dct_interleave8(p1, p3); // c0g0c1g1...

      // transpose pass 2
      dct_interleave8(p0, p1); // a0c0e0g0...
      dct_interleave8(p2, p3); // b0d0f0h0...

      // transpose pass 3
      dct_interleave8(p0, p2); // a0b0c0d0...
      dct_interleave8(p1, p3); // a4b4c4d4...

      // store
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

// wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
   { \
      dct_wadd(sum, a, b); \
      dct_wsub(dif, a, b); \
      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
   }

#define dct_pass(shiftop, shift) \
   { \
      /* even part */ \
      int16x8_t sum26 = vaddq_s16(row2, row6); \
      dct_long_mul(p1e, sum26, rot0_0); \
      dct_long_mac(t2e, p1e, row6, rot0_1); \
      dct_long_mac(t3e, p1e, row2, rot0_2); \
      int16x8_t sum04 = vaddq_s16(row0, row4); \
      int16x8_t dif04 = vsubq_s16(row0, row4); \
      dct_widen(t0e, sum04); \
      dct_widen(t1e, dif04); \
      dct_wadd(x0, t0e, t3e); \
      dct_wsub(x3, t0e, t3e); \
      dct_wadd(x1, t1e, t2e); \
      dct_wsub(x2, t1e, t2e); \
      /* odd part */ \
      int16x8_t sum15 = vaddq_s16(row1, row5); \
      int16x8_t sum17 = vaddq_s16(row1, row7); \
      int16x8_t sum35 = vaddq_s16(row3, row5); \
      int16x8_t sum37 = vaddq_s16(row3, row7); \
      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
      dct_long_mul(p5o, sumodd, rot1_0); \
      dct_long_mac(p1o, p5o, sum17, rot1_1); \
      dct_long_mac(p2o, p5o, sum35, rot1_2); \
      dct_long_mul(p3o, sum37, rot2_0); \
      dct_long_mul(p4o, sum15, rot2_1); \
      dct_wadd(sump13o, p1o, p3o); \
      dct_wadd(sump24o, p2o, p4o); \
      dct_wadd(sump23o, p2o, p3o); \
      dct_wadd(sump14o, p1o, p4o); \
      dct_long_mac(x4, sump13o, row7, rot3_0); \
      dct_long_mac(x5, sump24o, row5, rot3_1); \
      dct_long_mac(x6, sump23o, row3, rot3_2); \
      dct_long_mac(x7, sump14o, row1, rot3_3); \
      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
   }

   // load
   row0 = vld1q_s16(data + 0*8);
   row1 = vld1q_s16(data + 1*8);
   row2 = vld1q_s16(data + 2*8);
   row3 = vld1q_s16(data + 3*8);
   row4 = vld1q_s16(data + 4*8);
   row5 = vld1q_s16(data + 5*8);
   row6 = vld1q_s16(data + 6*8);
   row7 = vld1q_s16(data + 7*8);

   // add DC bias
   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

   // column pass
   dct_pass(vrshrn_n_s32, 10);

   // 16bit 8x8 transpose
   {
// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
// whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

      // pass 1
      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
      dct_trn16(row2, row3);
      dct_trn16(row4, row5);
      dct_trn16(row6, row7);

      // pass 2
      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
      dct_trn32(row1, row3);
      dct_trn32(row4, row6);
      dct_trn32(row5, row7);

      // pass 3
      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
      dct_trn64(row1, row5);
      dct_trn64(row2, row6);
      dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
   }

   // row pass
   // vrshrn_n_s32 only supports shifts up to 16, we need
   // 17. so do a non-rounding shift of 16 first then follow
   // up with a rounding shift by 1.
   dct_pass(vshrn_n_s32, 16);

   {
      // pack and round
      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

      // again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

      // sadly can't use interleaved stores here since we only write
      // 8 bytes to each scan line!

      // 8x8 8-bit transpose pass 1
      dct_trn8_8(p0, p1);
      dct_trn8_8(p2, p3);
      dct_trn8_8(p4, p5);
      dct_trn8_8(p6, p7);

      // pass 2
      dct_trn8_16(p0, p2);
      dct_trn8_16(p1, p3);
      dct_trn8_16(p4, p6);
      dct_trn8_16(p5, p7);

      // pass 3
      dct_trn8_32(p0, p4);
      dct_trn8_32(p1, p5);
      dct_trn8_32(p2, p6);
      dct_trn8_32(p3, p7);

      // store
      vst1_u8(out, p0); out += out_stride;
      vst1_u8(out, p1); out += out_stride;
      vst1_u8(out, p2); out += out_stride;
      vst1_u8(out, p3); out += out_stride;
      vst1_u8(out, p4); out += out_stride;
      vst1_u8(out, p5); out += out_stride;
      vst1_u8(out, p6); out += out_stride;
      vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
   }

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         STBI_SIMD_ALIGN(short, data[64]);
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  // if it's NOT a restart, then just bail, so we get corrupt data
                  // rather than no data
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         STBI_SIMD_ALIGN(short, data[64]);
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}

static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      // dequantize and idct the data
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case STBI__MARKER_none: // no marker found
         return stbi__err("expected marker","Corrupt JPEG");

      case 0xDD: // DRI - specify restart interval
         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
            if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err("bad COM len","Corrupt JPEG");
         else
            return stbi__err("bad APP len","Corrupt JPEG");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); // version
            stbi__get16be(z->s); // flags0
            stbi__get16be(z->s); // flags1
            z->app14_color_transform = stbi__get8(z->s); // color transform
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err("unknown marker","Corrupt JPEG");
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; // no match
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err("bad SOS", "Corrupt JPEG");
      } else {
         if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
         z->spec_end = 63;
      }
   }

   return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         STBI_FREE(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = NULL;
         z->img_comp[i].data = NULL;
      }
      if (z->img_comp[i].raw_coeff) {
         STBI_FREE(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         STBI_FREE(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = NULL;
      }
   }
   return why;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
   // and I've never seen a non-corrupted JPEG file actually use them
   for (i=0; i < s->img_n; ++i) {
      if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
      if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == STBI__MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = NULL;
      j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
      if (stbi__SOS(m)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == STBI__MARKER_none ) {
            // handle 0s at the end of image data from IP Kamera 9060
            while (!stbi__at_eof(j->s)) {
               int x = stbi__get8(j->s);
               if (x == 255) {
                  j->marker = stbi__get8(j->s);
                  break;
               }
            }
            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
         }
      } else if (stbi__DNL(m)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
         if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
      } else {
         if (!stbi__process_marker(j, m)) return 0;
      }
      m = stbi__get_marker(j);
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
                                    int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = stbi__div4(n+input[i-1]);
      out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      // interleave even and odd pixels, then undo scaling.
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      // pack and write output
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      uint8x8_t farb  = vld1_u8(in_far + i);
      uint8x8_t nearb = vld1_u8(in_near + i);
      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
      int16x8_t curr  = vaddq_s16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      int16x8_t prv0 = vextq_s16(curr, curr, 7);
      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      int16x8_t curs = vshlq_n_s16(curr, 2);
      int16x8_t prvd = vsubq_s16(prev, curr);
      int16x8_t nxtd = vsubq_s16(next, curr);
      int16x8_t even = vaddq_s16(curs, prvd);
      int16x8_t odd  = vaddq_s16(curs, nxtd);

      // undo scaling and round, then store with even/odd phases interleaved
      uint8x8x2_t o;
      o.val[0] = vqrshrun_n_s16(even, 4);
      o.val[1] = vqrshrun_n_s16(odd,  4);
      vst2_u8(out + i*2, o);
#endif

      // "previous" value for next iter
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}
#endif

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}

// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); // alpha channel

      for (; i+7 < count; i += 8) {
         // load
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

         // unpack to short (and left-shift cr, cb by 8)
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         // color transform
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         // descale
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         // back to byte, set up for transpose
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         // transpose to interleave channels
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         // store
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      uint8x8_t signflip = vdup_n_u8(0x80);
      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

      for (; i+7 < count; i += 8) {
         // load
         uint8x8_t y_bytes  = vld1_u8(y + i);
         uint8x8_t cr_bytes = vld1_u8(pcr + i);
         uint8x8_t cb_bytes = vld1_u8(pcb + i);
         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

         // expand to s16
         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
         int16x8_t crw = vshll_n_s8(cr_biased, 7);
         int16x8_t cbw = vshll_n_s8(cb_biased, 7);

         // color transform
         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
         int16x8_t rws = vaddq_s16(yws, cr0);
         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
         int16x8_t bws = vaddq_s16(yws, cb1);

         // undo scaling, round, convert to byte
         uint8x8x4_t o;
         o.val[0] = vqrshrun_n_s16(rws, 4);
         o.val[1] = vqrshrun_n_s16(gws, 4);
         o.val[2] = vqrshrun_n_s16(bws, 4);
         o.val[3] = vdup_n_u8(255);

         // store, interleaving r/g/b/a
         vst4_u8(out, o);
         out += 8*4;
      }
   }
#endif

   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* stbi__float2fixed(1.40200f);
      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
   resample_row_func resample;
   stbi_uc *line0,*line1;
   int hs,vs;   // expansion factor in each axis
   int w_lores; // horizontal pixels pre-expansion
   int ystep;   // how far through vertical expansion we are
   int ypos;    // which pre-expansion row we're on
} stbi__resample;

// fast 0..255 * 0..255 => 0..255 rounded multiplication
static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   // nothing to do if no components requested; check this now to avoid
   // accessing uninitialized coutput[0] later
   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

   // resample and color-convert
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

      // now go ahead and resample
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { // CMYK
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { // YCCK
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { // YCbCr + alpha?  Ignore the fourth channel for now
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
      return output;
   }
}

static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__errpuc("outofmem", "Out of memory");
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__err("outofmem", "Out of memory");
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   if (!j) return stbi__err("outofmem", "Out of memory");
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
   stbi__uint16 firstcode[16];
   int maxcode[17];
   stbi__uint16 firstsymbol[16];
   stbi_uc  size[STBI__ZNSYMS];
   stbi__uint16 value[STBI__ZNSYMS];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err("bad sizes", "Corrupt PNG");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= STBI__ZFAST_BITS) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << STBI__ZFAST_BITS)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
   stbi_uc *zbuffer, *zbuffer_end;
   int num_bits;
   stbi__uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int   z_expandable;

   stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static int stbi__zeof(stbi__zbuf *z)
{
   return (z->zbuffer >= z->zbuffer_end);
}

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   return stbi__zeof(z) ? 0 : *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      if (z->code_buffer >= (1U << z->num_bits)) {
        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
        return;
      }
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s >= 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) {
      if (stbi__zeof(a)) {
         return -1;   /* report error for unexpected end of data. */
      }
      stbi__fill_bits(a);
   }
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   unsigned int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
   cur   = (unsigned int) (z->zout - z->zout_start);
   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
   if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
   while (cur + n > limit) {
      if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
      limit *= 2;
   }
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err("outofmem", "Out of memory");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}

static const int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static const int stbi__zlength_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static const int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            return 1;
         }
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
         if (zout + len > a->zout_end) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { // run of one byte; common in images.
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
            fill = lencodes[n-1];
         } else if (c == 17) {
            c = stbi__zreceive(a,3)+3;
         } else if (c == 18) {
            c = stbi__zreceive(a,7)+11;
         } else {
            return stbi__err("bad codelengths", "Corrupt PNG");
         }
         if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
   // now fill header the normal way
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}

static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};
/*
Init algorithm:
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;

   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
}
*/

static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}

STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
   stbi__uint32 length;
   stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}

static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
   return 1;
}

typedef struct
{
   stbi__context *s;
   stbi_uc *idata, *expanded, *out;
   int depth;
} stbi__png;


enum {
   STBI__F_none=0,
   STBI__F_sub=1,
   STBI__F_up=2,
   STBI__F_avg=3,
   STBI__F_paeth=4,
   // synthetic filters used for first scanline to avoid needing a dummy row of 0s
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err("outofmem", "Out of memory");

   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   img_len = (img_width_bytes + 1) * y;

   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
   // so just check for raw_len < img_len always.
   if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

   for (j=0; j < y; ++j) {
      stbi_uc *cur = a->out + stride*j;
      stbi_uc *prior;
      int filter = *raw++;

      if (filter > 4)
         return stbi__err("invalid filter","Corrupt PNG");

      if (depth < 8) {
         if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
         filter_bytes = 1;
         width = img_width_bytes;
      }
      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];

      // handle first byte explicitly
      for (k=0; k < filter_bytes; ++k) {
         switch (filter) {
            case STBI__F_none       : cur[k] = raw[k]; break;
            case STBI__F_sub        : cur[k] = raw[k]; break;
            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
            case STBI__F_avg_first  : cur[k] = raw[k]; break;
            case STBI__F_paeth_first: cur[k] = raw[k]; break;
         }
      }

      if (depth == 8) {
         if (img_n != out_n)
            cur[img_n] = 255; // first pixel
         raw += img_n;
         cur += out_n;
         prior += out_n;
      } else if (depth == 16) {
         if (img_n != out_n) {
            cur[filter_bytes]   = 255; // first pixel top byte
            cur[filter_bytes+1] = 255; // first pixel bottom byte
         }
         raw += filter_bytes;
         cur += output_bytes;
         prior += output_bytes;
      } else {
         raw += 1;
         cur += 1;
         prior += 1;
      }

      // this is a little gross, so that we don't switch per-pixel or per-component
      if (depth < 8 || img_n == out_n) {
         int nk = (width - 1)*filter_bytes;
         #define STBI__CASE(f) \
             case f:     \
                for (k=0; k < nk; ++k)
         switch (filter) {
            // "none" filter turns into a memcpy here; make that explicit.
            case STBI__F_none:         memcpy(cur, raw, nk); break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
         }
         #undef STBI__CASE
         raw += nk;
      } else {
         STBI_ASSERT(img_n+1 == out_n);
         #define STBI__CASE(f) \
             case f:     \
                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
                   for (k=0; k < filter_bytes; ++k)
         switch (filter) {
            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
         }
         #undef STBI__CASE

         // the loop above sets the high byte of the pixels' alpha, but for
         // 16 bit png files we also need the low byte set. we'll do that here.
         if (depth == 16) {
            cur = a->out + stride*j; // start at the beginning of the row again
            for (i=0; i < x; ++i,cur+=output_bytes) {
               cur[filter_bytes+1] = 255;
            }
         }
      }
   }

   // we make a separate pass to expand bits to pixels; for performance,
   // this could run two scanlines behind the above code, so it won't
   // intefere with filtering but will still be in the cache.
   if (depth < 8) {
      for (j=0; j < y; ++j) {
         stbi_uc *cur = a->out + stride*j;
         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

         // note that the final byte might overshoot and write more data than desired.
         // we can allocate enough data that this never writes out of memory, but it
         // could also overwrite the next scanline. can it overwrite non-empty data
         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
         // so we need to explicitly clamp the final ones

         if (depth == 4) {
            for (k=x*img_n; k >= 2; k-=2, ++in) {
               *cur++ = scale * ((*in >> 4)       );
               *cur++ = scale * ((*in     ) & 0x0f);
            }
            if (k > 0) *cur++ = scale * ((*in >> 4)       );
         } else if (depth == 2) {
            for (k=x*img_n; k >= 4; k-=4, ++in) {
               *cur++ = scale * ((*in >> 6)       );
               *cur++ = scale * ((*in >> 4) & 0x03);
               *cur++ = scale * ((*in >> 2) & 0x03);
               *cur++ = scale * ((*in     ) & 0x03);
            }
            if (k > 0) *cur++ = scale * ((*in >> 6)       );
            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
         } else if (depth == 1) {
            for (k=x*img_n; k >= 8; k-=8, ++in) {
               *cur++ = scale * ((*in >> 7)       );
               *cur++ = scale * ((*in >> 6) & 0x01);
               *cur++ = scale * ((*in >> 5) & 0x01);
               *cur++ = scale * ((*in >> 4) & 0x01);
               *cur++ = scale * ((*in >> 3) & 0x01);
               *cur++ = scale * ((*in >> 2) & 0x01);
               *cur++ = scale * ((*in >> 1) & 0x01);
               *cur++ = scale * ((*in     ) & 0x01);
            }
            if (k > 0) *cur++ = scale * ((*in >> 7)       );
            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
         }
         if (img_n != out_n) {
            int q;
            // insert alpha = 255
            cur = a->out + stride*j;
            if (img_n == 1) {
               for (q=x-1; q >= 0; --q) {
                  cur[q*2+1] = 255;
                  cur[q*2+0] = cur[q];
               }
            } else {
               STBI_ASSERT(img_n == 3);
               for (q=x-1; q >= 0; --q) {
                  cur[q*4+3] = 255;
                  cur[q*4+2] = cur[q*3+2];
                  cur[q*4+1] = cur[q*3+1];
                  cur[q*4+0] = cur[q*3+0];
               }
            }
         }
      }
   } else if (depth == 16) {
      // force the image data from big-endian to platform-native.
      // this is done in a separate pass due to the decoding relying
      // on the data being untouched, but could probably be done
      // per-line during decode if care is taken.
      stbi_uc *cur = a->out;
      stbi__uint16 *cur16 = (stbi__uint16*)cur;

      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
         *cur16 = (cur[0] << 8) | cur[1];
      }
   }

   return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   if (!final) return stbi__err("outofmem", "Out of memory");
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            STBI_FREE(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         STBI_FREE(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err("outofmem", "Out of memory");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}

static int stbi__unpremultiply_on_load_global = 0;
static int stbi__de_iphone_flag_global = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_global = flag_true_if_should_convert;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
#define stbi__de_iphone_flag  stbi__de_iphone_flag_global
#else
static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;

STBIDEF void stbi__unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
   stbi__unpremultiply_on_load_set = 1;
}

STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_local = flag_true_if_should_convert;
   stbi__de_iphone_flag_set = 1;
}

#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
                                       ? stbi__unpremultiply_on_load_local      \
                                       : stbi__unpremultiply_on_load_global)
#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
                                ? stbi__de_iphone_flag_local                    \
                                : stbi__de_iphone_flag_global)
#endif // STBI_THREAD_LOCAL

static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      STBI_ASSERT(s->img_out_n == 4);
      if (stbi__unpremultiply_on_load) {
         // convert bgr to rgb and unpremultiply
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         // convert bgr to rgb
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}

#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))

static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3]={0};
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case STBI__PNG_TYPE('C','g','B','I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case STBI__PNG_TYPE('I','H','D','R'): {
            int comp,filter;
            if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
            first = 0;
            if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
            s->img_x = stbi__get32be(s);
            s->img_y = stbi__get32be(s);
            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
               if (scan == STBI__SCAN_header) return 1;
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
               // if SCAN_header, have to scan to see if we have a tRNS
            }
            break;
         }

         case STBI__PNG_TYPE('P','L','T','E'):  {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case STBI__PNG_TYPE('t','R','N','S'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
               if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
               has_trans = 1;
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
               } else {
                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
               }
            }
            break;
         }

         case STBI__PNG_TYPE('I','D','A','T'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               STBI_NOTUSED(idata_limit_old);
               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
            ioff += c.length;
            break;
         }

         case STBI__PNG_TYPE('I','E','N','D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               // non-paletted image with tRNS -> source image has (constant) alpha
               ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
         }

         default:
            // if critical, fail
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = "XXXX PNG chunk not known";
               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
               #endif
               return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
            }
            stbi__skip(s, c.length);
            break;
      }
      // end of PNG chunk, read and skip CRC
      stbi__get32be(s);
   }
}

static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth <= 8)
         ri->bits_per_channel = 8;
      else if (p->depth == 16)
         ri->bits_per_channel = 16;
      else
         return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}

static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}

static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}

static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
	   return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}

static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}


// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) { n += 16; z >>= 16; }
   if (z >= 0x00100) { n +=  8; z >>=  8; }
   if (z >= 0x00010) { n +=  4; z >>=  4; }
   if (z >= 0x00004) { n +=  2; z >>=  2; }
   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
   return n;
}

static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}

// extract an arbitrarily-aligned N-bit value (N=bits)
// from v, and then make it 8-bits long and fractionally
// extend it to full full range.
static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   STBI_ASSERT(v < 256);
   v >>= (8-bits);
   STBI_ASSERT(bits >= 0 && bits <= 8);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}

typedef struct
{
   int bpp, offset, hsz;
   unsigned int mr,mg,mb,ma, all_a;
   int extra_read;
} stbi__bmp_data;

static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
{
   // BI_BITFIELDS specifies masks explicitly, don't override
   if (compress == 3)
      return 1;

   if (compress == 0) {
      if (info->bpp == 16) {
         info->mr = 31u << 10;
         info->mg = 31u <<  5;
         info->mb = 31u <<  0;
      } else if (info->bpp == 32) {
         info->mr = 0xffu << 16;
         info->mg = 0xffu <<  8;
         info->mb = 0xffu <<  0;
         info->ma = 0xffu << 24;
         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
      } else {
         // otherwise, use defaults, which is all-0
         info->mr = info->mg = info->mb = info->ma = 0;
      }
      return 1;
   }
   return 0; // error
}

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;
   info->extra_read = 14;

   if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
      if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
      stbi__get32le(s); // discard sizeof
      stbi__get32le(s); // discard hres
      stbi__get32le(s); // discard vres
      stbi__get32le(s); // discard colorsused
      stbi__get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               stbi__bmp_set_mask_defaults(info, compress);
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               info->extra_read += 12;
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return stbi__errpuc("bad BMP", "bad BMP");
               }
            } else
               return stbi__errpuc("bad BMP", "bad BMP");
         }
      } else {
         // V4/V5 header
         int i;
         if (hsz != 108 && hsz != 124)
            return stbi__errpuc("bad BMP", "bad BMP");
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
            stbi__bmp_set_mask_defaults(info, compress);
         stbi__get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            stbi__get32le(s); // discard color space parameters
         if (hsz == 124) {
            stbi__get32le(s); // discard rendering intent
            stbi__get32le(s); // discard offset of profile data
            stbi__get32le(s); // discard size of profile data
            stbi__get32le(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}


static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
      return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - info.extra_read - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - info.extra_read - info.hsz) >> 2;
   }
   if (psize == 0) {
      if (info.offset != s->callback_already_read + (s->img_buffer - s->img_buffer_original)) {
        return stbi__errpuc("bad offset", "Corrupt BMP");
      }
   }

   if (info.bpp == 24 && ma == 0xff000000)
      s->img_n = 3;
   else
      s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return stbi__errpuc("too large", "Corrupt BMP");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - info.extra_read - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
         // right shift amt to put high bit in position #7
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = STBI__BYTECAST(a);
            }
         }
         stbi__skip(s, pad);
      }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
// returns STBI_rgb or whatever, 0 on error
static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
               // fallthrough
      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24: // fallthrough
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s,9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
      sz = stbi__get8(s);    //   check bits per palette color entry
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       // skip image x and y origin
   } else { // "normal" image w/o colormap
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
      stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}

// read 16bit value and convert to 24bit RGB
static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the "image descriptor byte")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}

static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);
   STBI_NOTUSED(tga_x_origin); // @TODO
   STBI_NOTUSED(tga_y_origin); // @TODO

   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
      return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return stbi__errpuc("too large", "Corrupt TGA");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      //   do I need to load a palette?
      if ( tga_indexed)
      {
         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
            STBI_FREE(tga_data);
            return stbi__errpuc("bad palette", "Corrupt TGA");
         }

         //   any data to skip? (offset usually = 0)
         stbi__skip(s, tga_palette_start );
         //   load the palette
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            STBI_FREE(tga_data);
            return stbi__errpuc("outofmem", "Out of memory");
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            STBI_ASSERT(tga_comp == STBI_rgb);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               STBI_FREE(tga_data);
               STBI_FREE(tga_palette);
               return stbi__errpuc("bad palette", "Corrupt TGA");
         }
      }
      //   load the data
      for (i=0; i < tga_width * tga_height; ++i)
      {
         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               //   yep, get the next byte as a RLE command
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         //   OK, if I need to read a pixel, do it now
         if ( read_next_pixel )
         {
            //   load however much data we did have
            if ( tga_indexed )
            {
               // read in index, then perform the lookup
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  // invalid index
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               STBI_ASSERT(tga_comp == STBI_rgb);
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               //   read in the data raw
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            //   clear the reading flag for the next pixel
            read_next_pixel = 0;
         } // end of reading a pixel

         // copy data
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         //   in case we're in RLE mode, keep counting down
         --RLE_count;
      }
      //   do I need to invert the image?
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      //   clear my palette, if I had one
      if ( tga_palette != NULL )
      {
         STBI_FREE( tga_palette );
      }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   STBI_NOTUSED(tga_palette_start);
   //   OK, done
   return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}

static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         // No-op.
      } else if (len < 128) {
         // Copy next len+1 bytes literally.
         len++;
         if (len > nleft) return 0; // corrupt data
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         // Next -len+1 bytes in the dest are replicated from next source byte.
         // (Interpret len as a negative 8-bit int.)
         len = 257 - len;
         if (len > nleft) return 0; // corrupt data
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}

static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
      return stbi__errpuc("not PSD", "Corrupt PSD image");

   // Check file type version.
   if (stbi__get16be(s) != 1)
      return stbi__errpuc("wrong version", "Unsupported version of PSD image");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
      return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
      return stbi__errpuc("bad compression", "PSD has an unknown compression format");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return stbi__errpuc("too large", "Corrupt PSD");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      stbi__skip(s, h * channelCount * 2 );

      // Read the RLE data by channel.
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            // Fill this channel with default data.
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            // Read the RLE data.
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               STBI_FREE(out);
               return stbi__errpuc("corrupt", "bad RLE data");
            }
         }
      }

   } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

      // Read the data by channel.
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            // Fill this channel with default data.
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    // output bpc
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  // input bpc
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,"PICT"))
      return 0;

   return 1;
}

typedef struct
{
   stbi_uc size,type,channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}

static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask = 0x80, i;

   for (i = 0; i < 4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp = 0, num_packets = 0 , y, chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
    // for the same channel in multiple packets.
   do {
      stbi__pic_packet* packet;

      if (num_packets == sizeof(packets)/sizeof(packets[0]))
         return stbi__errpuc("bad format","too many packets");

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return stbi__errpuc("bad format","packet has bad compression type");

            case 0: {//uncompressed
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1://Pure RLE
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {//Mixed RLE
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

                  if (count >= 128) { // Repeated
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return stbi__errpuc("bad file","scanline overrun");

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { // Raw
                     ++count;
                     if (count>left) return stbi__errpuc("bad file","scanline overrun");

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}

static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);

   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   if (!result) return stbi__errpuc("outofmem", "Out of memory");
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}

static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
   stbi__int16 prefix;
   stbi_uc first;
   stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
   int w,h;
   stbi_uc *out;                 // output buffer (always 4 components)
   stbi_uc *background;          // The current "background" as far as a gif is concerned
   stbi_uc *history;
   int flags, bgindex, ratio, transparent, eflags;
   stbi_uc  pal[256][4];
   stbi_uc lpal[256][4];
   stbi__gif_lzw codes[8192];
   stbi_uc *color_table;
   int parse, step;
   int lflags;
   int start_x, start_y;
   int max_x, max_y;
   int cur_x, cur_y;
   int line_size;
   int delay;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}

static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err("not GIF", "Corrupt GIF");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

   stbi__g_failure_reason = "";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!g) return stbi__err("outofmem", "Out of memory");
   if (!stbi__gif_header(s, g, comp, 1)) {
      STBI_FREE(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;
   int idx;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   idx = g->cur_x + g->cur_y;
   p = &g->out[idx];
   g->history[idx / 4] = 1;

   c = &g->color_table[g->codes[code].suffix * 4];
   if (c[3] > 128) { // don't render transparent pixels;
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); // start new block
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
         if (code == clear) {  // clear code
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { // end of stream code
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) {
               return stbi__errpuc("no clear code", "Corrupt GIF");
            }

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 8192) {
                  return stbi__errpuc("too many codes", "Corrupt GIF");
               }

               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return stbi__errpuc("illegal code in raster", "Corrupt GIF");

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return stbi__errpuc("illegal code in raster", "Corrupt GIF");
         }
      }
   }
}

// this function is designed to support animated gifs, although stb_image doesn't support it
// two back is the image from two frames ago, used for a very specific disposal format
static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
   int dispose;
   int first_frame;
   int pi;
   int pcount;
   STBI_NOTUSED(req_comp);

   // on first frame, any non-written pixels get the background colour (non-transparent)
   first_frame = 0;
   if (g->out == 0) {
      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
         return stbi__errpuc("too large", "GIF image is too large");
      pcount = g->w * g->h;
      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
      g->history = (stbi_uc *) stbi__malloc(pcount);
      if (!g->out || !g->background || !g->history)
         return stbi__errpuc("outofmem", "Out of memory");

      // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
      // background colour is only used for pixels that are not rendered first frame, after that "background"
      // color refers to the color that was there the previous frame.
      memset(g->out, 0x00, 4 * pcount);
      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
      first_frame = 1;
   } else {
      // second frame - how do we dispose of the previous one?
      dispose = (g->eflags & 0x1C) >> 2;
      pcount = g->w * g->h;

      if ((dispose == 3) && (two_back == 0)) {
         dispose = 2; // if I don't have an image to revert back to, default to the old background
      }

      if (dispose == 3) { // use previous graphic
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
            }
         }
      } else if (dispose == 2) {
         // restore what was changed last frame to background before that frame;
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
            }
         }
      } else {
         // This is a non-disposal case eithe way, so just
         // leave the pixels as is, and they will become the new background
         // 1: do not dispose
         // 0:  not specified.
      }

      // background is what out is after the undoing of the previou frame;
      memcpy( g->background, g->out, 4 * g->w * g->h );
   }

   // clear my history;
   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

   for (;;) {
      int tag = stbi__get8(s);
      switch (tag) {
         case 0x2C: /* Image Descriptor */
         {
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
               g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; // first interlaced spacing
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               g->color_table = (stbi_uc *) g->pal;
            } else
               return stbi__errpuc("missing color table", "Corrupt GIF");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
               // if first frame, any pixel not drawn to gets the background color
               for (pi = 0; pi < pcount; ++pi) {
                  if (g->history[pi] == 0) {
                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
                  }
               }
            }

            return o;
         }

         case 0x21: // Comment Extension.
         {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                  // unset old transparent
                  if (g->transparent >= 0) {
                     g->pal[g->transparent][3] = 255;
                  }
                  if (g->eflags & 0x01) {
                     g->transparent = stbi__get8(s);
                     if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 0;
                     }
                  } else {
                     // don't need transparent
                     stbi__skip(s, 1);
                     g->transparent = -1;
                  }
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0) {
               stbi__skip(s, len);
            }
            break;
         }

         case 0x3B: // gif stream termination code
            return (stbi_uc *) s; // using '1' causes warning on some compilers

         default:
            return stbi__errpuc("unknown code", "Corrupt GIF");
      }
   }
}

static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
{
   STBI_FREE(g->out);
   STBI_FREE(g->history);
   STBI_FREE(g->background);

   if (out) STBI_FREE(out);
   if (delays && *delays) STBI_FREE(*delays);
   return stbi__errpuc("outofmem", "Out of memory");
}

static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
      int layers = 0;
      stbi_uc *u = 0;
      stbi_uc *out = 0;
      stbi_uc *two_back = 0;
      stbi__gif g;
      int stride;
      int out_size = 0;
      int delays_size = 0;

      STBI_NOTUSED(out_size);
      STBI_NOTUSED(delays_size);

      memset(&g, 0, sizeof(g));
      if (delays) {
         *delays = 0;
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
               if (!tmp)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               else {
                   out = (stbi_uc*) tmp;
                   out_size = layers * stride;
               }

               if (delays) {
                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
                  if (!new_delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  *delays = new_delays;
                  delays_size = layers * sizeof(int);
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (!out)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               out_size = layers * stride;
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
                  if (!*delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  delays_size = layers * sizeof(int);
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

      // free temp buffer;
      STBI_FREE(g.out);
      STBI_FREE(g.history);
      STBI_FREE(g.background);

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

      *z = layers;
      return out;
   } else {
      return stbi__errpuc("not GIF", "Image was not as a gif type.");
   }
}

static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
      *x = g.w;
      *y = g.h;

      // moved conversion to after successful load so that the same
      // can be done for multiple frames.
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
   } else if (g.out) {
      // if there was an error and we allocated an image buffer, free it!
      STBI_FREE(g.out);
   }

   // free buffers needed for multiple frame loading;
   STBI_FREE(g.history);
   STBI_FREE(g.background);

   return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, "#?RGBE\n");
       stbi__rewind(s);
   }
   return r;
}

#define STBI__HDR_BUFLEN  1024
static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == STBI__HDR_BUFLEN-1) {
         // flush to end of line
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   STBI_NOTUSED(ri);

   // Check identifier
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
      return stbi__errpf("not HDR", "Corrupt HDR image");

   // Parse header
   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return stbi__errpf("too large", "HDR image is too large");

   // Read data
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return stbi__errpf("outofmem", "Out of memory");

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
      // Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {
      // Read RLE-encoded data
      scanline = NULL;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            STBI_FREE(scanline);
            goto main_decode_loop; // yes, this makes no sense
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
         if (scanline == NULL) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               STBI_FREE(hdr_data);
               return stbi__errpf("outofmem", "Out of memory");
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {
                  // Run
                  value = stbi__get8(s);
                  count -= 128;
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {
                  // Dump
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         STBI_FREE(scanline);
   }

   return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   if (p == NULL) {
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) {
      if (info.bpp == 24 && info.ma == 0xff000000)
         *comp = 3;
      else
         *comp = info.ma ? 4 : 3;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy, depth;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 8 && depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}

static int stbi__psd_is16(stbi__context *s)
{
   int channelCount, depth;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   STBI_NOTUSED(stbi__get32be(s));
   STBI_NOTUSED(stbi__get32be(s));
   depth = stbi__get16be(s);
   if (depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}

static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   STBI_NOTUSED(ri);

   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
   if (ri->bits_per_channel == 0)
      return 0;

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
      return stbi__errpuc("too large", "PNM too large");


   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));

   if (req_comp && req_comp != s->img_n) {
      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (
               !stbi__at_eof(s) &&
               (*c == ' ' || *c == '\t' || *c == '\n' || *c == '\v' || *c == '\f' || *c == '\r')
            )
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}

static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9'; 
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
   }

   return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value
   if (maxv > 65535)
      return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");
   else if (maxv > 255)
      return 16;
   else
      return 8;
}

static int stbi__pnm_is16(stbi__context *s)
{
   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
	   return 1;
   return 0;
}
#endif

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
       return 1;
   #endif
   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

static int stbi__is_16_main(stbi__context *s)
{
   #ifndef STBI_NO_PNG
   if (stbi__png_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_is16(s))  return 1;
   #endif
   return 0;
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}

STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}

STBIDEF int stbi_is_16_bit(char const *filename)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}

STBIDEF int stbi_is_16_bit_from_file(FILE *f)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__is_16_main(&s);
   fseek(f,pos,SEEK_SET);
   return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__is_16_main(&s);
}

STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__is_16_main(&s);
}

#endif // STB_IMAGE_IMPLEMENTATION

/*
   revision history:
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
                         1-bit BMP
                         *_is_16_bit api
                         avoid warnings
      2.16  (2017-07-23) all functions have 16-bit variants;
                         STBI_NO_STDIO works again;
                         compilation fixes;
                         fix rounding in unpremultiply;
                         optimize vertical flip;
                         disable raw_len validation;
                         documentation fixes
      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
                         warning fixes; disable run-time SSE detection on gcc;
                         uniform handling of optional "return" values;
                         thread-safe initialization of zlib tables
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) allocate large structures on the stack
                         remove white matting for transparent PSD
                         fix reported channel count for PNG & BMP
                         re-enable SSE2 in non-gcc 64-bit
                         support RGB-formatted JPEG
                         read 16-bit PNGs (only as 8-bit)
      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
      2.09  (2016-01-16) allow comments in PNM files
                         16-bit-per-pixel TGA (not bit-per-component)
                         info() for TGA could break due to .hdr handling
                         info() for BMP to shares code instead of sloppy parse
                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc
                         code cleanup
      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
      2.07  (2015-09-13) fix compiler warnings
                         partial animated GIF support
                         limited 16-bpc PSD support
                         #ifdef unused functions
                         bug with < 92 byte PIC,PNM,HDR,TGA
      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
      2.03  (2015-04-12) extra corruption checking (mmozeiko)
                         stbi_set_flip_vertically_on_load (nguillemot)
                         fix NEON support; fix mingw support
      2.02  (2015-01-19) fix incorrect assert, fix warning
      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
                         progressive JPEG (stb)
                         PGM/PPM support (Ken Miller)
                         STBI_MALLOC,STBI_REALLOC,STBI_FREE
                         GIF bugfix -- seemingly never worked
                         STBI_NO_*, STBI_ONLY_*
      1.48  (2014-12-14) fix incorrectly-named assert()
      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
                         optimize PNG (ryg)
                         fix bug in interlaced PNG with user-specified channel count (stb)
      1.46  (2014-08-26)
              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
      1.45  (2014-08-16)
              fix MSVC-ARM internal compiler error by wrapping malloc
      1.44  (2014-08-07)
              various warning fixes from Ronny Chevalier
      1.43  (2014-07-15)
              fix MSVC-only compiler problem in code changed in 1.42
      1.42  (2014-07-09)
              don't define _CRT_SECURE_NO_WARNINGS (affects user code)
              fixes to stbi__cleanup_jpeg path
              added STBI_ASSERT to avoid requiring assert.h
      1.41  (2014-06-25)
              fix search&replace from 1.36 that messed up comments/error messages
      1.40  (2014-06-22)
              fix gcc struct-initialization warning
      1.39  (2014-06-15)
              fix to TGA optimization when req_comp != number of components in TGA;
              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
              add support for BMP version 5 (more ignored fields)
      1.38  (2014-06-06)
              suppress MSVC warnings on integer casts truncating values
              fix accidental rename of 'skip' field of I/O
      1.37  (2014-06-04)
              remove duplicate typedef
      1.36  (2014-06-03)
              convert to header file single-file library
              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
      1.35  (2014-05-27)
              various warnings
              fix broken STBI_SIMD path
              fix bug where stbi_load_from_file no longer left file pointer in correct place
              fix broken non-easy path for 32-bit BMP (possibly never used)
              TGA optimization by Arseny Kapoulkine
      1.34  (unknown)
              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
      1.33  (2011-07-14)
              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
      1.32  (2011-07-13)
              support for "info" function for all supported filetypes (SpartanJ)
      1.31  (2011-06-20)
              a few more leak fixes, bug in PNG handling (SpartanJ)
      1.30  (2011-06-11)
              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
              removed deprecated format-specific test/load functions
              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
              fix inefficiency in decoding 32-bit BMP (David Woo)
      1.29  (2010-08-16)
              various warning fixes from Aurelien Pocheville
      1.28  (2010-08-01)
              fix bug in GIF palette transparency (SpartanJ)
      1.27  (2010-08-01)
              cast-to-stbi_uc to fix warnings
      1.26  (2010-07-24)
              fix bug in file buffering for PNG reported by SpartanJ
      1.25  (2010-07-17)
              refix trans_data warning (Won Chun)
      1.24  (2010-07-12)
              perf improvements reading from files on platforms with lock-heavy fgetc()
              minor perf improvements for jpeg
              deprecated type-specific functions so we'll get feedback if they're needed
              attempt to fix trans_data warning (Won Chun)
      1.23    fixed bug in iPhone support
      1.22  (2010-07-10)
              removed image *writing* support
              stbi_info support from Jetro Lauha
              GIF support from Jean-Marc Lienher
              iPhone PNG-extensions from James Brown
              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
      1.21    fix use of 'stbi_uc' in header (reported by jon blow)
      1.20    added support for Softimage PIC, by Tom Seddon
      1.19    bug in interlaced PNG corruption check (found by ryg)
      1.18  (2008-08-02)
              fix a threading bug (local mutable static)
      1.17    support interlaced PNG
      1.16    major bugfix - stbi__convert_format converted one too many pixels
      1.15    initialize some fields for thread safety
      1.14    fix threadsafe conversion bug
              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
      1.13    threadsafe
      1.12    const qualifiers in the API
      1.11    Support installable IDCT, colorspace conversion routines
      1.10    Fixes for 64-bit (don't use "unsigned long")
              optimized upsampling by Fabian "ryg" Giesen
      1.09    Fix format-conversion for PSD code (bad global variables!)
      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
      1.07    attempt to fix C++ warning/errors again
      1.06    attempt to fix C++ warning/errors again
      1.05    fix TGA loading to return correct *comp and use good luminance calc
      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
      1.02    support for (subset of) HDR files, float interface for preferred access to them
      1.01    fix bug: possible bug in handling right-side up bmps... not sure
              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
      1.00    interface to zlib that skips zlib header
      0.99    correct handling of alpha in palette
      0.98    TGA loader by lonesock; dynamically add loaders (untested)
      0.97    jpeg errors on too large a file; also catch another malloc failure
      0.96    fix detection of invalid v value - particleman@mollyrocket forum
      0.95    during header scan, seek to markers in case of padding
      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
      0.93    handle jpegtran output; verbose errors
      0.92    read 4,8,16,24,32-bit BMP files of several formats
      0.91    output 24-bit Windows 3.0 BMP files
      0.90    fix a few more warnings; bump version number to approach 1.0
      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
      0.60    fix compiling as c++
      0.59    fix warnings: merge Dave Moore's -Wall fixes
      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
      0.56    fix bug: zlib uncompressed mode len vs. nlen
      0.55    fix bug: restart_interval not initialized to 0
      0.54    allow NULL for 'int *comp'
      0.53    fix bug in png 3->4; speedup png decoding
      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
              on 'test' only check type, not whether we support this variant
      0.50  (2006-11-19)
              first released version
*/


/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
 JFIF       C 		
 $.' ",#(7),01444'9=82<.342 C			2!!22222222222222222222222222222222222222222222222222 
"                <   !1AQaq"2#BR3r$b4C              (      !1AQ"2Ba#qR   ? #'Spi \\\YY@FH-14.7{6 HB@NT2P8
M,	O#\UX	>). +J)JIMe_Y:H+rvN(Jfw=zV:yIoUX {lnU/3+ n|-i,aWF_ 7?e+^ t]9R2i L4 + f(Tsz	_x P i>S-mLF;|\q;Z$U&)W5P P,&kkifckb@$7&6Q_{I oN&&GUi 9AW|^}!$^O)\H2LBP-- 'z55}s8U~kqsK>J5 ilVnXO
AF'8	Pn.IEq "8@F=yA0A&@q-}QxQT=T o8!C EfJdV%z"@ =Xm~9%.P! l}|P:#kUMq1$w;PRXH)O84di(4W$	&teqiS{BtgWX@aib<(.DTk@:"$T-52 ed*7FNS)}3HqW_l+Ly
F\}<7VtWD<
v*l"+Ljd0y
I<)a-D 
2:JntwTz#c
[%lM|K2Vzbh`YspcQOC}h*0S gI+I!2CTS';H1ouwNHUfc%y*2A6B2GsD)&5!p ?+S>Sk`F`>Sb AU>[^h2k}JIc3$q;&icLk~%T'juxnh^T;;]["Y7{m
7xwp* <h1?0@"3$=}@O,8=}
. rut]
B0A|,Y{$@0P1&hZ)I J7e)`>	Jq  R d?D7Q@
=At +YRznRU1A PdZBr}<*d@)
t8)G8?/smdgLi=$~B_D  '3HtW9b)FeXi)MG*E:Rc+=p9VXW*]!L  8$YGU ,xf^IM0H
X!\uxMGU@%4}#YZ$rKrcZdu-sCX9iyFBC<B"Z;@zFC=G`IQW= ZC`:?heJ)d3t.7Pn?Y&SMR08Y&IV4W!-}=%esO-pB	Gwy4ZwP((ad>PIkLLc_E,BW8Y S10p<);	e @s~e^v*c^-MW!M(KaRb"aBU%s$$'u{Q &![A ,'Lf99,Eoa*#pu.$D^R42F#bm7V1A8VA]+;Hp}6VH_DX}y  P6R e.~A /( /( ;%x@	?;%Jd_ %pt| q  /<(!G7"7~U[R[Wsf?2T)bK(wY#)Ho	w.(f{
meu'Y,z)F85gK'JtX r 5&*QC\(,o[9 RL3U)I-zRW4bqZVAcpWcuU H'.Zs e8!hruMDl/ OcKdkp@JS%%FBR d&N?!nSE5pJLBZm2Kz?wI&kdE H$k
{[!|shu,NNDw8x[G<MG__MT]1'&a\*;d(oqm@J|aLw
5@1pqhG)$^6Vl}Qw4)*2Z,^Mb({+I 7pn^H{48Q#[.LK 5|cDeu1 ([oFSb f]|d
B=Uy`'!RbhV?& &s.`>XLA VyCkl+V$n 
z6)hmYFP.#(@E (d Y"/`@<Z ?o	J^(`%_BP~  Dlg) 
 )H^rL*5-PQ+.8U%G3B
2	H;P<{&'` *Rlt+@H4~7
B](0AcTwcM}@#o9YDM+FrEh^I5xNnI$
H;*?kXQ2GO VEN	Z(X0k TMSN$v@e.r~dC5Jy.i.BBZ{psu]2XDS #$S;i"FMa%e$_@bh4nx`Sx-*|p9*6S0MYFEnlHUFkK{t,-N-sJMp}qtdyF~YLpZ4xpt?~N	|%W3N{#8IBQ<#}^
IiaOO91#2);6-+uJ~D /[HM2GnQ*g&yLN5sdnA<4g29+A yR:vY8"9tYX_9uLOVV "HY'e\h@;&mc _pR8F\k dTYh''i3qK[!GxI<(Z65Fm0 #+ o;"7 .m( #t( l  ~{ (JIK9o* ilfZax$[v~k?2`8J.WPGi
>.X5WiU ;)#D@9	$ =;?uqHW\[0ik)'(5
eu6\[HNZmrA&78J)::\.k[< -ka~V^/j>[KNn0''EF6V9Z,)(s%Y`};:}`DZ5G@GM]l6K-cZmXK/wEgIa$$zd;54Nq
Zp8v!rE_NO>|yZ<ge4jxY|%5GL	Ao)h $6;5c.k> 6R[fYD8PXMR{8'0TH}Vd`6>w[M)zPwpUE__  P#NGKX ?l%cdQ/8@	@JT [/###R? pxF#~K?dpi (" &&"4C	$ PZFm~t~5eY$vGq~tgWp>;t*4vxI?/Y!qu`)8j&8lH;Smz/f\7KkQZKN1^W4`mq{,+%wGoOxi74d&pmA1Ild|Z,P2ME#9lMIE#U$P93Q^O` O|<f	| 9sJID d kK 9P4Qk#8B,w{$ ,fkO6o+R'ZF:8@ W`mlI+<qq+J'`F(MY@n THuMXN/)S9LDrE
W$;UueK(G5wi
V/eL#	q;hX;.`o/1xtq`y: g	Fc(18qW  AAElyAV
8Ect+/kdZT{7y9$/y@	A K~@&Qt2mphh9r0Gh8mIhkC{A((aC{R:#,K
xR[Vl:CKBIXPQaUAfe kJ`1d;#a>-3E| 5Y%8t 	tPv{w9qVoH ~Q( zG$p00Bgk5$qg$>t=KCAQb"ra}d*GF>0N1*ywKQyi
l]pk SMZ<2HV@ -t,{Hsw;IV9 6Xf1+|hmvl2K:V4=,96<Q+NF
Ka}
Uhb/|69YHl U+a_
c\!$r!5h8
`NerH"lmX$8e;*>Wf#Z"[2
O	O,/yhRw  8?5sX/AZG(YLOi CB!c5FGA0=Y;, >p,R\~I@ `:EGKHB^v/mh9)k>hg@	XxE &PhcK9@7n\$A;"Z@kJ N<0Ij
 (=L((PZhd0bKP6 D\yID	3`G} 2 Q8! %~MD3 )IC4RA Q 20v]F-wHGi9+eO9c/^7R6t@?X-wi+H
K$sxVfq+3fNdjX+Vkc/{WcQks>#Yn3F9[3tkl?QB0&027
'=$'8SD@7x2HY'tz~Ld*z(gieuC	. oKY,u#	k^yzAklpV_3VgGi. |=8iF5Rf>>?4h|C{l<~:%`!{Q4&wu=2yZ+e(:1,a#jVvREfG8isZK>#-Ef^#calqh3jqtx'%VD3;}N=Z_!R2&c1%P5{Q<	+Q#!_#_{
=i $EI+z QIF7	F}	k	vG*bxKC6JRF 	xh	9J'(E @!ZQ[tdn+`)FW8#	 9t). =F1p)!` c| uWR _R 
P;>&)dedx[
"&nipzLvr 
zwglcb~P=9hpSh$:}ciq?hd}CCP](:5bXvE]D[Kf3w'E~WPC]	[?HU)|MrvsC;y|1oBK 
x7K5YluF 6X34 VB]DWHvKaM[MI(2,St}!Y3@]Nha#b7ZchCMMDK0a-$uxtk oO>eu/p.}4ugq.-uRt_tOH]?O}/m<okWKsu@Ihf,6v(+z3i3kq#^,= 7]7KK9]DKX><GiOs#Hr|5SsHvr8_a{y$kE:~@VB=b$76yG{_Z(.j@AG4wE B_~ 7 @7FAgB(@ @#!>b_ a(G=SQLA -0#s8KT|$@ O3(cJB/%e{#|{ Y@s-6D'ub>(&ci>-<^Nc#69jEeyb UP~e%-3TM$>(~u=A'TA	c/&rF9p%`=\! +R%|^
^ooUiJm<#x'eIcuZ}7YG 	)c7Fmc*.H	 ~c`nUm:A%rSZ:Y?nj-FV#vvv!snf4MKc 5A26>X|jn0cFCA[6I wPo]a>;fzgnGZ$S{_ JY 6YVe:8tnJ	Yp=$kId0'i$8ZlpnlT^Fce(cTjf
4XJi5QL?1M-@qDZ}!lA]1 b[O
[W
k6-fpXnhR\#xVGM<IFrhL.#o*!G+SH!?h	2z-yH?+ ZA[;cQXm [XK8IHSgq1v(HAyJAZKF)GA7=i . /	+)) y x 
-kBL${S:%j?Bs_RQVWt+[otp3Eh!i6e$p*
i5t#I2[U2,E#hkXyY\\@')vIu%qNYmefO3A.8M$]{@4O<O4x\4|lW;qr) 6<o)kI;
) Oa{ mI|%v%H'/}}}U.?6@vw\A7vPj2{
(kI$A+Q8)en/=$0i
YK`nH@^3fK-p\s.Vv]D=n@wA;)O{N	+ >V-Vg/oh5U2XG$$#ln+v49>WkC(G{)+6F;A8Tc9w^S`,Xs	4qP7+!nYZK/umtjnII9S7c(56'et9T]W[ d@-#J6c7*G;~IobHpD&U5TFB+v9P0
I6vPNi}WEdi P'u|_in8c\-<#4?pjm\^XA_u;Z
fRo0k	lZhX0VotG_BB(E(^,n
:8\XWExAREFm~4
8KIQG R=1Ip3ioHQ(tX =Ih"Rg'vb#\4
2a);G)]SY \2$*s@9WFvYfE}yg.&}wQ#r7is`H4/ Gg(*Ms;
 8a!9!YOS]
F$ x'8=R~  U~# [	W >L/
e wT29z	.)|c&ko~
wDNDia+k,Bg#5+MX T#C \Yu 8 ;cfHv2R(h,8ZO@X/|,>*)L${;l
M{ba%J(u6h.$ RM RAUac+JFfgE~Yrq;McbrGs5Sa4%y Q
fS>lh=K"{ nX yk}k!^aJ8B+C/4u W5u{q ={g|]ta2,:koM{&	EIQ:C` dDXN2FFNHF@+XV
P7 N)Tg(LW;>,\El;jU-\R;Lw 5qaXh@@I_FnTs "(x)h}
{%=oRhE'cp@sR%[%l@@cM8XEiY3 bWsJJ4=RF+ PR~xNcM]RZVpn1u(pw)Ev(   E2v67%!y
Ap
MQ<pA=e<B[x>RDy"NRE{)$VJ(R)&3 @N{xW&X88 EU^"]?T:XjQtAO("F+*O[ =kF\0fiy\]lZ2#wfN$6M;I`XE m"F89y	m"?<1<mRWQ!*f 6!9>cu8N54	x%&frP {z$uh*ei2ZC[# &
vQ'p".i4=+@EF;^mOQNS,m.w	>wWC`rS[Dnhi>d/U!%dRk7Tq'4:@>8  )jb;O #|W)lx qw*bI#gi-n;f o<2cccqsV+zmcb<<{Kb%$p,nJ	yVi{px;n6Z,x|ab-sd}Bp}R4BZ@_Cn-.k %_	N{~3Eb4K<;$wj LXiKW4G|*Ad&QG]L6Q60
IW:sBB @ P |
" |$ ui,[J@-T ,`Rvw6
Za Xo<7)F+4och U )k|CM i)c~SH7Gt k N}@6p J$wGu$ Fl`0x N5HwD~%cGQuN6m>+u].T-WE8n'}	_@uv7r&XrVtbG2Vim4_n;v0*M.\Qzg .OpQ& y[#-~XJ|@H3E@<!;Wo+)"FumX5MPM?k+dZFB7X$MC|"O@lfGG
vm1pBthYpkEmwBry\eTu+g:\H+ j` 8~i0UKwN|2~7<$'QEQMvUFCMQ\:iab;Ez:K?2[5xU_#4 8l4>%Y ZG"=A]}|_'5YZ/<',p}DeCCV9I6	_8t#l0MDiz9$pW34Dd;!zDRkKoe\kwsN.	b:)~^FGn^6i{/?_O{5v/&33a :4dQMW>=I,?DNRv v(P!QkH@RcJ-tCsKMM3DPo}W|rGe{"T"8FmR|p'@o )< ]lQH6IXkZK@*)y7tE
r!H	$y@?.9&<O  9('C)MwH |s ;gt !=	`	6 FN@-y _	w@HF
eVw`m]c#Aav"i}6UYL ZJdz'.>.MR4
>/G
PPc4e=|8<}I7Wv[,mp#g1u%$v"XS_oz@=W/:c^l/\s$w;u63OW6\ztNh"i$#`@
tCAyVEJq.yyJhp:H4gNQB.zlzvWck=mzR#J	e^HKCt6Q3v> 3!q	#Cv^:[f!mP 	HHZT!ZEf5LI,2H{.2U$W q # TDaPeS_]*0z=Dm^]e=")s_#KpVKXh6EvvoOx f"GqW_Y'r43'EWaW?@48vX[}d:q  jI+hKpJzK+'P7`utEn)hKumt~>8Sb.V+Fhw!AB(|S'U ^zXdVpG6*0`P#zI TbHK
#b< 4vt.CbqRAk8ZDXhJk<yi\E&wVus;G6Ht&0P?		  ~Tr ]Vo#7!R\v5v| 	7uGJ3TvN{p KH ~8=Lv. R 8	 sT#(4	+mPV8%aAH5\dUI Pm9U|;3[$UdZ}k%=1EX,gu>pePq/pS `Sh r< sy	X)H =biBc!&4o	4%Q .0=cE5z'8h?Dl/kNm;	Lg?7$(eN@u_ v7rZmqfQ||2I=s	[t28Y>H  Wh<+(S'qO/tx)[.0MI4fg=\ & Q!;b#oA`
<$?c4$N
&_(#b=_Qkb pBI'"S=p'slKOug\	wi+:vYU Q!H']Xw|\1X1KkIAKi`%9+F;[rM2m#D:4V+#S=[@7~11tQ'Qwka7^nhGi~#\hSQh0=6+GNucEtHHFIZ]K?R/W$;vU+d&nl4c8LoLpU)>+Z(Uimdukgy)E/*A x^>s4z;E6Qu*0p	{B9DW]	94|*'I  4 uu ]2w;
KLG""VKF*N<+a8vtb8S/|{0uJ;	u<f>Ldcn2Q  U rdg9K b'6Rj/UX/F(pki0170)J`<osMjx	GA)jk
|Z C{( Jn38@pCt ,uFS\$F^vnsN KhN${y@/wJ 7;x0E<&nxnE@w{*##uYcGr}mE[UEgZfS#pq sZmk/M!nGbhT`)y-.CisOf"nrS>xF@I$^soEh;L{ofgOk@  8*#w6 aC<i\@6M{-s
L6
$,BhVc)ce%e>N&,0"0dw	W94lC`kA'=8C]i
*F=
/qoi`],Q0mVge<&idsrZ6f&N<YX2]$*QdX
JF_##dxbuGeRJgi:93u]v-]?Lk `+vCj/kCl&M`4MzfP/UwdEBILv; dlJ4QMp>s0kTV|t18I&9|6
%b<k\#+zv@Ud<OY4|-]LF	Mfj%'r'{<y&d!
8~4].Wibx$A_u	aqy4"M6$Gm' i3G|(h;~pp*5M a_tp@	E'wz E.C5XLKU1NiW^#!w#D NFT#9y3nShH!#riSU1A yO g08<Lb>2	 a8E@'eE!~cDO Iln0,h mJJm =% 8ye>i4n- 	G@utY iXoz'z |8/^3SXooFm!6;biC\-c,hQ;o|t<4R@mXf5<mf	.Fw_$7iF	L,}er|;V- IA'#G\`ule(WH7WnB{=T(/ uNmt m<>j-T~tQ)YNc2mxpIri>p'F/&Wt6!Ln_FK'C*(iaY}Ivnl\llrNg[t8@ 8]%XkMKniCG+,=J]1d7jl-7k&\K,3ts5Gxhz,*lmGX(j$:#F&5!?qcGT~ :y{tZA]I	
MN4n`O]qh\zVehp9W;\DZu}Lvhw[.w4C^C'ImZYc<x.T6?'NeN,Ctka o[xcY?CZTadg8`	0o0:O5?"mK):U$sK]Ss}%[s[;^y%!(;EUmi2hz+RXZ2=}J8 #*B@a?r[cz]=pGd_G#0>{\6?e,tR
{MP|evCydh^cyQ0#b3d
xfEUOGm'qVN08S?%]sY5AE7#e5U5Ws9#k4@ H]uXOq|(od7 	!9!y'bunkGtY	
i2<
b>(ps 3f-/q;_mBp|RH/;zmc cuI4p0u8j#J}cX.v
8THl[m1!IZE4hS1)-cMDs#i$S|-UY.LWb9&b; SC '7vz3/p~	e?8UX?L8Dr,+ 4HF9#:t9~1FKTI"KrgU&		$&P[;th!XyZ?;krTK8gqeW?Feq73D@6y*ORpS l+o,=oS~A-MJ.Xp77M)a[Z[U<&3T&Kwn@/RJ4U5Iut.&6JrdbmS_
i!6;.$78]|tz*<.{:E-f|+:IlQ8,m)KEY6ZHKM+VXIx _HZdef} pTg#c[@WFuM3^ii^Q5wc^bsay_O/6Pvx\n*H.%+VIl y*yZG}UT%$Ak
a dnQT3%Ye<b~i&V=)p>Z5,MJd	OZ OJJp: yX]`O4Vgqi FCud,l+aJ&i4WD>FQ6
K4G1|n=Q
r@$06UHq@$^7Ct<$"hGkW40_P#1HH'm)<yLbqF(rHCEcdc)t?U#@Jz@'kKjmC P]~DHI3&FYErAORE'd|N`aknJA\,dCx[rs jZZxPk\\rU{#7qhiu##14vH)pxn
>4a4>G}N-$dN6
lv}^y26vZ0.WK($0+7U^N*i .;)f5NT:unnrTpdr&DuS4]40QJ^szlM:_VVELdSu=AM5riKL, ZyZT]IzrLXFui]nN. c|yOtjC>KMWWuQ$C-k%= $_u~G&OtpH{@^+$2['&;]I=(^% ^1C?B&p2Zb\ |F)}S3MdU<^KE%h5QPkFj	QO	Cq7+7Fli$m![Bs[ Z&jp`# HGQ.$WM3=F[fH5yW|$3ZgB1xhBtnas;[d	;kzf"8Q$/GV^2k02oehaonFsz;c^F)ge,-DYO 5Dld'ct6-St> er#)y\[5V\ ]h>k#GOPUWktPU;]1ZC'eT+GX#QU&CC"4e8$:*j*M#~xLE@ wN$IH|EYqBhwsU]($$VpDH(E#\jd+\^i) yQpxJ3 .udeiut0^&4?J,&Mw8rUzQEw@) o))S#0aZe1;C-G'+:Z>G2Y4_Q;XQN ZXm	T;n]8c{9!Q@tFNC?K4-~Zs	HL#I
$|oaj=qC<{.||9q+i Bz'N Jp7j	AmH?:%c,FEEIS.3qvLu> 629iy#qkaj){+~3'd<Jy$Y0s:P6'h;$N	lr7L{8El6)r.k68{a"N+oFQhp 	oev@WMb\U7O#]-dtA:+~1#6O{.|EkFm. wiM3 mwH3juB=Y;q,?~Eg|$ Me2>3M30
w*;P3H<)x9i 	'Jy"yRv;NXV0|  gd04u(Q.w+os}wihWTgq#'>kx<$q# !,E>!x^B`o3<txY7W5Cc*db,$wFCl8$+2I(8 ox8ls+wa nC
`A8/IA-7 d`n:G]{=A5ir' C&]CYJ+gsCIq4EWO~Tx5v_B_}:.o,S+Mk`qA#coj;KDNk `x?I.*]rN#to~B5`#/hc6	62L8:Q`Td}DU/y* N W)Z}
VRLdM5}i/u f0o;nO:x4HV8rtL[+k]Y8Z<=q1t u(|kv\i'	?8(1zemcxn3K2ZIHN"g-OwV WT
Frv.*u9a6Q\&0^69@5G*Fa c%$foJ!h,pvS
d&'>D_;qj':H,-dIZtOf)@8+T	PK@%Q<q4Pz=GZ(9uV6%m%%lyOgugVmW)b;+N?HM./NuABas@TzB15o2Zn E/RZ24fdztlG~_/sI eP8N<&O:'<^c"T?hNC+` C{<3cH7'.#?)`mmi 5UH: 8rTscXtVXVAwY+ UeEoszLgJERPk>"/PyG<s_V<GW	=_Vn *inVH\8;*zwzK{SlC*Wv|(&E 8WMuEOk1b  1 )CQ97zhd-}'z(ho$dV[lti>Nc+;u9@u3w=?>u06Be /`46(bk@A@wA[8 eBFaG>t7`479lmcPT)RB}:>+oZL{;E&	3[)@9:mC.KS=NN%V-Y^z./S<GQNJ08Tkq|H gMaqNg]``,Cej@C]JJLJR=q9L>br:$xh kA+J	 A07qItOwe9qL\kAl>>hd,hmynbq $hJcpe^a >ux:1<~+pe8'oSDFk{{]gnI#WTHCtu^HOHvE!}'wL7Olvd_vN.CH @nfx'dArRNy4t E?}c7i{|/U}\[U' NO7!f.?bjYu^IhHbp93+$rE!`6jbs&Lu,xKZCa4v~xS8FKeFrNjb uu{YQ.Lt<l[BCm&8Idu=vVDHk4sDw+B+]D x\i#l5pis%k1^gMO#.q$i'EUH
_5.R$_u:n4z$nBT`Dc$lX#RVqwfhpd_A.?= W~CZvC'\TLJN2MZ6B \~Dd V;CF+#^N::*BU`E<-j_rZ:.(^Bt3O"kwS9QN/i<#z#`3R	m[
(B)UwZ	 Y|{C4?SqB"=PhtAM"|T!/ez!t
^l zK!/B`zAT" (B	}E&	B^}>m,4yuMTgM{.!C.D	|Btw+>Xm
<$N!{n,!r#,0$c&=+H!u`{9IHzpIM1HefIjg1!!r6Vmd~@ZYiABEk e'`	B^0{<L3[xBA^>Fl6B?^1~j_!`BI&_L>"qx0Mk(g|`8Bphcykl4ui'I V'liFY\!,vBL}j 
ghkUeI!< m03y4 XSQ0HKCcn |936Dd B3F>Yfp |,41_2fVuAKcE-^0ek7	Rm3$NgRl}A|:9P.8r|+B"Vt`(B.VwYeduBMT^R_(BW&#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

#define RFONT_RENDER_LEGACY
#define RFONT_NO_OPENGL

#define RFONT_GET_WORLD_X(x, w) x
#define RFONT_GET_WORLD_Y(x, h) y

#define RFONT_GET_TEXPOSX(x) x
#define RFONT_GET_TEXPOSY(y) y

#define RFONT_IMPLEMENTATION
#include "RFont.h"

#define MAX_ATLASES 5

struct {
	u32 color;
	u8** atlases;
	size_t atlasCount;
} RFont_info;

void RFont_render_init(void) { 
	RFont_info.atlases = (u8**)malloc(sizeof(u8**) * MAX_ATLASES);
	RFont_info.atlasCount = 0;
}

u32 RFont_create_atlas(u32 atlasWidth, u32 atlasHeight) {
	u32* atlas = (u32*)malloc((atlasWidth * atlasHeight * 4) + sizeof(u32));
	atlas[0] = atlasWidth;

	RFont_info.atlases[RFont_info.atlasCount] = (u8*)(&atlas[1]); 
	RFont_info.atlasCount++;
	
	return RFont_info.atlasCount - 1;
}

void RFont_bitmap_to_atlas(u32 atlas, u8* bitmap, float x, float y, float w, float h) {
	u8* buffer = RFont_info.atlases[atlas];
	u32 atlasWidth = *((u32*)RFont_info.atlases[atlas] - 1);
	
	RSoft_copyBuffer(buffer, atlasWidth, bitmap, RSOFT_RECT(x, y, w, h));
}

void RFont_render_set_color(float r, float g, float b, float a) {
	u8 color[] = {r * 255, g * 255, b * 255, a * 255};
	RFont_info.color = *(u32*)color;
}

RGFW_window* win;


void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
	u32 atlasWidth = *((u32*)RFont_info.atlases[atlas] - 1);
	for (size_t i = 0; i < nverts; i += 6) {
		RSoft_vector npoints[3] = {RSOFT_VECTOR2D(verts[i], verts[i + 1]), 
								   RSOFT_VECTOR2D(verts[i + 2], verts[i + 3]), 
								   RSOFT_VECTOR2D(verts[i + 4], verts[i + 5])};
	
		RSoft_setTexture(RFont_info.atlases[atlas], RSOFT_RECT(tcoords[0], tcoords[1], 
														atlasWidth, RFONT_ATLAS_HEIGHT), 
														RSOFT_AREA(atlasWidth, RFONT_ATLAS_HEIGHT));
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(npoints[0].x, npoints[1].y, 
						(npoints[2].x - npoints[0].x), abs(npoints[0].y - npoints[1].y)), (u8*)&RFont_info.color);	
	}
}

void RFont_render_free(u32 atlas) {
	for (size_t i = 0; i < RFont_info.atlasCount; i++)
		free(((u32*)RFont_info.atlases[i] - 1));
	
	free(RFont_info.atlases);
	RFont_info.atlasCount = 0;
}

void RFont_render_legacy(u8 legacy) { }


int main(void) {
    win = RGFW_createWindow("Basic buffer example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
   
    RFont_init(win->r.w, win->r.h);
    RFont_font* font = RFont_font_init("DejaVuSans.ttf");

	RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
	
	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized) {
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
				RFont_update_framebuffer(win->r.w, win->r.h);
			}
		} 

		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 255});
        RFont_set_color(0.0f, 1.0f, 0, 1.0f);

        RFont_draw_text(font, "abcdefghijklmnopqrstuvwxyz", 20, 0, 120);
	
		RGFW_window_swapBuffers(win);
    }

	RFont_font_free(font);
    RGFW_window_close(win);
}

#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_matrix rotateAroundCenter(RSoft_vector center, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_rotateMatrix(m, angle, 1, 1, 1);
	m = RSoft_translateMatrix(m, center);
	return m;
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Textures example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));

	int w, h, c;
	u8* buffer = stbi_load("tex.jpg", &w, &h, &c, 4);

	float angle = 0;

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        } 
		
		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 15});
		RSoft_vector v1 = RSOFT_VECTOR2D(700, 100);	
		RSoft_vector v2 = RSOFT_VECTOR2D(500, 100);	
		RSoft_vector v3 = RSOFT_VECTOR2D(600, 200);

		RSoft_setTexture(buffer, RSOFT_RECT(0, 100, 200, 100), RSOFT_AREA(w, h));
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 150), angle));
		RSoft_drawTriangleF(win->buffer, (RSoft_vector[3]){v1, v2, v3}, (u8[4]){255, 225, 225, 255});

		RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 200, 200), RSOFT_AREA(w, h));
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(250, 250), angle));
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(150, 150, 200, 200), (u8[4]){255, 225, 225, 255}); 
		
		RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 100, 100), RSOFT_AREA(w, h));
		
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(200, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(200, 600, 100, 100), 6, (u8[4]){255, 225, 225, 255});
		
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(500, 600, 100, 100), 360, (u8[4]){255, 225, 225, 255});

		angle++;
		RGFW_window_swapBuffers(win);
    }
	
	free(buffer);
    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/textures.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="textures.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
 JFIF       C 	

			

		
 C	                	 j 
	
  !1AQ"aq2B	#Rbr$3C%4Stu&(68EcfsFTVdv'5DUW            	 K   !1AQaq"235BR4br#$SC%&DTs   ? S@ @ @ @W)`%pF3; deMNZnmu">#C
ZJ=]MorquO+1'^,.W=Zq8MyW?lYj ;vvU=8 .?=W/  , W  ~_g  ^ Yc pd??{tXx .??Y2}9 C;|+ JX}9vSjjpV^^qZ jt_hGq6qL	C+3<sBQ]%P0xrR;b	 @ @ @ @ @ @ @ @ @ @ @ @U${x8 Iv&)|4>-)`$y]^eK R!_Qj[??yj[d EVAxq0nB gr6=t\ H?Z'b_er5K~ @ @ @ @ @ @ @ @ @ @ @ @MHFM}TG(|cn|3NcK[ P-rd}2+B-> JgnFxqRQ
]/Dq5\qoxjq[h?F' _e2is                         *XKoY]Uh\[D?>2Az:e6on[?+KfyX*xi{A}EhI>7Gtn "Z } _'PU; @ @ @ @ @ @ @ @ @ @ @ @h	>^)]t:{xegvd{~iK`,#Veljuuwa		^Jpw9' 3efLm( U~GEOM=}|q j<Val#F1Wc~eeYhi&6u|I[=yIH]OT ?U2*MIC^HsN'?q jo~v Gj*5T|+g	WN}{~eOZXg=%-:YnWfqM!Fqs*\yd~ChMT-(O(                        #\}M,N3@t.6YqGCfIrz-(@i` fbdu@-j'(G&vA4[ seT8\GPnlAPZG>N-V\9PO~r(V<y= @ @ @ @ @ @ @ @ @ @ @4V;T62^@b,rFJfecw  /( i~:+&PItm(Z]=^A;D4gF23=tYc< (.>{}
il13@yhKt.t 2D|[(j
'!: @ @ @ @ @ @ @ @ @ @ @1k:c[OX 4b g4 4PN=
ky2W$:{]CqWts-.Z:5RHq$=$|O>(y#cye>hlgk)G4nk(y,CUW(]C(-GF|=Eu~?8d}mn3)@Lz2qe[WPZ5@l1H9^>($ @ @ @ @ @ @ @ @ @ .73 @]R3goz A?+-*_)d4y67ZG[8!}<
4T[twOG(}1vMgQ\)|wi#@n96_yIj"fPkJheOu1=@zAD;NH*mDd*Mqn9u.Q]DEW[N6=5vp|Gb                  
=ot6m#v=p@t^&Q60]u(7% )kBAko	'7wq&d"*dO"'0z`qJH+swydUMoa @f$VYE6;w \BJ;(M_M.10?.Lr>% 1o4]U+47r;'nv }Ud5SUorDs*t33|<5S*DGf$>#@hP @ @ @ @ @ @ @ @<qz>4il`.?@`lq@\T{PKCVI\]M#y\Brt.Ti1<Gd ;RJXji^dvI@Z 8D,79hsHx93U?z4)Pk{5
g\wy<N+|{Z.bAPk#C=T$on:{#=l,;P %n4GQO3K^%5+$tMe@QY#H-@L9dm)tGhwV|ZZ#! @ @ @ @ @ @ @ @rE=;#`Uhn4Tz@i A@R~wMPX !)i.xqxZCI?gP !x_5qN OG\Gv\NotCngJ{I7a@RlZiE=l~69^y8AEV;zvp!@ih.Nk6VBCb>@^=z@@QWP5--.ImqWg @ @ @ @ @ @ @ @|GCW 6*v0&[ ^^@j-j
d9K;r+GR':GO^ Ax0gv<l
 @M~STA+$4o:TvlWzg:WpF	VT>x'2BIo@tk5_oMK>n~iw;ZDjao8e Gs3:CFY]Ep}$c[-zyw&VH~G>rL               *}-r6_!E&5PU8g1'  +<=	^
zu@I/'zy ;E @ @JXukmx=2jAwIGpRfpcp *6M 6kf]"9AP#@#!] 6x$ , @ @ @ @ @ @ @\ 6!u3Hrgi=B27@]St5 nP(-NA[+C0>$nks
:nvb}Dovsd_   k6-:*A;77@|4Z\ma (n<@[a.;|2?[MA=iVr)u( A;<              )5OH8,hlM@mhN@\trD/@(
r7iH]4Hbdn4o  5v5Fz= ;*YL8x@ @>ia;zx09pVhMIS/5Q	7Gx ;qk}Y}dU04-h3W*Q,nu(mr5V[vf!,'#              2<Yqc )o@t-&P8!uJ /-R@i!w4`=2QXc@V\	LydE\>FVtlwL$=[>z @ @uzcovpKG3:n@<	@u67u@vM!(&r)P7*WF0a
zq;(@ @ @ @ @ @ @ @`(U }f[<[Av(Ghks_@ZJZ5C26
r'(
:'<B#Qzo <,=m?i FchX/t\.z?5(    >j:_(-wgdDx .UW8sFPoH27g.&es#'g}, @ @ @ @ @ @ @ud,e75T.s4(:g)nk(Y
OT%|cuHPO73i@Be_Qw@qWE<.cg-cIyaDE?)c4   wI_+iiE{'~y$HNP[=I|ED@|jsQ3o              ^?gevd; -]@ZF)@]S0.TI6pg#M;k)1S	 `q{Bw !=s(f
b	UK##in#Sonm=GmOH/?g84 @y)	-
ih0,HD+AcXQ0Od @ @ @ @ @ @ @i s}9Jc;$P	=|PJs8sF*)w1bJ|D]cN<=g!2Gk B,ah7mW_/?4o@vvI }~@i  @+|cZY.~5cw}HF5ra(XI6S@`z*#(@ @ @ @ @ @ @+?z 0 4`=Tpr*BPPKl4 APja(hsA#y#9&&PPlD?<?@p0gZ2Ih3`+	Bx  B{}PX.<LNGnOT@utn18n/^ WVd}4ou4&H+'xG;'Te\#qhr"g|P0 oODgUvg:EYA@L@ @ @ @ @ @ @Z C=ZO7,!v
{Pv6PQH9 +>O@Gf1pkCGAHl|/!pV4=w82dlu|| =~OoE=6cH@XNAQ89y%ov~c/-H              :Ivs 4~zsP9!6@s9, a@{r{R@zb	
H #L0	8{G ^P}E@Cs/~:unecP1@q$ &@K0zDQ@4rOA5x<|S#> @ @ @ @ @ @ @ut>UIpZBv@[@XDw@Mz %%%a>3v]by:ezz5_-R<%hh1.OveX@AqGBtNC!8	f: 9;p@F@gn@lL+c @ @ @ @ @ @ @q h jbq>wdNt.l>c	?!tlwP79@&<t@D8'@E 	@p>>cKL($O~&@r/Dva/=D
dr_Gk-@ @ @ @ @ @ @]qI)iJN=wTo	QBDrJ\ Pa:|w@Ln~@r4(k<@@zh@q:o#9bDz4 <88$ 8Oz0 #J@@AeWReQX}Wc]q>u-H@oP @ @ @ @ @ @s~LH	 ?W6~T#Z[   t?|^#v@K..	P@NiA@rNCIt@	!{ z 8$}s(3*jwYVBXs8~Bd?2jhy @ @ @ @ @ @ @0SQ=\z;X\z?8i)c\dVcPh@P}`%U Pc1%L $G[; 1TW:Pr\G-j<~4wZ<~ $6D}@r@{]? <|BG3pp^O pP~HfqJo\,*TF|P5BSyJ}'})H"*XH;@l @ @ @ @ @ @$5'kI2VuQi>^qtUbG$%X*OD.-"csi?!x*jMSLqxVNf?r\rw/l.16jvGi/a&w:'gvDfH2w{jTo;wgA@Me	v(@r6C-T8B6v<m =KLM4 <|BQ3T@{@z>izV 5.BRw}R%?NV9CQ OyVy+e^5'?(8+54t]UYXYVR[t9F"> pV=            jA60Q.#fqWcJLO,QfRt=UMtQJjErzI5t5R'BB`<emIV) 0Z-}W{m{H$,A 5db*u7?BY-<FK1]^[\vL9_#2i"4u"BIdm<PpgIG[';:wvwR^n;DR[$|S9pllhc?Xugirjz5cukmj(,r%Tt{q#s3X;(7v =Ju(kr;nv6k~mSW%;*dwhCI'~6iF6R}Dn!rLlU*'l'^o#U_m	ZQl8epa`'5Xz-mw~y7qxZ8&ZF5?O-[p@b0Gz"(kqNPJ;J+GoT.O+)lSS6z>r@D .8 S*_W:nknj}tL.Lb2 2dd5JP?Jy=1|bt Zz6vz&Z~[4LU=Cv:j
XO4	 1^eF7+%JUqx
mE&-Vb+UZUHmd;7n ?/)~#W94IO-w%6G4Zya0x'>{,Op	bI)Z/76[xG)cQ#},nx\\S7dOC_wB0~qmFJmZk^?[6e{Ky $$8lGU~'"_IOg:ubUC]LJYkB}ybOvUOQc*9~
zTbkW+Rtw{-37t366
*U+K[}iJvSz{\3VjT[#[^
+'nOznE @ @ @ @ @ @_qR7	%f	gR0=2?KEzicHd,pB+QjA)+J9E.Oq6@K&kz6@OOC^k4Qg;/WZ5K7_Ga*k]b$v2f8[WF~|:r5=tN~Se{Tip^)z"1xI{sOx,9XfKduqv]%6	*MPq+/HK_m 1(L=hVew"<{WEeW]WUW2:Y%4alrCllIgFOB5#8r7wYh^^"cxDq7)U1='9Q*p&JW}.FoN4\eM[88.6z;MkxCU-9#u4o@ix\rzBrK_Bg|+z&*{M1qT\Ak}lt\A>rahwa"{r^?)p<(rJ^rR\<noMsjul<Km:j546:J_D`Zg'xk\0S.Z=KGC.t/IUe.eS{]ESSL)h=
vWTZ6;I(y_$uU]{J_)|:X*Jp^uGoCg'IuQOQGGf:Q-23:@9n".`3'YZm&xiBFZz*7[VodHg)8QSfV_8H#cqF2:&a{s
jrj$IoB-eMa8M]~&)	a"RL;UrU&+WE3(S$IJRnh]\5w~km?|K$VVP%<HSHkNjI[kCF#!>SU)FvSg+_WCStImluSGLyS'x950@S*)^/ZArK5$Ss~hihoVqKOwAl-&"1pWe	j_E_htV:ov$O['-uHkt/hZ[ws-U9UU*pmOYnI=f{l6[ouMi]Jy#5n6k@ORk-:3w.<q"8EXG*))_E}v	W.=p~yIVB<9j5.S<L`	t5 dk<)[UrL<QtOELx?3/,^ozGic{^5.2/R~sL~"W2nFR @8]i5nf6qi oTp/.)^u6G=Hs=,nCT9Txw,WyCwV^U;O7T(R4,:oNO^-wr7[L@ @ @ @ @ @ @=2gS6i[ f[
Fr>/d~ L?WBz+sV6eN:)p!Mt *QTH[
vQ0"k[&s+%2K>fLz%Rv$1^Zrg;Z:u{^ryYgzy{Gz9d-2N8
#:3WPRg$JiiS$m<= {B`[NTA+]"b$I*,O+,o<$J+*&S+'%X:mGU
6|%K?aOWi?5s,N]nkX-h @ @ @ @ @ @vJs_<vhW=>/d~^]nTig-7O1:aKhJgL6W!n|Uj2WE%oW7##wIfIc}P>Dm e9@K[9cI^#7=h^.N8Uom`j62lb
.UL[YmQSQMdt
4#|TD/F-'0a_-)swjvx:C/~+_3Mq&R|48*'tW)Et_ SQK%xf!QL8&QY5Wge,tr	$?a7gJ)E-L]#2O9_Ly%' .KDPjn4iY*"}a%ot#)]&'fdkW<wSHte,T5rLL1uWjK]KzHd=JPLPFI?b{@n cp'}'>7\%f             q]LEX""c='av=W4S^ 9tl7Wz)Ok
e=Za)PPn-l
u B"OIU'b4Q)^6Y)`
"}ETi8XyGY5YYF6J"=wuNgQSv,g49e'.N_-gIRWqRpC
+* @{,xk>{2ey/F?y5>Lq>kG ,V;>"{>k(jY$R~/w-4bl'_<.>idR^;2O;bRma\[I,'q<zUofv__fuJZen\h7_0}qtBEghco_pnEk0FM rN5{6k6|G(nbx4Wqn!BMWOBq/|l=-H9A)*|sj0Y:JN|ac_-=omZbz[-3L	or&i*=c2R%>V
^D{ #b|t,&uQsw^:._5tw\Nq-5bw57'+X%1+A+]](VdlWwR&RuQKSSU
oBg(U	p 
dSCmSgK Es*g;u/d+_k>Z            	FL	0~#e{,bfG~Tn?y~1a&{SR:,i#
\3ilT*2WlWe.Ez9Nl)uz{L^%ch2Hz6h'G=YY0<F>}FW:> ;Iox^z8/N]{O~(o(}%53:QS>ohpSL-s|~yqO~zmE-;pt#,5Rl&J`d{-6jCY &SpkWe}jq]n4:>N~!w7pg<Azy>CRS5Hq_SdpJ;-/ig}0p~,q.v
2q}Ks'5Q&STt`7/\N9xIqg^Rk8&X/'NGNfc~LS7w%^sJX\D3Yt5(;7aB8|bpA!YsZKaG?EUw'WSV9EXbby2||CE}zCG+; H>&*yZ/oJkik-hF>&xdLtqL5)F%fu&fn{Qaw	b0R|ixEsU}1_|vXEqhS .wn$S\i;>|I9bis_^o;Lx7E}.;/5QQndFCKt*5EtrJE^=B"}6etN*eT&S+*)|O+j)2! FlJ|ue:ulyN}\<Gq$rjNUUb@ @ @ @ @ @ @^9_UwgG27^eOK0eN]>Kg4)U0*=JxHB}G*h0"-IX+-!@D)KXm^x$C1+N^4dtWu&F8%UV<)IhgYoB%A !@.	fcZe}goeW[MV8 {8^oImFi=#'-G]i%%4#i`%xMW_f=}\]Ic1<~S~ldkDyf" ptlP~|:\*yToV[
lbZLPZ6Y7qHSe+W>=P`eiezRU7|9uP=xI2f^RxjN.QKx=V}p3}$L%H77r6k:?_x#Vqf=Xj)9bFUq,N_QA]MX"<kWjRO kwc:Xi=lg'o0e2"eMe9yJgcsyWp;T2?Ii+asVQ$WoIIka5i}<9F5T&)naWJF"#RBEMD"d
=jM3	N.HrOn#<W~.?[Go$t !Rp@ @ @ @ @ @ @6OkN'{,b~jGVqwZB8 rxUGzl$Ud'z)p"JE0jBp5wKM
Ji^-{Hg;hWapS*?G2. x)BZz> z]s"l8%HO+SkSNsmdq_`<yB
k).	}8/ kzHZJi+2	hSq yL~bWvG~P<KnymY,$ky5A<;{`Y/{.`glFC$cGpp#ec	FWzhrh25>h[fOktmj8y#51oh$clg[CNN.[0Yf*Poky+{H^t%*	#:$FY6}+8
B}?{!p]u5N&aw#ssFJ.wb>K-nerL"w`n*>;]icc]1$@a=F	[U^<>SN)/v_!yIM%vKmD4uR9KUML9$vqWWLe<&cNk5v
9OrO 09].JWee^
+/g
vk]%Ul|cs2K+l~8xgu 8s_	*5f:oGfv^mn"j90Apk\79qnw_/a,M{2:.t_c:u'
m_@cJW67y%.B|BK=<=S({[t^MC5wi=yiMY4v[=4lA7Zm6l3g>"5ts4*U^=zgev thdtus>i)_iGke:9ls[{=A3|1|:2o_e(yg9-B;3VMF`s\3x>'FCp!{;'y@^)qV-TwZ1Yh|#b^tTPWS;*y2<BlW>`x>fb0oy*QvJ->mv5F-mz=]3)WH\v >
0l?((tu]_\_ys	kWmM]Bv{+6'~HSNq-IeeE9+3	DHF<U8{yC~~tNg:/-C^2u:NEZU4h}\             OpU7 |)0 $lav=OHEQx!O 9t7gjQYc2dTDce&I6Imp`U^O[R,`^},o1 NF_i>|+qs- YQOJZ1
\|p]$CKI'6|2i/~v[|?j N4~o_yaUWTE=At %L]${g[ge5XRir~NRQob"XDpVCmZdhkOBV?OPSxidzV;5={=FLF{t>_n_"eq?_Gm<bkBv (?X\Ws g_I?4?#WK L_*U
/WvGf&IGN];]!._;- V;:jYuLo<z2</Zui +O|1p='o4*l q : v!<7)pAb	FCUKpjG
f,w7clke!|EM}Y43^1O>ip9;Lc+>a]7Z/}YyM[<s<)q 	\&]+nK<qjF~{JON?}([tg,{oo_=b<ogkf?@qMU+55(Zn_6j{Ln+& ++#]DJQ?U]i2:+l	&';+3$tfrM!Pd3T$/^{n=\<5t{Ek|             e9exkA!s
DgR?S?]G
r9&*gV'37)0#JW9
J,9\MOa]LR-ia$>ZYDiZY,dZfg:Z5&To(7B'T
x}]kfb.6lK1^<3
i-_i&k~%`?92 t of[fnZkn&Px6rnmK*eR-X
8j~p\MY,pE<n{y|KtxZ 39%	a)Ktt? -<+l{g};4M%Zw)?6<?j75mV\?n]A ^g $!# 2YTw|x')5'f[^*q"s)o,bst37WMk^1G7hk]-e;mtkdo<aa- yeeYam;>CS,,M_uv]0<9 T 5Y~7pb )St7d r?q# o&RrIu ,g  2^Qc7}G[Gw5U\^#|X+6+F_]>:cA-60;Akp^7e}7|fZTIjY'iGjhFq'(xHNZwGKi8IO,Pb:GG3+%kZO7?12u#9/et:P;[7zVVul9lR^<cDLL[:3UmiJri9J/F=c,n5bNq>'k$P~zg*UxJu~:}> @ @ @ @ @ @7Ngg~*ygR?+H*/zu<3~j7GJ[h)y=@JdZ\0}DdG!l <+V-sFp)4gu&}y}u=_A'~x
XV_oOIo.	2L[{::GP(nc5k
4crL_4R>N#F#U]5i5G7a:_rT9|f KymDWK:EXe[	'MTk:Pqq:Ge{O8l1,;Ya';r`')JWz6ZT::fJs5H!ysF;6*9.3 ]R53:FMWIKNjb0X0H&J9vaA9K[^Ua%fv`(-~+Ga3*|+KM&8SuuK55e5;$X9G($wl=$ZhA|FjZNWZ	;_SCUk}CP|'Dy\rlT-gRn5_Knir/*kk?gdCKR,?w;>3_i|/(\Lc|YD<&PL69)k	C 	YN6U::{_cx>IaR"fk=;U:oQ$J[a`h ;{L=\`#EogQcX9\'3}<vqK,	gzM91=8ecU\3^Y~]=E(15_rem+xei]6a9{3pUn+eJ8-

IJwgd$c$kY5s9`J ^~>"v;Q72;>:mB<Z94hX#MS9m>%rpI+1<nu&gJjKmKiO	mQOVVDbG4,pl:90m]G^[8SvO^+I29UIl-O2RCS=n_3<v<Zxe'<T7 8swwp[qKbJ<vUyj"u)!N\##_$ZJl0wZI!9yC-_0e%^go6J#pK-n>X: @ @ @ @ @ @3(WEI.ed{U?wp2sS'^u,/GW3P$lDy*&Aw{HkU7li>)/Q% 3j?\V&c~T F\%$mSJpoXiY $8	Y|*zT,.Ua1>V5^4y8/9Ice})ZYn_etVYm	2<~!p&8v-TT?@8S8W:*5M.xB~	QqTEKPe_/xFscSW+^sQq(9e25UhMqWVj~)oSUV1Hrzcl6C1	g<MIq~? ,?.@|97~1#'	5Vh_%]wT|1MW#\\\93;Le8Lm5N.^$jY;azgs{p&1X[{^{Sn/\UKp%&xZv  1-k.b^&Wk.2OQ~#(*50c	sFH(	upim_fXt+;/k:pSLGh-W5:4Pdi-6ORWyv6Xl}R:q3Dk#hJ-4V:Gg6R\MG+k7,[Ky{.8?k&3Ih_q7c'n4T:F=8[ 0s*%UlWq-bt=/u%+q
x~K#$4e>W*/Gg5dg[vB;EvNhKX_b3&36hDr9Ia\iV[L>soNFMgcvvI6u	yI@5V|W1;)]:L`N'9%o**
X+&[i0*yA{m3kg2\43Xg+_U j^f3sCQrqWlLOGuvR@yyF	#(;:rw1\Q_4@l6 :+T$PEr6Nx n8/5Rx:.QRs7hv)+fB             q4-@t c^<iIYw(GCX< .o|)E,UD*KVG1G3B^xtk7'B}[2an{kHz~{jJkqjs+nG4!#e
n7M]QXrQN>L9kZk8 !mQt8Ktxk\bFt
aY#o ^6zhAT9AaI#-W)-l=h9(=]'FTL7%C*uc:kDNUn[*^+}s}K,^[/g^NIu0X-X{5/u}-\1,9fz+:]\p|
f%EEViRC8 12VqdV
5*] k^<a=d#(~bR_AWY}Q$RWh]WH	5Qv%fSw$G4Ro}>`$Kn8/L,OK3acw+{K\<;~GMVJ/fkeRi=vROl\6N4NGcZ	*?3T^#V4d^\BW7$Z'M::70 5o,l/K#,LM3WuNOZ_r%eVRBZ0#r~Y\6|n
 a/n
<.CLTM}_+,f_{U;;o@%bYVj#f[_?TdGQkPA~%d5m{ApU1z/. 6tw{7KQAIH=4lG@e<:V#QM:|(aV?D\.U.=Gb1S)-8.qWE$K1$`d[V=:sRo5}hK^G5Hd,/y6,<Q}6nSR4BUy-7No+Z?Ave{g`uZm#9$8t?qMjV4~Zs;N|?<>7t<~' gB             qsr.v{Nrp]K rW2v'<U!O+S sb)rmiMN!h:k$S5VlhZ	i4GKXqqPI^ai.k%{-}VTkUJnBO))&Frqg<mhzTzAda%\]F](4K4hZZy2u@t5` @^8[=n:JSUBAd/qx:7pueW+c_|^|%(8_~X|W=8R
}__[nO7^R[nk3|0gB8g`pZrMI]eQW4r] SbV{U<4r^_xWn>sGo 59 MR6iy[dN.=zqs*_YxmZUL-dGHcsTH VU3Z5O&9H0K%0~2Oo3eW9I*}r'Gx<E,&]tGBkN \Krx'/5O`Xl%\KTA?g_xi{Je8+dlCujXROJT2sKolFfQsc#I#k+e+E$Ni|]ITE]e@^]\z7ol0xz*8^'}eI19k&UZ`
}>j+3WS-IX8#"qk_j},t8Ul`?6I6ci;wtr<<$y&=eZl!t0gI[v{f3[}TrR$QOYWE1p)_*|w~?}Fl             -#_r 1p0?twE i 
S4V'*5Q1:ZF 7;m`C4veZ'|0+a6l\5hsRniqWbC#F8}%,#sh046d#wdUM!J,h#LsY2+d@ mdZJ[%JRYu]qXhK5!n:rzq+}=|ziD}|?UgnSLO]ZAX\^W-[IvI8)u~>z/]OpUIT=22D;GE/.y*y(Ze~|{lZ8l P>=7qr,/Gz.cu,79u$+J:M7/8y9U5={E]DLg`X>j\+{>lur_K ,"Sw{x^)SZ+E{,:h4-ost#H>T+Jcd35vJOuS@O]VI{JE<z\~kN5&ckN}V9d>TpUo+g/KI*N,~*bJ:qG<q6[EDM>W,s#q T+f/ L|\<E->WeE] lVTRl4n\@#K_bDbQH$t;NpEl99L*wrN&M$j'V]OYqDFC|oRky%m-?8u8ZuVY             1aO}c	sx?q@~dd__5?_U)|Luz RfD# IctX+jTV[@KkM
'fM7<lFs87#Je>2P&RY-85VH04V9iJ=J:ti'iV@7\V+V+Ffpx*3LzNoIm-MhR[MtluZfYNbNFCUF*rgI8w54>XVz-U|mSK^9w%*\sQTt*>qE.5SKOErL  ~o6P4m=,L,\\&tU:6WA=J>A_Ycx#
<VJ_*~g
p\]V7%k[kqBND~LqYoj;p. C$o3{	k @x.,}8MzZk:B Ip}]1 I,yyv+TM,~%6^3H*h>YQ}6+&,3o:9'`7[#OH#4s)ckb3H|>u]MK[gRVZ6GX[(	y% 98J>nj6w^ZtZlj< jht4B#`X0UU^\y4lw5RZX]rC^A;XJp4VzehJsqgeMMuu.,694#/.nqFgKK7{
V]z4<+4%452vnb{C| FnX,8A5rK<wBihkxp{KpZC|(tm[?W!2;RUi=to=7^auV_gI^K%A!s>UY>\bZCH!|Mi 0N=tE_H%>\n#1;'%KQ);u#)RIPPSGpc\^1'7k~>br~%Rg /gkf             q}(--{UA>7e
q9u,Zo|-~[*aSKK]_p@/R;uPw-":fWHV|OEfKIVVK21cKC dnvdS*> (R)cJZM9'eZq-z5)GrP#Ly2[Dq+hcx38s(hNRV^Z8xoTm6jE+`s#3;
^r[Uc.vX}OQwZc6:7rAcCysjj_v[},ufmY-qbAe-eqfsovQ*|PMQ]OQ>RVnEU;TCd#E(ie}6`9qVrwwJ<Zv=~6]EjzE|dqL_-,R=I;_dyXyURn.Mj+N<VJVz|u6zw+]4k.5j
{}C1sfkTVJP/P|tRjWjUcI|^c4:Y*	+Kih$WW^4cR]Do7[OFWI5U;EDH")Z{^7he)W}I.m,xQ&ZW}y8wm5-iTIZ##xh>}-9LC~r[:cKX3\IPM`*;EWP]u;o3GNjk3DesoOUTk[]w,|%TU?E]v'\_SS585%4H$g **chZ5g,{FmkN~yG3j+Gp4wY]CResj 6pr|*-RVW+}:ovOk_]uGOZ|Z#A]8F4)y:\Fu95{5ilZ${%mO39 qd[

X8Rtr$-MfrO!f!c9n`~1wAnVZhWw25;6(rwm(gNl7+.wG);:m*\/m%CEDKII/$:rk~I/n]*/WH,r62w>k\B^^x=XR:]$dr@pvLnBI_:Hg+e             
JZ2$%NNMOw|F?|>Z}q|r]V+,1]3*l:
nxZ'b1WUh=&GuN$kds[GSThqkGct>VS#m9a<OW=v-&gxQ+U"#o`Jdd9{rq/ep%Se
:@=`D 'p *V-'Kc168 _!G)  r9Cmyg_thzR}HCTVRkmp7kO+F0]"']>UYvKicUKzH^I#qF1XKnk
_"J+gCTjWLCYw`l)CtEQE#uaGNeh sr0	1C	v089=^*q2kM:!1qw)-f:giT4cBg19O)5n%d'9#s@(upW<eUE]d2Zj42B\9@cd/Ulu9v%_,m5lyJH3>7rH	'	pZ{YXedUH#f\N>8KG,eizel:GYQ.3K%K|ys zjRmre5NA.NgDYY9nd-q UmbfWGQ/x7r0	y_|/I}QJgsd0 *
oI~$j\|5JRK_HPN}QRHvz+Kf7JH.UjTeR:TVbPa,":djV2 9Ic%WDQlZJ*k:tY`sy:
uK-J` l#8RJ5lqV1uUP3ylr|bfYh~hodk]P/)W|rel<~,	a@ @ @ @ @ @ @^+	5wJ"*pw8?&%n[/U'3f9k9x,8+	SmeM]4d1~kTd-36H+_>R}Elp`eM8d;vT,&Wi.Y3a$%_O~S[fFCS]Wxh-[pll@K_1c%#t5V.QkE
8UIu_uoz8!pZ#}+yfX;v]WCHfRqv{[]uc97~!'a)$u~YYGfn_c$UsKS0A   I-zm]a;kb%g{FKeV+YmBcksGT92uL(M7esQI+Jql#5[e|8*_LvH p'gb<Te+]neJ4[o{pSXCeuf Ns*p!vZH]mnCDyQ?gCEmNW3?1s4t
&U6x^nyA.F{u8/qZN	]eI\1rH`IpoIJZ>_/'U,)x*/5Bvds\drfry=B3fG8FJ[bNK?_iVpkSEN!e{\N)qm<-	MZ[uV'WwOfFNZx7~S4|L?,sWT#QI6kj[K]k
~>q-nog-WS}97a\[ubP)*$C&J-D\Wu4{=izdQ)pByyr	=+&m5zn{O IZIz>M9utZj>:V=&sK>]dwd'NO)e}U<z/.K{C%5uc%syOK<TrT|Z2+YG^FEh%Wi\c_]OSKSr9WakAM]._30X_IWfFW^?&4m j|K7N>GX4%ic&jMG6I4jwR[YP\H{XpvZU'NUjRqR[Z3c3Pu|Ek.Xt	S8S8}57*MtMy$eD8BFI g|5q[Wj-u1QInO1$E-}tt(}}+CZ*#z O,y+rvWl$c9*mE666kZ0 y^dZ@#W:BD_u(]'
d             2J9w@N+?2;T] o1yq]/r<7&OeWOQxe>g\,6U)I-eO-U,,k~yzwu)I+Xq<5]EE6*'AK5xeh[{"+IF)]FVTizRp[O.8hO/0)g9eC<Sv=%N{nt 4 jyN#t65Z[-88qA$%Z$s*HU:$ccvghah EM4(Yt{=j-4
*{h-Mi{Hs#ZxpX=\g:nS{>.mQ/..Eg#%7LRBiKcdmP#hP nsf<-]%E}IHf?W_6p{4C,-98,jsFMIK~jXX^q^p6]jm;ZYN'sz=[69i=Z$s~lW'M;lQK?O{K4j#>2$-{)40KPQ"( Uh>7;>kh-,S
yf$dN[O+N26S?EWM,=IqzP.4MXJ:w2I#R`rcsWa*YsZ kuJcb{/vq~O[OqZjK!VrK/tblCOOp6kX:<JOu{jP678j}Yq*p)\E6sL"qpx<'g8s=vgppb F"J>H<KC+.:VrIJ-L<VxSr6QwvFN\cV{VTU Bk+'1hcXNNjyI6}kFk1R5.OFw*z|%
O}GQm2;jzIvD~G![I*>[kQn:v}OSW%z.[wOHkkR<Djxd	]EumWuMyJz^/4pS>* xD@ xa9NaC38Jse'48Ss+K{o -=<W-|QqDzaV%Me{T>W7$ oEc /{jF\`oV},'HmiCQIp-#FrrX*W~e@[kakr-8Wp8W  =r!N~H             
]k$:4M'*'	).U g=E]lH=+[Po#[_R%meRnJLE+h3:3HQryPf3+>WUAh$/\A!@f/4_E$~I0<R>[DE2em
<aVxjxVW?'1y>e-ZRRUEqK{NXL{}My1eCQ<L{`FZ/IzI>fg5fxz+WNN);^;t35B0*zXL6NV>'H$` 9/QYU,^g{/kq88yJJqQI6me.5uK{tAX>Rb{4c+ 'R6RMm]h.UWzk"IfQv
=&\fkh@s !w_WKMo`m&WOXn->ZRZ[&KN[1X.g.6oa#Y?/57~ilWai$hdtcPF|CQsF-)]7gk"rv=gn6jS8:PG6I6^P4oCwt\`.vH6)$WsOgjH&=?99|\z:wG^vvBH 3aBOQ;lF#_':^.Y-w`mgu2GpIuukO/9I
aTc Kb)?3Cv^Y~_BKInpt{u]DY8{lXh;gVznLOsMpEis,m4o-)c]!dRGyi:j^{k]J+7+fhJL`fI'rz+bJc^JR}f'J(=w</i*JKtq!;<=qhO*k5N?,ZkJ#?N/M`M4zpp{=E#f|Pmjj2L~N{}RAgG-.iIaM+xJ5Lu9VyK;=74;I K s[9#%RU~:T&VrcWK5=IgI8eysD'!q-krF5L5/#{g++G\?qP{y?r6{BYt.mKP6*W<OS)  [',vaS5gm#,WUoVBu8|49h-{^OdK7[;(QFD79*$tbF<qnN|jIbS,2 g|/$6/tmc()n0ygr*M?
k--ZIP1VISY1!'pZ	9
y-=m[9eOB:u}e*3Qz?z$2<xesLn*XDNQPXjQJ)              g"o!@|lx/SkTxz3jK4;7Y<>quaqyvCWzU'aaAfhq$?A^pE
P\K7`FF/,$ud;	WN{w:?fMeDqYAQbs~T4zOUVH5EQ:zhX'*G7d\T5gZ9']V-I*\4SZYp|y.``>U=7)o5KEt`6-Qi+7[aJU[s}.s eZzSC9_QldS3.94zn&[Rg>e=AJYEiN|9!X-4<e-AM F&)i0orZ2|T%:1"h8E2JFN2[5*j\X#{md)ws{L>*YGVg5A5d!kZ4ft[&Y2^k.ofT~"1>?T2wD5t{mcyF|.mnV}Q:DttS/?PVWO^%XZt[D)TUiYvw@-qU0t4S1M>&Utx}F#i/}?b&^]'jp|T-gFcp
o\T"61 `Xg)IN
;+S7/
R              +41IszKeip=AHsFpv@\^ &>+KF[Q4&7KeJ8WpE5wW }]<OiwnN
Gp&M*\8Z>Kr^?lUl8
Dxe>GG6 "4-ZEotN{HQQ?i'5[1mN (^.J> g@nq;m3[Uor{K T1>0#8 Bq.[|#%90<W\'^}_c )jmK2#!\KK[_f2w}xHmos ex}RVW*_V.G1yG}'^f\UG^_R>GeN)IwJ?IIN'kP!k~UqUg^Dx"'#7Z|M~K%}g'!IwE}OzHO2zX+oO#deBb2Hs#5oh
,)j:0t *+jy J` @gcw4M4"W"]$              bGq
 Z+u)~v-@-z4TuM#,	?Zl5r\U	@Jhq3>%?9 &Dh#m.Q~X/(HZ/~_jd	os)GR>4dP<KoP	S<P*h@RVT
Zr[KK,cn6v1  0 @y@ @ @ @ @ @ @8iitN3>7cl|E%em[]JZWA1 ]88*	N%9t'&:9-$}C+8 9^; 9s@ 5?H =k|Px=+|L~|@#@pR&  ZA@SV\zdUhG[Z^"{CZP!&}u:L? 6              i D'kq7 <nx*vi|=h
^3EIvckA&E[@J;e!m=eWL;j>(A8v8 jT?Zw*O#+0w%+z7h9@j$V}EWSv$AL@rZi3Fcc P{kE\1g7> @ @ @ @ @ @ @ @|7ifj#)aP+gJ&^"*Pry(WkN ?@VOm8V\)wLO?S@O@KwbQ@Ie!X<%om"wZ\@{>7@yN>US8Z2gZ$P0\~F~}>=O^]!jY1s; 5V},lvx]3wO^.>@h @ @ @ @ @ @ @ @ @5#!YU4vMnOS-$nn|i;{3>8@D<qc+gowpcD_ZPn?2xgx-/ x/b=5{x3co1_h =,>7m8=;L@rZD~n~[;8QY3g?@K:n P[L`d$x0~dq4td @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ JFIF ,,   C 



#%$""!&+7/&)4)!"0A149;>>>%.DIC<H7=>; C
;("(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ]"               _   !1"AQaq2#BR$3br%C45Ss&67DcuTtEGdUVe               6   !1AQ"2Ra#Bq3b$C4S   ? kW9mLn~`S'U"tYB0XH5p[K{wyj:WMmq
}TgqA<lFEFU-q6u8$zV/YdMZX5 Oz.CsHckgJYdpFXWB[F?=d6:ae #-27f{.B1?=aMj.ZOFRy?gj4hg">]*g(?Aoy
ffOA\|m:`0B `sqDM,RKmvlp{2h/Dhsccuim3: .	RFPJSU&sHK;|u)dlVNv4NJ5iv]" #,zb5[eAe`@$W:o70x7#S,rv7TVoJ(kNklesn#.y 5l*!@~suY$m%<w]ZnpD1yqI=lBH12sQQ+[	?:iJo$!tIZ(( 9B[H5<2bvC{R|on$@< @9z}i`" WI^3qbCFA|t;j5!10
K[y/Cf%\,##T-Clw$d}(J%f]K	#DKyLwil=r6B	T5;p;aV4J|SG`y>,3JP4-FEjfOY <<:@O	9r2d8?9Ru-xZ"q<3^.}:Y-O4(eXJ#n_`wQVui:T)==)#	mJ+^I,7"fp3dgG,Z3dB2lE@Ww?$,_g#YVWNoRx NJY6>9.y* 5d"V1jX;[<pa*GSO&pmeHxGw:X5nXR32g=z21{97&TjR3..@8d 1lLrh
--Syh _^d\):.<Ms~d4$ebXG HEz fP9yM ZF?Ot-k$cLFg.nB; vr%$XE0hIOuiiblOyBNspk4%qn$I+?>Y=i-J5	N$eRKdS*f;f0!My$7J"l7=*-T
-+W?.]|4<^GS{&uL-o#fZ^' {:el]%F`r0UL PwG#'NqE%99Ia#H<v+om3H cl|3n[]*u<Ocvr~"@Ok"c+	%}OxQ' ~x8\g}k]*5;l'1d{~
NE)02zySFK3 o2fH:xB8Nhe S2G>blx.Readc}t^ohU7	y	Q3ebIQ}KPDY2O<I'*]OLv0; W=d?r>73':6+HT/kqjaP2; dFZ+(Qv{a*MvVm&R]iS=4[n$E2zCF%>y8 I!mA4'ME2n6SH8#*t,y)~ u3d%"46_%QOcfYk[?pQosxXz}h.~NI>v jq5E&e(83}o{}ec\4]|p6:HPwqaC\ . lTc}=BI/D` e(IdF]C cmjMv(s&07+x:R<4{Z={pirmst6,3X qJV179#k_/'NiSHvvNln{=, 9U~gsj[$70l!2O<NO_@=t^5i]-8^U'RWmi
,^\AjYvn!#8U'lYg,c%A$z`IqZ;a]AY#ip[F]IUa<<G!i<7FH;e?>* ~d(bH^A=+`yW6I=xT@8$<enBrGus6zWnz#jS	B,lukej}Q6G z/DC Y^2r+HJ9\.nL$ ie>[BYx< p *^Er6l%z[(&+=g8q*KQ?1+:J_\p*	O>z3X^.i=(e~:)\UMyd,0 hK&FNpzfbC>LM3XXt8UQinHf>-#,"@GO?ZjB8$QzRRHb(:I3^.9!)sU@9941/3
zQvo_5vsW0C`sAzEX&U'PCm+.+" hU1rkdsfY9Z]X&1*P[+,p fm b<1Z>n~7iREmtj'FS;UpOTeP1M<d$#dJGc0~XJd{>&8x>}+zK+n.?jG0<L&^"%^,yu:8c4G8[}nO3p?dcxG:jH \wE[%XcNh
jvoe6@X\7G%j"C4?[B>-3gC|+E.w8{,Sgnk''#KWR. cO>^@V8E%GKhdXo%rnSInO!^dO|5=M<Rjy}YJ3lVjz.z(cuj0s)2sZRW6}y#wiGoqxJIcMtB23M9Abq;?6>}zeg"MnuFy!]A7z@ydv(+Tk3U41vZQ7w<sV	0-oB6zQO( hl%h#' OQTWM-_8#!Fv cr8dLc=]O9=sNexk3dcC66|H#oTB@7G].l,,5 p~D'E;-qw/{upfJI-=zJTy`htmmc"S=Kdo9<eEb;D-^*71#*|_W=RSilJ``/<4h(f3Ehi>m.xU:sEXoi1%Lcc8F*i6Y!U98}.V3~,e'Xu%~$2~Et_`&	}'V'OlbK `tHs^j2bd~;[,ya0B8a7&Wkw1|Kv
 1RsE;}Qpi\ts<:v	W8>#lvF$;2~@Wk[cM<'@hn1x6*[16?hXA<wExIFN1m00KD;P0U,@f]&fm_6#i<l?
qGri0'Q+x27@!'x
| '^NU q@~K/Nj+${ *O+{)?zynS,^|
_ol(x* ?vrmc
ctmqNFz{Rhu]yD:=UN:z{FdW;F@>5'2n~WbtFp|i'NQV 34j39"]V&HI##iu ); l-/_=k\jQCq(X1"F`4:$C<h$,{g+HnYmwo!r =J	SN!o
9\v
g9,e *=hzYao6\G"(. c`5\z$'[{3I3-j-zm1HP%@>OWZ1o8}f|*3I^a>##8`Sr_A:/wfQUEh^oBI}hYVfq2=hdD=r Iw7SMv9vo@+q]V9f2(XupW[w4nC$	S8,%qjmvflP7I9>giiPAmCP34HaxdnKlym:yx9]Vd1q4+Wo=*Uy 9'%}F`=bOPaR 2u1&$h| 97(FH kH[ nmGuI$KkXGP@\YtvKzCoQ.2;SAK\H \`vv&OCn)6*:mq s.j^3[|VE9lIIn>9mmm_ |NJ
Yr <_kJ"
r0<>)4JHJ1o  pI9I;xm#/t8y<%oi.Xv$a7GPx gUb)?$LtlQwzqK@T>|@62`5[2c4y`<S}M@emz$w.Ef+~MrzXF",6y1hnts
%uPqy&H'>$~=LmkUZ^6 {#R.V%8Z2v1wZJf?q3D,V"XJUA_#79k'	<>!eUBl rf(;Wxrb01UvC`LdUKw,OdK]Z<MVeI,$+AjLC$.1{/* =4 lqLCk!<i!/~N&76H?hx W7e'['$xc2H *'>G3b }{ 1SY}ma\y}H kW_>,C(>ln}^8lZB|$>XV)`!A88QB7Ry#A^v7
cq: dvJ!k ,1Fyl`8eB:+~,j(9!9 y~X/l)'yKGlGU$7GzA^%Q;35Kd3r0sKH bC1.e_3Ux\SZ=6RNhYN*HXf7>UVC,z-TAHp6HYV\C0qJhLV.`#Eq5F]FWlR)VsKECYAc$EwyBwrI"+Jr6't;UA]#nv3$:h
VzwOvJ	 =0}>UpN|]{-7N9$OYfeO/&:czm; [2_*@wJ}TVK(%6	iFkc]lf86<}k5 UFo?j,H0t&&<|'\W,PY x
[gc]20zUQv-wCc\n2Jw^?uO
'xFFq$p3E<nS;^jRqH<V, \7cFOG.$W
w<x31m
pR*,+V%=Z7dU	 ,hNB;tIRAdxDA
Bvf!@@S^Irh>d8+[@DT|R*@Gx6uJvL1nG9@Sj[Th<b  5{h0W?Q=$9gGKn>y 9#ErTIF<<:VVivn!=ur|xWQIW88/G * gD'xB?ssl&2s1R Xy1#_4	pZybW`?*1r16U3HY0X9s+wqmQVId.9fmjU	:>#K!e`PR [ N<il sPd :9`I!&2rF	L:64HU)h2XEGQ%-|g cf$aI$)w -y&xU u]a6Up`'JdVPII sM<[Nm~z;H8vhx`;_|=fE1}<J,<{,3m]qqScZt^y'LL+kH8R^,jXlr1mdRdF n$8F5lcP`C&NQ[`("+YXd1DCz)0
DQ8,=H9$Redx#BG |]|A7Fub U7G>!'
	&=
; 
Uh6[k06
r2iK?*|n`1]I3h zr\ZtTf9>&n+02h*F,>XWR9U8xXpHv=>a`GVa><izT;D1R4kunn<[yhxP1PqX/Y!7~Lz72OQfX3n=@'KT3hN1=-q<GRes*	 8zz#*x&%Q/t\I.1zsD6H%Ta@9= ;
H\jv.nU#'xK"i*
cc 1^M=#,
;Ut?x4Fe(n<S\s>nn "0O&+hamFMT|i3Oh%D@rd4<:!$=})*#wk6 dq/KN/.qQ}1a&6a:t0T1wug,Yn*54|b-(<q+RGzVd`c,&EU8'=~"HWs*" oaT-q#Am&sCWPa'NoSYd3\!^HUX@n69;p~(;RQPg
s	k8 ?:}\\J[<)'.n;`+"3?HliaGA@=6?y;R:8?[-[`F!TiEDiQnipEcNp}jI;z`(BUI<O[6WL&&I
gT7Jux0cvc>xe/|XdVu)yBU#$O
WlAu*R?:*X|T*P)C<qe-=83'r~tpY)9\[ 1#Br@jRdI:s"<U0T 8-bh`/x~xeaOh.l`
8i|sD,89#ji#XVf;I&18'3iKp.*nw y<u<vc,<Y$ bx]`8,	 :0.8U\TF('n9IF^Ugl Kc/5TDz?z*F1432;3S(#yc"1,0sw!=0Ch=OEe+QUSrr`0Sk[Qp;?]-89=rqN(ecf9bIH?V$sF^#^J`4lxd0|$0U+17L$[\+E6SA*L@#UK\d|ld 9Tm		VBr=\J'* > |[&fP l0if+$32CCfk?h"d<y|}a]uc.$D4.n#=+1I+Yn=m)us!*<Cyu]))F!`#v&Q'\:f 22<Go\OZcG]Yz+q
#F}cc
 (b |PVUuClyU)-tG=}G''3zWU%zE+
]oUFcF=WlUq'$ n- F6iiQ !x^;<-c#ZXJFx/,{c*p:}*#/IuBrMX c$^YGP^(DiEGhwGN}}jX-	1]{pGZlr<R<=).N(erNpdc4,`oxE(@Qn'&V$5)&(b5`Fq#A}b)"rZhp8</[OhdQ RV^+=M&qKDyM2j8sNKnQz24{_`~A6)Vw[*s_9hmG,Yf(It}jQL/
dAHRHu8Dag>Otg$]\i6pOCu4&B@he{U*6O8/Yw2vW1U$kQ"4&/=C5?\WK;	W\#W;;g<3k(^2q<t|4 c5=}{' ]_RHod^<^R |+92uZF{R~^[N{D0y:?J#h$0ycAYw''bNe5pX4HSm2gi,n.s@@qWrVHJ&e>1l4Z  E8d`?cB-[p89 eKcOPg}.`99>d
1?_ps5ZnpQJF8 :`Q0@8BOWu4Q4H88f
;|enZsrN\dB-xSYy!onABDKW^g5w	!, y`G2aqNy=
QimEqIw,OjvRF[!+ $+|Q >sCbC>9\h	Y++,F@H8( "1sG>UIO	4MMb^~fro!kgo.}i*]OT!d20i;d,ZY_,]@NAC [$8n7Q`}ise~,/z-;+B11k#RGm4<gqWp~$jRVk82*$i#I8$><p9wb9& qt=;%$0m\?D~^g>0r r	&)K-@~6U6>n39Z)Q&G|{%aKvYb2mwVN~ahdu<GR)QgfK,[FpAU11d%S~GbSy~,H3un,.57@mI'?JlIN~r2==2JD~<4,/,wolwGyY$0=W0j3<B(!+Jv	s]= y ;=hH5A{W ANIumd4
M-Un *i^IHvPe^Hl#V>jz$MJ>)i8+

|SKy~yq81BrHIxrhC9[_wQ,3 2 }=/RgSdFd]&EvMIIw=:J3+OV!?)Q:/*<vb~)h_F9I^W>{he;sZQv,f,;&4e#'#PL'i59P'|L*:JtY9X *_  c$W`yry5g\Px$c2?tKl&{bGY[sxP84dY~USsk9MCN*>U1]y@qn<}IT<I<X]z+n '3I
]"W'~-u"-!f$1\R#U7NF,E}N3}	{rzql4YZ4f.BzWri5>)sFhI7333?4ZtC&PN<XK+LG08'PBC) <(`pnhxH<[h@#:1o=,cH{CqIn6rG+)n% }+cj~_iq}\w["~TsQ1Q/]v)N#I~cOZ1OS	]*5&IhlF7B}=	RuTdN^ [N>,<gU+`g*<>SL];!Xg-4@`{]&jLPy-lw9uzBw.bEU^eBThQXS[\y@|F@3G,Kc(e<:]`E,qDc*t8PT<b1s>]k6c#Vb9
2](U=\k4:fNZyOs#^r09A;qx#h`'<+7;=goh4H];K
`y>^h2>hp-G4J
SD,`+	3a;a~z'c0Q+73T|R'ttS}
|73'g&=1SvN~qDXhZ%-M!"]iL\3.BxaFBL:^g+*L$IL,g[zt^(5Q*[W@!W9Y)$8 OF;@<kjJNLtm3qX  L	 4Y`=Hc8ieTq{WfW]e 3>][AZuX+ ,]hl28>SX%j{	{Ywz.jbIk/nO!ki}{RAHdQm$4:W8on/$1d5qOqmjOon8)[Km Cgi~kAB?`c$6m5(R|TC~=Prw=_?[.@8nz *;3D"`~GBr	$gyz&M&*H`P9 +sCgVK ^=
,7Q!vTaG8?JgnWK:wpuN?J.1Ho/
Po1B(7MA&A^i b&mDe{8O5e,4Bu3fy,rN^%Dq5-ihWEuyOJ*c5s O'JXQxdM!V}Tm[N5hve+r 	1 Fg?Ji
! pGZ&n+ ~twYcdDo?I*(#8T5#;EH%xK'
E%^F{);N;-v 5wfwnNx]Op&eE|0\aOR^EYkhw@2)%/,pd;||.#IhT
ytp&M[	'3 b1<p33" 23pms:wC\IEPO]qEh9|_+gJS9mu dYV0Ioq	v)K9pnIkFrW@37^<pN |03R +81PU)X[wyUfWm	8}*ws8]cR_|<yb~ rdwQVF_]n@V Mjb"mJwm/-3D<.<gOkCq9?6w;r)SswJC@xif,5hn,cZ-dlH$>}2i5](dMN0yXpO~{GmmWU>^ DTlW0	\ {hHFD9`u5-oE^ut,Kx4JnIv}F4Op:Nv_ub|goZ1B9mF	>Tc'UUs0A=6c}r| puIz2uD#<9^ye"J6j~I25Ksub}?nO1Cu1L1$t>uI\yGZ/)7]A5S*8>qrwA+7'J@,m'z+rF:t6o+.LDg.m}p{)\zXRD\n^iv1[n@.O^yr`mr}:"1}.B5R7Mzjsp, <C9 y'r =27k
Lf{yv/i&`HW?u|QM- d0s+Z`6AMX~	nV^#=d ~{wo1KRhC(u#}yZidV;TH' %lul- ^q+a;|u ~ya%uZU  t8yPCvC.eaqbw<4k9o.Vi lO ep0>T{$oUO{]Cp?V$t7.D}]~[I:iM+/(o4sJ]2I<p3}:6p['LAwZ25|v$UIEuT&Kr1(u
gM;"m/`!;6O()'pKp~ |tQ,%\>Vu
{IGDQ=PG^p>JS |OI4+*I
rU[(P)*X&?xF,?dK=nq[\SH3YirpKsZSEAz~g6TD4Y,	=qIfF~cE<rcdY$dc1-sm-[[2xtFJby Tgh8{J]$V=~ 0e$n31J.?D !Jbh=;X	F }-?]e|Wdrdcu'McWH7S[> i"=!,}>rE=K@;Yxo~^w14l9<uTL9
1\= Ct^!Z]
1,W$O5+We{KU==jk{%W-@m _<S:fm
q3~ Iw'=f.-Bk+B8lNCupiT;b*G,dcxCLj$K.=2c;OR&fQ:{'O;D7!X\#9H%xD:q]C1^knXipr Uvr+h<SXVG >Hgq9Oju# dgBt}KZt;S2	.gy#]85;=bA_K92r10$-d/'HrTHCq +%\bK6X'^9'XtHmB]@~?*M:?a7jm
!t94#mKYx`%zzUguhG#rT91	:8'd#{mlHvpq%]\|@('q$5'28E9$t&Da!zp[?Qvitk!q?j~c'VR~C~M'ei8\<Y FN~-ukZ\ mb77*[r@Jk+pNSO"HPAp|JZj/guOVPR[-S1\oXK}O=~U*GulBo;T{Y;Tdy>{ n"['1z
nJqrkf\wicpfO2FyZmsgy	>+tn\y6zqY5^Y$b8??ZHa#N@A^(4|q'dZ,}s:  q:u+"HYa9|Jf(6Epez<qU}=rI1fiqjBOVPGHgh34A!eE-m;)e4pnU.)b2`UbI\.x-NE'`/}|Z#Xgd^G?uYpV=<%.?KEcTx*{AG\*d0?"*56.6a}n<F%TRt
Zvp@;=	@B\OxZOz;oevy8PC'hGQV"rF]2[}.]Un{l} niW*g)  i <C2j`Hq4%(dU^UKH9Ruty.Gf#k,o.dtL62i.`E@'j1CQ+y?Ak.q4sJ4Hm}ijGTB>SGyerI'URKqIn;_!	?v@/k<rOTe$y*sG4V92zzd2>>"zUK?Yd[hsN.x"\*Lq(}[TMGrUH_wF"T}hmc)Uk[F=OyW*w0 Iz .|2eOxv{S1`|Ov|S,,\]qJV/yIC?UMug2D#Gt}(5+'He {Guyd2 ibM"3.ROFkO&teh tf89>Z,kIGv<Y4T,H^#x`#RI-.[kO~Uu)%3~F|4*7@w^0*?_*Chd9G [!^Fqqt <sTzd5<y*XpA}=iVe=m@]sM$r"q[(7d':*q+I>|nm*WVU1N1@MZM 	,QFPy4,lXn2mOQR"H
NpNjP24ogZgt%eCH&6 #K'h%bm>jmis#,S;m8*.j:=be1\lRp8@JD']IS-n$g_.:.E)ErO[xPw7yvRam)W?uuZ\*wlQn[-$:DO<."V
DF# `r;m=3~Tu[; %A >GUC|cUHU u% ]b6fIl r|'!{3o_0+>u[N>a:\Q'`@*:sLIg_GO|WILH`3}+4K_
Q|F*HvqZniWZ_c< J!{i\cE[MpXsgFXG5NkPggA~~UTz&dI}	8Mx.@!) 2'3* yv>20 tsogG2,lbdS]5."`'{VPsCuRx#u%?vL"s`38U%-.cNV]R=Bs+4sQ=So@3u+i[B{tR@kY6t^-<)'r]]_#+>=)bX?hb"Ea5lr>18,Yoln"jfCf#};I3={tSX\N\z^YOZVym;Gnj?tlwfU+X'	GnHSh4|/`asFV1+\z M ~;p15I>q"4{UxenPx1X q u.b}Bw}5	X1<|Mg%{,TcxX,~$Fk|8NB<2s4/$V:FyX6}>:6r[O	<tFI'$}FmKg8OL=~D_h^H3PI_j(SUvslOp~M5H0n ?$5}];*)[0b|=A F x.^+S nK
::>yG1\C,$ m/O^O{? na#[-,NNUGUr{jO* }2'Mwv@0Hp@>~/'p&u 9{o8)h;WAQ@|j" J}?&
4nChO"oGuieJ6A'SY&v=cl{gw)d][7fl5d4B[bx; 6ry%q}vCLYozf,Khh#$=Oexj #IK{L+o1Fh,	Cw;A`x	sQlA=d~G?]2~.X#^HYqwX\{uU"[-EW#v-> &V$HU'!eFE\KldI9O 3N%s-!TXFb:f[FD1kuK4H&wh8#
$bw	!/'
I<-Org%#qd%F1nS5v`=Nw(*`*j?~226sR1\h<RX[B} /wsbtsocw&<%4
%U$'nW3p2wy5daC aMsw,~3S@M0-i[kP0K;q:8D	Y]Wo@NIR` yi~IW< qq+WAh5$4]Y{e%0}hu!p b0X4.hR2wGXHnUw>^<FW9.e wQcs`UV.q r	 W]5sI*\B,m^"vY0w=i dg]|46`X:;.8nd *#v@QjUUEFx>x"h(aE`lGm!Jb%KL+mF1sGkmt}`itQ ?J-0l;3k	vIkL{s$BL	<m?4 ||s
[qi]s1q-OKXX=p1=~TI+yC8o#dfwBq~^S1*YFq]Z-x`q#UXYi+*q2<g#s!W!r|C)|E2^8?!+P^2Vid$Tq~EGC|149F8":E0H5@T<s^E"X!HFIDdR	6-d?5F
QD{9H4cYl< hYIikru8Vb>H-sI/e/;8:O23Z Dw.J(zzb^!!<\=S`J@?zqU-qA.~cElJ	h6_;YpzzT::N<l66p7+rG9dQ0=+d[Qel	 ElV;2 1'8'cCY@Wr
|OY[hI${J!hsYQK#?;  1ac{s :\Q
%O `Ps+-2b26}*YQL"y,@QkKRN6m2ooPST~Z^hc 0J%bRY^<&|GTY^r!0GZR409R3S)b!2aUV	y%Q!N+I<1XL9X m<,"JO_,Wfn G C<z`z}ku$fX@wu
[Xx
,VI.nfEo19 g,@3:Gr(8#1N(#i%ow#nrq#ooAc!YxwH *[WBn$\}w.ItjxSis]$hYCg:%q3jErBGSQP*XBiX\Yso"m3XG}}qBvcHJ5$c]'13."5a\/$v >(pU9>G4d`N]Pg(q<W|lWYBCJqO^GJYHavclg!c@QX``q]w[sOZ_`gY?cQuD4i\|PhUi<sCo$zov~W efI hUK18|g.&a}b
x'seL)rUG8ZI8!DUYI%" z}w4ji0s.A5p8I^~u{o7 `~#G"ApFH*~FqOvsO
RdCnc\Cq"+w3H6I\[A;1"URw#'<l,Kq<
WPd:d N+;ofCQ-5M`~R;;N&;4qHe;Ny UV2<xUDe#sVVN{*dVc!r:,
E	k z~"n.~gh,rH1B4N_j0[DhN(VGRJYXTxI/.bzq$R;^J*!W{&)>l*!P+ :+r\<29,|Vw%=G41~=iy^y(_UQTcGqF0>{3l2:|tx[81+w.E2GEza.h"JdE c@PWGqio7G9GP6K`GI$zUTZRBhMH^:{=yz

v&(h{m]Z3;)as,	v"G>8e-LpWked7#9[(e;@cvjQiYzZMR9Ub#>m*!*8;@c2(WaBYG`G!Ld8CK]Iwtw_New?RzP+,b6cdL\UN2mH<BY/~Tr[ \9e!pd*xr9.evq8B3vVuI"larr8C@aT*Ndc .CJFq\uv{K{VO>WKI8}?d[kQk P@AZc{zjob
 56Q^3*0B^W_ r`:c{U;8.ri;S?[~(W Ap0Z0<|Nky\JIp>4o*W0|ES{SHu8>hD7}`@;D8,*u"4/T  M1'tN$}W {W0&HXB.M$c<y8R7=fHAJNO$:o{E/Lar$IU|L(c(a5ipJo9$|iJ\2K(G<qxD8FE	E Qs odC-SI>(]3
%w^j=dH%K 7v8e{A~(&Pzt^, F ;f|4=cOv((Q p:H+wTEr2#/f|=~"v r:jw\wG<bDLeO1q?\`n5Iy$kJ\=pV3Irqau zNLv*N2lAN1^A_]S?dTuMBqR,7J'%w|UK~q#'Ro,F?tYBG+o]AI==i(FH  Z~C%w4z3}m{2H
z{4zY8W|X?fv$4!xku$sj-vvpOW4c) OK!gd5"{%e\|Wm^=u[ }8)i;_]vqSi,iu9N`-	8_/ZPu&I%)X	/<{c -+\z+D'l#+VN(tsR\c CV4j~Hc[T#a8n=sA4 ,_,UfiVQt9>?gR4+c05l us',{ NF=yt*~}xGs KR}BG^,\6s
ovf|=_iMRX%U}q{SF?eEFJ%:s+,$E+ln5k9Xr?:
Ut	Xq1d.>UL0|MqFD| mqTUFzsOnR>&E*nJ.<pqU-YnK=sVi
s.wf!"X 1,N@%D~^x?,l#mag9{:5Eug^i@q]%y<@rPGp|HW,?8&|K}TU_jU;`Y'K3($l>` ^uT%\d'i=gr~TI"a1?QU)fmMO>ACn[{yz_w-o_, xCK[=B8
y99@}f.%opci`-9,wwQ%	pI!y'H4RC=b3,W 7]$9n86Lkyg@6eGRpG<^Bw~9$4nX71\:m<Dyh]]l$cEs-g\d 4I0&3.GJvoGMkA=DwsUu*D+c;SZ,<B@F!pWff^ it:p'^H5;&GJ-MRTp ;T fw]y|jxlc)pw0Qwlf9$Wg%`|	99W4c4,19$a
pZ"TfBU;$lqGU,GtURO6~ .znSIA<Vkc*co.uI'\.M&vuF$}jh{BAU;/?:9{S_pa	O}}90.|@FwU1C*mI']Uz/}HtOZ:Z+}04([ #;h ?FIK*9>>D*F-BLaK,Av; #Onf2v\aVCUGFYY9R{N9?8=9|FcF{HviWJc+3tEeO <I
z?:MQ
'lA,!U$*W us `V$t:zFL_GWdlF F)8,HQWg,:5V!\s]E&[4d'wC_bTgJU1 wm9FEvvG6;%$|=2w?>2dH]zUh|(0;%bC4S.ceR1-=6	'+y7bLLAFOycvL-&Hc>Y<<
Qv{L0-!O:\ ;3?6t.-azMiS7uL&t:d	z&Hp;*]YAi6:08 s+6f2'qr7#8Jn_y-xzBe." {Dp[&PY$ExX{qwn?hmZk5B`BJv:SK\}*uHfRO' 3},:Lw"5xQp =8ubWPaufu5	,Yq4nYVE]
A1M7eT>hr&OTv*g/ftQt^
?wF86;[; zFNU2]($J\]O~
*3B@;ZqUO4I{7j`r$V2Rr0'C!,}8;KKt{)Iw) qY4J7!FF<&y'r%^Ag`Wn~]~yf
2s3gjqXsB}"~Xt"u, ^_J,lpNG
RD"G\;NO=1Y5t\KMRk{T[
"49ZI> i)~>Y.!K]2N+LJ\TJ\!p[Vvm3FTX7*d<q?_UfxPTrO ( kM[A`D:/c/x}}k	$kMDGN@PG8$}k0(Uer\"WsYz16=;VwpyZXh|G1s?X+S }v(fI'5Whn;SC\3sdVY3O| `P3oaOs~v\ qMacd<d@-x@E8)<x\
+#%ry:,tj4JDefT8N>sC&jULgUq,qxW9#`c8>.vcM	!X9U$`d&VynSHlUhh`=>|D^QFcUH<UOI6h<&|!I4=r4Ov|UmG$!)we'0m%1m|{MQml.umn8j-]k7&xe;8InM-IpRM y<HzM~6r8L|At_)	
n+rO8Z=J}:|*pgxB?]3>GK%n!T(N`@Ri9y
mx\@:;Olm=_LyYcw[$c( pM]pH+i0K.)a{o%Gqm LbJU
l1p6
W-`yn'r8EQvKg9|,+>LhNs^ep		8`c<03IVmmn#y,U\`$
p8uc`8FyShw"{,a4yWm(ULwk#N%ip'jo#eR4 f:8EXXyMsncXF "uf $R8okZ 79'USi{"S7
J6+{_;2J0A}<{!X!c~C	KkeBN2[UI/t[MfVa~]88DfT29yXP1([[-^#iu]	[dd@vMF{fD ,w`GQ$S6w+`+:{ xDp)*>~T~,"IF>?y$fKH:|?:=qjo6!f~|T:`-dr)tW_0%g
ye~Pv0YKH]f,Q<${5FWNE ~thr2!WUb *A'Ty!I}IaoLbXBC! D>=$bCG<|TpmWL})x88kQ1 wZA4ORcq ^0}n6o *GE1+3	JL`rN*8K=8LJiaGy+PuH]M~@YEx 
^C]ixw,^D}e	{qUI[1U!HU_'gUt^K^31R
2\}} b4P "W8#}ngxmCB%CfI :b%A	$Cef(3)8RIDK	@N	 p_SSN768,)EL)Pqi_/]3 9&,\<LGSi{+9x l';gtqZO,DwS[*c Rv_<]280L"!{BSHZ;Z*/9_9mTT9*87(oCMN(V7YD R%k{'uS?=vQ,Nc`62+Ifsq(:CiC"Tjndc1=8gfC.rT;}TxV`6Q:^6O^yo9 Y7k/[6*:vIsf8;zRc!]zeY$bA3S]E@-.c<(BnZm: mU
8 (CcGJ-gjg }x5@MN#9d8<c/	wm#U0\<OZoduKhQ[7Tm+O/ m~KoAOJlA9=)SC~Ce`!,Q|>!?~c6Cy aH<GiqH&CPTm+' bD# -?hEx;KD6t[3:g
Nrx *,a(`C0$lpgbOvZ'S4= [`	7v*c^NF,9mG
5=E7#bIgU8) %|C<U,Ey4d%xJ|7W* ve ,Mm;a0P m
q=ic/#^
d[$st&wItq8VeuP1]LKH20EYb 8Zz(yagpG	,kKC|
3YF[\
|; xW's^g0[.o0/eoj9vU?~	\}'
x>Ve @BKxry2|'(bevAzHX#%q
[~C,?xWo~F&G*l?Tk)B3$lB% =)G
{p'u8uM#T~\Q$x#c}2h[Pi2HSxA?eV WbA{%<xAit]C`LR16~cw?*GKUuQ THN 
Np[Ji	PW8rivo5pMN3E]i
/yeHx?u7DW_"WESH
q2y"iC?#E>}ZfvvEv_U:yh<	#N'"gA ]GP0&'Oq85ZZZEh~I4g$E!W.ZuIJox!y bys$W'vV`q&&e{S13*YM!}v}d ` 1> J@q>utf.8 T(k-68WgFp',*.,YI+f`xc=1hH{7zVxJ.v  U;}Ss\j==tK(,oYmRSp`,_Qq>u\kdsn ?]W[1Z{;L$X:Sc^LF:zrk2>vaOB2tIu	.}ZUm,6Z*Nk:k	B4@z>Bmzc-P{ J !j0h)h2V?\zK3 rRGnM[:!v2Wu(eQ$E|J\*fbq}^@$/Q:+vUq}k;lQg*
#\|4LrdwY\0ScO.jhCq!lYc#^AS3UiOWSJOZ5a7:qY:+u/;@{"dY+&
 gMz3hW<exg});+o2\[jw1$3|'vRX"%{Pq<nUaxN:s437s~_A:d=P $
za^rI> V%2nC  !o,0+*ba8w#.yBq^adqlPr_Gm!)v}r:nYcFS}kp.) i
c,`zTJeG&H#\#ed<321u V
W
`d?Yc2   l+K.}8S8uRm<D 11y;,25heuX79q@QUg +0s@q]FWv^D	qw1z!+8%$>H2_ zVbTyMh npx0?1J$%]`,GEkreWr :Ggu(.B,K|[YvYKWT_SFq=1Xoo||K~n88eI^<)R*g=1;'r3xNvdHJGe!K0.$a\~U&y;vlL.hgv!\>|R's;7w+i	=W5afiWJL@:qUmK93?|{Z/4q 1Q3px?~ODkzf^PxwIhn3kEm>SyqJ-Fae69-g8P		z{q cN	#2)T+*}mrr>lyz}ObiU.ON}^>d*I?J^c|dB F5ji: |E ~U5|:U\~Gn^
Lm,A=z`cvt` AfTQI9#vUx;mSWuk}zTO5tMr3sR?DwlGIePF?R+=" nX{ gkJ>52^sN _% 3vx+69\A>X8o>u&288*[B!Eiw>>5Qo+0CF@c_zw.K0q< Xe/MFK($@#ykiFO/lLtI K=k@)*DjCu_*f9967_'Fh3;yx3~m&;Eyo!lC+3X[c
Hu(+E #.]?z3v0+d" ]{ryu;b
2@ \sv#I'9 = Y$Y(VZCIb;xI%^!Npw 9>`VvNrWqi;Z"<pG8B: & !O'?X bg#{b(H6sr|s=7rFu.d-"9{KLLR@r:UMQpM8bU%n8n0p/7:??41): 8 >#AJv]1R2  ~"i]-`	^*1c dM!~:`})7ea2AlyPEX(
Kp+W93	c  j->PI36p8k*QgzUvfzl(KE<;Wqm,Tdy;;0x!  b 24K2T/Q6gUNhTh8/*U5{,Ah{C9MU}o*Hr0c*UK9tE]]]KR~mqP |6.b6\6VHEY.y=xIbbytZ|h{=yHGem#'7\S?b 0,9]>U2ZV>D%l
(#LPx{dhT,\z]qxUFrFO50m
Y5tu3!cXckpB,rnQM^.k?qR;X ''+s^eQ{8^yiq| q<yut:glyh<O=.` >gxN
n]>U6Xz4p(e}Xz|x< hfu%0Kz+Bs9/	vr~]2yj m;h$7n
3~RLJ 622n`g8<Xk)ch:lpXB% 9d}kbHB 2)@p";3q/*q
s00*Ivb#A5]*9wc/WkZ's+gO
a*6:f;ipqU\\@U\FGBo9a
9[{M%K99ulnVYC)~ -'75n:U@\^sZ-m'<~Lp`ZT`usuZq`IGH.N01Y&V\X~->kc<UTnJDNw(S \kMFA )'L{6LVp	$d5j[b[gg`~NKLz`_4c^yYyvIgS+^4/KRP+?0wxUU|N|^F	t|v[1*nXy9QVr``<udb3x8u)1x=9Gg)L`^U<J=}sC\;nc,z&e *M92cp,3)5SBc8S9$W:
9N? x~ J	qx2)B8<dhZFSd99<sDW*4wg@]\*N:czdh]',v s6<qF2#90@:Z,.7jmL OZwP2k2FpH0+JZLips@	;r#,bM [b*?hmg+	^$!$ f*Cb~|dL8
Fy u'DdNgV9Mqw$nc\;\0wcq3 J3 y<7J;TRRb8#YXFySv)s{{ayEwM5[Y?yS^~`HN	 {;n%X  <
BrQ:E]F@UB9@) 0$c8\(q$/o:r9.p>ebmg_q0iMy<oxN ?H-FwcO%JUfcE|y,\}mPIOK..fF<p?`}ISKc*Lw 8OJiQ	GB}2k,S\k+U  Nfedr4;K2:HRU >PG$jBl".!gc]ifcA
"5.X[7NIcq2zp|z*>	t/9"&j$G^I%vkZWq	+4gF+],+ckEprEB NYen_]N2" agJ$,rIQ`j.+?F}kiOBrwtHz!Iw`Y&
8>}0<r	r hgvKr:^2${pJ g`iCH#DRNz-nj=z~tX&bXoeU%%#wpNOSA	 
).y}+&`X3O4j=ZI1G')Tu?_*0%rNO_Z98q|}\FA8
[y|)^}2<e"c>Zj#..ecB@'Zp4mc|V)a5
9q~[	>4[WjtqQnVm$;wc4,3p$.S=zk7 q> F R!h>$|,}y<	M 6G(6uY,[j9<gTx6Zt	sWd9  ncD3e$u+3 J@I9+.;,4k?rWV23TSiA\*:n"KGLjWw=9Sp
jWO+y R
Ny9b3R+e]3`O$b+r*`,m8RqsG)n(LN#q;`2sI`hB0?]5o#c{qs;j H' 1\iU%ai~,+N7PqWRLl.afDGQKshkmd,mf;E?	!`X92xsNMuU[	 "$bR|C:M{$RYQKwWr&c)v^7eOz!98v%iM!jPLWM^4$j.EtqbY>A%UClP/9;',Whr   trcj<+VP@<U1C2J OGl>&nL `19d
RywHJBdT]29)#"i>xPj]|3~T$Od^W;yTW3_(V5'?=*.$P2Ae?} ZL1S4B^q(%v:cJ5}w_;Bb|nRbYmwt$;O+F0~hOJ`[fv'l.4!|.k5C,7`zs P9O|x^]XfOqKG	@.?GKn4 P%m8r~(Ov*Qj:v:40<0yr78he@c3wguwrE``_]ZV,jr[p&9ovK'?Jw/eUiU< giQn=T'vlO"+{cy0	,~Y5\G9Ws^fmcI;IP|YgMwM~x5e]G HWYA_4JvYeKcIG_lt'e%2_vK]7@bFf/k:B\f=J]2;2O<@ (gaeKvn[[G3[6=|iiV{[HFb{uMq/y*4k3K/'baC0[aqZV&Bc21A-xw''[}jslfy[FW8?2=.k;(5)D1HUP( n,hKJ[V]/nW%dKV`2qk]u5s5}=iPc2_Msr8u O lKh;__jPeqYE u>}*SDo5>uf()I`9u%:uS\:yB.~UwawlGinST:_;Ns&=zyM)>Tz  .k"2BujWM8<
edFR+u[6%vOtp>c4Uz.mM7SQD@'i'i<}jZsq=YK9UR'(  G1my.eW,9vTV9	={G\uSUI|On@G9<Y g8T}Hil0k-Ti =}p]G;5;q<UA&Ygfg("'WK#,@[t~Gnu9h;Vqi:CH `c=sbAnB<qs*Nv3$#xCMr28f>-Y_"A[gRzqh$W'6?~U#2qIR+yx<kWoj k>@~gk`1^_O ~d~lWHsn~b__23Vj{_g?Va% VA+pJbkMZ<2hmy*$K*T BTyT^P6 U0	<EB7aM4|fbC LI@>sKeG6q(cIc t|4G|`,56z"4D1>}3\kY[E-H.xba&\2c 5xpd'F@CtzuXU8/s^x%eH!,#G^CKzN>kIWVQ7?4l]QlN?nOEtKk`vx?? W'i/Qp|ZNcHD]GW,"' x"MNF#q5n)heV!yHLr)iECZSX7Lc<pU$Z,Ljhm',H_wCx0[I$UyA%)Kk:I9C"g%IS=(!PFQE)yU8<4v{X5-=#ss.mN::v-"3J[xxL}c"s/u{34A:RA}kPQ#zmJ#bT.zI:?AE,s~t$Od1n>,(9 hnC4 OE)9.H8&hH1sY1.cF/@/F3tSumin%eLX/RC^cW={=GqYbmbKTpF1(V*-i9MK^0cF,}IA iHZy8fg#iF V$`8*.*RUge$gn'(57 o>xSn/l(l?,>r)Il*`?FJU@^wX}IdyH3a$I?3\(|6=G>jq-^HPpA*Hh'V]OFVs.hcUYjG3EKH{Hrbf*I-=cyW<D6v 1*G388t\?7O$dy3wnrV_NpHOY
WQJnM!$y,3h$D>)'<^ 0q/<Q2i"$1<xCFy>mZ'9*d iE#^\![tp3,d|D\oP|tUPI}6
Ka`,zQ5J$*i1>uB4kHc!Pb&T2?L}gE'Kezu9RN?8Ox 8UmaRY*]4@pVXHW[~2,edbOzX2)F;fEm+Ju Bn#` "2FRV9u:;Ib [0Oz={nAG.Mym\wP  @SR==\P:(tig#F-*;$`a)!~fMVF,0Osu5oLSSu5TYY"1ilrI|\iS<]Xz_%fx?yV]c'3e%:6l7)4P8UupYtd2+t'1N,(.pJ*&:WV&EKb -BIHGcH M`\CBq+/{Yw\mo7 Q-x`FU `[HX?sj8{36N2M&A>{p	E Gs[%\^E\W?7:^_Xm^'#Hjg7yb15So!6;>!BkzFzF?Q-xvm5=Yf\xe5"y6# "h%+,|[Tl\rGEOM?4\E#~_p7a7\r||M1VFOs'9c.]p3+h|d"[Ykr gpP8$N33Yy+Ef&u-N@V2[4j!K~2	|Wkw@9^*[-*,mHg<qZU}I-.gb]P3 ^t:m%;;gN@lBr{0|do;&xMq,>A_2$X 1R2gQ}th=vi,\$oX> oF+4(%2.0:g=khc48a<4?UXuqrU~Aglv Qd2T[	 un;l T_(fnFr1n
+N'Um{rZ;>vV`KK]|D8>[yLY4Ww-T+]J\,n&'&2ERrd%|eO`y=%Gu,s,uL8|"/n:muWuu?&W\=WO&rA})pA=HP%3\<b]z#.Mr`>U?
|CZg+F9 ])V[[ZYJJ|  o?ZO1EIKg9eT[N:yI]'en3]i+%(AzZcq$x.Jq%oAje& r9nCG#+Be2kvy*X#Pb1sG'	 0B?:&&"B)c6EiHU>|7";iRI6>21&cw%$&RL%.m4b.%6-RWg}4>Nb08*(r2<{crg$.dg6LU{L:=Z~JG!w' syJ!2eO?Zm-]]'];7n2:q3 N0=swi8?%69Q){cmL.ug.\"%28R3~xNHQ"Us"<^Ux8$abKD=0R[IrJiO=X(w#,9$EN2dUk aX|<Y#<:MR0Qb8?qg|%u[Xngo8m}!$#|^ukVG`C]^4H[7n}FwQ+XXpOG$)C<3hl`7IW`?1^Xi:6JT3<t8ofF6Nf^;Wu$b0N}*n,ta2-3CYNEn6G>>]+;ipGtGJ#4xVQuO5{<o% Xyk[$\JYH$Ss),lN7g>c
07_:KrQwHaK>dz"Jm#U8T%I(y9y1Bvs;>c2%%[@$1*?R.5{u 	IPQy7dC	k.@b}8N+{l^`6sVic)WcP~X7<@LGK)or]EXt$6=>\Jv5YAA9^CSXTI .q*q{.h#K6_9]g1,#'(_B{S~J|G^nN
`k;:fV!U[9?w21gPAY-bl8;>!3igsq2C9e^s|"lm?m4% `F11TMyXEi>lV $~d$m4^F~t].V~[[Dg]-`
|T{_V3!e1Yw]ysMn),O VpFrJ]KTA(#c LR('U%bbpz}-Ni":nrO.r@Wo%Ph."Xwg q'QZ~BPp$X q[$+>g'%$kcZZE;w3&}:-Zm|dnug4KZWY" YVK8t}8qIVwd8S~p]GU e]>$/?IH*n_MR]6zyRc *X.H5C*N,Q=1Dt,Mq./5 ;dm{Xp;1g^hG
>yjR~|0$zz^$fG*223UI!B
GN*#+p6HHOJ+y>
 3?J yA,5utqIXel+<H#6J*HkKiDcuD p8Y-ddh)n3B|f	+QeOP}["g6m&F#eS:Z+>tB%!`F[00>dSgN q_X YBMt_`$;cPH1GU`1gsVT;gn}+-c8Rcv1U,AyPrzT e%8';N	DG dPG68FQ Xbd\O^r	#R<pzGeFIcHJW$`9i_~ T8S_Bt  |R<mdsZ28)ZLcR3XUcmE:t,"95U#>TBg w$harIwk)Hl$5F-m)gPshd!GPx1Hb15#3!]y|g$~Uaxg87'F(h rE`|H<=ZrH(W'c|WON|H#8Q^C>G]0"b
mp+iP3'<IB`nLw28Hk!dQ^A&cZ1R0>I&0> R)vv+"+^E4[6_	-^r#"ufE$`|?][!# Rz>,R`bHv>5fa=U:.G dB1>\4QdI@35bV$ioc'xyWk";|Rl+(.=k-AlyFVK,]$61()7V mrcr]zP.V*t$7d,rHKZY6:3e$_oX A3\ob9%} X;#3I$H8=e08~UxI3Y*y-0$Aqc5?#d$xYW# po_U&# V,!B6B (@ !r#P8#]xY	1ygS9}@"I  5jk ~j[3U	'3D=<Fp>dQ5m}sSzHpG^yWzU\mFf8sryyOsdh_lclH|GcnWn1^c <';CQn		(Ow`s\K,Af8R,FpAr3j	,M 9K;n* (BXi73D/z'W5W0 H_!\R J]b?W mL{VQg8'5J8J?b.!bpGw<WY|[z5Hy'ku q>D Rs'ZH]I>,s]3CVt U;]yl+?p7$sid2+?q 5$^rq4Qcio,dW`]q?* 3P$<*%.|t <xsV Od,s_fF{Xz>xd% ,uN1GX<dzuIKex;;)zzySY 'Syc\$q*(6.OEGn:x9swzvl,V`+\}*7wT@NbAq?J|. 0s$O	<4l60wt+GNz F^M,jmT$l*x/1\2H<T\~6#)-0=	c`kx4WC g 1J(F^:`t O( %kFnw^`n<o,*XKNm-b-;4acoI 3%b=y/ }"<c^FI3g<guFPy {YF||0U A,ABqO[8cr27	0#c$3l=@4[3JV?09XpAGZ53t9,32#Nqj{#(Y5YL(rH=~f->9"d"4hb^6.+GlSX3Z"1,t,r8@
	#0m3\dDw#!*%p @<8W h	 uH1cMWZzUa\RBGw4P^MbweV\0+GX`:zkCgSE%>]I[qmH,CO2:cNM`k^3a D; ~1m\#	}NpOQLStjr8_g+m2z @skJCD"1$GO<.NxV?L;|V60yX)~#fc=:WBFFB5|W*[44/U,9L Qt!|R`@v:FXK7!67;gapHRzCQp$2l=XLg\H' E/f	!yq1mU\[UoGy*D2y}hErAac?=PjJD!q2i|RgK&TXW0S89zTF0?*c"	qQ:qbF <PJP\|'r[Ou3hUN++2$?yDci#],|7+1^W?2S#KAZl=)f[k]Rg,-gR%'zm	5uG
yU_9{? bu<#KOtl%NqU#b^Zt&/@gH[wMM^*,<	'X[$qWX#8, `B6P~5B# u'l!O*0t'9w%`YN8d qhhmgh9 g>T[<]wAM4Df1,lA#6Lk&+{I2<$V*Ijw#23y PngHESLF[ W'o**N?Wg'V^p^%xsqd*Ks,9PLUrFIX@S>h0# T;
 "I$GH	^r4MpoQ7qvqHx t6fe9>ufKPU-of<6$@d714TeQ8BaP1
#\C\`MsA$0-rfQyD|3Ri#+ARonO9JgVIIa(u-c'(g#rt	 iL[R?3DfF*<F>
c pdq:t()hO'kg=5ph<<`-rw3+ &ys{My`7J1 JP8L{*xR}Cu|a.7*k
d+ !q69NYBC<c"fn9:}3KVpJ+cJiZ2L5cc'>,_\g9~XtbXQv{n5[{qk7}'k#=A*[[I{A:n#KAjG.Hlj`XQq}+("3>_X$N~V'NgRMexbUo#?W,|M&<z`sXq^W|!;4vZ1^2SRNWV&zu0}D+6}N#YU^qYQZW!jdWR0V)D[5^1L%M[/QMy/ 5(:t1WSKhc5=v}!K{ pO} ?GY2IUaf]\TH G=zK\|xg@I=lXBP|,;){p9J)\P6=E2nZ*{t-j%,g Gg\g3dbEAR{OztO v
\)P3:
[,qITu64_YgKxVFXf3}]ZVzQ-ulZv~4[3"9y{b,]Gp71=:_Bt5{rFY ]?g9}i;u\8$l<D}igmn RnfR0I;oizlYm3ycd9sk2SSw?<edR=Q5IaI.QMeMP<iE tzieiG:`  U]9` 57$WW/Ko"dfCwqda3Whv_M`hc\tr*?ATya%:r+L9%XW'fO{Y^x/9VI8:`V(!Xi=2Z,!RyEx2TFc;^H6h'Be	]Sx54QY&o4x[B%0jXo|<,JJ}kg"I"+&N@8
}v1 uN#/P6X{@.xAzv1nhT.['&]rN\Jwg>UM!ilH -.iPc |\F"&6xv>"W5$[ YF	]x%G0@MZ#XLeG_L`phxdS!']0ye|]51hwS8
<xcU@rz(ps<.VG&lyN\oJ;ri
8\!.u+0EP9A`[\(#APXj/9r<,_HmzyzS@hH?zb>"5 r(D#2iGA|A_$,_Cn^AJsP=#%w>6sjm)u(gi}F|naldclpbcQwp4Q  bU+D3.G&7*A3+w;|qcI`T[kOjI	u ;&S\k6pC>#]YK6wcw94r2@d* rG_* >\-:4e&WKt\nv`##8'\Wk`n5k;sSKtpm2;Us%x\t)O#2v5=n%2[|Suw!Ju.|um?e=m0
99<|#7h[ceH8*YWid7 0*xO{YlJC=T}-$Zg,TmCQ
yN?g?y6J62y%VA1^! $c)T
:Q:
ZhrH6=na#'8ZN?
>cG	`si"bRT%'P<J}nv6QvtGc'8s?^c-G>	gJ5<9hG036> Mm3Ii"$`CT<a E,8>|j
wIrJWs...tl>EP8[x@ml0m z{k-Ri' j5Cx v[Q;kO[29,x;IR01AE~+\DpiH<6`6I;Iy-mrV$}Qg}{mvC@Fw3_<qOPU!eh$ckw2	S(<1cuP!\q^MitHrE,}(Dy$'PC?z+PHW>6=?7nP|5Np8[Gv,t[xn.X0FH\Q|/.@,R5<)iHmtR-0
.8#Z,p&u:*i&=Jk*YvxN=h/M{HN |g5fGoL~U$sKRX^$^th*6GA4kT&V\i/VZ,)S;!<+n'}}O9whU#+fAH5eQ2l(	iP,y,a]c&"8Ne6SH46."7,p8,8sE[ZXfkO 9zWysFUbT# dZv|;Vl~%rkm2% 6*@~k$O |Pp}q\Xu>_Z;CgV}{c{lwImR{Kc(03-(}e`ar.U'BSjEwvbcbyvL3wG=nuR{*gfU~$4x`>M;+M,[)8cks$ku%szWgNa @-ecJ-9D 7pHh}3crK.q9f>(itiA5QR4;My1|#V-N?w"P$9?Zw%H^Rs"3X?U}e:N=i#9:uJ
;{.<1H`WVwip@ `:"(cy%#P'>-<wN.v'>|`I
 r	dV9mzJUb<(9$GbQ],)e( *5MS4x=u%	I@N*Mb9wee|}k82Km#QSn[l$@6d7*5E__J7.=,8Jd^x#v)XFPWxMG*677gMSj"yK8  1K<0U!AbBp :v!zy:~_/}1UD(9tmh1Zzpk>Wc(g	-Ze8}:=Skt,{!Ps?/os$_~J`=NAv^*vI9_gfm|5J)J%)=y%U\!0<3Z5W#D	J><N0s^lE<EDRK+8tbBOL<rg++'Ky) TF<zUCBGJO_jg'I<e-8i:cB_s v?_TtHcpe,7ZZZ24VC$g|N pzWGrMn(,5P]oDLbdP?!V-akZ"7\l9>pkE_3
.&#vvg_QtyC}dk]H.#8W:LzU-tr[k&tY#v*O_grEa<i2O+@)qVipHvS^nZ44vD(w.	a%q#$.T(;pQR$c\k i9nII)Ci[/.~dgUFpz YV`[ o1+2!2'?QR-6IA(RDGurW |ls`1\LNkiwqkawv[^%9
I?lxNXQ{[/5	f|8sJ^K3K(3U<Y5`or*J0K%lH	SJM"J'2)c?)J-T91^},9Nfo"}rulOC'RBT[I 4H&F+Gx(=y>g[>2 BZ#,Z[]B1L;l\Ma '#-7DV1g"G9 ~D:WDUj:>pX,#pT)^A:JbZG]BUMKHy?:2-BZ?$aZW(CrgRh|>%&l4$aX?,w%j$83F1F+.?gHHQ\}I|5(E]&+	`~Dif3gh 4"&9$m)`3=Fb5 cA?<JR6hd5NN2z5ABK0SC|Hgm+M6//-! ;@'6Z:9%S|F?P#[#8{~us].!*Fb9
IxBp1t,cF+SokuwQ2F"43wnqk{t"iCIG}Im!;7v
#sx4'mG$Fh>}8HRV]g\\=5M%sKB\vzjI;#bw2jI 0+`ZExij>O`f#d$JG8?&gL`$	^7qszu5CKm38Cs[]2xAW">z{F3#C	SKBH'kX=QqhS[xp\W(1&O>9* ^rc#&Dhzc[Y*`:R{_[3Z7^j.\bMfeyn9rlU[`/itbCo77NN'?Vw:	 x!.<?E}q"K]y ~EcidtH5$M35S]mqE=ZQ/z2NY~/cg$%C^1_e_3]/`pqhtrheG-.bL9U2uv@77BFt^ =_V&it-BX.!!8<?*37hqKDfff_N })kk)IGq8a!'Whu'  mVcy>u)q@r01IqYXpG'uj2RNJ >":VyV!~*?*G,,]6p>3Z$11x!kO?IE\>C uPo4y3,p Gn?/1~vG5"?WTv8d8j}>vR8
d>k/%kK9Q|]9V3og5p``PM}z:Hhws3Jel|n$HQQvJem~l4$exeZq`B*WT#]Z4=EZ6/< Yd*Z.x) pcel#<nya[ zdUI#~1 hZ\q/]wuX?N:*M$`C:/iW\N5_k*:KS,ysFi'h-5;2) m?,yS*gtZL7{W{RcH1O|
u}^n.lB A/fR;N?3ImsFQmq&gX_c}FX g$sYqIIt~ I:2vFdWy.Bg{[5t#!3>xH6t);7F6{9^Vdw]=?ARSY=y7UQ/iJsG;Cw|xa}3B'd2_wdn5(7&s($7d}yb# 1T=:6v.HLK^ZhXdyF>f,][rqM.`bJXyDsQf?v28Vfhp/j=fFiH[nG$E_n[* AXd; x4a]26'|E#GhfU?E{*s5vJCpXt-{n6I7i!8OH~+( 4X?BhuCUAi1\+Xnx;4mJRY=$Ff>X+M7U}:NN{sW'eWANO<K40MR0{
xbfa<lzV	K@}2Mu%=7B0<=.ER\>S8>Jh1p0t&<=
H<Wu;`\iwA|l}qC(eo!
[ 2F_7IvSte2A1hhfKn7AZs,{md`cwi[i1\Dv=7ul*Oi06^e{FB8/[YHV8#RGbb^ylGQ5LAR[MBr/Z36a$d&@|:Q Y#*:yZWsvC?> DDI#&I
~IlGTqH*H$~Uv``1| }%I[T Z6	%MEe`vq?G_vkN&+{UbivW-Y`uU8wh+g3@%qYEg$z8~Ac>cHO	$"];(qn/ubggO.N_:[#\&,!r62'`?u$JHwcYm_g\ad8V|Nru=H@uq{s\.z~CgcOU*r3s'~-#Q=V3$Dzt{y|#K+)G:VQ+u|1sRJI"<CZ8J}VqA(o Is="y*IW#7 	#]mM*5D}.!VxD<8Tr	~d0fc`\v8!Wu 2)-s-u+%Y2 `?dZ}p{XNV8K\UM9e	mz0Vm SSWqKoUB<fHSnxpKB
NF=^x4I]6*N<X23bXYw7B2x1c8P>G8B1/,16G*aT9+=*!(pZlg%[8uPps>H`VbJK5[x[$$p>~=Z@p"'qAXbR30'p# T#^e9|q?GN:,2<N NtQ1xIld&[l{_i2fz\}h$u	#1(xC2=IS1&- 	YuWfPJF9D`o`28_[R] xUf-Un#L`P0kvrmVr=p~YhInGB8*`1 1jx!~Y*q)+cX/F"M'{&K9kS8}s|/C?YR[8?r \{#o#EUrr9 JQqs(/]^us8#F8,N^PK=OXX \X(Eea'PWY0@9 bS$ {rz-GbH3]t9A?:R9{ tC:CQGd^O=+4f>gdmw!pOC wePO*FU{7]P7?:N\wpg*R8\1Y~<1W"Pg2^CM?VuY-#mN>x5:ua'>TWs`g{A0{|>TSj6HD_O2\S{-6\minEmDdS.\yuWDCU8 rqJ`4A*]U'5SRx* 9T$`3pzVh%*6,5T[%$y-33bSq^g'9y i1m{Abqx \F9#$:w7h-m8a&CY{12I"}b+*Ce<6Hj$BxA;rswY[j:W6)#$J2u<U
%[zSqklwuQ?'QEE?GZ)kt$pA#*"Y$gcmf5d1x'ur]]`UV  R@B|`u\CQMpn^y+w.bx?jh\FNrpHsrk/^ixuo)#?5QI"5\lo!W.c I<D'.qs>td7qi!g2s*G[r0@Krh6$.yTMwn\!K6O<trV4[*JJAr1t]/)os	D*N' })(7xeZc-s G;Z72} 5f	 )Ww?Z\HLg>Ct#lrJ#@*bigZYYi{{b+fPRe/vbs2=O{M2\J42rK.0I2N?[T.`=:n
M+#>s@j[dCpPk	dhB rUm(bI
0~J<4}WUX d'Rs_@LX f;;]STq!&8O#wr6	s>Ox%9CC6UWJa
Plr^M
)fF onszR $3PJ#81f5L	Uf!\>fk 2x>\v2[@Mb qGgHV p8??Z{Wxe 930n9  {OZ}F.T	HLO%$FCsT>39{#n
X|g]2;'OyV"8<'<KD]"q9):GHm#))|vaAR}3U|lHo,$y5\vHI2hC2UN03T6ijG8b/Y<Xq> U2nTROs}fr@$}-=v-&a7R)$QW2x9i_01999'Z"}RNrBhR;r1ddPZgZXI#'xuN\F0~YA8al5@Bp?Aq ^2!wW- ~J-(l7Oh4rxU*\S4I%#\AuvU1>jV>	
N|=*/x]m-s
0F!]~a< /%O?xc nfW|Jj<+n92|3N}2*J=F=DG$S%N 	,bBs"KDdr962ueg^5X-y=j<
2|QqQ+sx	$Sk
py|J_-w"Ik"H[$pFrh3DpOJ%|vFw$d_Q|<JN5H@ljZ1#&lsT%kdUu=F2]4d?I4<o@,	=k5fp{S!K(7Z{Ah\[87?b>F?>zg@Z9{=Ohu-VoNs2\$yP;s&mj+TRr[i}y8iirJ/>Kmh]{Xj${N;|CvnV,18I{TCs>Y}Liv(*Lb_lU\|u;
'"+j7wR,Og{G#t:L9c:}*BH ^uL"BFGYbdR
)?Lgp@wI8(WF;X W1;.0w@<U'iW{c$5r\F8sz1|_hOZ[;mWBBvc>` q[nD-3`%!O'iF*QX iO!
2>O]0 >)[_4'=9>kp>Yr,;yv>eh\\2![$P3*m1"Ew7eNpHM*$X]	1g	Baz	7H]D!8 ~iWTlxSA%$1!#I#<Kr0n4G&]J,	P*T-	89WIyAr	+1$k(8'SA<i;fhzy69$#[%<&7M:!wpn6{
,bcb8 ,jxLr1@( sS,r_@Z!Rp{I$]?Ou ed<t*q<g5ed=	Y%`a/v^~,%+)2GE$1p*HcXJy<-y z_jbo.V/!&;8F.cOT<t5Y]jnUfO!SnrI>+MkeYc|'y;L%6PtdSH&I#xN\tiE05Q}$ub|  1WYk~-n)Z39B@X4h[=7U1It$u;)D  g93)|0Pb[%cf5]7
zz&|$(_$#g%rOz&Yg;Soa_<qv@w?jS<t*BT@orx^oA;#Vo$(z6>akF]<*2X ~XGBkrYB/~8>KR=G  =}jmf+FxNrRv{%Sk/li~d:I=r6u_:	4 u5\n[,wcn6{[tv! ##EZBTOzu/66:bY;(6k\91UG**7 ^nV# )GU`sjTb3T,lGH"m,Xt@i cXnkH@hsUn1S\1Lp>Db~udRHx	[wV|C*U$qsXT#ZTh}PFUeFqXi{,bF6G}DKUb >r,,\ :M)UPN{yx9KuVIlvP@aC@f,px'+$ap
wdw%ex Z7G"y[cg+b#;PFvo}n%Xx$5QPHPpqMz6	+:uy?$4rJSgO_kz1Ec>+n?SEV:Le&2Weg C8TrK$0idIQm.]5YnN3(@g'?,yK1%$B*y$H]9'G.,
?L :#cJEz*i9"8MPgA v;! sq\I"8>~tEw4 v ?wJ1<9=FFA9=oRpxw<8|E(MH4|7Z4_\lV	s 3OY<MUN|fm~D]Kfq rvB<r:?uV#s|?zH{`:t?ZSo_EGA+ U|*aL.JnvHG8#&.0i24eHsn=N+JPmvQ\g,]v6# :iS d)uj|LK26z~v%{2$U.:i+T9#<{UfvDQ;z++G0*ftLy)UAM8J82FGQ)gdmpqGN#bpzw3(~?Z,d!@y<}2kYJ2G'FaKy2Iy-pI+\	
8k&2 1K[gc ^{NVCFYULY|E>
v^]cXk]2Cnp0r1]OhW1XL;TsL"# xcKYTd 
},n5F0\ZhgLR;YRw/I'9I.`H(QNhXhvz {DyC(+7S&?J-J)&%"|"!zA>yIL/v~Vtmw
>~67M4&1o!$8}WqB9+a&=X/OK$H;18R@Uk`$q$ 	 ]A.S+gGEI[\v\oc 9E`y Y=(iOE7vkvvy/ iwEWmcQ*dbA&<}+b(9F }zB&F3yD$ke0n]'T9CU=C; |V	
8p.1:z,jycv$n/@o2kBl4@F0"YxW\2 +s
1>\A#k~'H5M*gJp9(NXxAg=hbla1|M 2}H#!Z$Lov(6u:t&,09kISaa
F:So|H- 
=MW@ 6H/ft;_HQ*@B1k{unFWR|<d,tSI7zvV9%m<;AHhy*Lu@>*CygDq<k;!!/;V4[kuYG S0*c.2'sn }/ \ Ak.H<b	c_]jqK;>8+X|Dw[8/dy'$;Xgzt"]#9wBGI|l>e:t9`~;c}!#~G^DQ*Td9=MFHm'#?+X.`T"@UdL);5PFJpUv$zb	Zek+2;)%:1U9Wftm]f2nDqG|`,}:r+s{X.Q!*fZ}JkM#&ix>b8# 5]"5*@W !X
gi3&sc?h#]Ic8a6s?,Zec2k6\^"mcldc:A1+do-\AB]j9R|XRocnF]i!mS!w8IL,3[V0aLHnNTgjve&bEnk5]kQg#H.au_`0px\s3\"s n}8}'Sw%Q'M2lE;
+ `z`K&O{.'h![gxz{* ,|JN2G)}G:W\KZB<0>YM"*Z7p1Z"q^])m0U$+n:>we<m!cZ3S:\{[5te+|igeYH|';eH!]RhliayV:Zw6<iU"'1>2)wRE^=s$1qk{y0{FQ]x&m#zd)d8s.,S9>x+$EEC<#5t3][^}Ah,y J}F+U%UB?*iCu]Q6-#~G;1q^^^X#JOTg'{.1]UH$s<1F$6	'	QaT^jz2F>[vcA;*(#5pHK	77i :vC;w'fwhUU48!:eSH4gVS](F@!Z`AK	?rHQVS,Ka\iGbj6#eqj$	]:t[;Hv"d+T|C\$cSyreDQ!9?J;ELKW*QTqN  3D"ZM*Wd{@;zhxp\4bt sno'vDRPyoaBgz^bRA]phZZFR%>d89 hq{M5q>B^9`o\Kd~66x c:).=#+gYtGuDoKG5du*BES}Z_{qrn{O*Es?DF_3:4SE #~TZwgjO<',,qN,J?z)D 19i:VW$y GO>1nyl)?AHQ,Z@Q5g`w B1Eg'R>Cf>mc,EPa(Zk_k(T(n d/&A*N3woDwfbQwry08;=sVXVw*:&Z,xBg+xQT[sdp}?Lnvw2q 8DcV[k]N4pnRm},J.c`#uG:k<jk
Xv&HX;k5vt
z0]
stl6 tlUg; lW`A}vwPw8M7G6a;v@3G=zPMdeTxuGp.,#!,n.#I/e>X30|]AwczbYwp7y+[6juE_K_!V28QIf.pq-P q\"."	1Bkk*@R:S+m;&Zk5R%v'qkt~EvK _8#Vw4l-e:E{BxW,r.qrIe@p8'`~uWkv`hvivVFOmP;
d|V::~f_nxU `d%@n;*YI#U98qe2w(,7# #5491;BmtZ*":>~F[5/7d?*4H* l c~D"F8%&_zt?j=?C@z V\*C5|^F8j49fpK*P:8[FGu&!$yH>'/b$Bwyb2}2#A+mV0 O}|FXAWs2a1"x^3Rv,QeJrN]VP`uW]XXZbSqT1&#eZOae2F F$~u0)by=Nj4^O)O*Y#y`7x^V9NXsD;+YKJ9 ~Cd)"~[;NBU~I<MjCjG92Ft$Y\LX8C^[}D>#:g\may+XA:p|?*Eq=q pq?!32M=?	?~|?j(>9x~95^P.e"`[j[=Nq\\vZou(OpY,vtZhulT?c|u~NYPe pKtXp=D.kSM*"5R	84&k{N._ENH+3Wn^w '>uDsT 
\~I9l$ {9?q+,},6a:{R7,(o#$iq fKbJc$hcR:<9n7v~ z}BJodRb,1+1743izdQ4=A">jgImMNYF`A
fyaUcOA{lj"2 <%_vSF&+=Et$HoXTg>O20,|<[G^R,(s>t~6< SYnSQ9)qZoF3Jh~]G'vqm Fg6Yofsq
[fl $P0nORU>	jY	$s#yTYa:g./dX%$ iBr=: `Fl o,\v7~C*#8E$ y'nYa/#8#0}q@V97h{Df\|d}1bF<W7m yc=X?rN~H*&l#E`hwW%!,ivemj(!$pIL]&Vx@OGt}@A @pp+$PVecMnb<3okWbl4Trq5(WttSMW8a=N+Ai^]wHfum9Q0Z8a*t~[?|-5:j^?ou$i	#XivU3N<]h%CYRx`4mgg7mjQsw@$4g_L[ 'x`z=<BWm(c9*?D?|4{8 OV#G4wh1"c'W6Dv+xXJOlg],_qti Rxwqi7g;U%R>@}(x4Kk0-cO6Q!n]&|}-s,S~+IxkUJH>u$rK#MF_i6Z"'i<BA=kAu5#%3~1=kue|9<{v~"C	pwIvf6fMY!80GdhF#evId `'
quH}($W3.]m2(nMHN<>^cF&<p|W~*f$-=HRQ$ezg,g`9LT9yDR2^|_L@y;G[:7y@E_/fV=LP,3A.<V7iw9$>g=?i;^l6=j65#c=k~_8<zV:fc8]7QC9 
g\UGN?JhM&@3GH,9 DQ\v> ~{	yW'Z9}jI7zQp*4s jZ ip ugR*1|}FLxAG#U7zf;b2F E;4=5)uPO 035W!B!s[vn+fG.;/sN)<bh%\}/C.`{Av<L32U =*+5F)m]s"'#W	r&$egN*mNy4x!0zW'f=YD)"k0O; d 29' ( FX|+fJ|;Z(mi{O<l_6	=z/`c-bV:FIMpLR*Xvrf[{<ng!Fo5 _LN*}w,p1ZkF:rk=V 
:1:gH+Z sfoCEX`Bse;O+EvCWO1bK!_	ktrDOGi?LWm0NG<|E>]=>|=;$~2'g{J#/x?~@Qa^\I;gpA<}iUi%EN$hp5gE"'\$8gC]iSIiI,l?:,;B0B~?(u/`aeq!<a226v8}M"U$^:nPOM'jRW0<#8$Sz<tg)[T=LdAFUfwBlCfIlU$@P+Yw E{Ae?w\M"t|wpy :Xt4j:@8xZ+&#e	8Lu%@8, 8sZ_o"J 	cq'fo&;N06l<~lYwVHN ?6N[4f8>~H"@I5AB1G3XWC9[Wa`%T|9Uv><,+py'ZJKvw2pq?JT~{;Onq<Rcv\Qw <MA_ZFe$G#nTeJ p|mn:F,dP~I YM?jOv	01Tj=/lt%`gy;20r<qy>G=M!G?S$7+}9ZVC,%Ulg(|=y:vmo\6,F|ZV6GY7L#Z.Omq?#T~U4oN <rp=ye{Gv}<p:q*&y9etp@"l  by'rUxBrzqhyuFVWwT]~y>
-QGfmlc z x3m dXGzr`@wpIl
yxqc#R%	#syg@-	D[Z,4X@*qQQgjA_f`wQo5*G!FnS^0 ql`<lnQG+iKqZ1aM szqntz~jeK~wolg8Cr;)U?\gu{*p3h,,*Brry&MV= zpt+ aI(jq+*t>_$1CeV0?6WFl2pA/p*nbGcyUB  dLx<*?::mjvX>0R j&6id;\#w<P	p/	--n>ROZ~S#9YGmKFq8F[pW@ 	RI_l*:KB1?IV,9x5`rCV3Q3Y$kV F 'wOn;TJJ$f6$ "P$.YZ QU:kxUs9?9<D9)#?n2-ev q\VnH\@##J{bj."VtQ]CR^]gr< q?C<0p 6=+_}H\muK^X8z{zUNkFq 3[+8?+D`\b|v?jzg=(Om5&a^{q=)R6d4R\x< I*1! OjnM)<Awg 
yFaR5anwDy$f$IZE{n@9J =3[?+dg> Vu9dJ9-+F: cOStj+$l|dr:Xq+L`y=IkAX(3ysds4NOj29-`j6( ?+nn3*?bob9m0~srvd">Erqp,jHk x?zk[9,V'jHC)Gaw!lG_3[$3g?2UhMi0Le*7>,yE.l:
m7q$UR![Y'2zB$q\`(mjYbH
HW7-fl~sx ZXp(*C0\m8=$=z1U-|fq6;[REc&Ku,dNEBHNOZMaq:\J@d 5qG '5we%eQ}<dywj	#w^0h{!E
:`Sf2y3 v3SG75y;cF7gPK<7B0?3Lt'k9>dg^z,9{wex|l0OJY#Ssz(^_ru=R=*,':'<snMqU %0!] 1UFwH0+MZL *@u`"GX#',u#u6IOb76M.q~<$$8LDAZn[wxqurGtBeUr286 !Z 3UG_QsF:)iCGn.Wb"<c8RB9G
3( Si+S:h`0A#OBDb@lc+/$V`Kp}) wKBg\1< :^lDX9C>_$	& [C1'><I	1EkF\F6vG"ce'}DAn&:exk4$I^GRtG ifYw@q-[H34]:	n,Ss6F4|O?y{C:\vg'<{Sdqs6xQB\K12yO<Q!SfiV{	hd-K9\/@;LE3FVC"J/	s6,D;Ah@g&xUP	2gVAuZ=4 jn8UK1 sOT"S!S'>@TyR?zcDRH qU3BYh`x&;_Ai;
77ew.I`q5FdJ7OA|?bmIpn~]wW gs?r9gH@o	7:EC4J2+nd$y
(xJd9`Wy%Y77ilXcs y=iXN2$o8 gM;7td]9xUDn\	@\uvFrCE>|1xFO<&d"4[bgs<S#;27$/!H I5<CaN3TuK}+S	2*;8}$Gg(`nXc&dg!XO)HPvk!FOu5z"hP^+dIr\'=yf	>+-j_ZQ}zg9'laCI%;p68'1mFnzgC	i<9'Cv6}0V *BKFQ)W#8nFs*GY,@=zAj-Q\FS\	WtG|,	WX<nC78X}0,A>+d'Tp]M9:-PE"UMR1;rd]3Rv4<i,ZUg<zW44{p>xTWs'4wC=#	!Sx\>x$w19b28ACmLv7T#muj`g zNK[;g^EtOs0c1FjKlZC/Q<VBT!P%`nm70[D\{hZ] phyffw`3N,c-#TwQ 1:rKs)  -c	Wpw/5V&mqMIN+>LgQdu* gxV=]&I$YE;H 8=,C
=pO9ljK6 g J30QY+NKgr3HO8qy9 sO|e dp%T D>T^D2<][;6<{#ZV|=w{sRsWU>-D'rSy#t"=G##T'Sx
aF5Uom+=V'my  H7 Fz`s3&@@{z;rrizE6Iyk$9>szt<S4Z*iGKflL2vvW8?jYw%5=PH1$c.AbA^W HWa@'y!SIY$irLn6!u$$%cC<	T D%`9AD+ *[,kI`@1<?#Z.Zx3K6s`8w$eWh'+GP-'MAn__2Km4H#<CjW^;pID+
#T6#>@LNz\nOR!|jEe$\'''?:+a	dTw(a.`Seph;}gwuY8 i.mRnK=xy@#yfvvxb{9f^+Qyg-W" O<IL%DQ@g?eKo^u#mE[$qw#+@nSH<|=yfe zzt,92M[wtT*quuvo%YC7r yV5i%y9nvOL+"UdQZR\.A%x#|jQ Dh63X"zd-b9u)fwu~Z# %Cc?3VYOs- r) ~>t+MWH3XZrLV	EIRQq6w=zRyQ6GC>;1znm 1MZ%)aF)dP[H	8jqC!&b3$32;,sZvtr_LedNN[9 $w4)6?_J[Y[P FP/=q#~#M-$z2L1[97J&'IJ1n9ss96g$J X>DbhN6VyF38Ghpnm]qANz +KP>X^{UK1bNxQ4<]vch/]0-^0==1+ptK5[ A#Yf h44:J^7-rWs#FK^3[$iXHw(!yZL:x).6 ]{] dRNp>
 A'9P|T;t.BK6	.;Gk~f5x9FRU=8_
]8+*<h,[jf]]1$ ?q^Z7)#qY<<eRnWJ9g	p_YZc&Y81euq
iowr7-g[ w0=ilREfB\8lFxUd'V~.t|{:qHR.=sn\&Iy@5'=Qs-	]$B\_vO5sQ]hFF7{? n#X7*3]P6~me:e7cl\LUFgz x_p=9#?Lf8!nH\5JJf<HU8vsuw\fEgI!|^)w38W#8ZYe0?IEt}eYp$)f=.-Wzd[<@Xyq3
Ykx5P?3y!s p9tMnBQ;l=gnIpASc gmq5QnhXp>im'|pee
.nU?s:[Pv#+#-"uy*|4'hE^88^3[-#B]Z,Sr-?R9C]$H;k%sV2UE]X	XE{f1X85k^EDy~bO@PD&7zOl4.&1*6%	p'v	L^BVW&f_J[	'i'OIg5-$RIc
	=oOvgU.%p"Ws++re41npdh4{nLA`!<ZA;)bs(lcn';e6"v-8pr?UaU~j	vr6xjP\-BzqH2V=Ec<".2IUhy$x0vp~[=7Fk+YQX#1R~ui7[b<p'@SDHHl&yCf'\9  $%^[J6B<gudeq1rqi\i  |^~'*_&#8>|v{^/}1Z{D2>\u-u+3' @=*yfhuHMQ8"?E.460Kr0vyd[:qBpAp-:evyMNT9V}ixPv:2yGQ_@fU"D RHbKs$0
wtI #M:vH\?l(u]3SPpcoS2-c=I8
k3cw,#E*|z(DmXXy~-*,	wpUvz5q:#%E<5]wh}FP=-}r
_gtz>kldXh gu9aN<{e!zc\Gynnn98<AGJd[[/:v+G=r$6QdB:qOv#XKn3B>6'Qk$dn2%CQ2UK('hF>MZ (b^g#4DNw8? AO$,5L O,v`psj3tYpKq2N~}Jc!YPV#jM[iZcd`ORY<(=]$k+`wma~UY0b^ ?/yN,E $ jS)OL_2w_q[;GK"Nu+I+Yao2)y##GS>?a]L>d6Ac1^LvMc|<We"
g/#'_*>dD[I1#3LO{g%uIcq%%/.Zb?*1yL,4~leC=8)|Ped W99
s.8UtjWXuj
F#'8XP|u6xy5"lWe-taK8'A@=8;I3vnaU$OqjNQ3UR%.K	t| zUY>{.PZl#9 </Ap};c?fR!#|7r&4TKr/Trd|[6~(8pLr^vH_Qw$f_SHw3<)x``)al/CtL,"2q31F_N|? U'q :x9{u)!rD|8ngLgM(:? qXYJ|":@&W	1N1-V/yLrBD+f,:z_g?[UV%m1G)3IyZdVAfKc>muH!A=<7]DM&`29Q>LzqbCyIQ:pGo5y5bq$G#nN}4el4iqnncPw<sLeEu3*.mcPQt7*C[`v; u,C/rj&0@aBO{PR+ 9)=3W {%^#H\@:a^FR?[$W$n>&5tZ=yg)\AG|k_n*<6~c"%5Q+'bf.f@%$ 2(#r8?uvw[i%]o|b3K0^91BbpY}Ao^_<0]LV33Hj5Yl..)5C	|A' Uk91NWW,JwL bF:`bEV]Xa6	i"+NYwlr#{s 0K:tr)[]V2f
H9#7,rGNWjSY
yn+%giS	8 `2ZEUs6R[ wGOjf89$O#sVV*jz fXj:ucN89u%	<r0<h% r09e"bLi3Z"7jUu `r["e`qq(y=<@b'Gp 841^q<zc#>g5[p-U,~O.q]\F-`H<!H4"qiA$Ej;FCmDc;xw?LQ'=w5dcXe]Y^$C JmRMf,-]I}d<'EtDYGLSP.SJ.9#2$SbJJ":9S  DR?<*Mr4xb6TBg-E;Q?ku:
:=: 'C
[p`>[2k;Cg9ETlw;q{}{q"Tc2wmCQmtgv*ZFkget=[Qbq8t)&D t>7n YT4+=>tK.|^BK*i8u!%;Zgk[?ih{e.f;rVl]'q}z|f7f;<TSH>e{bP8le@{qEvHrJUf	B:w'vrqr#d=07r'vOK9OEufI,#F0<PZ7g@j0Q1O1/c=}K0[g5{ 1Y1$$2vs,NVF<$ys)Fb[doNSxU70yDHg{yLyik*8F xs'mEd0V.G #)C |*I?j=+re$yq>X_Q6Nd0#[ATF;lY59, =}{S.y`p	=3Ztnm*Ka'4{"KL7bKUUE>Hlhh)4-/zwBDP)Rwq_ZKyoq{ZM r1\ 
G_,r|&C5m`x=y$F9&|uJ!)@z/}WOdMIOsU^d Q9l^y%{^u-[OHm1G2#c#-t+F9/DaYaIql[
HyPOf.ckIsB`J=Lc)clc!o%}g@})LR393 c)Ife#}.GV<lu?3S8/hlovZ'^00<C%$#?t#R]46u\ic_PFb ;	c>GguT^$~ g"?ZmRHKKn$OywpFgTzT6s"KDA$*Q^KOSjm#jtf!@$LLj"8$
N	=)xr8QsYlA,4$m9N{L&8<_J6K(H\`;N@ym1@\'VY)MIx31>	8JqGvFkYdllXXmdsqyX`$,I@dSi"IFieq4>d,`z`>+_E
f':.9
ne:c		$f VEni[P
3(k3LwJ.|ec6EZ@dxN>G:o+\oP@Yq*B+dgpZChg\c/ m5%`Ou,#Q>.X1==kBEx6	f~;Xy{e[#CX1R,cv1:}+[Kvl(;WTI|$=r~~uu8EKiq!{G1nW<hR?qXJ.R:gWw3n	Ws
oEw?g852 88MVg>/xFcR{lcE'v[}1=?MwZ,][n"+Yh`uFVumcb`$0)e j` 2m:Vqp\o:+]<Qk92Wv'A3tpSWqH,_3gdg]<>d8Ak_Vk.j%^5x@O$^J?="$qK>qt;s2J5RTcy>ZHdthUQD,@?S>*kALCgWaq tvb\G$A<@9&Y-3V+!Df-SlgcFBv*LIw{6rYQDa<}f(K(zz{A5"vh{24z5RsQX'TcK8o_XoqC<t. $&;@N}:vnw]lc>x@<]q2'V?9	pOx#p;N:g48*[>DzB,`y9N(o\moN8/w(W@l8Y+%3,.0y.c-%9u#wJ(y$pqvEp[vn[mG+#bOnV|}hmN{heVhRJUFMTqpF2 xj*Nv/kVH`uDjt>qW&827F`O>'b_#5moS|2t;sxvWN0a 3cp#'hkydes	F9i.9d$#]O&u	 g\^HBrK{s%#\<=j#iZ7QnZ% [m`wg!UkM4zL^2;H~wQr6 C 7O_ZD&Uye'UyC&Fezu<;=lFBNqz&)Ts8V;enD"0e2ySR\1Hb_	'w9v/!F>U?i8W#x\`	BF}0p|+oA>mw|@D$299w%YnGh_`1|V=T"0aAeVI'	#9#foj5MvXwH 	So.1V/*f Z]~/?p0
G=~bN	<#j:e9( k`:Gwp#\q.:{#.HbinI'"k9s^+HXq'*I  ;0N	1idDQ	 3<:)RIc8:$qwuE{K]BO2bS}u'uFapz?3NpJfE>vxZLO. =[~PnI+]uus(e#cBGwcc!vCHKlmjBM4QN=qTxcNSr_}CtcaxCLys"a~iDWe IgEwm4o)$ >E+!,1HHrH"mJ2qJNw\<J;m
2s$		5_j+?Sd3.! nT& U,rj{|1IxExUBp9#`=NzIs)Xazo|2rlqP'|c` n`k2 |RM.K7z qO$#WfW`rO+#[A4Yf,18;TzX8+ZXM9#GQ(p:p<2'jkBZ&bc-|Ca<`!ql]~\O"W_U"mz!b'G
.!^}!zc'M=Mq"Eb.CSFw.u}|?b|tT]FXQY<!I@'z?6j gv ,3G$j@Y xeRkc!4V1*)!83K7Lts0Ddk_D/kpvxRW!.+2Xdb0h4p<0oFxz\o;U/ilai{]1*6w1xxg Vc`]$@< Yij.I|V&l3R;ferv,/XHd6:cK@\xr2AcT RkFnwbQc gX)'<$D+'3Gknn];`#>~J{+r*f
p/\){duI``A9G,(K(Iz **eU]cy)kf#LO;@cic>c?k=qt2e@`|8kGLv#G4RFqRc<gdD;B|# 3}T/!W Heq#;`gk xRA!MX `tFA_<N vDk5+ |p:Q!4k%/ ! rIfFn&1Og2,a 7E>@3]3RX#]F(>&k[H`; xza>1+5+zW-LvRB9<(_!OQ\ 9E`NM7R1, )ln{7`4d' Ou[D2-_ 0Gz##T56m3v>%e) #;<sO,9^ZKpA}DhKx;
9 HPw2'-jtTiw'k{ewv(#9ciWdThj%.sU@
X1=?:-yWzP*"d8IR9%7 JH#,P({rA',xJ-b`0$eTAtK=(. yJ#Q3$e=8ev#Fxp8.RUYhT/,\Lehm HLVFsydDr6Nq^IEzjs zxGJHV8.LUwR[cY/v#N6?2D13]wO][w(^1t*DD h,~Uk,"vC }{$Jz36Eq<$	`^vRqWi6KOw=WNGZM(b`(;1\^DRI?O*.|8TA:{ji9JU8t)mldvG3$1[~	 g)^_\1e:Hn-q\*!NixZVbrpw*5[s}yI?g0kt9suw",mf-:ivT==B>C+B0]^\MbZv&c=!X]UGS\x:U[9?{<zb36S v~T>#n 3	y9's!z?-mP|'(Tmmr{4n2 #FawC.d"BYUcvmzWe,m?E]tQI^{ZSrnRk})pl0<$6g 0D8?MRa;1_k6MmufF	)[h
0W|SM`R;Uz\='YXdl5#e:dWg Tm6<6'<i34/BTE,*[;v r}Tc*NNjuP0H$SSu9-"2\,:!uKN/W<:%-g s1qrvc?U[Hd7C[AK#T'R;W3Cl9umB1sHbu<6mzg*dO;@98y-bm~x
Tf5|XnI,8<d/;W\*!G=23iu(B;KrkI{_eqZr{=D?y\?R=wI>@r@$c.g?3/inZ&-<bq^I*ydQF.q/;
Oc[M`~"'RqdJ5;u1Ug:Nx[u=u2|~S<IBh xiyZm y>1Kq1#S}zvL[c=![U},r}3XCRm_}2\3:r.4%-\>q<cV-RG.K.PVFa2A	DoIVYgC 6G?nCg&h!1ZL78 >xa!Ym/ '<uM*A
^Lagy?:uYD\wI<`ub	oxHqk0w3^ s*^[6F>=oXvJ{ aESSH`|y 3EQl|_#Gn|f97	h0vy#	r1/s!vUa0SyhDh	p VCvf	,1uT\I6<9WNOdd$iEE?m?:4)#  ORPix(o>H (LG#_c ^>k_^+[8,p.:}iItit&JO;'Pzsi*,>A_yA=:Wy-&.G NO_Jj:qS>sow4^=&NU>hlt@OW>V2}pH(^]5SPYLrml&N+,iZa4Y1Fy^:\Zt1ddV%qn;v	1@kk<q-$,CGA A#:"'9fd^]vW=O tm7]JEP-"Dfg7sBaXVFml,`q8",O\thmu-]-,1"f
h{(2`/gZFc qqN p$/bV{MH]I 0O4A0V)Q)yT5hXcIaljx9Q
9]~Zq'H?k2@\#1>?95;8^6;AR |;X^m$?:P5j5	i%E}'7]w'}Cp1eSiq<LA1}OT_/}z~u<-2>6HxI/PBdXBpqvR\" q#-L\!yZ+kS?#GPpUfZ[^qwv/(nC7h(EcL$}*k%S
6:KeJvm7(}z.;8L]h$z! ZC<dl\7>yw']#K{+s$i4] ( /1u4w_<\IkebqRQ;h ZL+xPZ35v[P?Q~h'WEnrG^m+ce20:Je(kyeIi/o
C85^9tlFq-/dqW3H1rNI9<};~
7C
Hp>Ghm&AJ{
tdu Q J gH!M	 dJI4%<cIe nq ":LhVrlq@ I.$u#G >y;FieVLs z*E6-EI3[k6.7}9gWlKwxsr$LEFFNp},F0|}W0zV>+x"RJ9Tp1KSf1vAj]idw*$)eu{pk7{0> ?,MvQmqoW AuDk;!#f@)hsma	+uI@oFydUVV8$8<S$a\T/~Z[X`<q
viv`N988Z		*)@*RBN0Y,x/L{x)s/Y:zi!XE0~OQ}6)f+: ##C[^XKq}h]\[Ffb@?LsB{]6l.a^vG$;KmAXsOElO`L+I(+y%I Q9KN\u}v%|wWE~C3V79f'j9[c:V7_{WBYjao8SX}AO?9Qj7g7%#]y"$CJp)'B:= mv~LLc+wt3\wf  =M8upL :V	nuIy2I3g )v]tM?[as'brU3Q2[5w!|A_#TbC#(P|})9FrB4Yg)Kg] w%{aW]%Oi^F5dr>Y9s	ceL+zo:03.ZJ%i!S6[U?ye!pHY,sJ}G5i R; G:=:`g&tA-
$5PWUAI= ;Km>)~+^E ;Jdq1+=!cd|K'q,;s3KRu/)m4I@^{}Wav-"%DJ9	mXl4[#S>d
;;-|Gmm\*Kx>bFt0L crn^.*	Am#Gp2q>^t,o2n=hO\:6j3*)`|FqFvD4m|/u8rzUB>p{&%tbzfyvXJ\6W9fBzd*]Y>y</._G-]7u l~3Cu>gci.ejfE1^xGB?:U:G.Iv]pH_B#X;Ij16TvVp;X4*x>ZkC(d4jc  T@!
'A>dDb]D tfb9v	UgDe>AFU\[i9(idz4+W^lU'	2pF=	RyBmu*6%?Z>=DrG`&T x ZsZk< Dxj>gg|drrJUFc,"vvM5[ZIt;>dj=5(~]CAE?D98+A4po
|=y w>zg*-a`K`l9+>&WGnrgm0NE;#uGPV3t[+Ds_B'gI\+)e+e?qjS g'ETLJ.
%7gSiqn?S-;?c*\hQsR>i0w t~/<UN8_\Gw }AK"bqI22JX|LCth4F ^tf$u0j/:f3tA2vG9g|H
omodKK;wdyc	o%wP8K/qLH5$+;. []N	($A	I:] .!P|(m<MN!#S? /k NG\;=As\k-azr"{Q6ju}R&^X$688bW{DR 95Fo$0l.,*^@}N4VHtDn?z1Ty7A'LkBd]8u8Uhz}if4VYFP|?}NZKiWiht c<w
Aeh	mj
]K	@7i
<UrMG?"kEuk}OOd`F rOF_sikkN9\n\ANT~yY:kPT1$r+l7\ex'>sjk?~XEJ=_	 V=J<m~[X4 `On62_@I"*<lRCjV!Y'!a_E<]fF]E>s8od&h8$>rs%9s(S<$Ck7SA;m6s??V[bodgx0sK('Y'Wl6o"]rluCu7h@WFvzU_H;7~I`l|ECnF%F&YY-'B|2;RJs VtL3+&t[<in&qKNLc>^2wG9<u&Fw4en5VYm/c(Z1<<
`[Kn?iCqENsQ	cHx^@:sN;1eeK&bQFG07D h;^OGqj-ff<(& ?zl+qubCN$ya,ea!Wf/E+Eag*MR7f6`(.MKsl2I+^PuKTfXT%BO1XLte3S4#sl7)r 24$Ok,Q-@J)NEf9&dbJG\Kg
ECidK` 9chkR9Sldd-gAIdR`:Z8Ot/KmC<gZXOel}	_ZK| 7MGbe#
f;[#4&t{@u :wR%t;^tcZ[;\p|*[4	l*l
2 S1\CrwH yYXk#hq| x<X8Vl.NSl-: @!#N}>P!y2ez8<(M.bP'5m~
I/vMu <f uwR;Y4
K*!?M
ne}3WW-?}KF2XucVVSx2_&i[HP, ]>+dO*^[c
U*lG#}&	2DW=kIm;E#cL~kP<<_3{V'^|u9'Z4k7p>@/>-&4=:Xs#ss!8sy"JFPiin#9
zR1'IXsE9=nc^}q,T1i^86S)_B#v0Yv|?3$cWq+.c dk1 <w-t}Es`{O;Goaj1[dH=s<$q6cYG)s?Y#Yfr=|vnad|9P_r<EIGqM>:MV)e7V5IY$MgG{Jp\ur4cdf*2^pXT?nX?	b/js,PsW Fe>9p1VTu31XjvfFf=4.|G1<u.[9@]."0)8>2F{iS#J,vPiq[o6@vsw(U9~ZF^|X9c UdOz69jQ5gdqom~H-IYX}_^6YF=Hv~p.clPC}1M<ajTp5PrIG$O#q*dJ8a*Oqc?S]{y&(I$
0GLSi-8e{C%7n?A>z7(73*nuS~0ZMj]eL> Y$sN	4[/gc5zE]Q]5Psiz#mD[zGgQp'W#rx9`b=R)$;c&82
=iZl&_ 7Iq	JN=+=2 #9G"%V-##<(M#A t^x,~EqIej3RKii= (kb^w+r.9*x5#nSO&D_p Td]	9VhVv/"klEEdP@#*@V8f	?oNa&b}su"Dk><Z>P1,H>fF6U1S?M+PQl>k-(4I x=A1p=$jwI|KR23Q	>}@N*[M?PWc7#@+iD=:}2ycsXH[Jg[>~Y/\Yr<=is<mBc%s rp0xuX)MBKk 4K8'=[B0
p3 zI!SSCB	|p<'G$`I0@	zqt"[.s1>a<,H&d<(Q64FHFlc^)d=E6a$+qsz}zZ<DK|B9#nf uRkQsY	;E^!ny:zS?xGui$C0Y	4naH6wGPxtY1sId-DPXd9*$h^Kxw+'=0s94/beu+_ZvXHpN?0x=JSY9eT7F9Y5_~]A+ Oq	5+#|RB#uxRIcb@E$b ^$c+pP?eN|iEc,WG!2O ">ZM+nTc> =:rgDFxA?J#R3o.zN{>X=)dGM[P[w)p<qAw$Nqjfq~o1AJK-CH2HKM2,B;m.}Mzo G%L	 Oq,qk
CF29
GOSDG_ [Enz_5nT+WuXI-RI$ H zB||bTd*RJoali";lyP3S@5LV,{%dCuck2;+Km$==b!8bzn~u(%bav}~WqK`-Dq$q#n	JzcQ/]nYq> q$rn 1:}\X|5mYYY< yzjv_) ],qWy[y;8&W1')[J@;		T G@O t&xy4-{yXe	GveQ;Kl9HVw[#'U~vS	]
Y=GOWm[]n:;GO
i*3^_E	sY4	F6X~f5SZ"fU1rq8{4fUt[rAUw81.2}RSQ'+_XAHbx[0R	kYgJoRN_&$FFv3z>U"3xsR2[x|020p~tEl6sMisI#>hIa9@vpp!%\}k(	rb^m"lh!PJh>Zj"e hJP6'tqqVD_pra`ijQxlY#d(Az$Hh)Lbv'3[*l'\xr^qH>@0GwmX~fUqc"Ldor^jbv26`bo&5!<=:rtA6JFah'chqdgiR'hPK]'aZ` &]=d|#m%Nr0G>_Z["}z`fYQT }=seyu~"(wu|?*dF?*y^*Czzun[NPdg >^kb`9xFhlN [=IAY#dq18__hB	v{K;1p02)ctX3]<6F4[N<(in+9,J1T2'\%lI#0>5omG=csyEB@3'IEXc I\`=t-b6Uz[W}xOi	aJ3T8tC|U%eYR{q) d9&#;t[TWT' 4td3(e8=DCJW(9\o{x$H=<KMa+mjVd1W8^7 *Q5Bv=VG0O<Ie2*M!u+kE%]xk.gZIS\\EaW;O}+b$mQ88;>38h#L	Y#
9Q@|h=@bmEH$hi(sy=% 5UJ'3(<y[,h	vR3&s*,M9)-GfUv4JtvebKDFk2g1 w$wCA=OtI'qgA].VE>,{9'8v>BKV9qv%G'`]t xGv_/8i#SO_@(Ie-pzGzgs?8rGaj6N6[QSnKn 9<N>^;_ 1.IOXY	gu((21LP~5F99s()R5sf.U@~9UXw|sd.kZ6n'"AIWS?8eu*U<)+gp\Y~ps[Ec[_6L9$+(
X^5" _
eq-/+qHdW=DNF*x =3L{i v<X3|),H7=4_izS wO	$sNE3FO}U+QsB(=KS}g7UpX1[5\^G8AWt0jR\BQ~F{9|.tc.|=Q!2:GZ_IKI8S(,DDXzcgY'c kI=hHe& V{_g19$SErO5Z*=O^| uL,k9]~uA2
KLlFB3LhY.H`:q+jjE!`ry=z`V [U"M3fE@S?4~/fBgr25COruQ/(u9"_Wp>}hIdi#F}3sM.=XL*F1Twl$ ^UFR==!P?s:zh$Rt`<O$j9w<[Dh=I&5U\d|5$@ d1ZNz	B|8`gJ`p:lY1,7pu_^v@9
.pY,V3HPX`o?YD}v8r*dU	~6:rlSiMp_,9!Y~c
Fd$?AY_q*3)}t(4k35Z#&{A?`&\G
UI6pyHHF,~T<NcgJQeU71p[#ZVLya;0I=)lNE`vi)67.f~c}jY?g8P!po^e#eU9?z:K\fl&s:`6n oD,yaO?-N|cAmb1218+mb u?W% %!Ca^7'lJ4BgJ,fa/L8ur*o]2zq]9g"6{1Vfej[pYe?JyBkN2Ci5k+TD
Q]}wMnI=it. ufW32vx}+#9juKvT:wil`xK =8($#*1>E;WplP^ )"vn9rMjd'on$q]#Ri0=x,irm9w 69 	&!IoJjmIw ID\>	`tvj>w(>F}UjneGw'NzJF%!%w<yQU;d$Lar-w?Y$yW>RA|Y5Z&S%Njv7Tev4 !zWI rMjle?U3Z 9MovsLZW['"	r6)ebqB7@3]V`\;>6sJWdxRX~8',I 9P: W~##RG5zGV,3z hxz(;M83Ol z`F}4z0\m\\Qnq9#wlNtTqu.Jb@Fpy s2y5[hX8Ex>U[r  8=ryjXn;$;O' ^rNu\guhU4h9dru*,P.I{*H#t<b96Y$v$yJ	t\=/QXn!d,7mc(G1]m`R) pN1{J}*Jk
/V4i]9R+<'.2n <B4\'5M)5fFxm~qn ccsz	KJk*7>&|+ XsO#5Q .m9j5l2=GDx_?ZR>Q_U
6_"qE[vUdb p<[F<OGv~W}@&yOhB'*N}/x	AE+b@y+dMWv}0k{f1,'?>!DPs4gq-9Fn}|&M$1PmcN%:N\s~s
9Nzj.{F\^8i'xN=<jM!*::Yu(,][wpmCao%mlb	`;c Ig% %IU3.R\,V+:~\f,:7YGM60u$G\(ZM  G; b/	];Xg#5Ucc[[ccg g|[xRcppHzeo'H 8o-t}5cntB%9?+Nm4-mms*nYc:89azY;{_->J6YzxV*\U+v 3cF,Ad)Tl7Yd(bl4Dq#'$?/*E|gWi4} 6>WwQ-("$^TwyD9QtfTa|k 7Lyxf|8+4cbKG+2R?V-R19#Z";4R|@AYp2jk; fS{'+~jS)qkn y?fVb5x<IV?0Kiv ebPI gYvee  y9V@qK5:]-'wn%<B]S
Np99p%gXxW*1+@cPUvrI>U6[x'Nk4ePO#s]IkK') #1@7}QVpd_:8d JT;PG_RVX'?k!l +|<gewSv{EpGp#?*e6].9!go*x,d7MO!5K%O[W ._h%Bsr8Vwe,}Lui[4:U[gIR!Q ,_6RQ9!U}@SJds)V|=`\rxDcscT}*Ag4w6h4?4AsJO#Q_3jruI6At
zaAZL^o3OAvhfibIv#|W8xBQnsGNfj8l)8U4LWp*&q^5
qYzTTt2)`wVS=h(&sw1]>[TPHg]p+b7&HcyX&]Wf![$_E{l 4!;Jz2B>Bddc?,;_.%@0z|{
CY`THkRr|TO3fXW3zHC1ff9sJi
qkdn\ghsSLA<`ccWAP!E0{=;k7izRK3?Py!@>d62}D!"jF\3hi @pk]9*^>^mN0	2`j"k{Ld$[ *N
,stLHr?J~&qMc+"3lt^)4d2AR=M'c-]Q$Y<( I vSygcK5=*;G{?$1wJ/	8+>~n;C.?FRc"
Ct
.kA&x3 '
oavCUc6#$'5agy|~nRVsWdqpy f1*>krFH2>4t`gq*=yW008S|jb\,F`#f#R# 1NH%:zUFe!OS9?GMrvS:~c}#F :1 )}]5+iJ`iu`H g9 ZYLnT
G>x5O+&iW!Lq!~5f4)ijbFq}=kU1`KcJKfTyp0G}>I!Z HI bO#=:85$WHDQf#'iw[p]fg<XiRoqAqu[.rqQmr'A,;RD6x2Z-o!a}{~n$,@OUR02N8&l4 9vF"+8dbr>W&<~,nJKrS`	hp|n#Wmam/H]+L$7aybL	j:\2Ke7-m46;0@v9=xYNZ,VDld&Ix{s	y{MZV##+/c\dz"3VBFp=+m1I=b|
$OrRb=\u=[XL'!XR}q)ma{0xuC/$V%bhT(-&??*w 36L")?4E6:rzPs<zGx(q.!uO	A-B?\	Az`v sNm:h.cp {0<s+p*RX1 y3KVc: T>s!`rZ=>i8}^L>-JiwI7DX>|AhvC3j@h
$4s#XH?W{vsUcf9c&6<q[O,DcI 
WcsWG}1 -0F[ [O zPj7r]w<}`p}]vL#= ul\U:en`u-rnI*8*nz]^$XIirdKd^+ko3Brw1%9ZscUc'k(^uuV<	r^@\Wp'|0_YcD!c}	yd1'uDs3_69|\i(= mX}	9remLQL;D9frzC^Te+!^A7W114AH<UcO?x
Su	gh6:_&>LX Fc7.Yi9k<j&E"vhKwVesG<g	'7/RH#\TO4rA$r0&fU/c$U;[g/R$FJ;1qQ4mJK6$ 9 y{%tfCeKb`u;#-<u97q\nMe^ 4T%}3;Zw?]T6<qA_P=2F?:+,c8*\O"bcFTV =8Z'T-e-#[i 09Y@<6',0dOZ[
i,Gn1RmPznQx(;VO"-y~ak24@I0GbzgauxT:zq  p|UvZ'Uf@:41@4&i
K@qdc-_kd_ZMV-?[,-Q[Hrxtpx^esf9JDQcR'rip#@bNkSz|OPhh{#igtXFFZvKq0Rsy<`Z#Q=f
H8fhlrA*qwT3lKq4 iRL0/ NmJ#"quFRw~ fj;ZvcU[iRe,~1sH$ |_j][K$>+cn>". #$0B<2Tn C5U
VVJ%{MlpF}:_ A 1B--C$[kJDg*?#il3b9	c"FL2rxwh>Mr5ggJP7z_k:Kxcb.8?)kKKZN1f2.I1(msldULO|]eGR2!?rFEJ[v;.d~GH*R.SnJ=IVe n1_WdU_>D]=X c+a%^gK-w  t;!.:h3w(lAF>@Tg4VvV{&MI!dg[JI]F@S4>v>n<7F G#';]s{KnIU5&=w02]AS ~h;-#oR|Hd @:I]" CYnquu}7H@,B=L C^`yRvq*LL$8'Zo fQ6Y/o[m:X?
+: &1qkr	\g2%IBOUN{>|~P|B^'>O,( 3{RsW$2gpAHgUMz dl74:Z1u0 ef9{kYjL?{<Gw~||3kdxYdx2t.%3JtHFK*xCKy'mXbz2+q$)m6:uo	FeoM:!t;02#u4W $6[2}M8KFw`qVFVc?c^]Uo /@}F^'{F%^!LWEZ.G4Qm$\{MS/gN@9
[wE IH+=}~<FlsH|X  e=Xmr,|j'7yyd+#Hm#`8$}=~qVc('r%\O	Z{]dyj;'%C 1w8ljI;ph%Q~cg*Im472 'p>3Z=Mu	;WL{D?>:QhvR\vGbq"O>xJ9iO,U1r+g#	9>T}Mu`E;#*0qR+fkR~-_v~=^$M6L9HPkSyW8a%h4{wn'M.*(_(PDI)`~W P	s&2`e
Id-MVn9;Wp#n2J;M6~M$%1;R3XdE3!e "x WF7i`x5uitrP onFw?oPc /Y7tf|&M\e8nCG,^Y~-wSe6$ZL+2PA4%@P(jS$,o4Q{i.u;!'6Utj-4DPz0\HDrh"kA[#|SW<HQ_RXH$Q\` k4dt%uWsFqKQRY83.@'qZ]>bmGI@x85iR=WLb[[$yyLEnRrzKV2<HN1C7	sif)!85U'mC`p+G_%dB`E-8sec%A>O;2vvAy{lu9	G9CQ,F8'dfarw(+};Q*.72=+4Mnn^'#=1x~`1qZ&14l$lkm<`c#7hu`I{ae%,v^'~	UMx*kve}I/Jq$^Z[Y'xC!//G_>4QWb}>\7tGLX
K8 Pc0\d|2Y:CBa$3]SQ_V>B$0xzi{;=~e60.TgEMa';so~ wns`GZDv2Z0XpI>Xg{@a2AzZ=nP--;pGHW$NKZ|3jXz#d1\xR^N7z|Vzv?sS(\eg@rxQ'99"]"9;gB^vAyo
N:
f>Rry5i]:?{m+VckV$KF)Z]ZHw?jE;RUxuuw60.
r<8 yqLnfx	
CYX8G@GU$y`xotUA= qRZ\;sjLLPgUJfe#Nq].\)_MJ,I@Tp9?t^FAS[GR+I%FyA+=O*TiNS\'_OQCMk6}f>~e1)`z(LL(pqE*eX3WZ[kN{=}s#EqrvYs9f!PriiuS[Kk_\"H
=*iws*YNM)Y(F
`cxC;>}KX<HIxWiRE:0=jNz,xp|/<];Zv!9@?CVkp3G`$-1`V*0k'AZ+S.nq q4;;1ukSFQl3VWx6> gtoo2pY#8   WVF+/#(O@F$kA4aX=HTc#gw=b883YMc d&/R0?"9:pRs]l$2:K#C 9RH<*yG4vsZ#1irE{c_fLnt U(I_\y	\r* ?M4]iEK!f`>^XTjdsLsKP3K,w3QpzlPxt6US[;n0pW>[_ZYO3yL@:y{UMh>GR+<cV=TyDwaB<CsDFTxn$?6Nw/z8(#nO%zkaXs67TrO1SN\	6Q"8kmY9 n2M8Lc BJ`be->`Tzyt4TkO'	'[:d3"bNp2Yx TlYr\v[SxE 89#e?%s:S3'-yR+`?*
[6[i{,Bp}Ju-.XS$m U@6' q/Sc.mbI<zs~rHpUd1!lW<1Xc+/.a]XQM=.HH&5kO f '}3IPU S-?T_CMLw8P^
DbX9$kcx_=;39KB  p u$G?(\Km"?S!vU8#iy	S\4,qmM:WwlBNy1*]#dLUH$z.
15R*T*nXH/dn$LA";m#Hq{UawB9 `6$. pv<N9vu@	'(NQXl{Wdor|~3Z TJ.kr$qOi2/5	Q	Fspr	59aN^H"$h>$F}GP^k7e2$: y7Dw$.G V(%\X{	XqT]0IsQK}Hef)	C&*&9Goc<,H<*<\0b~ieBX'3dy
pD	KEO.<Wk)f >t`.M.6	:DEwfnV .F@KWZu(o}[@`e=(qYdAC2p>+C<]J n8$}1mk9Z"K21+0\H#xnQ8JLd})=1R4C.L=i@;_7 `;H [hwD%-;;)D+X 1bH9m1 {>%C%O
4v<oogsS]^'!UgwX)2vONDQ=eo- IQ(	Ax24.]w
KgMoO{dHFAfq6mcHqltObc3%fFOxKA(JNE{>qK'cGvO%s)U;,O[J:c#n|==)\g;v_JD!1BGPj=[>14%F%Bv	&[vO=N,:sJvR=(oNXsK.<@>O}USE%Y+6	?QR+=	|qR2qus0>q9ec9r!.snq8oo+Xc` SY3,YG9 W&<8XK:y8<}  g]Ew2	# +W[%
]TP.Aohc`;}<i?i}FS]1YfOQOg ;\~1O	p|]<*EFaxF@#mj'VMocY@4v$xry
L27jwQ i',O-[C1y\&aww	O*PR[&AxKLrOh*)$sB%%bdTY]'SAHKx#BDQ[H-s\`}3Y&v xHo3+GYb0chir:WM qG dF%O|0]P 
9}u +`<G[D*ZN8 gE`2n3U}H9 k+8.Jn@z.1y[Eqr+#`y=llb0f#2[1P LV2pV+g)i8:tL1,Fnw`y 
V
NC~8*	<'we#z*GCiV:3CS?{9>OJ^k$3Az9G*3B9dS)uKl, MmcW7(1c 0-{0Us^`U.DR#reO#%Ny'dy2$]}<l R1qUs9[gOrsDtg'XY/&KcD/]nvG#5x@
N-k~n+&RM\T6}sH`\>!#R ru,
)\'9KFVSji.r;+F9u.7tIGRMEPy9 U97XHX vywjY*34Dg5`A\\ei
BG4[K ]q9QSmIPSoM@1AfYN0
Gec9ZS4rw+pqzgEc9@)eB%`*1W=3 qY6#nUJ	Nz[gsq4`9`M3N)FGYWmmV)'xc(1?,<8LJ?|Vb hx=:|#{$E'W[+$J_
?S
"8<>U{Bqz:O9H2V\{zc[\r9T0F8 y3Y]P5D= \Ump [Il0UJ"N'h/|n GV~J'$%ln<=6x[U$\~  <Kw/KPqvnvw6k]bX.yE$y"3~M|06N{9LPr#,.#${dqdU9X1
ve=aXvgR0a-%Q c V]m  1uMr*GeH!Ac^Prjb*V[{h@,yJGfyUjG\<Auu;" :R(?zN[mGR[.!AZ6Cv9i2y%$|k+:]LI0n\)#lP-3y)	{?<*nRTr=	3S<eY:{PKtPJm+3`\vRY2
]Ja<rPIc];&G/chA36<sqN[u	{ @<Ns$R'
?)e]B=W7GCiW-.Wy-n]~y5kW2-_zs&s&n~~@i~O\?L o XTJ.TzuM^E%|(0q=jp!xC+	}Eq26RE1B x_|T>J^$2
>^t]F|A#}hn--$n8RAY FPI>|fd9xEA9{{W*"nPS?jeN9L	i<<RBuHtckn#zu>-! :I|wRDys%psWdIjbU4RwFoJnmcJ7]5+#k9KnTrY]!`P)j=@[L `in4 iyjA#e66|"aNvYX Y94qF8 955),Z)GW~Lkh9=c\OO#nN?$3,
 	GS\,U8
 

+M6Kxa8u(OV|/j0+VU}16% 34w$/lv6(VYX#-XOBqAljkj@ t?\T|>T'<}jy6Yb=c]l;n]H p3VN q\*L`H+La H?m,fBDy
y*q,Ey9H$(Qn:S+%LuAcHXm^D{fFsVTFY%7.*:rq/ Zs5-xV,$.I,g)(Rr<lH<~tLeykfDh7X{q/gBQ!5&+n"Cw%8-SEqsnFwidq,Y!Hg',#?0Hy|6l]Ym[kFmJQ'Zc`I0C^r!H&v"s9)I$FBF={Vf#lhrp=-q3^TJ95rc%S~%-![Ao(KA8oLhn	:gTNg*s$	`x0}-Lvvcu=s*h8 e898*m1jV24.'4tXm\KdP<uA9]\q*cK;!N	2i1GE$S}HzqvS#CA|jsGG{q&tA;sme.q>=9_"/es]^iC$XQ C|h2IOVw=z^BYV-A_^4x%j|/NZNoSy+8/O4VE6Fay<RBAfAI)'	4Nsqr{RFG&+O
HWg'DYYoUGE-HSVg-*'\~-;:{SPO_.b,"Q	l}rnYJT' 
8B>[M&g,98R4"9vf`PQ;Gux[p~_[-j56f?),&$![sqmZ++I;&q)7&v22M|"03rzVM>$1>4bI(iq]r_2;,\+s?Zl;7).~-$e2Q*0!A#ZEt&$HR==~oM@ Uw'n 	^GYfHLC"[kuY e#Fq^4  |O$e'g;:q' Df)A{^_'nLnON-R"d$ol#[c;(wmT;bwq)#)c V Y*=85\snO?"}jeqv3EkiV21p {qC
.tsRAk[C|j6>YLUznsc$8jAW.[vCs!y,*[".$'qz6)P$f]6NGQ.2BtV1N.&*[701a[7a[i'{P,ly$ql[H*w3wFcc8|gbF)aZv_DpZYdqHvp:S);0k~Z6`I2W5WeKT1[g0cO;?N:ef^2 ;d2Aw D.S^4RNq8T8Fi])%t%ZL&F\
G+tl{#uC-aKl	vN>U6b3[!H qK~Su!YBGK}G_/c2rY^\E-,pyy"ISzuH=3_YJ.Ini(- kSooN{w*nC "o#ePy*2y3F8=k6Ir:wOu&g4nxtOj"7O9.jtT-!A$(\lDCyb>V+ _CT<qjj.;|5^yn`:Rf^2pB,VatF0YBxEj{:w":o)LUSCj1pu3Q?+=$[IX  8; x%'e-}^V+0n==x8yRw?E;^GyF~5_P}zAil)t$)G)P`)eUpw68g[Nbovea@x=0c9Dis[ZG8sRoF/kvNq =F:MvrHeAO4DxZ#i;[H~4mdty8rs	eElm:x Bz5;T={Mfux%-P%y`V;5]6!. {x=5xhK6pz/vCnBB9q#RfbD	
ElYX#tW}2Xb^$h_g8<9#\%\H	SCyvN^ipDXM,QI ~8f}PWTkM2D(fp9'g50T~#e(a"Xt]C=X4I0IMKIaT<]F&dR )? v{Zv1?:R]$qL&X f{
82D,5`:88>zn&;Qyvyx6hd u:7{n7<7&^Ius)Dw>T^[^z[\8W*XkfYej1~ 	narq\|\/<K"n`	X/A+=e]3:c*n*w/tvN_l]2Mqy{U #o8"wQde<ss[<8fus]B-@-$B0<yIi J# ??-(w1y#~BZQVq0]G -MTpUwRK(mhehM>w;q81kQ^2M70wU6NUF9aYm+9	=:)
vWTbi/zy	G;pRFgc,xUXD3=hn_IA9>'3<0}yiiZw`)`s>\Z	1 b}r:HecY%n'/rQ9q)n+aw=A,mpr+{jDMd2>eYU##ju(`M*TwOziE2<ui:?0t^x%\|M7>7l+569?Y<v$2.5=5%{/q g<k"GAf 0=Ec-7p/33W=wrkS\_w {=f08F?Ue<o*O5>ckG>EL:q9;	?EFQ&[xzD2V,NF1kP>&vmjYQ*dN}<#"#Nw5m1';~@j="mFx J_yi8e!I~Vm8N8ON	69j71:whR'bgj1Y9OO,1%Ra`ruYg*G?&@qhH?Lg	%JV+r0=Fw@mb?.T9+'; j&.D^W[7$HD@=G?TnT1uSvFFM:,n|8-J-."~!#UEr7Y UEl!}Z$fyD1n90zO
P+g7?V})U"K0tO%p3
"cxxy3Pm+[ixlm'NHtt~K2~(ID$/eL2\:olEl?UL9O|t"RCbPh:k=Z}d>tf.9c8 datwTa#D%^@UC4d#C58u!]0{JYk#2#&G#)[@+MS"Vw2a%m#;9r&#s(F4%o:X9d!pqG`2 w+	uP(k*n =3Clok9
N0Gh;'{mqkK% @P4?:[xYN>H=&E$!q[	<uJFuuZ8Mu58vK4#g{/YUX	J<p+Tr5o*M%9Z+M:&F/B=q>>#SI2%s$?K]H)5h;wnM88Qkk Em# ?_zo Ojcb$G\Vx'Lsw?@Y~T
 $$5EFv6%#mA zU\.0 )sGM)l`>/z{DcX]QF%8}KH!A9
&hm9'r|3#O	_F8N|%5=Ud
A'<`~C
Tv:aO=zga5)&#t$[pS]A4yg}=Fd1qm<-$ ..ev ULdPFJu.i8o&F	PG>^2b;`>^1CRhvc$<;ikV)E6LRxW&ps}8qXQct(@?z"2o2wgn0	MJ_i]	bteh2HqZUFyFg ~ 8&lH$jqUASiQ 1@1 gM1]%ne6`f*&W{j8	5s!RzMhmYH|0<=w5-Y7>{(>ZB!
$}f@ON~TBJM+~&K7>=B`2w^~u$E lFrwp.C(@tpz.= Z(nr?_SYy;.Pc-4l{tgO)KR0E{i9vQH3n'hO@wm^6Q}SS7ZE}>h9jXI#K[;hd	*^RB#C\[iI#=@lm3'~F3>*E+(4#2Nf]k9m#$m;q~n0q'\&i;3#[JoE{BJI-|84[68
bxR)i\~|%d##k@*o<D	o5V dU.nd$d4Vvf. e;H=rOI%"hW0PuY 04-%.}v-Sn=8v%v3#7hR;`ulqZ4
X0^:f>kac#blq*	t61|M$cn'\-uMdU Z8W
6#To<=kK6y.#Wy :G(`A.G gj3>&s\Y(CEnI gc=+{bcsj^#nG=/"[`2Ozz.]+Lu[	C	=|;nlJgS>1}pqg\HX]Rd8~+	KRI!\`I^H*wR0cVu-58)%~*nGGC\8_qs YgJm}KKWuj.xm~<WquuFrs3YqpUPXxho}mueqs4%rwAnG\4]GEl9w1[H$yWFG".N@\_j$,m$8#>[E{M
[qVF=3}d	V	7y0x4YGl}w0f_*CxcU,5>y]7[i@0(U8WK(iaj3qYaH,)!d 4}rjw61&	S#93vclnjPI_PH2^F!} }RsLG^Ne@(y40RGx/Zjx:"d*I, 9rn;FY7XMic463^o4+ bX8ZWT]EfbyxTc$^%Nq# [: C.ve3C+cj/BG4mzRloIdqo9S$I6a]el"aTJYux`zX+; c0,q30X#<g C}jtD,aBSjA)QZRF	?|D[]#>9<+1kkON{2U'>xsey,uYc]Ea5F)%jy	Q kUXwp}iRO	 7QX{qG=fe%v~u:=A&
sTw-H&K0n0	z{c}Ur(cku82LgpT'G'{<P+r<=z6$.z>tW+XLEDEy]KqPU%[p}ON<s]-2U*H \HK<en[]"fU| Xfw	"%^[_( I887N\-NW;tn=I.h94SYFN	Rp=qsSivkvw2fW-9LV!Giow1S `f%$< 7@>Ghx`owY-no=*?	#n=j|#)%nSA<~u:8nZH&Xg"ZdgwNsPHM]N>8=Z8#Gr7^1^rg+4K{,r^0SO8k;HH4u/Ts+&[r7#DZeg(RN@q 5lJE?bN:NiS8>,:&x|u1. 1-<m6I
L$5'WA{o#YG=Gf/ eP|Ay*JKX2DOl|#>}Y;jETp9qzdr8L"({H'.k 1M Nj/h,Y38FIFKw8>G4e,\{Xc8'\7?<Xu;X?f%N1M{G-]3"`9 qhd#}+Ghaw,qj&f	?LI3R6X2G&qJt PRhwOj@fN9&b#;e0:m<@Md(4!Fwv& 6)bSeHHZ#mc	oGV+r
FTdrw+&d(Je'~R%%%Fz~u,mR1hfd1 Z 9Rvs9v$6<~T=M$YJWuX!O|:myq7D tt#.:b=">hP :/c~/# rwmN0o
<GR"7<NP:>tnvQNG@L"KV!cL11:<r	
H^:1!fsA3C`9n27  F#! T@W&RRAr3<9@dZ Oaae:Z.;dP>~J>r2	Rr FybwG>hnMLCxAJI4krdZg302P~Y G4)xx9eK+8l9uQ;gybYFTT`+e#WHm=IngwsG0L$bH ^WqEaBj#f?` J=65F;X$9 :]@p8"	1,A?.xdA;m_WIp yTEq{g|xF*`3Qd;r?J3~$9 cp1d*# i09u|*xGn}1V@syVtT#HIV$UEov;^At\q!0zy8@vLprgu V ^wnB"c[@Ku(fGj$	>*<sV%p.#Ifv7*v+O.lr>-<dUN9F9R=x9W qrA+#`gP "&%o!1|YVr+0P1ot[c @-hcg>jLK QoP:O'5bL,+;>yUr&F>*X@7WBeZYay*9
^	?:e1<*pr@UdfI<me@F"0$s+1[TCgvl8e;y9> j%
	>y+'E$ O\#u%L+pVkG?RiC0;A|~
UJL^E/v2NQU +_%;RWY"I?J,"fOUL#b@HXc'41aF=	TFr\~/cM;%Aq1<g,O9#XF~gq`BEG
'!3LsG341C=ri;$I0DM"	OyI ^N~Tc*k3K o
g2"uHJICiF*#TeVF%*a?:Avq1
= |}3zlau6T7cf+8B)$P8Ghr[s;V&>6Z9ibmRY&<#,T*)p1~}m\)8b|A,d13P,I$^ ]I '94gXu r'$~t-v(L".9>v.lpy\Sw6w5<`c_;)6MX,GXl3`r3|hn# V{HAfd L+@VjHz})5&izvkM(Q\9$:j>:sD6r9ckK9'%~%*HZKw>R*C*KRNN2zc4M@id (3}f2<yQ?Pwn!nxM?E;q$L7m$$X0#Q@cJ;bF.>viobbT[vx#1t\z
7?%$9C`vO! cHy_u';{xy*Wv6a}5p()f~QHpwpeSw/G4%\!S?j)0';c9#&RKF
yCN O/Y/@=nd?pj$r\$eN:Rp z*H~.)`G!,{1@3i3Zx=|p8c#&8:uwjG\BI,QOdq>y6:*?v9Y0Bci_s|u;D
C bee>%eO+jh,ZX_3xWn%wzG`\"$LN>z^N[c#:a<nd.r~,s<-3h9RKQ0\xnP8TRe#s},l,lYQ17)b"VM[8!8d%p5Fx9U!2-9.r\6qv]JQ+G=0tr
),}PsSjbh^oAa2#Z}h+BKi,!TMEG+u?bph	F)q;'`O;L&H*pg5:cU->dL#NQ(z	gb_ek$8C$u'/s3x>t- \8+\!qw(  ImOj5YU^M>*=E(lwp29QH$> qSV7^teK1I[w>DeBzbn ZYg@+#IE57o`HM]qkd};Y]hO:)8[O(#"c~h5\>fg9> 5Ac=9`Ad@ =?a7qSX);#Z#$ c.&\gpgR2GS/f?T9[k1\CZCn}@Ok#j/ii_<L`# O{I"j.( W_VS?TBWh[,iI5p,M1?e>]Es!F|-*}7> KPW C./vE>9I6O ^Z2~K,SLni`<{A#!RF62=t1$kuWE|vl'w 8oKtn6A8g?yQ)*z /A#vn2 gW/dRB@~ :/1F.]g,]5pLVR|@cT3=q]<9Z\V^4++q(X{tPqvCnAi@g\1$^"H$dfa`	}qGqiw3 l~FX->s <9#D(CNs)$w.>w?#C"..&e xCEk {DBpQ$RYRkyWOl]73!U<wf59L_S<[,5w?Y9$yyWX;9\mJFQpD@X,h`u)$/+U1H djdv
T8E>JMF<d}}C8f+etzhyfvCH uYPzFs :qx<5>ZY6hpF/uK=t$X?|RP@8%}AD@}-Xmi<qd%  lG5}bLmE@h\D4};+'%+gmtN/-5FqC^vNZ6>L1VXYXg0}+:b1}4=S_Y]i-kIgv*.Wx!nlL*c1jn-C:Fr"F#,2zhV\K8,30V_Ry$qz~.'O;ZY/oi.Vwng2>?QS\x!ztHV7)sy n>F7!j/9n2p\|C@!pTN47W;vtb$.=C$1cQR	#,c5)eKogZ1@wJ<G}3#Up2d#3+HbiMhc7.>Tfb\lZla"*sdKwXdWI^N|
K?}mXUO4N*:,\JE :`\6Yc>uY5r6*&s<,#GyhwZlr!7 e^gg:pq["K(NJ8J4N!\@svciNdOj qP#& [=v76x `f%HOtYC@hl<0}9]v=>~c;ao,%ceD4g/<Ys#E jNgP9s>X(cOd^0BJq[ox@?:HmE"%qv?	H`bJ\qVEnN=;S#*ymbMdKGVJ',2=,e)e#-{B$<;5O.-Gmk!Y##j2[)L;sQWv#@%A<1*NC,hD*qx5sz X0Lm8]#'qz)2vZXw-$@}&.Z<Nj"m@T}W&	dC1fN2xhlb/c]Y:ns\n<V'a5dG+4<:X6I]? "k#5=P9m.U$	-FK[tQM,,% 6#$.eW r98;FF\_S]YcR Wd^
,mH5jZ\o48l!b9=56[F#~wWuwpM 0|D]Rxer14y"PwsE'eJ("M=te.Pp~<pFJDA~Nu
C2W24LlF0]?vQURkg9LLUuZk\=BTcs^/9c.$8a+ Qy`[<]+%0QFI!lQTu6%B4mt/ LEi A3SJ-('`|6-XJe$J]1&dbv7{uj4.G-np%nq	$:0{kUvT+0XGgh=^E-9IU  ]#RnW>@b
P@+qV,So+g9:A+,[j3i6ufUW>M`.M[HO@A~sw6HxN!cZ\6RK*y#@\<RY6}qFr3'\`(G?,[x(Q-K:T/a,Af8laa]q/V=Rh4 =3],Ktd=zs<
pjn[ x>4LzjA-c M _C` &Hom8;x$6'XtA (Q?!@:i>>j]O2h)-e61	-l1Y?K>QOW9$)uTS<}+Qd$<T9><{blU<4c\;'|d|Wr&Z:\d6@+q}$Cc)>{AZyVDf}me$6s"80 "5 d.s]wl2E
lg.V=knyX:H|=/(IZdde_=]]3Li70y'5Z	m*	[cy9xA=i[u&|MGPfi:?h%@W1ExMH[H Lq +oe"fv|OUe~2hBpU|jhy-1cx^G8{EI3dlt8Ew[88e9F6#@t5`NIHEE 7x8hIrdyPo# f}1CL}2&$9XYR)=K'>Bj2)PK*K/bpTa:dEe;aw% 2qQ`Fa.D}*R<>JkWZ%FN	c~
Cl$bgI/Tv,M<	HyOu.$h obM=F~8K_^;l#@<QEuW/${#2b$lKI4oPw$>	3bnQ-iA<ld[<&mua $1M1l#AbYn^*x0	?WkNkH/v#LtyDtgDU>| :jD&
nd
Emlr-Hz0iGdf]eO[$E  /gub% FQp?1+pN/m-5l)lwo?5N =NivVH-x8[X^NIb3Q[c%<&Bz jQy2S83h`1J	E ou$Lv=o1Ls`T<cMRKXk|]M!Ph;A=qumh*pc1:g>j.d]R,B7lrF;B6sq[4bjJXiwV1:IHUz}}j)n6xNAtae|>l:TR"-2P m`A	Z-HltMMqdD[#6y1h%g#l /fn>.5|vOw=	eBeqlcV(?< jK^DQ"	D[Omq<LL@zHi?]vl	d
	~tEMofmEQGcpClAK#`_*}Y!N$Itc.6sPd&\^_];I;Vrx7zf4Prx\8.#:tV8nWe&/:JKq\z`*qHzN>KWD?1;1L3&[~BvoIrr2	A{?~	t'+^J*Gx7d3PYg=SK(}O&m hQ;?W\%:	!#S[?wqvOiHq6@7fm-	c6\0)y1%4f.&BR3I@Se	o#@3ZVm@Rt0Ln]nSB:^H[d;mA1J!H 1V.. eN=g4;	S*FhTwB$$Tub^uvRfxH`a\+4@vs} et6m"nd obs1_zS:e>!z1v,G =A+f<hLz}X{?W"35ZWl7bk(=x#yDp8Q_(Ht 3Tg4GVX y$3ZdX@TdZKF2dj{m*	hx~_{-&d"89 }l^;;D2+3)F|=-M#rH>DM%YivU.oW?-RVV$'j68#i1./,vvqO_py4eS3Z;/3*jxWS 10:F^W]AW/kr;NtIvU%d\.hwoM2xp}:}:a	k_qsjbT1`x"zO|I(n32$)FfT"UA?ZvT_nYOil>r*;hr7Dd>I$QPB;n ,}>eRkmAgjm5eob<@;TO`~42+GQpxa3,7Y*X3Tkw%A9S4yc2KX\zG=r	z}kc?<1$~\vlo`7Zi<GY5cAzm/0AGJsfid\ 37-r[4Eeen]6ddAp{A"hQ}vMmv:c5U	,G~Cx7Rt$x[%q|ZKH	3W3r \~f0U
_?:,|fIB${~?:H?khCx2I:W\Wk&]FW=*T;TiygN/9$Ak;r|?8EBO'uTO:uHQ,=?19K@rxLg>T/&2)_*N2~^q}t#Vzu$q1Ojj	~TEg5umOG?+;[#``qU"r~rwN	$u40mbO^th|rZ+`|jt>[b[%C;X<9>:f 9Qq`NpRvNGl)7c\6f-~#0}E^&RvIeYRn<CUoJ:l8m<9Af;Icf8qb|UKIC'x3Hx;
~c]Xvn}P>gV%l51,0}Yuu'l2c2| ZOgPKQ31GEjZk[(IqKT$l^-t>~x-5K:8F4v*w93J@g}j-b1ldxrYTn4><EV+(3F>&8I)*t8u t;55`Q~r(}\7!G3iUrQ+-X>M-y$}j4 fv;[}I q2OelZFQh^DU]mak+i#wL}5t!VcXHZ{}b= =nIFRM7y
pxMUbpOQl&<d)84ctUb8{cm.=HPf',yF=M,ltJUyFG?!W@FD	gnO7zXLt?RMV8C{sR"YB?NJxG[HF6<W-4J	ay"H h!q q5=c7;l}=(s~EIHQ\3HWrW_;QbhvG-[F8>};-vGi'(=+VA<~tve(2ir`FJ})EsK"'qa}}^w <{c]T~"S<e=nI m+g.SU7v3swd,TrFqs8:Q<34vu;gS|U,%[h??W67:0 %N`iy5=+tzr~l+)=C[7sq,fHb)<ck$6X>B{SsmJ1&u' 6{.Lgs!C99?J]N/v VE@BqYvY9
%2@T]\ztzYY<~jX<y
X!#L{r1eBR=Lz/B|y >My#%s'mseZuOD-}xK+x'<gmiS%T*d`TcAoY#rR917i7Fs. ;lUk8}-$r#,:z`T=l]o{(2}w%C`,=	^EfPF99w&5Ky ]k\RY{MkDwQthS5{140.ex`Z"D3	<YwDbbCFCsdE<m+4iM4:>9Rd4p8 9R}puoo<F@8$eh >V6pT	@	owi#gMd N)enE+`C!~\V_ck7zpFG=qW\cSPR~)D'z$+ 7IvFY6r"mV' /-YSLQ@n<r `csM<uh\x)RIu}st9	I>tSEqFEa4x>HDm/Tw VM`g8TI;A JPf$_(i/{#\&2NRJM~G\'P0#>4b9svk(9|zS9rzP}?JFS?jG-m}I:sO;sqoVX F),/-HwlF[>\qJ*H_!#)_2's9 +Y/UvzA9;HkavM<Dr=8U(#s q~9njdAnKHE&
q=v4=uFcWFRI#<T["^!6/VRPo8d~,8< &]js:-5,qL
\uVG/S  5:m`bDA[Y!%\L~	K9j`:-w&	e)
=<f(XyG=iE uJv9cAEBtl<8ULu=0 o`)c}kKxj2o@NOQ\XJK,%}?io/^A)E;]'OrxN3nmYF:y
(]w}U66avf,nvueOxX$Mh?K&GHZW
A =Mh" B<|Zx!3yH%O\,maA J6[wh@/?J:F
P>~rExd)}zRZF@yIO\t~<%aor?ybppry?aVs^Fwodtx;RT,,?Tj:	DX(4=@wu%6:y+]"T mK8 F8S\,H<N`F"XZ%[ #zz=]^GAwPeQGly<su:'yP,%,2Y'OFe$N:^=Vt1^>1PGoRx:xG mbF>i~$Vn2E:Gld8`so=4s]oR%2YHYGmJsh6<!z=c|f IR;J{J%q#8G6my\w;u=isCYx9<IXT_[
K TmqGX5xDw$Gid~ybF :Kh%fzzx[Pg<R;[^E7AMGk4rvh['HVXt''wNfF,<*&NIc,	>oyJ%X ?:%eG}2/(FO:;<7|czjSoc@Kn
q*aAQ6i>Pua!Ep5zi!"T1U6}A>Gtq^?rutySe'k%i.(&p06b}R1W,r>}~BS:wHU95I'LZYZn&Y~Vh"Dc ,FI?NjFT2DGfxXHo?*[;L)<(36T~lH3HGKq"9kr"b#s'~85d%c6ldnUlF%#tq0I<e&x9,}DsWs,\E'v79t;IP@#~*_G:`0swp>HpmyK4Np:jq[)-'Wx$<<<a)vRl'LV:W
)vs8e%r]AT|_ziWhrs!VQ{`xJn\)p`ClZB=N+.3,  =*1n}feH(y+\tT! X`~7,$#rq`+(bJWjsO{RhONN$1hix[d"Ict_6F=+<jlNFO/ 
``@_UlaK'LL=>K1u$57]Oe"W['?oyW')y?jcv#>Nu$	; 1OUNq.7Zb>Us*9!12Cf(cmaul%2	X+/?wy1QxgQmkab9G#$KuY3^"/p\~_3[+9c~^NAl|]RNh%XV{ghKJnlu#Kw.TR<q*# 6#Z$`	bxQtN]'}3Unc#:	`sZydRA]^K:0g`2!*,q%Ao!@ sXjy2H<WzR3@B< zZ1`vUS7^(]x;i-PcDp^Ilw(=N;Kek7-#`kmnFM=H>?c3 !GlN{_d KsHjD1CR[v0TGjUN\ 9kiSlXqKW\@"0IP fSxtGiUPw.8< FdvD@=?94M6MF7h#
9 `KxQUIPp8kfB$1>nl<0zS:D]GE=6BLQ@8?UG.#y8pSy8u9X'? ytN;<FDs8I*$D22 m*XddE2|(|L+RF>B~[F
xL2 yCSB0s^<K+:x)&T7 9Y e @#e!OeDxr/eofR@5l: }iDFSU):=j=.#[Ml ,y^8?*6}%dYTI"%QT9|u"C -;H]:,E!
xJtpQ^0ik$3('^_*|e$A>qE%is @NIXS8 ^WPpy n&Yzu'_6-ONz5_mO;>x
*bzENzps}T-1b2H>;dG%4WZ0:^d^(Pcz.wKsu*[P5I?vr QK2g|z]PnGTh#MJ8HJzrq^Cowxc";<]V8#p?T$:m9;5zGN+]{Gb# j;nin# 6iIe2W998dv{6E6`G9EgXvcH95S4Zn* dre9#=je$uiB$^r63P&Vvf!=	*? F1iu1p4d{3r$FNH|^ eH4 4o
r|d	B_n>8a#.=S3MIJBNgdq|<q,  zw1w.\$vSyVAA`NB#AH`#:8*[<eEqnqPNG[jM6%dmFXG;xf;hDhfJYuCK4]Mamh!
Y|'9P|^]J%%|?*). 9G4e46	RY9ki2[64USM!o HvbqBK~@yyVm0YHF*ZUl}=O7M1_<FmVZEKh),6OL&6.koR;Q/98tWRq[	 :\(hJm]GvHWzu 0"-:{XcF'
gMAE=NHD8XZDKXU~3hG%"f,q,W?LR)EbO5S@ZxAXOVrBT1{hdF{%?}wRg<"CK^Fvp!`U${k+cmD6<@>u34c5u#8|V_M3DJtt$U4 {0 rh$~xVA-8%8HEU&qIX1#vff<%]53 n * 8`_wgbrb"Qc/:wMdc('''w#n,yXE~4y@RG Y	s7]]OYNq=3q1VIW$dr<|n`ThZD>zvdmga.^RW6o[k	p'ZGps?<*pv zy^QIgLnDC'y~G	#j8ltBYq!]JHTl woL|!)rV?L.G]={#3pO z*M&%.s	>_y?tW Hi#(2#s^TosBv3}ci',besmEo#j.GNwj#":dR"?f[eck(^m^V,Fq yG%hr]p?LcycSnmd'<h-P3AZJQ]TzysGgce#g_)@I (/		GO:eqi1CVkg 4&K.c'?U-d Ns9R{x&	,Ha9WY//8^[|L0x8O]5OI{)IK~>nFp<G5<r-[i#%AbMs>Ri
u_m8u5F0#9#:$|5y{:V"bu[ l3' smRu'<AMmw4*3.!A}G>2T'i<E}N6Q=jH!uj28ZFNi9 +3[oN_3\FY"'ea.r=szhJh Bh sd`q. [9f(c7)ZA~I!%:BOFmNFlw\[Et<HAG+xu'."a/$#-lW!d285rl94<Cy5d~os+Ia<V{P53J8b qRp'-;OKu],y.^}SrA8'@P03*=HDSIm=Eu)?[Xh`ZfWo7qn\tJaMrpB9H9:vD|K3xo9\!Bq"LNxN3k*sPPViav4l8muOQ
$<s1Bt}6PvHN u? 7#-(i :qiiYxW<t^},4UESV,6%q([&X.~O%;q,r|T=dpGE
ZXZI4$w<BH_]f6.@P7L6r#Ux>@C#=z&kV.HT@s#rqE2VjO ?pqi-$Yke[4Xq|WwHm&+V1	smvu#Cn f[XW$'*6,]W`d``{._BNn /aoz.iyQq+{MrK376cI.V(YNNOFI<"s#!?y-8ju4{A^\liU_*\h6j7p	!?:>OAm\68uXtQ-$?sqwy"6> *P 0~=Q8,5J>yH(SEPK=gKg-J?{HbrS7/.m=x
)KRNjXg)uSXfs3rUm]q}>TL+Kh$G8>x,{
<R*MeAd@Gkkxc#`{rrft-x7#,NsD#,\u&t]I.
2_F3mCTa-T)NH?U[-'0Iq+/	<56h?:_:UmqX	Utb+r {qoSimC~Y< zs&c0B18U6PsH#]2065^L:UKE:wSr,Y) ULaB~\PA39<yBO8^T;CqR4ycg:u=NylVtD+,N.?yUw:tRh>9 DGQccuY]So[]+S0 UK,~tWNis (%G[2r7 `zDwvv8m#'+Fm9C\p*'*vZ6xAm$1/9IfO8WL{ I J
)/M#&ylOPl9qXy5`d"PvX8 *onlm#>kNI5P  *8'<|N$}]O# Gv3vO=?Z;`DIsWLDs(	& q *qg/Mq& qpI5Ji_@<8,yZ}> Ba?2S>TknXwGm{/ejuK,Xshi!.eKg	4Tl>$7\m	=2e#c`ycQIef&(+)H]\/"U]FV+;>cZ;nX.[aa Z9u9aF8rq}iuV_0e6&,nQ0!;<;=3iZu&+u'mu1X{e^Ph CpZ[{('#M-lSv#ue]Bq"9C34%i.yb|I+>Nnx["[n*	u\bD#;>K>]84NiI ]XaQG?zA/i0Ibhh9R+rr%8dl:  ircwaBrR#?[Icv}?i1qJ.h(,$BY<FIfX;EJj\ 9:$[O;\Y$qL\Tr$elf[x2h`\U78iAMuvO\bkF;n"8h}b<2Hq;Cdy~#GNroYN>2ac"RePuuikM<vD$eb5p8&mthq6Ngj[K);_W1oK!/#@a,wq:bB;XhaCc#v	V7go;"	6(;g	(GI	J=XUkvR=OZ]fU'I t294w23^/dm#Lsrk4r=jo!#-*2'6>pA=DWq}K9u#Rvg[_F#ZH3~!4.*Mlb\#Fzh6z.rfIYe0pN	5H8|o/YC:6rH99pXI2j6 %~CD}~TUftb2w*w.X.}[T$|Qi'	$ya'|XM!q&O]'Ja'_QUT-<yWm"}y/Q;@SI)WL,PEZL6P| Y[#[7iJZVBA?A=1;o{[hvS+s2pZR-nXqyl!33AC3Z<.CM)ee;9T-<PhnWnJNMf,*F):Xjofg&D`yC~$Z1	c	Rv(}zlM15ssiW	5N+9	Jk_Yi[`x%#' xO>OMlJO URqKW<.SsI4Le]DIdVn-[;=q0Y#/g#@2nmbyc+t`u$	rKHW@#wl>@I{">f=x^d|:}T	 8Ytu$9#v|Fmmk8B$IefgQ\iq!>{VN=ZU-*)BNRq{-A	}B: >P# ?);q|LA,F8rr[i",tzw3T*U	yhqZ0*>6xYABFV1 2gnq9Ng/o6%#oL2o?hfg}I<r|rI}F
PkI9!my~\Xb;.kF.m~x.Zf$y~~uTnTSZ\Xp~\9ad=BTC:#c}n0zvl4 vOn.$S"0  c^]:kaj.hUIB.QeV\1vpqebdE'ch-=Aq(A.O)2+pr|>znDYw'SUsYHDj%aQnVRbM'P6?Ge YEgRQ ?#W&A[js?+4cw4h1IqqLl"MbBERCm^Y6FddOF|Q1<$wQsg,Xh.[CU\wG6wZ&
O_&i=	5;wAe>|+cQ0|.]bfcpGzI/Wi=F2}7glaGcdIRsyM`:&7#}LvPnm>p?[ix:Y4q/&3`]FJ]B0$w"Jd47&sHv;}+2F.aR=:x 1\|8%%CG_Uj1"E&F?hMD `ca1&1
JD?\izTNT#p{
v7c>%y Z7_S\zsymEf,d0G>])[.5~1dIW'#Gb\^Ym43F1gjFwh[v?DUbe2q wfGL*#n[P|hs9]>I7vr;JcC]|\jHQ[R<rUMj;$m&{g41L q8+>`s|^'ej}= 1.. e?>k5
F=#R!
2D.JxA^ySBrAF<{GIqyj.@~r1T>s
j6	1n3R]Yr.X1^S~EGu[1G{9<)m5ZYOI0w09'QI7 -rXU.fM'&="!b}0_{0_FQ$s]W")?J61Xv1_JM7aCdPI>'t(Y"^`DclktOwD
VAW6G,2_j~"p$P8kUs/yxe>W y+"<ud6Zpn{uvBflX$Z/mCu@Sc(R >+}D7=<}jp^Fi^Qz|ZozuzAGBO$pF2Ouh<6#nzuiAa\z-6y2XvCZLs$CKmr51'>x;vV$(mF:gUwqp|})9WPc= `uC]~' dnSUx++mn!8 IS5EKx pv@)eug<b5Zq[I)#:t+ m U=t!Pj]6nr>SXAIofs Z[slv y<:(<M :}=4NRdwR&8ok7zS,0i%Sn/w(Ir`Y3"29?H5Mww:<qGV9bmo&{'R5*GLzkTV|khdYiN}NsIv`-Ddu+N,WY`b#*\R"otjJ`C|*(p1rObi%odu	?oze"-XlP9#(M5.5c|:]w?^!V8U?/_ZYsuh.Kk|BD.?\pjVZ8*@J\I8h;4fn1$`qCuIBNMiK0d"Z91Q3k=\ 4g)1qnD.0I$<{VZK+xP9U
 &j=xmn2 N:'qkPwQ<I9@Ty-W#+XI98/z(R&tRN01ZSC" eO*C,DobORYt7ea8-^2vL1Uq12,Nc,Dg 1%y=7mB"`$1u;~[;Y;zV<5wGn:T4SZet5Hw\<TCvvW70eT#]Rb"Y |.	7@H"U\g- 5'
\KbF8O:Kk2wp>tu rQMDQKh|r%Xy%F@9gEF(dFCgX{;l`j$9<S0'K%eMTs1Ml5>2]iI]NyzpuDy6u#d1[#`mA2O{_lP=-1_**7ig;VKg^t~UbinLAt@Qkf]C1N88ehS$q4-mv zu LA]y{[U?!L1.rGDL>QN|93^7BIqG>g]&,IC&k,$;g46I}}l7pzsY,4=8+}2KoO"1.Gx?*kkh+l@`<qJnEEcnUvctA0;avgWEpn<z5qqb_3\KC6<=I%2Wz=)$'p3"K#(#%x3"P1G^*$8P 9^(ds RV?Iy:t\obHk:'4+8"%! Rq*G`@]SFQSnLr40>aPbJ09e#\}|)$$_q]&\qFLc@i|MA$Cnec4b73~]N9`yT;m>^J	"-%UR6	@GoGcw9R$0ccZH$1Kz$h!q]$R|G:REE : PY"Rr	nqXQH1pX|@(#*w471Ff/T*Gc7\$A%F_:++gx+ [FV%>yKA~Q"6vp$!nP=0@'v kWqnmH{7428A|Pd~Wc~cf%6w'ZP^dk4VWL ywqcA`%V`	k.~f[F'GpT<uLU2I;m#!^6{qEmsB$'67NyEhQB5cv4d y>\ :Uf'$q~dfqH?@5L8P98 pkEEjdXqf}p Cwg}L(U)+zy`7 sq+`	9,!1nZr{Q&pnE$ddn>|@X<$c:%'Lc,F1>vP 1;s)r622Vb^>
dp<U);@sxoZS?p>YO1f.Kn:sls\\,((PFGye-PEq#ZEcq$P;dF>'13w83*Ug"OD :*0x
=1:[rJxvY<1Y,&`\?GV p>gbIKW-Bs_=jnp:PrkWFc66GSEiv  yPj@d2-{L'`<dlF ZYc2G5\H-/JyM,k^^I< 9uyg085MhTL@+0?8  J/'-P(	*_\*?+Sl$}r>DUipv"PicH4xgzW[FU2x"";rGu;6|N'Ghixd]}Byd<I|l{ 
 0VH_YHT7N@?7I|"v,s7qGoh"^s6<]|VEn
s>XKU Y#wGX"&r `P9X:Ay.Idgs4nP"rt!5(wjyw	yd
0y^Gjg$@G|GV?\y
aX^ytT<>"'>~b|`u7yx$wW_0|6v2<nzOXs W#
;U*  {cc~tm `0:fg(J!b <5YF{71Q%>:pxc4jFj\u4Bn*p5?vB;cg8 8 ?U {c3}[0 ~}lz?zH >J?\#.ZA#/BG*</B.`G=|OIf5amov>dG?s~&YZzG I#z:y8
.
9Js]K!8~#]Z,bU,2x0QLEb	\(PzAwRBBwq
C)Xx >j4VbY@\Z:Fc Opy>U1I<I3273~Z^gj#T#?h:X}3d$O:Q0x,A^pO?yTf%WU2 GMZRnGf2y9[n|YP	gZL'=g# ?j).TTYdz[/3K;If~%s||-	bNpyqY
Gac}x.$NL;oI\B
Kl. 2o:<DR(ps{iZ'd SJ9e$c8|(kxIJsrJ~W\op>tn<WI&YBlDiWa~tY!7O(tAX0;y*	VCh7c 7BG#G-3./E$L$b~R=mj?4A;w9+\bn8=OrB K>H!AT`9O$`iu<7CTd.8 c3I7nJ-@^ T|I"V" 6:~k7-N	CoN}r$uxe;3G gXm^+r @RsUcG . 4D=W
2:L7~%xeSq!'%wpqZWiw,G3	$"gSgIQg\4j1vCl,"#c	wK:#JR19|Di"3HY]FG-5*+HyQrS({nf,
xr8Uy{j$"02<=ygv$c),Nr|JR~N^t3[@_wk[-2;iVo?#RU.ybxO*a|B_ZDczS$ivZM{_`*c1{c9QEmG6T4%O:I*q_J9MKO\\3$BeSin`+}N5+M3|#9~/s,0Cxzq9-yK4xp~=r^KktC0Ci#<jW nU|QI~o+K+uriqI`H72gj@!5\c"lE6g?ZmdhV]XmX$|Y2/Q9%`OzW\8iq *# )rj}X!_6}VfYQ$jwv_y_^<UAn65js4wy
zMg
=nmx(`F =)|WM;[F	oQ|au:$`~ >({1~$en.$gE ^}~rFCM/t=.!	\_,YO'>>
%aoA *eF^FsKICT U30wG9}3R.uAU*E 
-kQhFc**xsJ,v#<6LnpFWOVU5dwi23H9QG< t!!D~_*-.lI HdY|;N9NZS^dl<oyc+vN7bqvz|+<Cr)gr" AHe1xux/^6cY ==fZ}ea I	 /%%s4G!6U]n=X|![ KH Tb `{[v^]lmdrH<,1=E90\cDV\;LanF:^3ehe]:z#ord.30gL$Q4@G-,sA[5`BLy hpH9O))=cFPybGp.;xy {:}uou zzpkwp+'|>Y,	j[RK)=18)Eih5nDrF9:6YL)r@q]$Q
|5PUNqXJINMh(O`8jP@G>E89Y^M~`d=<:TSs(DB.cxTapL|M$8$;5AfL)6$ydYv%$xg%G{m|cH;JJFUjj["N(Jdg?JkSo[ PqYY?.b1(]OQ-`)Y1'}Nj`T$A#,LG0xQn4Xz
(i6pR|Z`
uK]-].?:gr_w]hYc
zDGP``p{.9 ~,8b!`lMKW{\38 naFsR"OPNmL#88/?/Ggfva@d \Vz$yPN9$UY^-NEJkxCq-|4(4*{{I4Ly?nOk$d9u,LyHHzh.jv,2<#-5%\D7k9Cu-{MHUuwr-ve]3O	T}stpUgH3l^ziUKI2
 @<{RB]
pJZQ[[#@r+< 98Rx97G/k>L(_<zM2(	Y6 &Ckof%!i]evp0<REInC<Be,u9BfnM6\z 	*.MeP:6< J<L9`r{jWw;- '  JSJs882>c>t 9+gfh,.I:CyU^&e&\|S[?BGJy?YT+IAP2\HvD!Hl=Y3Z K+M W> 4,}>Vu1d;kM4:o$vNHT}3jO3Zr$/_aVIai-WBbvTnO<scUx7XrPectNqn)fw uFJNb}^v9f8UAikb6` 1={Wd@_/n)Y\MtT+)xy2Z.-#$r d~CIm3"J<&NNzUv
eyo8AYc8&x;9a*]eB[~\dUs}F"TmGs.3LM`Up$ <zcC|<#NumWTD9#/*L	3w\}Kx=BuU"AX<1-b2G#q83qQM!!4[p00	b( 1L+n[STH8WR`HBm`sf8AN#\I|/%lg$U-4rt`=0]7QF^ND'odHc~6u/R,~)[qL D9
o=981_% ?@ZGH3j`INiNb2/ {gJ3iwp~ Z!\miK9&&yPe*/f9.( }d~[*E
*,?~^m-XTU~7Sv{
g#y`j{-Zh(sx#;v}*KX]k't:Am1}d4bD]92$q.H    h>YK# Nfx	klY8ZR6zj.}xs#p b3|{KosPtx`^s |I{Ge y^TkmJ31lzcL0ORehdiR";ZVVS>5 p/&/#e>U\Z'U2+2$s"
-;exK4k!)ZX-&XT&fvOou	cAFRN0zUrj)VV+l`,y8=Q$A&\ aUIr*Vn`u}RDijp}2	tMDBKNU.&]=9$P =M$DkwwZF&#F<<{Qife&c89>jp,1sfc%|0TAq^wV',A?heorLUR2`=~13.zy
Qml?$#G=:NfPKIduS{T}rdJ^MKpG"!8cQ$tUG
5	r^9L\JwW|~h@}NL&6rb!E(-Nj|8Y
FJFJ^3O"&	^*]
<&d[n>(G,E60/`9R-iciKuw&XqprT%O1sLW5/[mP&^N?T9(!OZw{u"\|0OaI2[Mc2o+B-4+80wzJK>dYI[s`U~8g/:C~d1im]e>!F~f+nJ[MBR]jM$W]^:]F0r|]k:h58e!$Mrb|5f9oOX;QFVm-kVc +0$quk,F&$GC[{tw 8{ACovf.$wHH|N<RxLedeB fn%8Qizomv9jSX$)[9+z{Rm2 'zrnVRL_=YTPvZi`(a.;-gcPEuV{
m $<:;-*gya}og*B`X C5jWUtVs!Tr|[8gve^NB0@MK]gRIvq=|xb(Jz#)Y`%h!WCjFNPGi8wG#2Te17UrnuPt{{h(JrAv6g)~\oLf=xzk1j8{$"V@F8>|dq\.6vsR)fA/-H" K9'Rd=#8>~(x`*.m#Gcb-M4k-.4Tg1E*Py"IR>-(;|:hu+vBIe2=}D}_ cL$}Fi9'8'&:#o
z4[`vCWzs*v_l^RK*p"|xex*9L7]A d][2]+]aye%m^ed%2Kn6x*}F8c2FUU>#bPJ]6nH'h#bN0122`+Ah5.=zU4qHfGgiOcnXN{@dWPL#*'5NYWywE:Ivt`yqwC}#UeyoF$ln5$v/TX%Y$1O,xoi7~!r}-KtnpR]=9Qlg\^r-8IoFHSM  x~gZYrina~\y'f)fT',s#I=J~Py@ ' }oyf'?j<j1&rH?_Jor0%C@#> @E9s+d]RI- rzi
jc#b79/[mBSo#2Y$y'=zg5K&BTKv[7~D?J<21Me20>k;6X]SPD[WCwJeuPX+&YGqbvb< }}FtcjF7y^i+Zn/X{fn9Ce>?v;Jpr]<H #llAI<ri_$r[iv}~P*=Gpha^$zmrcSvt[6$}VVMFU-%$pLs0&;FS8::Z-)Xh22EnwKco.pU,#>XDW+w!XngqOZnk+f5j9u8G,f &0I/<1^6]r	kx*|jKd-\pl[$'WF3_+@@R4;QsHj r73O {bXTliTe[#'2Y%I]<O^(uvXB@,i2UptSL,?He0v;xv:q+4=h3Yt"DY)&C}?kwnK,GS8m5+{Bmhw8l9Yvc5ft+IH^@P*HmRyBSd3aeLy9l:=:4$c,^;z#H42^3 VOrVYHV6c9%<N
$o+*w,?T]XvjD\3gI+cY5wlg{}R&q-y>Cx&`Ow4m%
[3y Uvew|~TY[$1*Tw<F`|dgoCq&OLsUzm
0Ws<7j^:$c<pIc8!pI1STS.EFe=9oir*3'x 8:(TU-csG+1wqgdH5%B
>_q~ZeUkybm!0|nH`C{ydP
na_AsI$&megs:TO]3;`lwm_E{K11 ?zUFkyLZ&B;`IR_:L?E{ s
hJ, ?jY|(e,+7$QtFs%Wsa5;ek]egG\rG84HjDf]$s8*ejH>T}6Bn[dw9THR)n=}mG
IcQQryG=VX(>m~l8 #+*zU+w q %WMuTB"l9>E\BPN^;Klgk4>Mx-HX$n_<}<UK]M~z7e5oLe
T6V)"{IJM^H*00?ZkMO\Idw0,N@#8B-F RO	}i58_[{,rA$W
9]6c#;p?*GTAu7
/%*qpH>~	Qhb[:)1JzdA- jYU'k\6Zar7+?,VQ&x@ <dtZ}i)Mm0
CI]b *.)/3'(rH9Sm Uv&n5Ig"VC'AS4:QS|r$v[
1Uk"6:>EBJ<`|kj$wVk%p LR/AyYd[9m*33sceu^YpH5%{KFKZr;`w`9~Dij>zd9ajNMGnJyHX{;ceg4\Y4}*5#TwUJ 9aSmn0l`>90/vmgppoA.4}Wc?:r4N3"2n?C JMc}+K 	B eo- dIOmU`	y$C,irI!8-nQ8|N9y`T FI,LC 88tFFVaMkEO\>uu<g~"EYBGx~x*O Y;7s1FY%m5']NV(waT{n B?+?mr
nb$yG1_ZO{P&rFq+h-%6vAVKBG7vl;(L8?b$<@bF*&JwD)d?Z_pdv,cuH+q{5&l6H%[Q:giaK2?jD t0?J2=<];;)KbtAuP0CzQm}F *0>Wg:__;v3 }[fB	a R>4E$s%If
FcR{ 3L8}>,)s'$HGkQry;cdbK&@Fr %TFqQkF-K|#r<D/__}:R:u\Is04n9F3x=8=Oi{/u3aI}yV},=`B],N?I&{JRI-9$y}kZR oE9!__2}hH{l>H$g-s6w7=:Z}7U`XGt
}O<*OINu$@((fHAaFJf[{NE$uY,L>.zVhy[>Os-M!lBwysiT!/9G`` 	MZJ4`n=9lg ` SDF.$`1\<)Vi9t}},:'>pI"E#;,~C:Eysq5y9}hKK"8.; }I%p\#.w$n1]^M7eo4Y<1wi	]<hH@I[nX<3ro4kuQO"%\)mcBmyp>@Y $pAnXXtHuI(<VGNd<\X`G]4L_hr@$W8	ybcC]o';F9?@ i5b%N2&*8!sDGKe.-xm *H~`R)n6&~B97Ml[DSo-l<)pA\*4Ui5&MO+Uj[&!3mQ>tm\ydJ?vdvI31F|'YlEM#I  ['/8u7Z4vfRU^5f9\j]iwB%^Kq)o]iVk,a@X\m-v2HC uf~u:# fZAh+XhX:?\BSz;y\\;+H2z XD)c M|''On;J1\H~|phKXF dT&v;+dpINi$
o!&G'Vm?.}+2 <q A+DnEd$fZA,$0>x'L#y	v4+eN <gnliT{i`d c$ ?5I@AK*6$*|&Uz?cPwWPydg|q0f8%r1;^V/km$d`*D#wL P8 pOsrh~C)VOV91lUId].??LPj9i)W{9em('g988I?5l89^&-+~~]h
6(#;#5D0[~y5;A
8]H
x)s>m6ciq#R6 zj9:BQdf2zO_EJ R[?[bORI^?;{sOPy[<t^:tk'%e39+.D8VwO%pkw mWym >uijsbmi`x`|"rsy2	w?=F:WhYY@vR!3\\/JNA8I#PKx_V/^sMX._FmE#7J,	m3@.7(}~|R CI)XTb' qV
bi J#Rr
8~@=Y;)a4
/^~	cH=+HBy5j5Tbf`IzFy]R{XsRyq@w%=@$TL3O8$>l:~<d	Wi`7>k0,2hFCHF0I86n=9x$yL`dT e%Ft#5!z)[`t7Hse7 |E}"o9kEo\n\tHc2x`'n@U<bv}<t!H*z`'{ rrqW$p `ANyQnq#q'a( e?r<\r21Uk(U,8*T9sdc=dD`uU<tlt90C:/ZA_W:iYxyS!A?vZbxa	'rG& hu[<v%SyQb-qE:
gK%K2T?Sh`l6YA}R-6ONz rok l,?t'u<XrH2A.UW2;= 
 Sb0ts1!JXd0Hp:e|{ BsLRB(mXN%9*deh $;JvyW@yI[dOInR.\xZ+  {V_]D#\d.)h\G_$P
gQ 2c6z H/*Led,\	kWPPi ]mr|t47NEzFGVR3$>d77@<!iyz#9UNE\n#gqq\/y0Si,cyPa@7[#Iald89^|LLKe_IN0Z$-/;PyzT K~Zj{)r[`qHVVK;IRH1|7n!ygd(Lt&}
/1
<$p01h<t8Lks(G3~tdZ<hlfK;(]Ie4_LQMAX,De,6yX U	Vl.xku0kVl0`x:u./a J8)98#rs|UsM4[qRUbf8ge%2  e'~`f0?O[%,Cd{c uy
TX	|c,bg\[ (xqXXG0:D%0a.O_QH6/J`9XP[&I4q !<	Ha( 9_ vK?A#y:2cH)Pq$zQm!$9$'|1u/z{	apRJp1y=q`/e
h :q>ULw6L$MH'w 0@e>*0 c+m[jZE!#@^y]^4Z6,(TM[2+7v1~TVmVX:n[9=rp{cjJ]b{?3]dYs~(	L+3N$!C0ILg9/'r=Nd19dBC J_hH<\sS{A+.!W:J5x,hH&'`$ .G\{CN<hmD-;#`rt5iKfIo3w>y5(%mvG2==fEh`n$oZ0<#bIlQwTp#oIS	7L6<<h@R0q_Oe.t1:s*M3
"+.^B',|qFzmjFFFI(n^}QpOi<ZsQN#0s<z"nvnHEI9	`XR;(V;DGI*LUgzcrcTNHcLe}9M#J[ &\ F+>.Y(v,pzQJ	M6vp$0}x+Z<K
g*7Vwyq.w8^w?j!i! DPpN:dR|[+Gg!ww sx;y$&W;	 s?XuR|iyu+9$yN@ ^1fWQMz'gT'}fHq6gw=+apsm$4[&O2r6pGd7s:bk{YW2	ca4tHI&+k#[i qilYtoqK[J!en<}0:Ws6"C$p_ ;_8p}kgr&t/ ~bZ.L9V>X9N)NrMXvdh+rvN<>)zjoY-}FzoEsr$Xfm4{(E.wm;}&lir$~eeL#Hp?svs*w+=_ffm"Y3`V;r+? ^J'5krKtu4Ms{+38<{Z&L*R2j93jW~`nq9j:PT<,YG<p+Xg.'=fYY 9&KP=XFzSjf:9:\+)t]]?QBw\W+2~O 4*yD%1:{p^V, |8=W?ss+:v*l=4nVyjJIm`; $9bf(fzJiaTLY'HD((*0$s S~1\mSUL}<>
)]f!m9ZFl>+ G9+fP9%Gtiy%upZpK)&|.s `qN*A`T	6]?JQw996V'8'r^+j5iJ-+g\.,DN3$Hg?*Nd&3Mz2$*~MtCF@s3TuE["/$.Us|9sMIkl=v9^n#N~1[\5132OUo,S-0=GorHf(d;@@<qmB[pf(V\J-cil<yiN1/.G;G=<:.H;bd-cSg<cLgLn 2#I?zzRqd<wH#+\ibBsC>iG(t=,6mmJ	#'$z],@r}I"3@cmwroe 
H=<'TxCu2ye\\y\{^>$l1|R(Bbp6`kUEomBAkF$HIuwn\O{YMe^xB3y: q}|;C|=OnON3Q>-I$'&\a}ijpvykr?'73\!;ouL.1iy[ ~twgj$'eHG"[$+l{5oIegt_h\&,2OLz={Nmmv4#vB}qj #;q,"==z&},o:(F=~mENI@sY#Vn&wPK9\:j%RU@11M4#=!^)1zm;-sjXi/
6;J
|*PB$!NL~}<phg-6irX6YeP/zT2aEVo?]B4'')6v^;yaw xnomzu(~]ii	ngxHPG3Z&!Ld@2qjQ{>o
3%1{wM<Nv8t<R	_\gL.x5IWc }+MR3~tqDu*\9s]%#ci3t(Dgeq@osj:qBy=a!;^i#U}A`coFs}*TLc$S=)4UJrrtD0x$adxvy3_4lytZ3:gq[M/wrW]&;[ ^[@Gs|K;$r~wJ!v),d^M>< iA^~[>6}w=<:\u4"&~2[qZ n|e(*c<g:y K#0vC3t  ]Eo,
B5Qso!", cN	*mwd.nPKn+<y<Q^%-^ :!U%H># ${d j2b=wch;v,nf`~i-\q"8>(NX&FI@h[HKf>gm#,0t rFy#{?k6:WLDH!<|$dv'9oAtZ#pyVUe4d8Kua'1Yh!$OI YF+6B1\6 yTTI$aBK*~n]P('P	Y HvH+{aNpV=}+']s/8n
\j23{;q=|WFe26S	`B/^jx9g'vs$<O{a	V9 :%u968Y5{/U/j-'1 3u/C!URV#N;^\!0@w9ynBGZ+>7Ny<sSF>Nm d}ksylT?jyM#nf/$)NJiUy!&7(!-xPiOioQG'Y\a.h[.8#+3/_.b^ {+Fe8%p%fqsn$,1?yS0`zq7fp;98,]Ig8tcW"6_b/n `c5>z,C+GezaTMF+3cWpM$pdO-VS6U;Eo.d{Si	VRN:vmbo iHE]V}1oY."DrR}/PO#PLXm3Kh+%['5Gv5K~v*uf8qO;;@5IU3dd/j.mB OAzvr/a}Ni|TFG=rvDfd/%YjGfr[C"A9$taktA-?v~&&O5jw3G7b,A>y<.),D`Fu$'A,tW9-7>2hUUm&Jnc\{F3qr 8>^",r#wu)?*RK*hX37_Fl5~f.#kUgSsB$a t3\>K\^'v3P8u9CQE\D e X07=Ji4w_m9 Mz{bE 8!NKZk:00[H?z o pC~r1+AbmSl :l3 A80?~+qVxN7vJI[XX<$bA$jr 'dQ,}ayf|E=jTz)j=+GxcE-%_3kUWJA$SySF(+(LPlcXZkqAVfMQu1)p+}+^svvvm(jKvviONI'{8p(C"'i"Ly5C(\ \}fN\X(tZ~N*vZtR_oA8\`
Y%NH$e?.kEktmMJ,Dl8 |%dd{J&!!HtI'~HNjb5UEwA1]}inT&O[EvE9Lg?|Ik%2Ouo"nb08Dpw1isTm&T~ks F)H8eNd%4{ijsBwG}l I<>Qz.}n!brp	9J
-(Jwh;Of/s}\ZLy!|J_e@>56 N!=d<<+2$0.HMOT6i4]B,Rr:{{o=Z~]RG a8nH;A78#M3${V5{Hv,GHfLBp06 >[0&?>D(]P>(X5`}v39`Pv:Nn08*5+\g-9> q
r23z*=2UC	[@$/vF1z^O{n0q|j.g9DC=:*R2F]2-0dvEW	U+Fz7 - 1XBA`<L
|sW^8|^$|{];L7L78>a	JS;<HQ6Gv|,Scgn;N	8ZeWd"XczO1Z8N?3k5O.&ylsJ5t'dx- VJRR3WV8W&'G*=f^+r]$r;,cP:d[I{>< O^?WUY7=|^r2K5E"se_RMF/Z8tEKx8nZ1`+^}vD%yu@j:TWfBm
ABx'Ox&Vq;!@d98( y-V |pcY=?*iAcI8-Z'i$f3nLssTr4|c g\St?Gee`|,.df448*qv/Y7|pqLq3Ksa3>8U+s;Hw>GP>tv?&gnw2w} /Ej%F	M:wW |iud_Lb>X<	xI9zw&i<2d I;v{E|%\R2_d#8w\YDH*snqKy@QX/OM4v~-q,\?Pex'mangK~uK|[Db6(-%XmB01SsvL0]Z<J.j{unPu!}r[?ci.[wB9GS IJkr#*,gU%G?c8P	}kD;+H$ c gLW1v&&WT@rSzX&2 D,M\>*D ?8nh,r71$s9TR 2'o+|D{\+f ,!dhe9?4)Atz6j,tMQ~( B#/!Bs_Ub#}oNX;b4.GO *g@R=}DrW!}k]6{,N2l1&g} 7LsPs<<`Oj:bxqc\dQlNUsS(=N,fKWTYEi+Y*gME~*Je/AS=e][E\A\e-UT	6%3Hu ,xlKs#&A<gPcm;^.K{W}".Zl,3:U'Z1%:'%-leVHyyc7Q95No}z!' GD/aP(]Hy?*^28LNs+G%#\)	E\C:c>Au1o\"< To2zg)Kdcdbfc*ei95b ANXaj"n[O<e{{Co;I=>a^h;GBo&8[P#*W+(P6,~T&Dh,J#u4]BkfHdiVzc&I
$cU8Kq6a
C{dmgRHt[6gys@xYsA$Ly~uz<Mi@\l+`^Iw)`##]]#F`	#-IzE;c& mY|${E4B<'ZvSnG+Z}n } VR>?[a(I#n+UYh)ky-Pw"+pYr6m3437@LPI+51pI:6P~}ExJ([p;v`!0<[iH>hP{S#qkWN:<>@.e+y;#<WjpGmr,~XALwF|~SULy@FjI guD 1cO#D46~Mgu.+==(;+Y,d;;UGAj\\I4'0t<u[qqUYPuqj0u&|>v'Cwf6-pH8}sh.,gUwy{i73bdpq Zff{nVH$H qM(j	F~xLy`^Zc{[h)"PT 9uki?rcTk8	Ui5lbg$Q]*Y<%W',rM|8fz1uML&Gpk6:={58d	glArz\QwjV5VI@Xs:hZ]Wit]Eirt$eaaz!X9UJbF{~#V	| u?F>r8H(NS2I 1)<>f5tf^}GUfG"t )R#!}2&cj<98 eF8(2p}+qYM7W@!m)<h5A#.ik}V(NT4 [J;r3Gj^<93GIzD3d6:=MtN&mZhsO5Te;v6y#Q\D v;^vU^x).03~@oj~[I6OJ	# uqS`{9${ 	ILR3O,n]1py8uOzLF7bdU#/>^t::mYy NS]r~CA?1{sVw6fHA=s^Q4xeiSr@b1FCoKF/jwpDfS8pA 38v}k#ECILJ%$:Q6 H| 'jH7!DiD$;I.1Z;&A?Z\I<H	yEa9;,G>&da`v/M>,J3hC	?	' ~(P(0R$Qz*kqjx({Nhh,?Zc0;MY8&ir $rN?\C<QjJ2qsS-{K#*l&adW cFAg2Icgp`zSU$*D| bg{#{C'4n(I=G}cT~EEC/Z*crse^;; :s\:emA4P`<RSp?E#!q S$Bq=Aq'`Q>	YW).9>u+$qR!1O}UgV`+8N=Qht8?~nrgoqO]ygbHeU-'&Ew^xH-c *KYS+4I7;B?Z 3b`Wq ]3> wAA#hg+xJ	BwbAygb?7U G'PeUpyWLB.3|E 8STYR<0<7~!N3];,;0	v(@*98E?n'@>~;88H?$suSh B[&2<2#'${ks/'bU7@:#,8^px 3vDc1HdJ/ yk'X[20+%:3%4Z$x"O^%c>=?M2;O?#E$\AC%J"K+< eB`'{o]I~:p~J,I8aRK(i|;
BAB4M+=?`\S2K Q2As\oEKP?#D.*Oc pN+{.}?7GY hpJ|7wx|}FK-R0e]*u#dEL~u6
~0\	;^B'wN|*	#P@{5-
[}afvm;NGC!.!1Yd<scdXn$(r(U)S[8+rpO5h},{QkwI$x >B6umbL
v7U%"2Tbk[w >J+3O\Z847q<
7ObfqX3
=	 
I:4-,vv\d2}vxq(7=:B;dvt%;9P7z?g.{*R!I	R|CyWZC{n&;QZ<><*JXd'?j&e$-\ I *sKD{3:xd).r\z|%&$0#na\P'iu]9r.aa57rG\zI {*B+]uMr&kIv]FpIFN~HeeWr+ZyR=E1![v6+8Dr|8;r	:UN'$rw@P0O9\|p2[H;v{(!HZi;qN<]
Op%A[1Y8y5-axr=:i;L;DDaT}i4G}pshY L9j e+2Js%ru{}hsk0r	Y}<8o=<:rcEqV#zq$	CG.< rq=f#wm*HX )-Pu`U9{cDh| j.: Iddo`1jo&sh +2|>{vyg}*k1?3;P8#$%Y7'n[M
SNb{gaRg^EyL=} JRLM1j/
EmL<#y;W`nbXS"
XFy8<3^+O!WnK<C:-jpmph/J@q{$1wyaIL}sJzTLyA G \uzwnm YA dxu7n#)dm~X"'&EcsR_:mJd%{3TUQ@([M'>vYeE0cj5>Djr[* e`lp0p?sUCOpE!7V/Lg#E
H*=jU[P<A^RA9?:s#N	[I !'Y}X%_<->C\;FY,#9Pd$;~}]tKFT=0	O ~*eyfyec39Qk=qqK0dmKRD-9=pc I.G)xu=DG$<A]ZjI^8e&m!y}x.vSS)G\<:V$0x3+MK>NSt9\wrs<f#ju!`_oIJ&CT2vEBQ; &.{ g'6-TYraKtTI-*FXH)uGFcUUq\GjYp/fVsPH1"|s]&2!I^vPaw2HTdh{/<34=~Yk9S9Vd5tLoS6UIUFG%Vb 3Xu;.RC4m^`O<^yq
pNsVK$S!Cq\5q2|i*>
@;2x/c'Tt1:<2;/y8\39lglO H189fLpCtC[-uE[,;66Q8\)20(Sp6'{ qTp|fy$H)%'1DuX,BzpWRU*dR+O)]jcG]r?J%39r[ryS^nLI#$)p95 pH{%?Zr]^r%K~hOZBw1dg=y%g0spQ7a`37&tF7o~9.G|nb/Y?r@xx )PKiJE {"8B~^iHH(n	8<XS3DJGS[>2urC*1OS)hq /w>3]!j3IX	<<KHwhT`<dBZ!*:ldZ+u)wJ(21Cq;sB!Y!JsEA"FP~m%%<XNrHlonLQ|@g!Y>:d U{`qV#|KT{HU1X'<1UEDq>`sFh#Xs9;Oj`!$p9{yPp Ub{1|p3+~1<*#}8m:S9>su>kz#^H+g}:t`8 r]kM|Dw<g5Rxx!dt!2IY%qw{x &8~x($On)/<3@%SP6)gw>O,"t^I<Co.w j6c,@ZXx4eq@T)2[H0yU3DeU q\ =dsJ]B>	ZV[4PchKi!sD5{pv{%Qi|tu5
N3W~gm@etx1&%cKyNR[n}rF>fjB(fj( `uwyaqR1tJxp)>[Gju )Kvs{geEp0#H(l&=Zn$6| ur,Y<{c+2+Mx=vFkP{q&XCm	>ce=jd[: <+$.V4._|=3{{b&El1(|S(' @Zog=z43-rUCn+Tl
nn"ti.Xr|tma2FhXX7Fe 7a 5'fP,mcp4bX` 9m:rq Ip|#$&^YMGfUM	$8{oj
d3\/FbZeC'TwA9`r=2OA4\?huHbvKr3s>MUt'j6:S?&.19U31\&vR6n\`ZP$A8 	r2,p$=kuzOYAf[u_ZBGj'rcM<RsO*C y#Fx*l*03\[Ayg,md!9/Q
v~e(t29%rzSg o=1Y8 XV@H@X'U.0sWZyStp%`$=+y*	bH{R	>$>0	&v"X 3sYlrc=8_:]Bk)aEU-|r<5yss?/ 2F=8p+xAg7>)Y w=L/J&26,{e\^FbXcNp[9$=#5<N`4Fv:#`9gVIEQ:xx_*Uj;_t0?U#TXe;u) G>#:;oiUM+PcmN@gv9Mycfvsi%pv7G/:7_YrO$1tvM<j(n?P~Xcug.kUI0TgX)/$]Jkgt\!{,pv-hc:P;{2Gj.Q 2)zI P	W?k5WfHQF9=2;Es*vkya%a$s@xO?8}~IW=_6IW.x Sk2"4.1t6o
wy4-cN~h`6#ml.]Q,MaRFOJ0D#lw6(wlfu\'g-J+|KWI/fBi 	2>J@;HWFxTon2;X{O_dncq.Xg:E;'01I)Uxep71Y<4e.1Cjl'' |g NhrFW#;5E[ 936YbyH?J"(;/uHcLK(rFqVPm=NJ:6[o{d=r;j`wf#Xg.tdmhV3 P%\!=3>sB M!OS_ls6/f><p8#+n{9qi.u!}lwgO]p+ OV<S,<|;qm`l$}I oa6UL*30Emozjxl&Mxt#Yh~Iceg$/v@(5FC Tv{~%qfOtTE1F?_z;P7z+F-My][lp}]y`wE#cT.L=kH21\>AI.cS$4Dx.c<Lq5nb9 QrM7 FH5yI;;-6p6j.\cJc*$
|29U\cI,9@zY&A+#c6j3Jg% S:fks,V:b+O8u
,^G%t(`xUm].U,esFv~s]e]v !>M*(Y}bhA+s==)po\d4 7/L4dvb|:)\^ye{B{'id8	O"QTDOo8M9#2r@8MvkZ-	P0|Mg]|,nWLq".->3`-isyKw`q^Y0 N=)5Er%[h5v`)}>D# i#I2)[r3GQCHn)dl70PyC2niV:Sf/m?dc]C:Drqq[ov+|\qYm$!0#(# /]K
snvIuPf!^gm'.ee$ykK]B@3Q;'xf';gR.htKm:X"K1iIH zbXh"OswR<Yz}ZcSs$IioKqUewvX  aXDg5Tc'a8?Cw$eY;$0Jx J9mb
C1:Kr|7'9
@_Wqs'WwZ}(krgg6-lQ5`qNzmSi#1i,8}i;6ke?	|=>4a*,i8htJ`z:KopDOUg'$Sn,LWc~x=j{k={AMO[}/He	#sH=sFMwKH=?5MRawUU'-*CZWh";=jO{yR>PJ'f@io$e^6$%<i)'ew>J8bqN&ZP(dz}y$$aq_VRp ?^ZVra`r`y:LEnS6Ic#I- F{9GCIfKuUiIl0@k4v>C};jL&yP((sL^L.4aRk9\*O\$Lx",;u)nt+{)eZ5)\XLmbLqoOj>_?]?|SE*&6+(s!]K-8%!uKN'kZf-k5q Yp Lf5cml@ r~U@$[Oc{0}9B4MVWM:Ii5gU`2vW^PS,ewBzO'4.CVMAsjkX[m> T(M2yIfePHN>LJQ&}9S$ nAJ3;SC Yo=p>>ENKh.!9nz LUwbxd]V.7eCvcNO<FmMzHLU<Vz}WPE||N,k5+[;rsQsO2%`B1^IvMak[`0	HyLEq%LZ>L>u{`v[iKz\8=sBz@'>-Ml47ku)x :UPari5H9]<6Ju&qg-u}}3Fwa#hf12vZ|/P$D|:VsZj|;7XA<9s\7h.TorK )0zMd2:6y=Q;e-{kHio*|WhaYK}nm`=?[jfLx-._zU/%]5Dc[eAT23$=f= Rk* n>`/n32jlan^>Gu5xaI>WkwVp>$q:V`=3dmztd./ S8*_R*DIf^>~,Vu]^<W%Q>M$_ZHtyF~-Z93yl@9._+20D!?<uMoHmwkFFT#9<zsCw\Er[kGp:}o\!8ly] lq|SKmj[+c3w	r>>j/m%3mSp~]^s<nnl8Ak+$2E}:sRsV7zLyu9HA_zEi[H9]9E1 quKel:%U]-unU$B[\aB%u4mmpl~qS'f4c0 
Mk} up3(9bv U7zQe9DO'#CIX)<F}:|,R#,G-o
yh5yB,9RlEGsh4@J t9]B ;" aovByaKF\	k{]/Fy!-O"3F;d55G0$,BqI$s?Z+U$F>]kLEhSnwY!%UP3-%Kx{]Hr #c7>wdP63yqM?&m7R)?+}//p<C,RnLde|_j}KIn@O$V|!Jidl-O BN90N}5u|4Z{h0C2q\t^,:gr1#gi?ghOKHSw% xY&,[+C )&+D4R7 urOyr[y9;NiY$~\J$+]&<9573|tJw b~_ SfdE u1YsbE#,(r	;f7Zc6PeERUOO8>j[)%Y>{PpGhNGO&wv|p]\c\,	_mcU_zq9VNI$MV:F~VOm(ims''za6XX]Ih"TF4E	1q2H{VK~%GGyQ/d+'Q~ F0GOZWN|]^?iZ[IqBsS KSd=}	gh;/hcB3j.LC!CkxO\vhdg\qKtAmhbX& b=hCF)TSDgc~;1Up@~u\c{ Q/vuIg=HtJ~=GWA z3z:)D<af.`5Ee4_u{&t	 dJmr4$i&\y!$m3^21nxqq<~}HM-#`E+0rxKrS6QI `Uv]I{v+,jB+7:Z%pm$O0F:,,BN
AdsKeC
$:>mHI$F>8?4NhyH9
"#vYXSrV~;%2<t8:V~]'IA:}OXX-_s	I.xxl$Lyl qq=P:D=J.RZjq *GS{-IUz>jvNXONi}AId;AW$K~!e>kUA8VW
b.S  M Flv}c~X1@<J)[bs\|u 9[g51o^H/9 vP[n7{(q1'kgt'fmeHrf2H~>[-n8?IESzZqk*`zl	qFS	*J*`SQG'gn@.q/fvm#a+>.>Jw\,gT1{U-	9}@z\ S> hvHuaRTewAF1w9Y6|	=pkkqAs4F"Ir6VnNjY"MctIY_}FX?|W(9@
:
6	m[p{??qUA,G ODTe|q
TFf^r=]"rc p X#;KlH}h<zrn>#m *UZPk]*e#B@'P'Jv'nO)m^iQ7F2q]g$tD a\=z=Gl=\Qus*.r9=sI?$mRkVVtn}?f	0[p1;W^'emN?Z5;={Ag#[],.2?<DvKWts,^_<dsFK*@>nSa~ByP~@p|B6q=vJH9bjeqg.56<FfnMwf.|j3>~H\ry#`N0x#@53xS[`}$-0:W	)[OJZ<dhZ$jQuh*>?8E?z[8?Jvb(_@[~7QHe wh]vMMmn6.F:g=85qjYb]d\Qj2P2O8H/iU.Z b48Hel=4R0CaUv#$9xq-A)&Nx[IgmBu>jc>Lj[W$.8W$(#89?7 jiW1$~Y5el|)IP)2si9r5h*p;vrhl7R~gCTh#NN:`*pF8B' KcdC]7]?O u/Faw(c9BxHPxxOJ]^jWs|'y2.Tc#P;gb9&U?@sDj5I*Kx|u Z&$/lyUMg:Q-h|6wS9xop	TyNdB"NxT$7_=iv{RCAc{)<mnFtkHY~r[0\,'<FH=~SxW<?*ZyuK4]ANpsA8xIyvK7\dU\}	m;5Iq*5,
Z11MjNj2nc#?>3&M*B)8_M-=J}+cSfJUgkq9L[g r@S xc[XHsTg4z?jBjr~'pccf#\`f7*KbpO:}P]=|8=:OJz2it1{d|V
Oj]?r0g5KZ]0y&3T[-/>RiZe)^_7 r9[$Duz
MB<k]D,}PG:lK.+dkRmy=p(%H K{	vAg{T-v qFiK$pdyQ84%  A[O/}kNA~W54.m}9cVLIJI!C F
nI=(X\/QTH!y>CeA%xUBGGK}X# UtT~[i'2tU	&YF)Hp9$.eU;>$:,l_:?[X sZ@<$N:u8XXc";b~Y'xi$+y*H1?nt]h +v	|.Gf!dDPkJe+9@f
'9XZbkhIF s
HqTx@
s[pp}qRGbX(u+'dho!>cAJoa$(|EG&%GCLRIFa@ZtVVr2w!dK@@ ^N%Pu>3GnVv Q^6l+jR8c9d8Ru*8`~P}fi7sXhhX>xe, .I!\9$z FpiKvQw,kt0cBukqJ$P[HFdUHe3{K,X0svsj,Ybc?W<G5(FB>,PaRM4H99#TX* = =Ep&|o(i8UL$;OZA< R>cMBgVd@o<)'nd'{Jx~`He)fGR?vT&T\-_ufz<"\,@ceR<6qr?OFkO#EsPrxiK?{b^`VxWs9vv,_aZUO?gVUSHZb
W8^9s q1S2r##-H\XKU} $#5 *h7($keN2yZvgrjc'950y%r?PSv!g<^(6Abnflc{6EhMCU~\
xbf*#,Ty[h7'z/eGLvxP2% p63q9= hfz|]|d3) dq:^H	$u"C2=jj){H$`pI)kQ#S[8	X@LJ*K S+N^Q[s,bR]7?:~sTA%W2"POdql!\,I8  _[n#UrFF136"rw,'?jQ+0qg<^yq<??5vh;mF! 'RDvjW\7|NykN"V#$Ua_G ]_*!R7|UeNH*zlHI[&'w`bqvyu]m#,Xvb11 >RyIugZ^,JrN|bu` ;vF%dfUgs
:aH0UIxpOD9??J5#W19o4ek	Fc'
E yy9]dlT1T>~pa4TePqKO?3I,{ISf--N#qIT  X]I~Q(kD.Pk{p;gZq# *0AT4:+y7JkGTbvc8:L#>ynpI^uC3X`)y&F
 G)#&`Jy|FI9:~?#J$cJJm<3`F^rcK8m+#,Ob#[hx:jZu0,Kq+zm&N+9e"FrV^|c?WBr@|$UQ~>)X9r<Lk#sVN Z^o!;P[>PdD<xR92(fJL.:k.'2 8h:`lK \erJy,Ok&5u>GJ@6_&xF=8 uz2!N21n)ux~pC7z?cvdn:d14&!0D&& *%\}76}a%."vXg8yVn1$k$`FXEJsM;!\zf,#ybzDi~12GY.Mws"cjzB  x\^>SEaDeG-Uy3Hln18!9, <p>t 'O,y<We`DKSh33DgmK$ f[3JL+B w_ytu;X<X!r *;#eiV1APL770*n x=z+=;v;QbIj|dwgPkU)*3sC6qqjom HW%GS<bE$	<cDwn1x3hIs\X2J@Z+4`|"u 	?*Ar	J(1B5VEE0FWmMp~ I
 Y&p2u>Un@. z]CvJ)kl>_1Cp{M aV$`z
CAc=2MamH`Xjky)#y_eriI(HF~~JWcesM>}GifS4B
AzqLVnYI#@ss@i,_3*>e7s> 
3]&0F~}kD*~I&`v\jF5d`tCT=mfsY7OJqC!;y lv% 'v=()agmRnWO?A_sY?^i,Pp2XF2YAHB008|/nD$(qQQV<y\"Kx.6`5,8$L	=|/|*8u7c q0{h}DKC2PC%aF"42slRA,sm >Y-w3 1=yH7;sf.Bmhx$u=(6&k#lPq3uKyJ&}b2)r8a#qkzgHB9#vuS0 >/8dz&X{nqq\Ku'ldcyVJ1d7&V6K p=iRmg%d%0Q?U&BPvA#:Rt&"99>MQke>Mnn]Z a+;<, ;QF}+E'[Z{xHylj6G[)([pcG&m#"r1UFQgLsPsXu;\(QQVAU266$`F1RFmcW#2#}N*Y-I6JvQ:f}c+n!t*$el=q)dz`|	kE?k5&? (V1*NZUm
l#)8aFk{i;$z:"%rO<iT4{+'\ZaS'IwdBfe1d.:i	sn'?Z&i< Z6}q@JXerIRRwP* h\['DI9Gup}}<r<=2[ KY"{Q&#*HcB/1YODw2J+;KVgr =)g*cg-N*9^a6vNqWep@>}O%d>9$=8SinQA	p#CxX(goWpo5s3rxT)l.2=!eLg^Hc8kzNmo45Uu#_ZDu;<([Km6e3*1Xw}3Y `<%0Zc5 [wt\2"G	3K'<sq]|K9#{-8{B+W#+u)<M*;{wL_k+\zsY+!.1#CS6p20r0B3W	R2^YQ{d B1IZhI
3}XHr#Yzxct8\gdY.`t[l ER. g^vKp#8}zRR#2k CW^;gt%Ei@L5q<;kSnJ!MV v &.d0VX#^nq$G$i2pEG?gGWr5{i',^Tn}LPP9I5e 8s`z/Z.J|+6=[N`zeK[Z5BA q\XPv@JqRK
ZBI s,qb9b,q>".}s<"O_>i6YC 2W^1]XN]fK`spt+XH
{T`>GjOvn
O;^]~#.]z#4[LcFo(6i#zx-8xi|;HIJ l1Gi?^F0o! a\3onN-?	pGoyqZ&x$w}Ej:W%h9ec*tnhP19l7`>|K%Jn=?S49fr$6;6)8([nj2*qVEp^n4w!ccRWv|Z 9S].o>Yt$~H!-^n;K;av;08f[/z=q!D>`x888|b>V/#XN4;C+k eC-tTZA[xv((fHqZ;Z'/ pn?,c[dG)	]}ms[%2ZtR<wXVe?,u2w4ylp@F|=ctHp_lj*pq3.*!uS)T)4K |<76rI*  J3Z4sx(n%Xcx8R7g^ .Pd~4*vVAf= 3Y	TFw|]RJM2B]]1d^nMmh`'0	8OQQG>\()8#'q}iucQ,iw1J(@GSg\h%\Ch$L|}OhlG+)qvS1@A9rYW%wx4b<AG]Zv^)4xv':,e> g93Jn7) *g`8P@Ff <zT;v\nlX,s7L\4jb38e\,@IQDQsG\&O}6TH~7\$*wM+G>Z}*jok
/z]
134T_,se&"jr >FIykA;jZ6(O^@=EPrD15Lv ]tKucNJi jFlQHM.Sq,}t?Ws9{]I0wvqV+'8Gf(Iyym-8LHTVpcD&<l2%mYAa" XhlSP!2J!R:Z GdK&R3L\5+kbwLB}<s2I3dNi{2*+sEZM&U$zgp7 6	Y 2	6o/H'9TXFr3=2sG}p)h[=vl*8\gkgQl8M,&Jx'j	$<,^l3<{[=?WUePG$8Ms]H|DlQ2qp 6H]?:T`3xa OVGnDk^kupGv{u8m3u}ZfZ`Xkvwh8+m~Orf$:= eR~5+~"X% l$,0[Iz\Qw6:5m<GqQtmMV$rCqDC6lR^so;86A6K=v1xkW\ ^@P	hOx3$)qjN`h,+x{h/v|[~t#'8|H@[3}zUgC0Y#9\ *:(1V3@V;flp3'*]Fu46;&[s
-<zRD?fOLZbnv	%>.\:^jD_kAnF68D}[,
2KDkJd<hwW#f$a!hOs#>E?jyF(X$wAV!Tg\I<D,hg?JwhCm'^1Lp(${v|9Ow}Z1Gt!@+<X^Ie|""l!IUXCg/`Uw`pHiw !;9H$%N)#S$$}[[F,E]$E %iUFPO4\vbBWMe
tC'Gl>(f646n8gy%%Bswsg<EHPPNl'\Vdqk{7x :u"|O,sMxV%"I "H f98128*up,F?i(co&?!V$nA[i9 OY3jxDW* )#sTKe5^?$I{)hT7d$UXG.N@36!86vC|A$[!(lfG{IiFc.i.V1&s_F.#[y_hqt)3LY,-%#(|,'4vSyHb*G8l;Ig+wr\$GH8<>~NN(?d5SkL-(6GCPnm~vR$v$vMg]b#_['E=09ro^k62vb194CvH
I }0k|`d 	 )8$F/4[3Z? ZYT,hu|DKosnw~|?Uhwg`6l\S])yJ3fwd;k6+>G\ zs\Uy?iB2r3( x
jkG&@.6{`N=x{*6*3![;i:`?ZZ)_,kqK[fKkHBK8 ?4vYm\0n<9b-2rk28 duTJ%rwxUdc [yYk)"ka3,4cE<Q`Kw|PF$ %5sxgjki&XVHP8"@;dF=0rvr]Tzj[UxKmc1o%So@L21B8  jV^aL	WI%ndAe|-t@(G|F/w[Tn6,*(v(46BpDXUzqzc;go0E6Y <m[XI4.DlL~)~iZxxI"b{PcvbgO>s\@?z8Z;q#Zhu640gl/lYHb>gRiSg/]wW(9>x[z6 '>cmv[k{@W}8$`rZt;DYaqVw5HR0Uom$XQ ?AA<~uE=[0n@g>cW^v~k8H~.yNFr9IrQ.=P{y  Gd5+^+kbGa*V/YC$P6WFlT?vq;tFJ\!9Gg-]>`z')/+m	le-3xY1YTul[oYiB<	G9,=3AKyMWC%)Tw\S4p]Gck} zi5uZSJn?y:.Kb->mZk,7@?y\?@,Xz/Zv1x a>HA\RA)h{=bs_aWve$$?Z8NH~gY;=_Rll?,WQWe$sp~v$	+g'D$vd}OOqm)!HBuE2+FGPykWVYaFLktrNL`ygL_~d=	3'1;("8pq;5[=*-V9.IIr/`}ziZpO\bEgo~ r1L"Q_"/:Dh ltkPOAf" RA\/,(h@#Bd>J:(nf<gN 1Qc/ "vN]4 9 pH~GVIqw e8kL}?d~u!9\M>=&}:$`G=ilvr[Nid&'^V[%vN#mNv@ k:$M*4Gy'}}w-JqDgogM8|Rvbe~"1phF9e`cX3a~K0'|1CX++cZOY:k2c9J2f[t:@ ir.26zZm[Pd22F$HdN	90RnX~1ro!g$(1|QX5vJx[JlHV``$Wk'f ."Eskm>G]BX$~U;~$m7nc9<H0Z@<.XtK%=a6zrhb(;>fWNVc{)eP?$p^W3d@2V$zqhUat)w*> O\Ogf#R74XG'-|J@X%dm9=n!`3 *,bR	/2=OFrk&i,U. c	~%pHa\1EZr%W}Ewh/4rn'lElIMHIe]r:h\En]urK3IJ; f 9=Zg^h@ @#~)yuy	 o|>T\qv6i_j#^NiencR\,~+5F<O\r{ 2iv~T,Z7gnHA"CM(fYLJb`\z7!vnl~t=bbD	8`td`rIs%TWD2H23ei%m)qwr@1Fishk~!Q#1T^YnS2l[	mCQA?Yk'/m;,T_xm*v/)||R# H6YN)]'km$B7xr(aYYS!Q\tCp (	nrgrOY0BI 4Ni5s"#*A;mAZ[jQN	''*Lo?vf$4DI?*{3EK",~x^\*a qZ){1zwcR[,Noz9,kJ"igMb@xg1rA+&29kpiW=m%]vI`qcm-oWcv$yWDr<+,vZ9WVg??:8-99g=[vzC&#7w<Te2Bnyu22w3BNYn~YB%1 <x0qc39Ot;nb0I''4!%$[	Ag5(XWmvTv :sghT:gX=Z4}*MN8#^I[nljw8+/cH4""N}r$LVi/fvgvbK*=
f6pP)`]lC-ui;DeFeFI3)
DiY|::~eejrYfTGbJF|&B#4a	qnEeU#wH8Nh(^m^3 xbe| ~IXEK0 Z8;c]&{w*;Wc(Sgh}9w<{o;py]cnp_blWI&ha$09f^(Y.ntW0:,R5Vi"ul41GK/#~:fN-.{59A?GJ`3Id^
u=M&}'<-?;M?EU}M3jRD@<c'2z~}!.lrP!lqH0X49$;p>u$6#Ye CFR!^ lgpvF~x@3V{kIwZ/}cGC]VL	eJM/]etX	I#R	>G89gdwI(<d5a n84<xX'
g9n5cu!Q*=G^)+K5o,omq)QYCYCU+RG#R-@EMNcn"
6n98S/>@<Od?+0#ol
xnGw35`9)$WIp9|s%bbTxV2U\t?{Pg)02sF;!  0>u*%'dz`'Yj`3\20+ <yUE@^ kEt&tw-Zn
?z8^ZTCsXN=hMUc9Jg*(J6nrG^}_qX/<e|~h' L\9vFA1^D9?KV+,I+
 ,NaSd,7#oyrrN|\JCw:FZW:I63Bl{<ors
J(@{?ze$Q-1%w61+ y.Zc[89b[qw%0b):n`U0 r CT-rx>*s( 2bw!YHS%|?evA8sJ{eY*6uba`ohv<}M*+p9r|j ]e<L|O1
sBh3x26Hl+,i#{f6
<LsWBP//"vN=ODl
G_T6!"DXeXl*F::>w@!tFd\,'#3]rkn#sdRd 3Bcp:
3MFc#$DF >|;hA$`qHQWCkJ9`N[Q\xPsqAwN$ 	Drr
%jK<iz>KCEs0G &Vg_'xh$Dz!'48|/-#+>Y"N^%Rv>"z[mR:jpp|cG  !<TSH<Uo	eP,D|Q06	$cf	;OfGVe5d,0~ :I}Lqhn3mI `H?XC .X cU,,BHdI)}jmdOqznSj?()@>YR0DHNx</"ep)jV/*co<|I`kF#YUmS.dlo Vn9+wml>t]diLn/*U8aGFLxaVIQ%*n|W6-`?j\:FP<GwO$7%I>+o&a?SIT6TEDpe@dc8EfI]#*t:{18b^kH9/v8|CKW;{l`!j;!|)Y`y?za6$}'lZf_,F9^I OdQ=Wi"')"[zI4j8'mZNN:2d
_O$8za#1{kfsdR/w,D!vIVTdy#)oWrczh;&o$2`9pGu#UCr'L;GcsKJdR3)ZH+eC%*w6[C>yV84
\;~~wRCo-U'7bK(@$2\,MQ9%[x>aM3qF /R_/ VumrYHa9pk0D;3Z2uaWHHC\n[ X&|UM7k7WJJ<]D,rOSA?+{\q.Zm^4m1:`HcR)]8&yrE$(q<uz68 vN*ViCw?NR1yyp%Z5.{3"x/QzPDP)0S>?9a+`m8fQAl$t8VF;+Tg(#f2Qrnhy;$(ZhW$qR$w{Pq>^1+e,}=_3p1	O6U)r@2wqs<`G8*;uc9WH>^urri1F!l@*<~\nA3ZaxI<+U]HY(302A?1YEN
*!G]tp2;PL:q0<2$rO>zY8`Hc<m |W',M2T7Z.;fOPZFaQL`17@G$`{t+ef9uk
<'Pdw)qB)D/kT=K <&: y?C]C1<=QY=?jt% ?e$cz&ghH!\`HCwWOn'Fl	2y7"x((QC=cs
c|L0>trv02:~uDebT	2Q>~ pAIm-sr3VE%wbr8~u1s2<py9$C++Al(l>O"Lv lLNkBgo.#_zs;_ \&yvL2'?^ UN$9>q:Z!v;f-g*C\AP3{u+c> 	 c
/ :VX8hs i1^F{^3Blm&9xBw)\$`yzkYU@4\Isp2;	x#<f&)%Di`3V6e [8 {U64q?;<p=M02r
CzMFysj)Cp9o,o?$
7addMl$;b[/tj.Djh g@bmcc]uF4TEB#mO%f29\3)V;h418A *oe`hdW*?Pck
d^<g%@<yHDxTXtn=z`jUQ'ch+@.Kaf9[0x% gCCl
X#d\)\)F98M}*[vaiOcah5i vsWvjqm[d3B9zqCv_TvvU8_!88sQ_"7z P,X( ~uf|Gej-p0{srFQ/U_cu/yrF0=pC/vGqWVG]NP\5(\zL@+o%Y]d
s|kqR&.KsF<uI/_ny q=i.5e	2 oiFbygvVY--3FB2FT ]j6%E8= D%\cz:JKs3HIU>W=z|(pqOA|T( f9Wyd+q[P0>98$p5+8n:{RTt8Cs\T9"=UG <5+v.-<4Hy=@nyT-4]r\PrTFr:$BC9uKl*OR8}*g	d
[3#[H?V3H$@z:PV</&IDOLGgr^Ax$vroDx+A6iceX+\z|(#O_5l#e.g p3tT|Wu$/9[m[.7gFw}5". -@3Y!~< Z69a=}QCvc{ka$U %3\d+>3<`zBEm`rs<W!QZ\*BMtd<6mD3ws;eB:yZ=!" 6yFkgV((L5x8"9pXcmb:S>zDL(['aV}N28Xi>/:Ny}C'<+c!nk$O){l:c8[T_9bb#i7lSGG$@:Gy8YlCshxSu?Pu\\}im0O=jx]Y3+5$#^hzKW2_Ht14cxSH3U0|\|MhOQ[R$VsH;M/oY/e+Ucg f:Sm[VN4.O!>W =3sW	,>r1@2k\8cf8QxZWJ\\8{W26OWLM}O J=AaY7k3V]Cf#5EiP^GmfBG84&8$Pl#
S7$gTc?W\j:yd>U-{dgM>@;=b3zI ;+l9	Cv	f;n#A!ef<mM<-BF<	!MRc<qD^]05l/0^9P`:P!e9 >gF?h`Iv- }96!@$r|(odmL6sq/_c	u& lrO'CoG9]^
]!^*dG#TclS$Ny{fo@%Yk6Mg`$3=h}6L%Gb>T}3$nUr dI$Y&ERs|r,5Mi:,Tsi,)HAxCgG'5].c|0$UWQ<'=u=zt$ ^[_ g"zLSsUVM]wMqs{P\I;T7PFuh*N\*NiK1xF 8bCki#L4<u3(-c	=6v/nX!UB_>siwRx})4QIXXZfUluVICB[)[CFUVx}UAjzx ]8&-T$F=[."Um!X1rN9dtG,z	rK wk=^W`lQNI.mf1 ``W1RMTh,H_h d)$Y#mM|DDQjW/Dh;
+C8X`V4Qkkf!++Z2W]0k.Kcps[8br_ogOMl@!`tl|Ev=zt F/x"9IEl%'4Q%<[*
	LqHW<{vH3/$:k,'$N? TSv{JBpm;69	GP2x,-FYiW2,	CbmLH}Vrn!;
F9Km.vq=fhQBY2A9RbE#D272Dd/|:%p]nR`<9F9W7Zpr	3"y$i"y#trx5FkOiY0I`WVE:WhH#lyn,JR@GC}}kRF+53iO)sXr]55#cI'Y[K)8oZ
=bINrYWiOAWK$;PpOQ5)42;x,aGVhh*u8
]cRPxL|MrO4K"BF|:F ?:T'c,?eu2=0zf=NK:k"@)~gnsM\l 3}jJJfY U)@ *e(E$dYs=vKEw3L[q1'UArH % {qRuOJ
ZUz^ZMP.[nJ;%'96#"k).<rk93Y>K09 :U5Qq+$R"zbk"J[sVYKkvpZvVHUy1$rx8/|Kejliwg;~uv{{Q0^9l{?>i-tvHp ~A&N=	'{mBYT9:t`xcIcRpyu`kV
\Zh"{Gt.z>$*-,}iLz6tRMu%IBQI4gK O nX4r"C$j-Uqt@q( xOvA*J`f $\<
h_q s R?JjFf
=
M(9>3DIZ7)eF $K 99<VP-bn,`(Lz{yT\V[GqQoKTtVNqHIVhU6Cdq5xJ<y,YR7XWwbfi sk?dfv2!Hya4VHCP_Z!msWr>C6lBiv 	|+pN|
qI?hlK!I\AC?:~0#@>0	0@pq
2qKL,>T}6ifUjnBG>]qdZwc$#?jk}AwuLw0:)zvWZI5q.Y9I2:Xn|:Jn89#EfnK9~v9;! *>nv[xA/=?@@fL2sSKnay~f]T9V`|w_o:d~ses2rC*A(xvSr7R#YZW /C 7}3Y#]RB^W%O\qXIvQ 3<g@|mfB+U$;E60X$9 V<`+aa_Z'1J9AUWo4Y1N}
&-w*,s1@N9g\ww[d#
5k&,ArM_5Twzy/ERu-AeI-u.d 0*>=
H6:\ZyA+u	BT1Qp>ckKq<'MVeR@) #?Jh"M[^9#TYXv(Pyyg5rh2o:4>`-LG`kdm46$J}3P]+sdQv75$8#m>Z+yE+2y'gG\\yf=L+}:wcen<} Yol4r26yJ}r{#]>A=D U23?yhukKZk(S<^LXnu??zU9%n9 #2_gW-e<p|r^Z,&Q-o`{+z!'yQWwbHmgC y\~IE"Z
7w|kjbq 3/u[+yevL@J!gblYOq5kp(b Z>gDv=wP^K!ccR]VRif'9?ZWmjZZ65]()&RB15"`Y/J/Z{K-(NK0 qG&$P:&$'c9E4W`+s	mu_6_?eb_i2 iQ{+WMf )~}O$gdO>^t{orq3w*0F1b\<pJ[K9{9BG_'Rhq+:VqBOxqsvnap:U2Ah_7n hmk{7_ HMJ;qs%Qe~@/=jS6{
O15gn h=X3p#B~0Lmd}-#J}O~7N]wpU<t#=)d)_h`+c<pQRb'sg{Yw@A%dcHa.M3]G(=9%y5pQ##y+af]q9<TW5Vz=o&;D.i~'xW .IW_I uDz:) 
S|k!aMLVe m~Y]hqF9H6jZb7Ba88i^.NVuop>Wd-r\MIbZ(06?ZY?qu3d{/>'8Rfr[j?by2co,$[YPZIUnR7tK	*gs)lYuHEGnzmY7p0m[y9?jf;O}!nY7=@|^eyqR|RBu+7[[H9;B`d9iWipb8:yQmw,l\ x<!Homm%F#S'OtLEmJeK?JcM&,,dBN@|IYL8M428R	`@*,@a4e5kwsp1^rm-^[KmB+h|Kr }9i2y
GkP\2'nfF
=u^ iqfme j(DYOOJFH'b9 t3jjomm{`&P|ZhWKiPXp dc9}@}>!m`}@V{bXc!|+?6`u^D)V})}* 1KuT"Xp&$Pj!k`$$1s3HSmuX\\V^iv,w:Q\,\z%{s\I2<%\G,W	8,F;$3' >+M[j2 U2(xbW\yC!}LLB	*RSe,ol;RhFj. Hfw'Fd,4rO#)|4{D^6 jzar;jrF;B	I f$$)\6FjGoZ@8Y*`+\b5
Y(u
Tz@ s'kfsq SmGItn!kREf
IX=9gkg:IGa9ZMgwQ~Go,M }|~g_\_B{c^1QY99JjZD:cY..cE5O8|k[[)lLq:M/JTfiz'>Ue1U#<*y&O/";D#f'pZL$8<:1z;N@?uUgG:eK?6gJxBN9T)aypk 8=ht+.u; <_wL(.X_9{?$Qfx' r+
VM1[vO>D/l{:d7N@==j QNzW#\,uD08;$vRkzgXbB[t5(.:08XG?,*j_/ggI5')'^ilC}JHw4:qM%p\U.OdhZ1i2:TIP"]i?R@Ik[Puhi"RcOj>+UFE[5T\ns c:>pXq4'<`|tB^/	9+VnqvsZs{V$R]Qg:
Z[62N8~XLI/R1ke.[0:}(pQLY V^x u-*=yK3b[z`G/7bn*	N<5o"2nGn<)e{]]U;-I<Vg$hSC 7_s Tu6 bAiEp?*5V_c/\biUU<|"2#\a	Gwsj6QQV
^FPXP9]s3WEB?_VE\mB?gjR:IG.pNr>c|e9 :<h+r T(<:h6hS21'0_oz]2~@I W;l- :l;H9/_cVTY%'d}z1F,c;VI	qvIA\I6vb+wu$VvxJ\Y&2WP~`?NI1f*8}hInIbw[D'<;vl-ZDx9vEp0|XC/D>f
EE1CDvkP^YY>)9Rs'{_Nr3>EdU}>BtLqF"d>,L`"(?	KyF+<[Uq}k@sF<(C,	7IJp ^cFKlr0XNy'j*ZNYXa5e$pL$aapU`NyEk1?#	'MAN#1vZ{B&#hc;FW'zlU<p	8d`5lj1KF@n3[IU<2Qj/Lje#*)m'e[y:uK4IX1|1F#9 Uv4-Fgee?JP0*.1x
8<*J"8 '<`zu8 nTpW@B/-cg11xP@Ygw{W1[;X.2IH\'1R {eF >O5II\/s	 s]K"C$:	&#G>T}`WP8@\('t6	cHcOXQNd2| VRG10MQ#F3<Ggiv2M,zvcP`})7,JkX%V<B[W \s`h^LO	y."(TfgyM"	qU*$KKq 
PG^MxOtq.|+ktX1`Fp||E Z*-$}V+#V. +b=L0zsIlJ<3N6s"2;iy64H$IzW6I SHKE@3y{b%?}RcF??z^B3rps*ype.A]K67WwBY6wG>*%Ix]|q4~Dc#j#
G=3Y==tRj|&#G4!>R%YY&V
yV*`
n#@FSU^ggQU#,pNq%W=E2=GtSXt>KmI'$yg<ew:!m;px:7'6"a$wnQ3:\0>Dxb72=}2Gv0tmRq2S CE@y} *vY$.R1/zA%S#$Q=g$t+S
$>g9}#vGH-jf\.e8>jtcDRFJx!e%\T`#9 UPO|M.I:Q1WW=[?w"K>Dc1B;sov"@V	l cg<Nk$ulH*;YcF,<:c(iXC<EK>O[lKpnZk>eOzq%;?*95CDn}(X0_L3] x>UY-['),w9>/T6>xa\4 !;*M34ZV?hgG)e+C;7&2r n';~h[)3]s.y]FT6={dNT 5:"G K9gDqX.#6cUJgD{XGsT yzGpKS ~HH!) j5N
u tc^sX!PX@84D,7+< <0;_#3NEu"0BmWdH^R,~ubn~.=CGf<+ 0eR08| -Z9!w[As{V 
g qS}Ed.Hds`=*G@46wX*'CHl23P<#TR*0ry>={SpJD48PH@ R- Xi8P\m& &Qbi'*	to*nB*O]vhZB#O'd$N@B'`-I$BCA[ub$9|TaIGL^%D "8RF>`o!x #:u2Gv2=G^mWmk'Luuly	({/y6mxQ[GlI,0V*]OcM&Rc]{[iiKh w:n$A00/P1$g%YC.<\Ul_sU%q#:$A[8bx`$A!`sA<V[NT*`:N;"cWG.ce"8L@[?:FX=?b6\z~W8W+v'NFiKns)9NyS_*GOx; 0\2@(yl' /T.pOjF $cqsj&R\` ?/pz	e.rIUa%69~>uSO>v+$!=*SY{HO_s<'Hx'#pr=k	A?y-stuun
  >kL(`v2 U1m,9-zPpRF(##K(Cm6y +El&3xY'u1:9OR=K	excfe%@0|x?Y.T4'$|P<K>=(+^$q8
Hg :YI3RfF xU/z>NsCATW!)%N3g6]Rp3&p~ex68i' BTMgQCYBxTt<
MKq'pr$ Ub$,Afir>w~Dx>GKw899N^v8<,p}iB]EQ >~=ve#8X>\UcKghk2>m1.11$RXaUuv@U$VMyDh2ll :7c/4|AW+s WOF'DF> #}k3$W}{^z=xOz$Hq-e/|tV{@,XTwzV,;:eSnRA8:~D%=O5dv lVXC ~_z &]BE2w![BrM&;:p+#2 T	8JVBtrXc$P&h?*Q_6	)u5SF Vp&?,3DqbrVnA |Z]#._2W>W$w\
:c9<QZIKXC
w,~w#c&	8xHW$UWD *LO`kTIRpwruKCzPfVqNy'PdU}w xsL;i%c3 *e`[pm,-oi*pO>U%Ed#/yA604,b#zU%97mFrVR s^>^y$imA;@~cV*JpRciC5^	-F!pSr!gXOhDfm7g8ZjI*G*VGg2&5B:F$><|^VXvXi@UKbF Pz+.2z}g8+qu.2HDG&7y A[s?5Tr2b?&{(l1tj\RF509c'=-?-``3&dwdq'wx tZtzq5s1{z-7HecZ{;@3Hz3 THz6k'^!{rFr]>]pVr+w#a,,z$xQ#4W$sDRG5-$P2l	51.<Qyx# ~46Uy@I+!m4Q_8B}G#85x N'C*. DHVtBIKb663>jnMPYna$C#n-SMr 8 dt^`Gc
V~**,r0O	=2+kIai(@QJI2)VoLL{!|+pTd(8DX N**St{i.(+$JwgNIWT2RG#$?lO\4zd+;N"('C%-6y29IfoF&k8=y4uQr9 % qHUoBdi='-FH=;QF/XF8T
xMy%$>);mA p~ySRYg\3d!)wr">?nG.#>E&E`Q|tkDN@yZhY7K:H.[d7wGeBe6*u'=h.p-F, -3nZrda)u)l@C;]|*oub	< Wqz~UX{wr 4*?A}].YB p9H8vO,VPs2?	?ZrnFj.u' Fn Qg9 >/qhz HBhvsSC1 k` !zuk(MQxfydM}E!D(8?0@2C>'P17x>$m#:FF{\Zx+,1p@??l-?HT-{yVaUI@I>mrbye'*[C=,DpB
^wyxqqG*;!GtpRygSHb{rA8yeYn~i,eUn?\Hf?cN~
`Lm>)+ivp1 ZZ.a~X]V/'AC Li	4J$dkb] P]J" 8*(PT9R1 mI&P>j
OIxwcWX=0Gc' Nwwqs"K?zP)*CZa*#=`ch>d6>B%`nFzvkPd*y\^YKpRYc7&D</Bi@<*{C{-V!.0zx[YHo32Tj! l':[\j7iu]Fq?~k:|Oe xdBWoYWx WF|VJ/g/p?V/$'";,#E`*1TE7wp	*}IV{WFdo@ (*p8rMqe$ml&>0c *C,dSwW'9S6cXmsDPAGib#E>j!@'2)VDHjz\Pm<dn:.K`W?'bw,W>I2>rr^@k0(8>|=3t1d+ZLc/A = p8q09Sy%dgxMJ_#m*4T-2o0ygNvNd~db y;#$|6'Xt<R-neZn82uw<:T%!m696w6s}FHsfvSsIuLEb7&B29{fj&cy0?ItiE%-iebCgu1s\Zj1Q~"@7gig:Ux,,fylEmQG.g6pV
U$kK}j0iIu1H-.uNR[x: }+OSBb>Xj	I nvR+9xU=c9EymQHgE3Ydr}?t-9g)1ks[s}oq,Z~.TSqo	k[1X]*= -M*pS2B%Skf# |UjPl9lq4/gW|?hXkd494VuMsrbDt'fAd\ZD1JjNzdwS_2=.I@REkrGY?nF<[Aw	Z!ojvj2{G@#%ml{hl!95.S0?!n*;ZvcnlH
_Ve-*bzskgcOZIS/jl3\rE R^.lI0@1J+f5,u]\ MA3t>Q~X4rq{AT$ZbtZpk=-em*3\-v^8'=k;x 'M#HiS?Nh5[		!$>9s XsytZSvnX>d|lPq
+<=FJJpF*+a*<`]<'f,k\n~Unh4O0{ pxMR!V3G2Hku"U<g?V\NF]ZI;xsX1)hqr~$Te 00uEcyeN@n~ Z!5%m" Ki6>Q;;YM,rzZj:
W^vc=KEX r4< :$n5LUTMehnnXi""Dslwxf$PE{WqJ$7grB]#t2&y5J%d0uX{xJV^qYdY9e%j
kT!h'RL>izkvr{s^K=%	'-N
>?	$}hncyV;^qWM'!W%J-#X@~*;|j<h4ra?OZ[FO8gZoK1t,!Gu	`0DX=xyCJ4FC4G|ECl<20}=W\e7Vz-@fMx]swQv^{]Cs7!N>G4M
 \6f zX"rFdmR8=^z{#' 3$rHG;yRa&+E_ST5\]mi/yQ/Nn06xaP2$h(%X0)]Z963%`HzTu`{9, kC,%= ;'DZR+aK~AqV pyUv(79#9:n/P3.\lKz2}{I-<#qw`uE.j_s4z #j\v=h-)X-5ic\:MeCbWYRGF:kq-eQ8).rpz_/\Q{!]NkY>2/h!RxRqLB& g-<--_65Y*N.3RwFdnpkW<T$b
i*s#*wY[if.s,.Y}g=iouk:&N$]Ta=}2ErZ*CFx#^>_:\7`$mjF{ qZVBrig2 PI\[ywCY=BMv+t\m?z_l,XNib5\$;CvN<sXu vI{)GEQ2+"os?z%g<]7N}VUVuXTxL-KMR-;a1:#\f7Gel1v:aMBD u NhAq	O< Vl6yL'
(?bUG>X4	W/ Rv*-kt (aO7Q5q8C
<yPP^ks/,BL1~Zkl;J^-TWb--Ai<-Ha 0?@;YU
Gs/ju	.pa=}>+W=*2'F&W=+-G^iF|FZv5ej]x/; |.Fk0S<w'<WN]GH#
/R1H^#Aq)~$[$y :&-^ Rek px.Y/bzl8=}E_uLO(9=qccj9(R^LhLre`|<ta"S*:?i!pqQLk/<r GwkX"H yKf1)B8i&U|Jb,[3t ><Ng(i[Lbi^{cxp )5Ua5R0[aSI(\M:dl%+JXgK@v-zo,mDe8gsfVR)FIV`aVA<Hdd^<q?kn^O%JRa7*_B,|<.k KW/wm= PM7eztu,,7/Y 8dW8hRcg_JX)Q$s u"PN?Gad]O1=#ZLUbBL*9G_r]BU>YKHhg*5ZlvI,!S
R?(PLsO;PWpxSOMue4xg$NYX^9O4}8}H[FGDw3>g3sU8<}LYM.j@n"^Aw`*? *\kdP-J?yo-' :,x:TeT%:!}dSOI})v	>M{L|<7`>^F7z6g'N\wO d-rLQE g}OAYo<CK$2$vePg88.tIcc.R3}sVqqI>hY59I9$$}V7 df[yP'} ^<Jd]}r\e;N@A-WR|gTU6sx>V9XrG\ya0R<I%ss+'	CM
-\kZ+31y]sk$C9!N>` 24GIdSZ_.]7FfU]aibBRKaso4[K[*>gvZ7XYB`xtP=*x@.hB66){kN{iO$PB'51GiE+UB% $@}p)_NQn[(F O9NI(4k'Bvqc#XsyzM*P[!d-H9 s.kH6v?|F7e(p sTCs2*`ExI>j9Wwv =o@Jo2Ro6"deRqmh$1CZ/@G99By5NHY;^VK1da76IODM!*1G0V   `[OHIR8*K]zwY6qvi!oe[Bp@|9UE	x=kR(Y/ys"  u$VX@H/+zzveKv[SC+fe0
wNMFX)p m{2M.U>#fj]-\/85EHY}gaqyn##>U#eH`,W+|NujZB{Ks"KsGi{;-v( n=Ec{YUM3h
zS=?GD^5x5U8,J8HK \T(b ,B0=`IMx`}[kA%p>b^JGT/V(;8>m rMR%)1V 7p.oX1Lv Ui,c\)Pw#`,:>ga}SG?c	#<:X][,Zz'#!~L;T#aH_$BP8T'g5[7M#ZR!q@HnZ[t*},Jar;1[R(7'R9y|EfLH)q$nA8 zVR6Yr[Nm%spIb0|1W9vsQpYo3}GU[97F$;M>li?J,n#y '|c4{;{qtlyrTI"1<sQDCI@hAmJZ96e	|<Q8,G@	V&WAj0f'Nr1DO vm-h $91}i3van{CN
e]p8F#)#7CHP	<{V'q[I
- .1?>zW}Ir\iWlG}"e3I#vKQ\?cH5 IN0\>dzvo:k\uWqF8G+J-,;  qR6 | yUH?hg
T 	$qpX5/i% C)(mL}<@qL}xlhn?lQQjVoNAQf;"	-0y)il;ZHP7?BEqhgM!xm;cg)
s;_.kZeomf)#jWq#+O>LdvCWh>C<Vo	t s##sm5
@5x5=7*Zh}uh1p?R)t?C!G}BB([(GMlw1;>.}c]Eqo$wSSbGy8?.JE]fE8SWJm`j/;K3D$6 xWsR@REnA hzgj<R\L~B ='o<&{-kl0;0w hBm&Y @ 3ONgftl h{];^\(tB_=ly@_^@>F|2T^`irD x%s*R[i3[p89Apdd8?4tdQ[B` lPomor:@?DS,<-\Z2]_1} 0N{\i|BLmjmu+~9F>@Km&.,d0ppFr(6|#4`5l,c\}iN?# C$gut#Mo -npuVcq'Zh[w9Fg^#&iwg+dG7
}Xi{/qjw1>LRG`pq)DxQp7fWAD@WO:%?s~Y]FQ$q9>^TFN5@GNwO+z~C5//o}x9O\i;Nj1 82ch[u6&!Up<\\I'9Lm`L{&|!2y@ofE" F%Q<~T4#GGKC/w4M9rp1xW:dGH/G
B1UN~^rw+CT_HV]!d?gnhnOy(f
r	djJ0rNKD&w GF6QIi 9~\j;r/ztztx2om?DvA*0#dy@Uv`jVz?wo&!l"p|-^X)wI-F
Ee;`A0lr<pfT zH@7x\s'cVD}Nrcv.'4t=,$4d8`	yqtp \|RF6`	ht+RkZk.YV_HMu7g`KWHbyxz%'<4#Hx{\$PAgebL-%5(J~NAGQ[b-%79F1VgY%mBI?9MxlDU\UeM<2J
!JW\gXI)*"gaC< ,9v9Vytb:NK.s~X}{{GxD$
?.$2{xaa $g:#oze62x$LoDl l p|V,j8y-[/zgXr-W5?bk/), }ggH#{<+:e}mnBQ@|a d$Jxdnf?@
>$JSyA('xA uJpJc9SNR&&(q1R['5+)%K*~py*<;cT4PG2d }m2xXK}T% wnD!Hytd#B@'y>]=+C;mVS.mTBwmY3ij2InI,Y94H 4$Ds>*(q:bKr"yjB%&z:eJ#FV\G(,8::b[ang!uC+wVwSRS08<yjfJ'KoiqHqbQI8/f8#>9{5"sa^C!My&{U}I9 >+\e$*wFc
#:F3Ecl7P6:FxWQg%AFE#?CDrUN@a%a[9CyGy7QYr g y+Co,1i/IvXPZKwLIvOPH-3OT1"7BJf	6E7sb`iqiePMq!xl%);
J2@!:Qyn<\"y./m% ? r+y$OD{O8]byeyy#QMb0v'csT;`Q[REQ@q?:*|2qT`;06SW@7s&,}h1wnbqFNH'^E[	#e0fXxiAK3nugBdtZ8"8NOu:Gr >Ey	;~,9e`?//RQ0JN}6Y\K+^L6,F$p#/|oM <r[eq+<g[PP%2rq*A,gpI6q5V!zP1Wc&qy8*&zMcv5
28$y.NA]tz=vD=U*zj'`If@1>tnndw@!bz(<TR.6T6!(uhI^OO.)|bI9GS>1Ogkod *)2^$B}F3Kkv$Rwy>|sVTB@<D1qUY9%6r6HHaHB&C]C(`w
>#\,;hh
I=<>U- eW}Mx*?$ * onf>xd:[h2?J+n )$AXS3tbxxFBy|H%U,hbFZF)p1ix5m$yF`Q1KV$~uKVm9 =A
n$?"+WJ3k?nvN9> kC=q8uqu6D@8 T{Ee`2y>u[aRelHv?i?jHNcyr"ya:r==i;wGvf22Gyp&r@Va>(!t`$J HaWL*Auv	p^fBX	,=zr M'3m0 #X2HK;#"& c_~:wiql@e2>~ K6Y% ? goP g04Du'=!
o
jWEd.bSF8wapyyp	O^w(d\mo
~Z{)|";hQYSy/zw0;X~!z0ipzu5r8c\ES}uyF]8H[ (Z>$0<xY2|"Yax!{Jp3dTZ
mx<PW6W&""%x$ypicv7d<*exytq	$sR)X{ow0709 "4!0\GP?5eB}:&kDC^KCw}HW$
pJMj;_+d4q* p0S].W1tTt!
Xyo37i##88_j{ kvwhgihHl%%;s:Akb1 ty2+X KqTOrMlGt[ '2j0p*Gj'L'c{lUY=WY8<X9=fwuh%'k5"\D=yWTD+1,nvYtR+>][Co<2aCIj[$2LsgELr*?tp ;@/J2b<j
"qwbGdK%2p@9q]I`zq<Rp=
z4:cH|7T`}Z"yE	b=<O61U *xQqiyAEf;Fxhce*T4r]yNd}[\QnS'r-cTp8}92dWzGjn8SC>6g+)\cQ
#'xs:9b+:UEM)bp6z8d
(s'}R`O W&0J8orl >u@ H#A1)@bs^/p|?>hD}/DtV8Qb@ttVW `r<+*Wq\-b9y8&)i^I\P XZDdc Rkb2^rC6cl8#<#;wF(a+V<72kTM(I	/nF8_K![=ci=}9-1,+E; g /;hD(>Gzq\KO:toAEC'hDZsOq_$@}?s@xvo{acj0,0aCt;h?2Bud=9u+5\Jx>!ZqikMs.mq^+*.^m3x_qO`m4qBf;vRG9l#kqcegC"Z0FY2g =:Ye04*H:{f4J+?/l[d=NDDP ;IbIc ok+89gK\^Ad17@>:rGWfnjm_k@?SrXA J~WCyqJ)b=*YOwr&`H^k<4$!VwI#s`QM<_ib;h@O5:6D vH	?kf 9g!z7oUl8_],
p''I[J	?#u</8
1IM ;G!fo,yj{}b\*-VMg`C`d88
uJx 7r2?c3vWH3FvP8V;b cXE0<_JHW6 IZKQ) @r9of{-oM%H/s+W $l_+[	<	+1tm+	Fp?L
Yl+i
}p\Bb@e 8YC+1GLGz"qVB``\gf-<<{zq\Bq3,yzK~1u${:lsl[QZa f!%@>?J I$BtRp D
_:"RVXaS
|\>M[S^,ho5'i{#*6XU.'iyvHV9?RfK	
1~T7G3!	'!GA:yJY%2s\ #o%X	SH069zQpZfU/HR!sWAIpse]Nex!O@@|eah8D:j;uqq)2OMZ/5QJ&.P)UphjO;4w2@a)G("qTb?I.gj2$l:5[D;v+dNQ$xpO:( ~1)0v2i.5b3nX[8ugQW(^(E9CyVeh9p6u *WG<}"f=^7bc>!@Sv.3S+>{D#EKDU>nq|QZMisoG1t6zz$qh v.5o<*h{Q3E
jlSgRwX{=GCZ=t*](-R(1/OSFS'omVgp?<`Z$lUu	?KE)$>T`>UIm(q Rjp	n6}$gt.~ i3L^)'8r'zNsXPHH p8+WEsD vCi/L,rQrD$%k1^N1=sO \< BhF~/ sMn]B6 +w }yacJ]]Xz`OJK%lQp9'_Q&]*rt<>7gQPG8<|]O*dG\fdFFh8Z6}x&w2HNG9<<ug-MPZT2, 2m]$*vQ!+d]:rKE<_aibSspw=iluDS{~@OLY } F]Im;1V.G?!iWM~Q=nFpAaziz}w)W;c$yY|CjHUy  AUBDy.l<}cU .79'}P<ajZzn\f5ly udz}F dgQT)>b0 Dw$:zIPk85ZdC$d1AZ_y7}bc *	8=<=YG\y^UFQMCZsh(G|~?Yv
VY|Lpy
5>|5fy3G UQiaILcXD]fc#kTD^>)&]Yu00p5F&kL@<f}b==2V'mrJTL34#8lEn LL1t"5pgu@o_,F]CQnvs<q)t7Ww6M90Bpad-Q~ PeZPvI$H}jSh=@?
2Oj.itB>0;d9dN%Iy:OVh3YE[I=?4BP-u"!U 2{*$,#z|n[gju&J4{K|Gri127x@H-b\;mArY9R^U@-C6C"m.QAW6ov<u`)dA9R&y/xn-$\Hjm8[1!md,%j!I3$2SPFNSMV4cdvC}2fD p 2 K4y2pi~8Z %
@A9?LsX3L53#rbvOia*F
#110v*nYZ-ki[1e?kk0F6$ *bX ~qt#ac~6}`v&5~Ev G& wj:[Hz)y-h&:H'?y<=zf]b-6wkQx#^afMwp9V>X=o8IDjT.pOv6UcYTrB\ u95}	eUn29_qJ%=BHghzm9'W4prg'wA&mQv|-JXf[2fXhN3qnj>F7\P!&o;?xsBre#(mgUrkf&V5#6_guakQ_OiU,>|?/u
dr[U5-JV]dNe^~7.\c "-% X q+8Yc](;nlX:pUW_gE&s$p8<ZvkKemaY!:(>tmy2Dh_w-G~|=s/k;|M?kj*XE?@ /\|<%
 q)u~ukY_BMr0})|Zfl![ %Ge8cm[HdpG9Q'l\fgZ
`I0d"<G5zhBVq2o?r84vBme,sxQ)	[FN#
3N2r:Fg.D_M\{9<.{f;SPq}k]N	9qe{x2}&WW<c|zjB#Z:rJO	*U}':-[KpcGi:xQ!7H85h8Y5(]n=,>jt{=*# ?g*jx5+x<8bGa]@*XUii6p2KE4q	DDS;'>^=Z9f(!x8W62gs Z:,o9;[x\  xXuS4uxWG%[fDO%5F+o4>}z46wp! ytzPdpiNK$g2~]C`#p)GR[#O4)~&'G(GR+ 50?nBnaq8<1bGuG,b\ba=J?Qcx/}bRFKis crjNi0D]';'6fG)$'9G^Z dIUxKrT,nKV' sY19u)[?$
kvdK&{S!Ra60>ayn-V%>iw="Hwlw:gcvW
~H#p[&O4&:q+j.2F:QZUMG4Had89x'T51S/X5A^=~a<4kOSji6y#RTw[+H9 Ai1;^	\7(>dsscU&W d6c4\",1c#[#tc)N.gba<qZlF.`<zN(3o*D@75Bc%~^O`c+UpYYmijC w(wd-#Qm_5}$TEu@/#@7j>EwY
o/_[xSQP9Rcv@=	lW+[uWy ^MkxexD,}jN	5fScb\}*MG<xKb~!:iYi,qisOuugYRulv
!rn30fL-A?2qnIF=x$}Gl@[d #~, nQ<+W\ ifE"{6=JW/~]-L J*=_,WnzvWIx&$x78Ge kedTm!hg|8{yLZ$2zeF<}+N. u>< s F$o,y#L 3ZC<+k(M98\IcmCt1CjsXF<dmRKMR[C3;= y2<VMb*Joh
zqAwi:liW|M,Wp2H^6	)qxiZZM>%&q1A ziZzeN#y$F1J*!@6uG6P+B?:bx*<xzCMf RT'?..Z! >sx=90<RE R* h:HhcL$\w*bXIC.8ggM5?q 
>a8Tt
A3F~rH,g N1;B~@E<c<OM?n n !)$V852/t?jA|4&NVjx>1 f\0l<\N"A]9bQ(3c$qDC=P&7)'99#8}3R?gGs={}"m?|Whc8p7l_)[\r| 7pi	1*u>:8 *kiEo q|"_wWl#](CIG1Y=yYl==|f+!! \UF G;|KCy("[Lc}
fY<)98+k7Zm=698>IX'Qk.Ls t4#Y49EmY\zsx"d{<eI-<cE_lDf.\+(gFaT[E@xH-59X'?:hJY+;ODJXFHnO)cyR	ed0/L2AE9&m.$
\kEdQu V^I^u!w k;2d$+s)mQLI(-D"[=r8AT]";G:xY-cL^%&*Sv@td*^>z1#Tpxd&pzQvZw(3nm6NGgl3qU;}H	-Bd<W4GvwI*W3{jvb:"e@?c36TWwBsyyu5[Hzy$C%ae~g2x6YB5Gq5r9|zxw&B;q>i;?cm0I}ko=Fca{^= ,OU\aJ6?~(T i6+O~1&v(n:U!':LeE.6;azT
E?gJ7%r}Ig5}^jFuS7+9ucLBA7x R| Saxm&%174%]O_z;_]XL{-9k&U`qXcsUH-(WH-@ $xg?CTDed1_8wCh
*}Mi`l;M= |\}8#ZLdep8@}k;K'Y}>*a{)Mi"K(YyVIuwqc{>`V: #+7D4MF6V|[p
sHK$`kQ0mNmH%.|^3kJ^OKIbzdm{G$+B\bp39?_J#9`
}+Shb+R]
[U /4Ez~X0z>dS2x2{"y	}9;IlW6dR={r4+)a^_:<%n'mm_sHcB|8O)>2Z^O7~<2H!=<co|ieJ>b1QM"BEig
\`Z 69fB6|	,+3@FL
As3; k g'IS-``R|Jr'=?ZvRD6UP6Ri]E!1aSN?jVI OP5>yPXk<-.(#s/qh8v'< :t4APiJmji'g{3aklo([+OtFSNOv3:>/TLx>m8~UKs1wbXc=ELbq$ZD$-H()*C`FhSg\GI!>YML:do 8$u_$.{3qK#,,Cc$gOszDZVT\]0: U.Tv#.>2F:\b~]3Dm[v8f tlG4! 
>\b? yW01&[s%^ o N5YjO1EdgN=xg GgWcueguZey^mX8{}28mLtgSc_l*#Z4jiM8}9_F#gV&(&4UW;nP#}ho6wl{kpam\OHg4X:V\]VQQb[4)'przIbK$i_.AMwY9']02>"$3$s"$0>23*n	3ZScvFjdUimg\-I"Xx>'a#x,2G<Kc/}sulrNduLg>F{[iKqVH' 8OK$-k"f9 KJ8V8zSYb2#[)[s+w_rF V`NmuQ\>G5[H*F&2`rO[GR7XkG@XLA! c7gq{)8Nj4<QIo\7[N[c/ (=O_iamwB	A}A9$bETE=i1lwN3Vnx7( @sDvW
[?F1*
No@R/Pbfv>|gFvJ"531bcCU'dybu"4#1	SM} iQEyd8 A4&pj :Jc^^7c~W</:h3J=tEA0	r}SPuM=MQFrF\=DgjNej,g$D,_";OQGn~*cq#Pr<Q
n'o.=[`,6^:H~ Y/AfUOh
Y!OJSO!+;zDtb+5=798IFXw.C#$[Hux1MJc;sE,<]a1um'wkjp86C^9>U	uekw!
U2!%* Abl`p0+GyrzP8jzaWdb`G@"! cd.OS>w:Eu,g|0u@B@hzn~=s]2O99*)ic3vT06qWb+$Jmq,:3"T0X/!f?@*89M^~WsqOD%Iy`gdX]#=w?j{56:lw0BZz$`9n$qKV tjC<gyU$\awzO:)lK`T9<scBK@i%{J.	 p4@x][#;2A:B3>fw&97[Cm>^fo O$<`vbL6SUI3R`dMun7jWs)YwU}2<g};<)$9|&VFW#/8\[Z"@Xav$C;apg<cmqOc$npN99-a8(Ha47vkIA:o^1V~k0Lx=}z\:gjd+$#4,~YMYA(:I	0;H-h<*cd$dsL;=&2 2N3:],3 as+b?*\ty_`uvT,B=|1!H
ArA}Lw;I&uV%O\~_D*w`_>*K"yg1v
F:U|M,9iTz~jY|TJ<}ijr~6uIvS+6zr:ufc#peqlLp;;Xo#9W%pNI\ sm)"-A`|$2?= 9m"$,UCN&^&lmPx0@c2:d5s$I
3Q8P|[ 2NOC!Vi?2Szg$p uX.)UsAq f g;$E) ??Z|(@ >tm<5K2zs.2ob l<ZS~e	 N{?xE$188ZX_ih,|.xAK]>gMqrF;< *WX41Jn[zQAv@l|r-	VOuDK A\8+I(?j^n<fB?}~_%rKce%d#fhA,OU[3phZ8=r(i/(7~2r6xQ '8 :Vl*a$kXlZ`3c@9=a#c<^U]VtY''QXyn#Ak&9Y2|9tUk9]"QTBb}^WH!cn?r8&]-O`Qg0!vR[*0avg.+CsE#*KXHLx_}+HWwO,(WSM	9-<UBFs5CB7O}#H X2-,-1e)%':R,L+;s<xrfyl-Fxj^(.M+]MVSfuM3Ij
Q$_*9hxbzA$t$2*ryLvovxMeP$8!gzzTvfSO$e2a"gMT3!e|,'h$-I- ZQN>uKIFprsR5$9'JSMfWmRFyPa1f2d#v`rNv'iFy R199,< jPn3!f^*9gFcr!kdSjbHwPJF#Y :6/scuv}*_buF$f} '|*Z2E9f<1|v'v9s?`}zP=I:8vB	ji pXIHn<c ^;pY0(s3C8a*5)YWnti$XUc4?"V+32eURp(JbvB#\<DB"=c-?_*}	#H$ \3SWF<s>	j%9	/8/2uzR8\ qE[#~X[ aTHW>@>zYE,HR9?3^+8(a,m*Il?W	R<dd0^'T r\V$C*@%|O  x|t0GNsZ]"c7atA\19Dq*gd;@'`aMWN b_.z'EBM@?rAo+`U]e;U&tNpV2 g]n`@ Z~Ap:m#rzig'UIF'"HQAEJN>Ck6sp)rIP0Q4uh>GAsJ`X}cO),aD#>ljllk$!2zs>UTq 7U^p2>uJ)<$,Aa0:'?*5I	?@=1*b?BX)dtZ>-3E2orH3@I9R Y9-wWE+?D1w;(TF&0(l~uIH%;\~C".D2$P+P@Ho%19ahQ<TP6H=z%qK)$@Y" #z?*	ogLW?"]F LV=9RHN8Ux'$9(?	G*I{Q1xoLE'2Yqz+Wb[
,	=89SH "6fDBFtm=<T
t 2|do#d *1 @J_nn<"3Ns/>u;8Uskf3DT9'<CX"rN	TS<GpGVS?G;T|O({TVm*U@A#9$9(e)#.ci3,rI! IW^:bf4{RB,r1 vw6l''<sKd#)s8VN[{, *JokaX,yTojw2A xINE w3}:by!| UnQ"L1U|7vP}z<k>m1o]H $:d:)cw! $ ^dWQE30)2REmxKq8Q$b#fpxO g 	I<dKfb6p:n/MKgMys!td,jJ8VG^{1oko-Ub0YB;qr|hJu$0J'.\X[;2yV;$yYR(umF9*51RcXz#89>5M4&iS)H><&5p]A 5H xeu-5Z3wdc}yvS'`G>p8NzrH'  <U|</<&A:wLrFq,W^06NiRIn<Coq<yK(NSL-g.^ $W8H1<]+==+T(V"Prd?8ws&R|h7gf'sZ>%|ds#9:oQ-Nh d|ponY&zz$y`prs
[Y;(Hi6TSh	H F>"kX~"8GQ26|/:t*L| J7Ci5r:aXUL*Gwl)A$B0FOO:.<gfvWP V;U-JR 3q<nDnJ9=?dHv7=zV&w*7ho"- `=<,*E=DV29I?#]),	'Orlq.faG,kX~lq\B)IS)b/h  g,qX}5Om %Rf+Y-b"[>*Y:	{Ps\Bi[%`p}[81Az:Ml;;'Ft1^d19$ZMo"0Aygt	Li]Y-#HImBjp;nxC.q]
5Efk*3'q,y& yp=ds:&)%D|e/A6i"m8[8/#hc=$MBG$G.Is1T;J+2]sP4Mp6]=y'Sm}kq!h4%JIlLn$y8a}k	2A G UKqkYhl]gB-qVQR/IIc9HZm	XZF2!]JyyVNQ+fX:.xU),\\XNslPAR37i;?&QAvx 7'*3 ?QPgc"19bKnJ0c[iXdydM%7$Qvse e#uI_x"L'Pg:5;ki"iaz"76vzd7[K
AYo$d.9n=8bKI/!H =i+<GZhROX&>|{>#a%.O.W 6?<kWUFYT{?bxi<#k/s *#P4AJZG?gygQX*	nzKoQgr>22I!,`K+TiIb{!K][j3zL7m'	P8 ^BrG:/*4.@ 9RUt}OpX&5 [<';`*4/x4A	d 	'qT1?TQ=8UzQai	2vR</xqm+@@^$EtR\.[ jc{cI-.4g[j|,Cm,9Js3A\\M+Ln`g zx#[lB^KO-cw*{+*6
Rr]E8clu+ t
 f{)e].{6w |Drl#4"A@	G!I`O\Z/2]1'+&ko0|Jxz*xIgb]\5[^8*z$2pJs*6hGwCx5")e"&XT{Wr|JqCSx(opgs,dn|q^#Es_~;{d3Q #'^$NY
 2=M:J"fQ_9:1-\e0
NG5B4AhPMDN7OA@ w;X di11CSGAz\T$uqrE:jqJ[~rFvgV[^77W_
A_~M5p3m'8 }&#'B-ZKrT(A^4a#z\evn'*}3n^B]1'Nr Zy$)l	-/O!EU{-603rjWDJ@5vToniZ%1uuOPFjGAh5p b1NEum_t]F!yUje$`<' s"DgKdhI&ePG}zY']w1R?M0> *zf_nC2z[k
)Tx6RPp+4,6d0bcwrx{Els?'v>^QD!'j>VhW?E=Dss}.uA2##SQ`zZ;)$jF##e%R -Z23Xxg-'(nC*RJ22bGq(-	3S[pS{u3Kf
;/n7`@|OHO =Y0Zu(qjD"~-^}^A sic/"$C<B2?:ss2BhV\!UxwQhS. >9 RxPYkK7fD5jh}@s~.2 yNA)x+Da '%'q<Cj"hl,&}*)BVxlNwkz#8e*&2z6x?<Q7"vRSwh<_F9zbi? =jGOQl<egf{ImcBc@dqL$=mB(#TRn>Rxf( Gl!,/?sR]KsLtD,j#0lqzTWE-+ pGPsFHy:[X,~y>PXcI[rF7  lxWi	QsYx@8.d#JEBnI<xkJ{n-"H|/WM51<$Q. qf }G=NU8C$OY @Xr<9WMS0un+jX
YG@ypOOZY4SM;]-o(_*tw;esZNecA'<QW7%GI5MQB{XqNjX zkkr7c5+	;h,J-a+zdLNIv<-&t8:[H\-F3TwaI:F'fOgb}Us }PCqWAh/6"8Tcz^#\Qp8~&l?*6cM[A`G956jSp ~b7gu+nHf s)~`+VhVS
ky Wg?]/cs\-bYTx Y"8=)tLor0jySGi.Cw1q c^!A\<8QVQ@u;bQcZd4	Vhus6H8~T?[g{CmlG9Wvm{bDYqvYv7dyTTr\:J~Kt>RU4az)rWb#;?pr=	UVtk\tE0{W>/ox|)2m8\aO,q[]:H\qxUBtK<`	k[+9{G;,g`qXTGZ:;szRw~_q:/vY U MFgmv']|5/IgHeQyV/Bfp8h9`,eq*;+%eJNw<]3s*pTrk.q$ji`js8aHsi~y}EDuh$*3+9P\J$hfC3}@MEied,WVHW Sgmu<
fKa[dk%Y%xd28*e8se>=` -*C\!{#v;WSK+U(bOmU$39
8jWEp|
Lb8zAe3c q7H*|uR?!.p5.\4UeuU}2CR o&6kpT=
s[ge >gU#$%+TvC+63]u/cIIcAU2nOv+p x(w|==)oQ+ _]`0d@:. nk]i6Al'sI^^5fGcx95[j_7qx 0<dsRB6w@@BIw4d79U~	03[0v5i' 9w0%H8>%h$=PysLVLz>6>\;cR1n<lOg=qza]!?	yZ;+WVd'>1(r;m{MNV$a:UkieV B(99zv
4p\#0*5z??h;$&1II!b IFddVY")?a@xNzj{L`+g H =OO*w.G#$wt=1<\y#G8e"k+htNImQb_,if,ldK!W?h1BX=^vY$v[s
^2=i(',lM6Wo?K/L3s/oxhC	1
YOpx0
\	fE=	Sf2Zl1 B913UlO O-NF
$oUOexT=j8y:^ jeYYtAb6 Akn$wNx4{J:jz0nQQ]WRrc\Lb;-8.{{'y~utooE;TntVMO]VjJer)bP@3H0")>nFYL(1W1h sqG7LW}Nw*%lwb3k/4:[I<xh$.nif&1:<=Id+HB1jO}s6Wv	2E  )\j!{Y2'.@c[wwNr6V%uiG&E8sf{;x]:yM&'V(IK/}!02p1${zmogpZ/hY\adZwrxI
R
2s	/n1hc
i\My4G'qc?iL
Kk|)q=}+38q/fK"%o KFNOL1<kZpUbFtx5=-d||\~`HakcLuw)om<vn8[+E{{2L<Fv@[Vq&' -`Lct6N:hvlv:tw}dV.Xz9$rkwnB
YA8~_jx2}FRxd=G$t7"'5THW4Rv0G4x$HBQMB~;)fN8;xVis(CG#-'x[$E{sH/v`(.VNdte{Y{g&B mgi-06+" =+W) ubi$UUsr)WiWKXrqLoeg]<;Fs^^rNr	d\4BxF>|`mcwV1$h4r.m55P2~Df]?J0]|hpx*@JuI:WQX] T=Q #6d[dP3vit',b	C.yG?cO>t_n p v@=	JKzr98^=%QqH>T`zS8edfVe/+;W<{4YrmDk6^C42o=| SufKV I#Fn D($
 x>tZpMj/U>33L!*wilh5#*RH93&H	Q W~Dw< O q^X*F^r@A{bonygHQM
A|$m5Qne1!(}f{
uEx#s=5qmn#9?[icHu	Xs!\c|;mC{RK$HTX<5)+v'Zg.qKY[	?|1_z.w.J#)o$1L%,Ha>R<<dyV\G#8O\!<JnY8dlw<(aUp7}=p8Nrf(fMot"Ei6gzrGuE3RijA<<}+?,6oEPGE|+tHlR!U`5wcFKMQrpy4-Aot#0J&je0T.+,F |j*KBY8RGCQfny<qZ>OX;$;9>,qk7Y,& dA##yU`O
O+\GkV$L*SD.U~xUTN<7rOSV}yEsc7f[k sm6n1b?>b}K#@p?U#]?y*Tz9vH ,^LFiQ7eO\Wvxr)>x ($B,Q[FWL/L(?(IY D2:z _jNpy:Ockw\?L
rlXtnKp~yq~S5~;@?KV.~Icv7(cBW >[d\/>|bq$&3^C29t+*DT.7yrf% f+3Uq-I` FG_#Fjv4{hvk1-x	4ul}[TgnqxFqd\@ \u5M)COPUq?*;n!2HnrV[%pY4U^k @ t;.{@
#%mZs1 #oaX]j[aT`8 WUQztLn3ON	$]A=N<[iu<r9v;]BFGNx5[jr3R9e x6HS?Zq+m,<}:SW|PM9XU	>	r0rJ($AKoSe EreE6FR7 S]u,uZKo#;D8#+0mv  '?{#Fp?h!!3 A%{<Jc|=yU~2Bq|j_Kv*8Hu+tx?OnN)gYzsz VOL)>UB6A3UPb0=q<O(%^xNUsdp.Kd%F3K+ bqukV<C{M"d9_j8q FH|}:v2F6VPK}l\AqJb**{?#5[s$|`2x\}v'N(e J=FqS" Uu8{J;#DpInYEu",<]+CuV@S>|Ct+0"Q
8V#@}+A	8qDI!RIIa3L2Bw2jP(c}x3R3}us 8!I)7;wJ#<}^j:}K n iw 0gOg!b`qLS@Mqm{-Sizmsup}3HsL#'T'A0)1:6i7)9sH%-\^om [q+>~H<*%|g")~f*I@ 4]O	nA?sxI 	0H$ujK<B=HmyEB1~Ugb9H=pb'$g`=+:nF!y@VZK6UutSB-dM!oQp;FqK9<r"FLds]%SoF{Eu}]**Z?GPot<5/fH\\ crf7}Eh;)d@`LI?LV9j.[6!|lFKSFQ8$UA10]2zd7k|?.
j^#'*7GtmV;G \1
Em1A"*,jd<P	?z
"H6Csd0Rg8F1ZHUbzK]}]Dmu;Q[w4nH$iwx1\KrC1ZW6^1[.wmN_2@#. bLN@8i^^yA|*FU`LNQ szQQDHSS[L29	\dW;8 ,Zr4Yb0T6:zi$rw qI#^NBCV4S6]g&m2le##qJ^x:?R]S 9P?C+`"`mv9\#jRF'? $'cI|,7c~Vea;!T?#$OT24,HON! xs#x=k>vpJ }@UD0Vy5kB],A'{$+q9U2@'zG,$pdX:M
 NxV8)ahn '#' 29ROt@6y=:4Yf.hbv9 y q'm8O c+1JbGW
1QGli1m L`}t~8g,%cs>_H{<HSxGQ_f9J& Pz/=GgX|R U&v 0?*  z ?qpfuYI
F==(P5ivG Hxa8`]z,p";ls} we`|l-/:M?X"KC<)=?aB&H3<q^xns)JaDe`wE8?:4ZM5R\Q"A ~w>"	%Er8KixH329_*eG%2TgB_PS#:<6&i$TXG>X3-hAQrB4!YyW}HXr%G_.7HH`<k3D pV\ YI. 8~juTL"*R+QQ0k'QK &`#D(1=@Qj_#9 R(*sl@g+7+^7Pv:NnBD=um.+q#?Z)`\F8cK;b9>3`&U$XZEBqYHfGI$Ua n}f=,LpB ^C<v#1`8ZjR4oq6!?$rOSstpRK)l_:|UR5W#Cw[!Z{px9hv#MI 
9o?t7e*7w]]vO'5kDk ]f.z%l`	Y#=`O/ejOs;;8GS 8]8Of2A/ 
-IWnTu$ ] zW}*8<>kU:2|po$$6H'8<5uPD,%q8  F#$p#@x
T zyV)cZ#{($Yiz}j3.w\U}$}'9s/T[\$nCwWHU$ZjUO:qQmW)K~6>k+TU,1DSiq/D*Faf: T6zF .jCI8`gL+pB\o#'<z1hn9Y6<,sb]uZ{~o~#F}FF[T+S@Lg0pO4Dl:`0U[p":Tu@\ H89,	Xdlt#~k[g:I;Jb)dYoi]z'b.i !}(<(Fv .<+F&
R8 yq^\:<
uuV&/shI"L7tpi$ `qq\]*'Gy-F69'X6kT~ZFrB2:{U@;Ltq'$ <=q@,j2MtQz[?a|J_XA_.@HH=yB#d/JJ:)tLW6yJ5H.IZ1,as6bhdm8iRN2A. ;_<2(es8>_1My7S?fzzVMGMqN<cA,gV>{U +zl\$<|V6s0J+o(B8``p\7xxO9N: O^C9GOYMhog!Tc38;)2*S13EZ[w.2FUGZw`C.ZuGLh^9#!S14>ql;
764!#qCn..W>HIuy^ $Xt3< e9[52PU{*]#lqJ^^GAyxt^Bw9F0He,7!8J]LjdI|*xY%(&4.
_Y],{I<<s#ocU2Xzjc6R2I *G:[[H{c J{j.iyg#4ZkvH@wwk>}i(['-F+p(~|tEWoyI#	 $!iuyWcb2>|61O87J\eAS55VzmdGpAIig2f=>X* <.|r/*TrEr{qk.v#r*Y"6FCcm[f3A9U* VPGQyYX7^Cku%vrnWx<|Rf#/d+h{/IxP#V).
C1IZpl
h8TcZX';w`uKyo4]m;'qSMvY)lqMK ;z	l[8`qBur6@	uq4P0RN~tt7v-PC:ldp>XNr>p]R{CvuS<#/F_A4Bu;.1"2.=# 7Jy FO@}kU9U\(n#m[I38 *k\X.f`ft<VWjpH:imlqU!epX>
9Wzen& 39dyRv`,==~bU!wAk y|Kch-[g>1IBk`7n5f%cis2nz46rwIb6*s=sJ |=)1\1eOYv(csr8I:7hcY8?z81c'+;<D0c1Ss\7st 0~gi5g@i]kU}_S[Hw9d$ ,!sh; =F>7!b(@>}a&l
o/-qdt,,vx?gA2&sWje6iqQ/yA+fvh	?d
Lqs*h@ch>mnoJP
'f&P{ 1vhQ	di<HC>{JZk`<zy{<NI5>`m&-
H>-,V j H>#LMpN`d31'8rQWe}Yd*N
=c_vyM}cc~~tU Vys*oO%1R~U'?LZgF^pq(N<L*Cp|sDv63w8u]=;y99#
)sp*'k:-3GJ`U?HIB c$uKF$eVlzuE/cYc[<-!O@ivv52S,@C.S F`Y7Kjzc *i!' 8|$$mes/g+t9 1#\GM2F1xban3kf5VF|qV*9ld'lyRpIvH0Q'sW3ib34F8>uECx;)TK#Hu2E(VE<"8kOmCTSF$qa]Uk;!;nws>YUH.[9RpHn%H~|<<3G*R=?uZA CyG&QWFXHae
N<\\.
\n(?9cf$gogvV9\TWf;/ 5oHOFHZUD@200x&on ~(w
>{}g! TJsF]jWL#O_:vFNYX>|`i$ VwdA}WTm4f{;`pA;xl"n%sSIVRF<5BN9ST\r^]$+=	p{wJR6TI92["rq)1!awefFnjT]8T<UBAk(wO}}+:(eE~n5/d	>5n5 X,,8='TSH ){SZ2]Hh#fnT wQgHp|'<^848C$mP(h,
	Q"O*vxkWA}y\ArOj91GjQ:Y$Y G~D40aI?LVx$Q<q?[3~#%~UOs@5fu@8k}%[im2:
|+c9=pAYHT	a!%kiQ%3Aa!A?<})$j]7/;zq>|6UF!9V:.ww&J9hq]GwE
; Xg OACO1[nZf*c<:~e]0uUL"zT 3CgI.-KZQ_#~]g5w)rmq8#Qoh,/kp1,xC+RU^9 o^@}Uj65W&Zqohl-m@vTIWu*WX74G#/^_$|;5PA^irK[2U>2vEY-a E/OfxAlV"3BUnRw?f1yms(	x.l#1U!dl@h]{k^Zu/GHx *CvX`
MoDPxY 9||{39RM1mGT{-^u(0cU8 *&	 |
\L1k s56zd.m[zF\h]iST|Y+PE|Dn|c$>ZoCx9.u bm
RX16tvsRIXan^[pU'jCHyS#~
L7:d,H}*7;mx  F
[#B{OSTg+4O3i5Vcx3J@--rIqUP~U.cNe99}Kc9` <xIr % l{#`%8;FNJo~%JaCNC` m/egiyffW[ Ca,!g?z
IJSW:5  3R]>11;{R>ei
6~)H"TtVRQxH+sf{/^wHG"5U7gH`q)dyDv.YOIz/Blw|<WUk 'IZMALuxB/sO4ezD~\-0 3Kfg$rkY#rW?!Xv :Qi1*B~);O9I4Uf}wSzUoH6
 ?:/.Trme`s#xCD9$YL-}?T2_I3,@f @Rr<tMkw|o`^O,m*$YH$1ikdNlU0[8)p<-5/OOrs*Pl1H=+1|r?$EriS:k~e:yBSd$(y#F30 >qi,m-d$NzR 5dq"q,r0e\_~>]BmGJ(qNVx}j\`fM5txkRH%k8m-=rg>M|7E$~R`n_KSIX YwNpvRe
zytB9''>KyX!B_w<xBP0uJG;Zb VTNGs)k.OVIO$8zsYUa%(8 z<pxBZ3Nxer2Wt:\<jU]6E$O\Q5FF.'OWY984+CKMUgKc38DH!uw\|s$+>4g	>TZOz+sa*F.7 uTm# y:P\ Nvr2F:lhy,t81euv]W[q9qzRD$Fw* R2=1R0;=x K|[$WSW>Wv ANkwW*>;n9)f& J	ff*#'	hMb$Nj1CoK4$!<M8khF]at}R\coh8}:zW8\X(IcExxWUwMRCh]A,+r93IOj@J[!@:un.V23!2FFFEI5Hv2<satgf7CGg89c&"M19}kO/idRO	$"!8>5qZ'g,=H8u8&++FhMq,%2)?.8>Dj,>"VMe#'?}=6c}~b#N ;{tcZv-<w
 y8CAws) EA?D]\OiqASWG%[ftrPuNxAXT(?hF+UXdz6A=JF0>Y9j8LI8WElFdGwBX%3Yi ;~[Q%\w&r,EpI9>BGTr+ d{"F	b{W@"${n"s6&8|gzq<e;US<v]!lR@?va^4iSrgt_Oe<C3SbdmgcBz&I6
lk-P p>^"'oeU,6A.9>Fv;]tAx	?,\8Xgp8i:D/"OffB'g.]tC hMqQ/QH6unsa<nh,=1b>xGOy+Rq	b\R3|T+Je|FE( #8\9!;\j<<`
%]gqh=;0A=3Nns)Y[;e6zmXJKFqAgi{H5^2??*uK	eAO{;iYKw{_jtIG3|"_!}5fx 	0r+)LBw7?kl*9Na(x''8Lnd0',0?^}8oJJ-$nHd0JaOS{t?:g/ V[ooQ-W/P^wKHUstEvtKPm
I>^`5L:][+t|4G[mLwJH{9#I kTyW7%t6(  }(cW.][k^O3 }Bg:p-jS(#5	&%r2OQ:0f pg}vZlKlWh}Gg8:Vv1#d<y*>#vP16- *sAsF}K..m<$9_,$gSb-82+$u9<g_GGXki4~r\\/Zzu5Mm8?<R~J;,L``=9Ea#I+L!k8G1z;=g2Zx( .H5&;|a!Rg`Qec!'3ZGK}&)	|;>@^09)h{NY"wA
0n9m=rKx#m8R(I.do4Rb *6BP$d3XzT"]jP$&ZG+^8)9Gz35WyWA X2W?>Ug +XprHTcA c'~wE,&5ASh$v*mE&`|B>b[Y ~]j9$<-JqA  e-d	!`si8<]o#0&2 p
N?$^MdnR$P\!	T$Q]X9#.Fz YhmUqxrM
0n:{o ckfCC>,vN?\U#!erXed[E hR77Lfg{lSVQ72:WMYeRZE~=:41#XCjfh2(G '`>~$gp08KWa'N6`>$F>ipxg4UVYK(0 @zY;BqZ,!RG?\S-$B"ro`[{q	tld!R"19O_Z`;7a{.0%w^0u$<$g*wcHnZPT^vCm
V{?qX46V;b&00|'<|`7lv`?M/Pt+cwunn#Gy :K^D
>2Jq9-M(QPb8T#? OK[gv: ]z;k\x^$ nWvf2#Q'<j#27@kwX1}Q/3S@i+;FStw#i_]$2FC)NNVB<F8yXH4L)-{MH]X;ip/qf|+>[Lbc8@db%hQq=i4V:eZ1^ z ,0<g51VN  O\mT}=e)weBcc##U(sMhlel9P9},m ^[L}$IkTI$p5:cjZ\m@	ca[X"U`{'cp%'$  -/f %H_,r/S?U+oj[:N0e 19?F/jH$-mt)sMu,OMMunFU,vXb?YdeV==*PQ8$=/#pK@dd[ , #LW62=2@7r;ce/'~t;3/"}(a w`>!S'D&D.+
l?zL]D!Ns#Ny{+{jW
<n?1Ty np$oM4*)A{1}<ciiqF SsBLF6YX;, 0tzm*y==(cl]b $8 8Au\.&HAxGZ\wD^5VV>JS%	nF)[WSmsw m8k{3$7B0,sQv Jrz PO |v.T
?*;+5oxN>(;+P3:2KgV9c(kv5gIK|pvUNZN%s1_7$IgIZF3rerOchrF"SR J7)'~TdC 4N'?#V%=>Rn<!
8'v3Z;im8j$d);q@#B2[Lp38'j9G4,K93I>?9
O^`SV2v~S
	RtZ7s!T2{MEcz"*k(fP?nWGc.DtJ; Fg{vxpNZ&l!|`gsW%'>.C+u4/q {]$*E!$c|t-rFtD
42HwnB>VQ'V"s2Z.il_.~^*[P4D&
s]NbkF%aqZ^Iq79fbT6^}(1Hn?ktRJvPnb Qdq:c[y`	}BJTgsW;$HG^JG,Q$C]6:+Eq26.qGuQ$g@<$9~>hCGEX^x9^/*  -_TV;FFH}@4gdw
 \ zt]\k;R=\6+" :rcuIt<+  b	tXOl2I{Gl%BeBAOiOy$Qp_8\<1#iLL(pzB  l4
)6$uA$wgy1@1 NvI#w,,"O9<B(|%`f*$#z^IW y6]Y6 3q3AFDR\1Sur\g9v=3TOb-wa8U%+0
8iRLd$q! z4pd<*/xYv L%o"YESlut-sIlBJ1mxL_]z7'lSZkt|U(A<p~~{ayq'w+7;<iZpskn& 0z1Dn'`+;%W>`q+iFo-~>#_K$7v%%G5p YUxk9B1%']='fa8Sacri u2
!=f!rs8^WXT=AF	i6+=:yP%-1*kM@4)mVD1 Jq:CI"LW}:.2"byI7A5+i(	*C##4TIvp@!$_xXKEs,7p	xN1Yk[q$]jnX,@=#>+)28s6X@WOj$oETe`?.07/I2Gn$`1VYC={0tQ
 (gG^`VeKp%BOSU]s\[
+HrOjIUnB)[r=2[8#E*=vQ9wS_BIU3]+%93IdZNq6bjn+f2C<q#:P"`x#]G1QJpy
osC`	QsT:*6o :;!&sUeZ1</#Xz:Yx14rwzUG>VrG4O>z^,$$#9(%W20"sgQONa5r0p| " }3g%sJeXOju=Z_I,<AH85w>C2Z79xlxx&	F`$*y]!$t'99Oq[$K-xhrzR@-&2'NeAd~<TIlI!<O +CA)B6I(nH	Grz
pE~5(qFMs%	r(j(q*@#_],	\O#h;|rkb|jI$I6v+fb?Kz=$mc)N;u'xlv p ,};~DqwdukEloD'qJHdPpSy}_z+U8'w,B^1,sq5&f8qCn,srGDTyUN|hSR8/1F{Kvo s{iUBH7a=:Wq)c`(8:#~~)|q6
1,X #Y>{&M:6
ecok(:a#`v;LbU@\9{)J\&4
#VY),~.=}}2Vq9_ Z-8QV.NA`~uz4Rp& 
k[f(V9#;my^ k.+.m]+!4,c,6zg(z\LgfwQk;]OhZ3|7'p2#i#Wtvr8~cZ@XlvBS~3I#[-XILx2TXU YK<'w?^0r?]`y5 w8]8Q
q,
Gt`% Jr>:Y&#s%sONJ99<buy%Z3>b_<TN~VAxBx~UC{6@'q>PR1r)ba##UnrEI&+O!79zLHx<u$H(IR=  	ie;Yhempz9	,su9$sGJj(Nrl,M4=i6aCS%2<qD'<qyeBlc;{neqfN~y*l{#ihi?AEA@;$1aT:y(bV@DM	
"GnN@WSF Q2lF>VI")4R>]*%$`e8Rvx?*;2p)2zF F3Gvn{
`0bA''*T=O9?L;8qX0xd[VyhP?gAlu >p^4%KW}/ho?1hs:I
dB1FRY/
44yK}|'|x0r1(o/kM^x-]OvIf|4/<3>Tw\~2y;IAcp n#k{PG,xNzO+j=QyI]B5V%3(OME<D	AT[od1wRH?L^+>[GO@@O~WlzU#q9EvPHXFNy*G2T mj$[<'_RJ7\#Qgn-A0Fsk$[A+NAUqWYc~-0JVnNK1s\vQd~qIV|?B0mjmy>'pP4T?:URwAL-RP?Lu:{RgRD`qATi>MRkuybL0N@ |k&E G8?ATF'=;vH?vRVF! 0HfSZGRs.2m:f#nZI;[v[qXsg(AIaWO]b|O#R'NPM<iY}> CuSm$VX1w:T9vSiiWesI>$n`sE'F4nMn'UXBm+:Hcppg]R	e%/vI	?Z);g3[Y9SAJ4RvX;%`=?O?bVHm2(C}p81fjQ{e	psw~.8ORMgVa>za*{U9@<W=ngiu6G' Y;L;hE{K`~l$%HVb\H{yD%w;;~EyWPo@ Vr@_0/'$O(_;]ii0}RMbh$R0dq5dMQGhn=cVl?c?`hx2 ]/c `{~cjP=z(+k{(
39Oqsw aMJ 'Dl? +-}'Yb8I \2 k.m^L1;E_sZNnnB0'p{1Raiv%y( q$7^ 0rH|zT0/k"Wy e~ Zof ,}J [eFb8S?LWW?j&2hOd bjPOg.wiifJTx`Oz <is*5Y H?2OXOksZIpJ%si/MKXl?#V:Tl- ?cP5vKTFm}yKv{b#$?XoS\vI>k,>lTMX_{c w @0icykR7-vi`yj}UJ Gu b5 Jk@d;EnK},7~u N\B#J Kki#OC /m:/o= '?Z j0KzYnY.ftP"H^>9 FRjI7_dc.+BkDs'-f*Q5K^]LPU`%G
Cm c<	|K?6OekMEV^9o.yyT3I?lV?g4%7 {c$qE$gYmR?^,Qcj$!+jW7riGRi^\}mR9V{4MwpG@G4bW5j0]wvs yj  %9Q,l@>0+pMoq1OU'>z >[X J4Tf]]E}o
#'9Ax-RD}P1W?s1mf|Q *F^MvSGQ T~W [UYYi6M%Bxop'MvQ9]yJ}+TK m
 ^j
I| UYz7\x}0cF +aW (\/F9vPpI$~_gVFkO,:x {l YiFP\gcdw^O_VYUG?+R(5uA&E/jc[ J8E5 \mu: YzgCHms*;uFAH-o
u(wh-n {qo*A2 Zr`'\ UYYxfY?mIc# EJh1+%?'oTEQmdB7 g /RCw#vUb6j 
7 ]ot ,6# JWwX??Mj6Ga??bV]~M]^<ZX9 C7mumi *l8oFr %b$\lz fQ>?fk_&-4d]1h[	FCzpejSA0YnQ?vSvVRf?;\FW0mLFeQ''$s W hZN-# eQX?U05bMPsV^@%jj[!A t /YnDX3'G# n(I rXl^ hz[Yn n5<-mTp2ic&u+\zlo
VxwV8+gjL}H<rQ*{}(qi *505n3ofq WI)
<m Vj#;hn5,m<#rTJ1gr~RJa	RJ *T	RK8HB
.qw4DydXVwbO@2eo%-9$`s]i7zojm/ JY|CG   mhJgoYvS_
>_fAeL=p TtRnJdBz:~vmnu?!M $O5vvsiRBhrJeQpI`s@KMqOs-|>[ClzH ?'jlC(!QP2OPR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PGG_IK*qH"w7sH	4 J*PR Jv{Rk+n1w#nQWK[m7f~>x Ji'fh5p#bT.
r9# WR6O!0)=9#1 t-lZV@CIPq|@
Uc=G{wD	}F:n{+|-D qlYaO~kWVXKIE$R[&TYY)VS	RJ *T	RJ *T	RJ *T `-z-snG* |ie#W?+9a6
O,|?}Mc!6tO'[v{Rl	8Dvc' Y%F3N  "_ / [Q K}g /}aP H;Q6O"Ae-]nVGC<~ h=]zIay%qqhm3Mm#$@::u -cy06>eInKEwu`WWAVF *Xx 8 ;   /G?n-6AmRXPT *7mo]ho7v#/ *5? J6q j(U+YH?s oX=cO KOoX=cU W TJWz b F*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PBm0Z3,Gj5MwR]w0 w/x_!Nk5(WzvBuvNBp]zI.mUc?x@_0t-Yw	R6G7t{[gh>0]nIo$vXq:v{ 4J3/F8iE%TKjKgokiv07,Y$>@tP>v:XN1d/lz>DzN]{i,t?uD@ylS  1?jcO_'ok@Wr,1Zd9t,A }D9d'D`pCAcKyn!R<&vckt5Xku<|>2  |kXR4(a$h
$7Zh_Zu5Ol=WT/i/4>(-)#n1X;W7M=N9<a>TZ5Jh4-i++{$oE0biRvjV4^$Dt*\R(TR%J(TR%J(TR%J(7#[ jJ/rvUk)yO_ltOP\ys2;mj7qZO3YHsxN^kYR#OT!ydD'G@: -m W jY q2Y#QE'Ci:#8[v@mi#@AWa}>2ivg1Qy?Zbzk=+..%noV;SG3$YTc
P?l;kWlmy8^BpT7F`1p  g"_? Rm 	O3qXW5kFFo6,rSj?  `E %?kS.={MyN5c G!:N&Y!Ec,6<D   jO8<( zvF}J58[4bE b,V=Z<3y 0X+k
FDk~sjF]_LxT*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@K,dKI&TW !;%ru 'px  [h:fE]m|ry5eDy6mtx}BUe;<yNGvJ+-vW lGeOJ jhEzZIm O=^mubB:<#_RvmV\B1On4&;"dp~E?* <{-k9")2B8![YcZ2}O-i6}-ioO*'j2vGR5X3Mb5c	< c)){I]is\=N,LxJ1hMa]/}/jBQm>Ups)o`MQ\$)ep?bT#@"oVBTJcFI<_{MG7~ 1{ ]7X,,qnGN
99s/h5tv]J5-TP @$eXX~Ffp}k>9KA$2u*Hx$DceHuz-SI{icqOhvA$'hcim _{i{Zerq/s>boL7uapVbHGm)W6\Gr7>yk+[Y\N!*%1p7`q(~~!Sy_x_c}g?GBUV"Bxyh.rNf*(a29GRyZ_?-l*>)u	RJ *T	RJ *T	RJ *T	RJ *T	RJ *T	RJ gOkmF&&
kvF)Ff[G
>N67s,`^G4 o  kQIU<8k_w}wM^Ms.1i*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@>-h?w,A8nY'#v=Xk*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J