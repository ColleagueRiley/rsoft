/*
* Copyright (c) 2021-24 ColleagueRiley ColleagueRiley@gmail.com
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following r estrictions:
*
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*
*
*/

/*
preprocessor args

make sure 

** #define RFONT_IMPLEMENTATION ** - include function defines

is in exactly one of your files or arguments

#define RFONT_NO_OPENGL - do not define graphics functions (that use opengl)
#define RFONT_NO_STDIO - do not include stdio.h
#define RFONT_EXTERNAL_STB - load stb_truetype from stb_truetype.h instead of using the internal version
#define RFONT_NO_GRAPHICS - do not include any graphics functions at all
#define RFONT_RENDER_RGL - use RGL functions for rendering
#define RFONT_RENDER_LEGACY - use opengl legacy functions for rendering (if RGL is not chosen)
-- NOTE: By default, opengl 3.3 vbos are used for rendering --
*/

/*
credits :

stb_truetype.h - a dependency for RFont, most of (a slightly motified version of) stb_truetype.h is included directly into RFont.h
http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ - UTF-8 decoding function
fontstash - fontstash was used as a refference for some parts
*/

/*

... = [add code here]

BASIC TEMPLATE :
#define RFONT_IMPLEMENTATION
#include "RFont.h"

...

int main () {
   ...

   RFont_init(window_width, window_height);

   RFont_font* font = RFont_font_init("font.ttf");

   while (1) {
      ...
      RFont_draw_text(font, "text", 100, 100, 20);
      ...
   }

   RFont_font_free(font);
   RFont_close();
   ...
}
*/


#ifndef RFONT_NO_STDIO
#include <stdio.h>
#endif

#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <string.h>

#if !defined(u8)
	#if defined(_MSC_VER) || defined(__SYMBIAN32__)
		typedef unsigned char 	u8;
		typedef signed char		i8;
		typedef unsigned short  u16;
		typedef signed short 	i16;
		typedef unsigned int 	u32;
		typedef signed int		i32;
		typedef unsigned long	u64;
		typedef signed long		i64;
	#else
		#include <stdint.h>

		typedef uint8_t     u8;
		typedef int8_t      i8;
		typedef uint16_t   u16;
		typedef int16_t    i16;
		typedef uint32_t   u32;
		typedef int32_t    i32;
		typedef uint64_t   u64;
		typedef int64_t    i64;
	#endif
#endif

#if !defined(b8)
	typedef u8 b8;
#endif
/* 
You can define these yourself if 
you want to change anything
*/

#ifndef RFONT_MAX_GLYPHS
#define RFONT_MAX_GLYPHS 652
#endif

#ifndef RFONT_ATLAS_WIDTH
#define RFONT_ATLAS_WIDTH 6000
#endif

#ifndef RFONT_ATLAS_HEIGHT
#define RFONT_ATLAS_HEIGHT 400
#endif

#ifndef RFONT_INIT_TEXT_SIZE
#define RFONT_INIT_TEXT_SIZE 500
#endif

#ifndef RFONT_INIT_VERTS
#define RFONT_INIT_VERTS 1024
#endif

#ifndef RFONT_TEXTFORMAT_MAX_SIZE
   #define RFONT_TEXTFORMAT_MAX_SIZE 923
#endif

#ifndef RFONT_VSNPRINTF
#define RFONT_VSNPRINTF vsnprintf
#endif

#ifndef RFONT_UNUSED
#define RFONT_UNUSED(x) (void) (x);
#endif

/* make sure RFont declares aren't declared twice */
#ifndef RFONT_H
#define RFONT_H

#ifndef RFont_area
typedef struct { u32 w, h; } RFont_area;
#endif

typedef struct RFont_font RFont_font;

typedef struct {
   u32 codepoint; /* the character (for checking) */
   size_t size; /* the size of the glyph */
   i32 x, x2;  /* coords of the character on the texture */

   /* source glyph data */
   i32 src;
   float w, h, x1, y1, advance;
} RFont_glyph;

/**
 * @brief Sets the framebuffer size AND runs the graphics init function.
 * @param width The framebuffer width.
 * @param height The framebuffer height.
*/
inline void RFont_init(size_t width, size_t height);
/**
 * @brief Frees data allocated by the RFont for the RFont
*/
inline void RFont_close(void);
/**
 * @brief Just updates the framebuffer size.
 * @param width The framebuffer width.
 * @param height The framebuffer height.
*/
inline void RFont_update_framebuffer(size_t width, size_t height);

#ifndef RFONT_NO_STDIO
/**
 * @brief Init font stucture with a TTF file path.
 * @param font_name The TTF file path.
 * @return The `RFont_font` created using the TTF file data.
*/
inline RFont_font* RFont_font_init(const char* font_name);
#endif


/**
 * @brief Init font stucture with raw TTF data.
 * @param font_data The raw TTF data.
 * @param auto_free If the memory should be automatically freed by `RFont_font_free`.
 * @return The `RFont_font` created from the data.
*/
inline RFont_font* RFont_font_init_data(u8* font_data, b8 auto_free);

/**
 * @brief Free data from the font stucture, including the stucture itself
 * @param font The font stucture to free
*/
inline void RFont_font_free(RFont_font* font);

/**
 * @brief Add a character to the font's atlas.
 * @param font The font to use.
 * @param ch The character to add to the atlas.
 * @param size The size of the character.
 * @return The `RFont_glyph` created from the data and added to the atlas.
*/
inline RFont_glyph RFont_font_add_char(RFont_font* font, char ch, size_t size);

#ifndef RFONT_NO_FMT
/**
 * @brief Formats a string.
 * @param string The source string
 * @param ... format data
 * @return The formatted string 
*/
inline const char* RFont_fmt(const char* string, ...);
#endif

/**
 * @brief Add a string to the font's atlas.
 * @param font The font to use.
 * @param ch The character to add to the atlas.
 * @param sizes The supported sizes of the character.
 * @param sizeLen length of the size array
*/
inline void RFont_font_add_string(RFont_font* font, const char* string, size_t* sizes, size_t sizeLen);

/**
 * @brief Add a string to the font's atlas based on a given string length.
 * @param font The font to use.
 * @param ch The character to add to the atlas.
 * @param strLen length of the string
 * @param sizes The supported sizes of the character.
 * @param sizeLen length of the size array
*/
inline void RFont_font_add_string_len(RFont_font* font, const char* string, size_t strLen, size_t* sizes, size_t sizeLen);

/**
 * @brief Get the area of the text based on the size using the font.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param size The size of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_text_area(RFont_font* font, const char* text, u32 size);

/**
 * @brief Get the area of the text based on the size using the font, using a given length.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param size The size of the text
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_text_area_spacing(RFont_font* font, const char* text, float spacing, u32 size);

/**
 * @brief Get the area of the text based on the size using the font, using a given length.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param len The length of the string
 * @param size The size of the text
 * @param stopNL the number of \n s until it stops (0 = don't stop until the end)
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_text_area_len(RFont_font* font, const char* text, size_t len, u32 size, size_t stopNL, float spacing);

/**
 * @brief Draw a text string using the font.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param x The x position of the text
 * @param y The y position of the text
 * @param size The size of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_draw_text(RFont_font* font, const char* text, float x, float y, u32 size);

/**
 * @brief Draw a text string using the font and a given spacing.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param x The x position of the text
 * @param y The y position of the text
 * @param size The size of the text
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_draw_text_spacing(RFont_font* font, const char* text, float x, float y, u32 size, float spacing);

/**
 * @brief Draw a text string using the font using a given length and a given spacing.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param len The length of the string
 * @param x The x position of the text
 * @param y The y position of the text
 * @param size The size of the text
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_draw_text_len(RFont_font* font, const char* text, size_t len, float x, float y, u32 size, float spacing);

#define RFont_set_color RFont_render_set_color

#ifndef RFONT_NO_GRAPHICS
/* 
    if you do not want to use opengl (or want to create your own implemntation of these functions), 
    you'll have to define these yourself 
    and add `#define RFONT_NO_OPENGL`
*/
inline void RFont_render_set_color(float r, float g, float b, float a); /* set the current rendering color */
inline void RFont_render_init(void); /* any initalizations the renderer needs to do */
inline u32 RFont_create_atlas(u32 atlasWidth, u32 atlasHeight); /* create a bitmap texture based on the given size */
inline void RFont_bitmap_to_atlas(u32 atlas, u8* bitmap, float x, float y, float w, float h); /* add the given bitmap to the texture based on the given coords and size data */
inline void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts); /* render the text, using the vertices, atlas texture, and texture coords given. */
inline void RFont_render_free(u32 atlas); /* free any memory the renderer might need to free */

/* (if modern opengl is being used) switch to rendering using opengl legacy or not */
inline void RFont_render_legacy(u8 legacy);
#endif

#endif /* RFONT_H */

#ifdef RFONT_IMPLEMENTATION

#ifdef RFONT_EXTERNAL_STB
#define STB_TRUETYPE_IMPLEMENTATION
#include "stb_truetype.h"
#endif

#ifndef RFONT_GET_TEXPOSX 
#define RFONT_GET_TEXPOSX(x) (float)((float)(x) / (float)(RFONT_ATLAS_WIDTH))
#define RFONT_GET_TEXPOSY(y) (float)((float)(y) / (float)(RFONT_ATLAS_HEIGHT))
#endif

#ifndef RFONT_GET_WORLD_X
#define RFONT_GET_WORLD_X(x, w) (float)((x) / (((w) / 2.0f)) - 1.0f)
#define RFONT_GET_WORLD_Y(y, h) (float)(1.0f - ((y) / ((h) / 2.0f)))
#endif

/* 
stb defines required by RFont

you probably don't care about this part if you're reading just the RFont code
*/

#ifndef RFONT_EXTERNAL_STB
// private structure
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

typedef struct stbtt_fontinfo stbtt_fontinfo;

struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              // pointer to .ttf file
   int              fontstart;         // offset of start of font

   int numGlyphs;                     // number of glyphs, needed for range checking

   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf
   int index_map;                     // a cmap mapping for our chosen character encoding
   int indexToLocFormat;              // format needed to map from glyph index to glyph

   stbtt__buf cff;                    // cff font data
   stbtt__buf charstrings;            // the charstring index
   stbtt__buf gsubrs;                 // global charstring subroutines index
   stbtt__buf subrs;                  // private charstring subroutines index
   stbtt__buf fontdicts;              // array of font dicts
   stbtt__buf fdselect;               // map from glyph to fontdict
};

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern inline
#endif

STBTT_DEF i16 ttSHORT(u8 *p);
STBTT_DEF u16 ttUSHORT(u8 *p); 
STBTT_DEF u32 ttULONG(u8 *p);

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);

STBTT_DEF unsigned char* stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
#endif /* RFONT_EXTERNAL_STB */

/* 
END of stb defines required by RFont

you probably care about this part 
*/

#ifndef RFONT_NO_FMT
#include <stdarg.h>

const char* RFont_fmt(const char* string, ...) {
   static char output[RFONT_TEXTFORMAT_MAX_SIZE];

   va_list args;
   va_start(args, string);
   
   RFONT_VSNPRINTF(output, RFONT_TEXTFORMAT_MAX_SIZE, string, args);
   va_end(args);

   return output;
}
#endif

struct RFont_font {
   stbtt_fontinfo info; /* source stb font */
   b8 free_font_memory;
   float fheight; /* font height from stb */
   float descent; /* font descent */
   float numOfLongHorMetrics;
   float space_adv;

   RFont_glyph glyphs[RFONT_MAX_GLYPHS]; /* glyphs */
   size_t glyph_len;

   u32 atlas; /* atlas texture */
   float atlasX; /* the current x position inside the atlas */
};

size_t RFont_width = 0, RFont_height = 0;

float* RFont_verts;
float* RFont_tcoords;

RFont_font* font2;

void RFont_update_framebuffer(size_t width, size_t height) {
   /* set size of the framebuffer (for rendering later on) */
   RFont_width = width;
   RFont_height = height;
}

void RFont_init(size_t width, size_t height) {
    RFont_update_framebuffer(width, height);

    #ifndef RFONT_NO_GRAPHICS
    /* init any rendering stuff that needs to be initalized (eg. vbo objects) */
    RFont_render_init();
    #endif

   RFont_verts = malloc(sizeof(float) * RFONT_INIT_VERTS * 600);
   RFont_tcoords = malloc(sizeof(float) * RFONT_INIT_VERTS * 600);
}

#ifndef RFONT_NO_STDIO
RFont_font* RFont_font_init(const char* font_name) {
   FILE* ttf_file = fopen(font_name, "rb");

   fseek(ttf_file, 0U, SEEK_END);
   size_t size = ftell(ttf_file);

   char* ttf_buffer = (char*)malloc(sizeof(char) * size); 
   fseek(ttf_file, 0U, SEEK_SET);

   size_t out = fread(ttf_buffer, 1, size, ttf_file);
   RFONT_UNUSED(out)


   return RFont_font_init_data((u8*)ttf_buffer, 1);
}
#endif

RFont_font* RFont_font_init_data(u8* font_data, b8 auto_free) {
   RFont_font* font = (RFont_font*)malloc(sizeof(RFont_font));

   stbtt_InitFont(&font->info, font_data, 0);

   font->fheight = ttSHORT(font->info.data + font->info.hhea + 4) - ttSHORT(font->info.data + font->info.hhea + 6);
   font->descent = ttSHORT(font->info.data + font->info.hhea + 6);

   font->numOfLongHorMetrics = ttUSHORT(font->info.data + font->info.hhea + 34);
   font->space_adv = ttSHORT(font->info.data + font->info.hmtx + 4 * (u32)(font->numOfLongHorMetrics - 1));
 

   #ifndef RFONT_NO_GRAPHICS
   font->atlas = RFont_create_atlas(RFONT_ATLAS_WIDTH, RFONT_ATLAS_HEIGHT);
   #endif
   font->atlasX = 0;
   font->glyph_len = 0;

   font->free_font_memory = auto_free;
   
   return font;
}

void RFont_font_free(RFont_font* font) {
   #ifndef RFONT_NO_GRAPHICS
   RFont_render_free(font->atlas);
   #endif

   if (font->free_font_memory)
      free(font->info.data);
   
   free(font);
}

void RFont_close(void) {
   free(RFont_verts);
   free(RFont_tcoords);
}


/*
decode utf8 character to codepoint 
*/

// Copyright (c) 2008-2010 Bjoern Hoehrmann <bjoern@hoehrmann.de>
// See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.

#define RFONT_UTF8_ACCEPT 0
#define RFont_UTF8_REJECT 12

inline static u32 RFont_decode_utf8(u32* state, u32* codep, u32 byte);

static u32 RFont_decode_utf8(u32* state, u32* codep, u32 byte) {
   static const uint8_t utf8d[] = {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..1f
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 20..3f
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40..5f
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60..7f
      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, // 80..9f
      7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, // a0..bf
      8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // c0..df
      0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, // e0..ef
      0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, // f0..ff
      0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, // s0..s0
      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, // s1..s2
      1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, // s3..s4
      1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, // s5..s6
      1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // s7..s8
   };

   uint32_t type = utf8d[byte];

   *codep = (*state != RFONT_UTF8_ACCEPT) ?
      (byte & 0x3fu) | (*codep << 6) :
      (0xff >> type) & (byte);

   *state = utf8d[256 + *state * 16 + type];
   return *state;
}

void RFont_font_add_string(RFont_font* font, const char* string, size_t* sizes, size_t sizeLen) {
   RFont_font_add_string_len(font, string, 0, sizes, sizeLen);
}

void RFont_font_add_string_len(RFont_font* font, const char* string, size_t strLen, size_t* sizes, size_t sizeLen) {
   u32 i;
   char* str;
   for (str = (char*)string; (!strLen || (size_t)(str - string) < strLen) && *str; str++)
      for (i = 0; i < sizeLen; i++)
         RFont_font_add_char(font, *str, sizes[i]);
}


RFont_glyph RFont_font_add_char(RFont_font* font, char ch, size_t size) {
   static u32 utf8state = 0, codepoint = 0; 

   if (RFont_decode_utf8(&utf8state, &codepoint, (u8)ch) != RFONT_UTF8_ACCEPT)
      return (RFont_glyph){0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

	u32 i;
   for (i = 0; i < font->glyph_len; i++)
      if (font->glyphs[i].codepoint == codepoint && font->glyphs[i].size == size)
         return font->glyphs[i];

   RFont_glyph* glyph = &font->glyphs[i];

   glyph->src = stbtt_FindGlyphIndex(&font->info, codepoint);

   if (glyph->src == 0 && font2 != NULL && font2->info.data != font->info.data) {
      stbtt_fontinfo saveInfo = font->info;

      RFont_font* fakeFont = font;
      fakeFont->info = font2->info;

      RFont_glyph g = RFont_font_add_char(fakeFont, 't', size);

      fakeFont->info = saveInfo;

      return g;
   }

   font->glyph_len++;

   i32 x0, y0, x1, y1, w = 0, h = 0;
   if (stbtt_GetGlyphBox(&font->info, glyph->src, &x0, &y0, &x1, &y1) == 0)
      return (RFont_glyph){0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

   float scale = ((float)size) / font->fheight;

   u8* bitmap =  stbtt_GetGlyphBitmapSubpixel(&font->info, 0, scale, 0.0f, 0.0f, glyph->src, &w, &h, 0, 0);

   glyph->w = (float)w;
   glyph->h = (float)h;

   glyph->codepoint = codepoint;
   glyph->size = size;
   glyph->x = font->atlasX;
   glyph->x2 = font->atlasX + glyph->w;
   glyph->x1 = floorf(x0 * scale);
   glyph->y1 = floor(-y1 * scale);

   #ifndef RFONT_NO_GRAPHICS
   RFont_bitmap_to_atlas(font->atlas, bitmap, font->atlasX, 0, glyph->w, glyph->h);
   #endif

   font->atlasX += glyph->w;

   free(bitmap);

   i32 advanceX;
   
   if (glyph->src < font->numOfLongHorMetrics)
      advanceX = ttSHORT(font->info.data + font->info.hmtx + 4 * glyph->src);
   else
      advanceX = ttSHORT(font->info.data + font->info.hmtx + 4 * (u32)(font->numOfLongHorMetrics - 1));

   glyph->advance = advanceX * scale;

   return *glyph;
}

RFont_area RFont_text_area(RFont_font* font, const char* text, u32 size) {
   return RFont_text_area_len(font, text, 0, size, 0, 0.0f);
}

RFont_area RFont_text_area_spacing(RFont_font* font, const char* text, float spacing, u32 size) {
   return RFont_text_area_len(font, text, 0, size, 0, spacing);
}

RFont_area RFont_text_area_len(RFont_font* font, const char* text, size_t len, u32 size, size_t stopNL, float spacing) {
   float x = 0;
   size_t y = 1;

   char* str;

   float scale = (((float)size) / font->fheight);

   float space_adv = (scale * font->space_adv) / 2;
   
   for (str = (char*)text; (len == 0 || (size_t)(str - text) < len) && *str; str++) {        
      if (*str == '\n') { 
         if (y == stopNL)
            return (RFont_area){(u32)x, y * size};
         
         y++;
         x = 0;
         continue;
      }
      
      if (*str == ' ' || *str == '\t') {
         x += space_adv + spacing;
         continue;
      }

      RFont_glyph glyph = RFont_font_add_char(font,  *str, size);

      if (glyph.codepoint == 0 && glyph.size == 0)
         continue;
      
      x += (float)glyph.advance + spacing;
   }

   return (RFont_area){(u32)x, y * size};
}

RFont_area RFont_draw_text(RFont_font* font, const char* text, float x, float y, u32 size) {
   return RFont_draw_text_len(font, text, 0, x, y, size, 0.0f);
}

RFont_area RFont_draw_text_spacing(RFont_font* font, const char* text, float x, float y, u32 size, float spacing) {
   return RFont_draw_text_len(font, text, 0, x, y, size, spacing);
}

RFont_area RFont_draw_text_len(RFont_font* font, const char* text, size_t len, float x, float y, u32 size, float spacing) {
   float* verts = RFont_verts;
   float* tcoords = RFont_tcoords;

   float startX = x;
   float startY = y;
   
   y += size;

   u32 i = 0;
   u32 tIndex = 0;

   char* str;

   float scale = (((float)size) / font->fheight);
   float space_adv = (scale * font->space_adv) / 2;

   y -= (-font->descent * scale);

   for (str = (char*)text; (len == 0 || (size_t)(str - text) < len) && *str; str++) {        
      if (*str == '\n') { 
         x = startX;
         y += size;
         continue;
      }

      if (*str == ' ' || *str == '\t') {
         x += space_adv + spacing;
         continue;
      }

      RFont_glyph glyph = RFont_font_add_char(font, *str, size);

      if (glyph.codepoint == 0 && glyph.size == 0)
         continue;

      float realX = x + glyph.x1;
      float realY = y + glyph.y1;

      verts[i] = RFONT_GET_WORLD_X((i32)realX, RFont_width); 
      verts[i + 1] = RFONT_GET_WORLD_Y(realY, RFont_height);
      verts[i + 2] = 0;
      /*  */
      verts[i + 3] = RFONT_GET_WORLD_X((i32)realX, RFont_width);
      verts[i + 4] = RFONT_GET_WORLD_Y(realY + glyph.h , RFont_height);
      verts[i + 5] = 0;
      /*  */
      verts[i + 6] = RFONT_GET_WORLD_X((i32)(realX + glyph.w), RFont_width);
      verts[i + 7] = RFONT_GET_WORLD_Y(realY + glyph.h , RFont_height);
      verts[i + 8] = 0;
      /*  */
      /*  */
      verts[i + 9] = RFONT_GET_WORLD_X((i32)(realX + glyph.w), RFont_width);
      verts[i + 10] = RFONT_GET_WORLD_Y(realY, RFont_height);
      verts[i + 11] = 0;
      /*  */
      verts[i + 12] = RFONT_GET_WORLD_X((i32)realX, RFont_width); 
      verts[i + 13] = RFONT_GET_WORLD_Y(realY, RFont_height);
      verts[i + 14] = 0;
      /*  */

      verts[i + 15] = RFONT_GET_WORLD_X((i32)(realX + glyph.w), RFont_width);
      verts[i + 16] = RFONT_GET_WORLD_Y(realY + glyph.h , RFont_height);
      verts[i + 17] = 0;

      /* texture coords */

      //#if defined(RFONT_RENDER_LEGACY) || defined(RFONT_RENDER_RGL)
      tcoords[tIndex] = RFONT_GET_TEXPOSX(glyph.x);
      tcoords[tIndex + 1] = 0;
      //#endif

      /*  */
      tcoords[tIndex + 2] = RFONT_GET_TEXPOSX(glyph.x); 
      tcoords[tIndex + 3] = RFONT_GET_TEXPOSY(glyph.h);
      /*  */
      tcoords[tIndex + 4] = RFONT_GET_TEXPOSX(glyph.x2);
      tcoords[tIndex + 5] = RFONT_GET_TEXPOSY(glyph.h);
      /*  */
      /*  */
      tcoords[tIndex + 6] = RFONT_GET_TEXPOSX(glyph.x2);
      tcoords[tIndex + 7] = 0;
      /*  */
      tcoords[tIndex + 8] = RFONT_GET_TEXPOSX(glyph.x);
      tcoords[tIndex + 9] = 0;
      /*  */ 
      tcoords[tIndex + 10] = RFONT_GET_TEXPOSX(glyph.x2);
      tcoords[tIndex + 11] = RFONT_GET_TEXPOSY(glyph.h);

      i += 18;
      tIndex += 12;

      x += glyph.advance + spacing;
   }

   #ifndef RFONT_NO_GRAPHICS
   RFont_render_text(font->atlas, verts, tcoords, i / 3);
   #endif
   
   return (RFont_area){(u32)(x - startX), (u32)(y - startY) + (-font->descent * scale)};
}

#ifndef __APPLE__
#include <GL/gl.h>
#else
#include <OpenGL/gl.h>
#endif

#if !defined(RFONT_NO_OPENGL) && !defined(RFONT_NO_GRAPHICS)

#if !defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL)
#define GL_GLEXT_PROTOTYPES
#endif

#ifndef GL_PERSPECTIVE_CORRECTION_HINT
#define GL_PERSPECTIVE_CORRECTION_HINT		0x0C50
#endif

#ifndef GL_TEXTURE_SWIZZLE_RGBA
#define GL_TEXTURE_SWIZZLE_RGBA           0x8E46
#endif

#ifndef GL_TEXTURE0
#define GL_TEXTURE0				0x84C0
#endif

#ifndef GL_CLAMP_TO_EDGE
#define GL_CLAMP_TO_EDGE			0x812F
#endif

#ifdef RFONT_DEBUG

#ifndef GL_DEBUG_TYPE_ERROR
#define GL_DEBUG_TYPE_ERROR               0x824C
#define GL_DEBUG_OUTPUT                   0x92E0
#define GL_DEBUG_OUTPUT_SYNCHRONOUS       0x8242
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_INFO_LOG_LENGTH                0x8B84 
#endif

void RFont_debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char* message, const void* userParam) {
    RFONT_UNUSED(source) RFONT_UNUSED(id) RFONT_UNUSED(severity) RFONT_UNUSED(length) RFONT_UNUSED(userParam)

    if (type != GL_DEBUG_TYPE_ERROR)
        return;

    printf("OpenGL Debug Message: %s\n", message);
}

void RFont_opengl_getError(void) {
    GLenum err;
    while ((err = glGetError()) != GL_NO_ERROR) {
         switch (err) {
            case GL_INVALID_ENUM:
                  printf("OpenGL error: GL_INVALID_ENUM\n");
                  break;
            case GL_INVALID_VALUE:
                  printf("OpenGL error: GL_INVALID_VALUE\n");
                  break;
            case GL_INVALID_OPERATION:
                  printf("OpenGL error: GL_INVALID_OPERATION\n");
                  break;
            case GL_STACK_OVERFLOW:
                  printf("OpenGL error: GL_STACK_OVERFLOW\n");
                  break;
            case GL_STACK_UNDERFLOW:
                  printf("OpenGL error: GL_STACK_UNDERFLOW\n");
                  break;	
            default:
                  printf("OpenGL error: Unknown error code 0x%x\n", err);
                  break;
         }
         exit(1);
    }
}

#endif

u32 RFont_create_atlas(u32 atlasWidth, u32 atlasHeight) {
 #if defined(RFONT_DEBUG) && !defined(RFONT_RENDER_LEGACY)
   glEnable(GL_DEBUG_OUTPUT);
   #endif
   
   u32 id = 0;
   glEnable(GL_TEXTURE_2D);
   
   glBindTexture(GL_TEXTURE_2D, 0);
   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
   glGenTextures(1, &id);

   glBindTexture(GL_TEXTURE_2D, id);

   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
   
   u8* data = (u8*)calloc(atlasWidth * atlasHeight * 4, sizeof(u8));

   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, atlasWidth, atlasHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

   free(data);

   glBindTexture(GL_TEXTURE_2D, id);
	static GLint swizzleRgbaParams[4] = {GL_ONE, GL_ONE, GL_ONE, GL_RED};
	glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzleRgbaParams);

   glBindTexture(GL_TEXTURE_2D, 0);
   return id;
}

#ifndef GL_UNPACK_ROW_LENGTH
#define GL_UNPACK_ROW_LENGTH 0x0CF2
#define GL_UNPACK_SKIP_PIXELS 0x0CF4
#define GL_UNPACK_SKIP_ROWS 0x0CF3
#endif


void RFont_push_pixel_values(GLint alignment, GLint rowLength, GLint skipPixels, GLint skipRows);
void RFont_push_pixel_values(GLint alignment, GLint rowLength, GLint skipPixels, GLint skipRows) {
	glPixelStorei(GL_UNPACK_ALIGNMENT, alignment);
	glPixelStorei(GL_UNPACK_ROW_LENGTH, rowLength);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS, skipPixels);
	glPixelStorei(GL_UNPACK_SKIP_ROWS, skipRows);
}

void RFont_bitmap_to_atlas(u32 atlas, u8* bitmap, float x, float y, float w, float h) {
   glEnable(GL_TEXTURE_2D);
   
	GLint alignment, rowLength, skipPixels, skipRows;
   glGetIntegerv(GL_UNPACK_ALIGNMENT, &alignment);
	glGetIntegerv(GL_UNPACK_ROW_LENGTH, &rowLength);
	glGetIntegerv(GL_UNPACK_SKIP_PIXELS, &skipPixels);
	glGetIntegerv(GL_UNPACK_SKIP_ROWS, &skipRows);
   
   #if !defined(RFONT_RENDER_LEGACY)
   glActiveTexture(GL_TEXTURE0 + atlas - 1);
   #endif

	glBindTexture(GL_TEXTURE_2D, atlas);

	RFont_push_pixel_values(1, w, 0, 0);

	glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, w, h, GL_RED, GL_UNSIGNED_BYTE, bitmap);

	RFont_push_pixel_values(alignment, rowLength, skipPixels, skipRows);

   glBindTexture(GL_TEXTURE_2D, 0);
}

#if defined(RFONT_RENDER_RGL) && !defined(RFONT_CUSTOM_GL)

void RFont_render_set_color(float r, float g, float b, float a) {
   rglColor4f(r, g, b, a);
}

void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
   glEnable(GL_TEXTURE_2D);
   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
   glShadeModel(GL_SMOOTH);

   rglMatrixMode(RGL_MODELVIEW);
   rglLoadIdentity();
	rglPushMatrix();

   glDisable(GL_DEPTH_TEST);
   glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_CULL_FACE);    

   glEnable(GL_BLEND);
   glEnable(GL_TEXTURE_2D);
   
   glActiveTexture(GL_TEXTURE0);

   rglSetTexture(atlas);
   
	rglBegin(RGL_TRIANGLES_2D);

	size_t i;
   size_t tIndex = 0;

	for (i = 0; i < (nverts * 3); i += 3) {
		rglTexCoord2f(tcoords[tIndex], tcoords[tIndex + 1]);
      tIndex += 2;
		
      rglVertex2f(verts[i], verts[i + 1]);
	}
	rglEnd();
	rglPopMatrix();
   
   rglSetTexture(0);
   glBindTexture(GL_TEXTURE_2D, 0);
   glEnable(GL_DEPTH_TEST);
}

void RFont_render_free(u32 atlas) { glDeleteTextures(1, &atlas); }
void RFont_render_legacy(u8 legacy) { rglLegacy(legacy); }
void RFont_render_init() {}
#endif /* RFONT_RENDER_RGL */

#if defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL) && !defined(RFONT_CUSTOM_GL)

void RFont_render_set_color(float r, float g, float b, float a) {
   glColor4f(r, g, b, a);
}

void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
   glEnable(GL_TEXTURE_2D);
   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
   glShadeModel(GL_SMOOTH);

   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   glDisable(GL_DEPTH_TEST);
   glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_CULL_FACE);    

   glEnable(GL_BLEND);
   glEnable(GL_TEXTURE_2D);
   #if !defined(RFONT_RENDER_LEGACY)
   glActiveTexture(GL_TEXTURE0 + atlas - 1);
   #endif

   glBindTexture(GL_TEXTURE_2D, atlas);

	glPushMatrix();

	glBegin(GL_TRIANGLES);

	size_t i;
   size_t tIndex = 0;

	for (i = 0; i < (nverts * 3); i += 3) {
		glTexCoord2f(tcoords[tIndex], tcoords[tIndex + 1]);
		tIndex += 2;

      glVertex2f(verts[i], verts[i + 1]);
	}
	glEnd();
	glPopMatrix();

   glBindTexture(GL_TEXTURE_2D, 0);
   glEnable(GL_DEPTH_TEST);
}

void RFont_render_free(u32 atlas) { glDeleteTextures(1, &atlas); }
void RFont_render_legacy(u8 legacy) { RFONT_UNUSED(legacy) }
void RFont_render_init() {}
#endif /* defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL)  */

#if !defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL)
typedef struct {
   GLuint vao, vbo, tbo, cbo, ebo,
            program, vShader, fShader;
   
   u8 legacy;
} RFont_gl_info;

RFont_gl_info RFont_gl = { 0 };

float RFont_color[4] = {0, 0, 0, 1};

#ifdef RFONT_DEBUG
inline void RFont_debug_shader(u32 src, const char* shader, const char* action);
void RFont_debug_shader(u32 src, const char* shader, const char* action) {
    GLint status;
    if (action[0] == 'l')
        glGetProgramiv(src, GL_LINK_STATUS, &status);
    else
        glGetShaderiv(src, GL_COMPILE_STATUS, &status);

    if (status == GL_TRUE) 
        printf("%s Shader %s successfully.\n", shader, action);
    else {
        printf("%s Shader failed to %s.\n", shader, action);

        if (action[0] == 'c') {
            GLint infoLogLength;
            glGetShaderiv(src, GL_INFO_LOG_LENGTH, &infoLogLength);

            if (infoLogLength > 0) {
                GLchar* infoLog = (GLchar*)malloc(infoLogLength);
                glGetShaderInfoLog(src, infoLogLength, NULL, infoLog);
                printf("%s Shader info log:\n%s\n", shader, infoLog);
                free(infoLog);
            }
        }
        
        RFont_opengl_getError();
    }
}
#endif

#define RFONT_MULTILINE_STR(...) #__VA_ARGS__

void RFont_render_set_color(float r, float g, float b, float a) {
   if (RFont_gl.legacy)
      return glColor4f(r, g, b, a);
   
   RFont_color[0] = r;
   RFont_color[1] = g;
   RFont_color[2] = b;
   RFont_color[3] = a;
}

void RFont_render_init() {
   if (RFont_gl.vao != 0 || RFont_gl.legacy)
      return;

   static const char* defaultVShaderCode = RFONT_MULTILINE_STR(
      \x23version 330 core       \n
      layout (location = 0) in vec3 vertexPosition;
      layout (location = 1) in vec2 vertexTexCoord;
      layout (location = 2) in vec4 inColor;
      out vec2 fragTexCoord;
      out vec4 fragColor;

      uniform mat4 mvp;          \n
      void main() {
         fragColor = inColor;
         gl_Position = vec4(vertexPosition, 1.0);
         fragTexCoord = vertexTexCoord;
      }
   );

   static const char* defaultFShaderCode = RFONT_MULTILINE_STR(
      \x23version 330 core                \n
      out vec4 FragColor;
      
      in vec4 fragColor;
      in vec2 fragTexCoord;

      uniform sampler2D texture0;

      void main() {
         FragColor = texture(texture0, fragTexCoord) * fragColor;
      }
   );
   
   glGenVertexArrays(1, &RFont_gl.vao);
   glBindVertexArray(RFont_gl.vao);

   glGenBuffers(1, &RFont_gl.vbo);
   glGenBuffers(1, &RFont_gl.tbo);
   glGenBuffers(1, &RFont_gl.cbo);
   glGenBuffers(1, &RFont_gl.ebo);
   /* compile vertex shader */
   RFont_gl.vShader = glCreateShader(GL_VERTEX_SHADER);
   glShaderSource(RFont_gl.vShader, 1, &defaultVShaderCode, NULL);
   glCompileShader(RFont_gl.vShader);

   #ifdef RFONT_DEBUG
   RFont_debug_shader(RFont_gl.vShader, "Vertex", "compile");
   #endif

   /* compile fragment shader */
   RFont_gl.fShader = glCreateShader(GL_FRAGMENT_SHADER);
   glShaderSource(RFont_gl.fShader, 1, &defaultFShaderCode, NULL);
   glCompileShader(RFont_gl.fShader);


   #ifdef RFONT_DEBUG
   RFont_debug_shader(RFont_gl.fShader, "Fragment", "compile");
   #endif

   /* create program and link vertex and fragment shaders */
   RFont_gl.program = glCreateProgram();

   glAttachShader(RFont_gl.program, RFont_gl.vShader);
   glAttachShader(RFont_gl.program, RFont_gl.fShader);

   glBindAttribLocation(RFont_gl.program, 0, "vertexPosition");
   glBindAttribLocation(RFont_gl.program, 1, "vertexTexCoord");
   glBindAttribLocation(RFont_gl.program, 2, "inColor");

   glLinkProgram(RFont_gl.program);

   #ifdef RFONT_DEBUG
   RFont_debug_shader(RFont_gl.program, "Both", "link to the program");
   #endif
}
     
void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
   glEnable(GL_TEXTURE_2D);
   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

   glDisable(GL_DEPTH_TEST);
   glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_CULL_FACE);    

   glEnable(GL_BLEND);
   glShadeModel(GL_SMOOTH);

   if (RFont_gl.legacy) {
      glMatrixMode(GL_MODELVIEW);
      glLoadIdentity();

      glBindTexture(GL_TEXTURE_2D, atlas);
      glPushMatrix();

      glBegin(GL_TRIANGLES);

      size_t i;
      size_t tIndex = 0;

      for (i = 0; i < (nverts * 3); i += 3) {
         glTexCoord2f(tcoords[tIndex], tcoords[tIndex + 1]);
         tIndex += 2;
         
         glVertex2f(verts[i], verts[i + 1]);
      }
      glEnd();
      glPopMatrix();
   } else {
      glBindVertexArray(RFont_gl.vao);

      glUseProgram(RFont_gl.program);

      glEnableVertexAttribArray(0);
      glBindBuffer(GL_ARRAY_BUFFER, RFont_gl.vbo);
      glBufferData(GL_ARRAY_BUFFER, nverts * 3 * sizeof(float), verts, GL_DYNAMIC_DRAW);
      glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL);

      glEnableVertexAttribArray(1);
      glBindBuffer(GL_ARRAY_BUFFER, RFont_gl.tbo);
      glBufferData(GL_ARRAY_BUFFER, nverts * 2 * sizeof(float), tcoords, GL_DYNAMIC_DRAW);
      glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, NULL);

      float* colors = malloc(sizeof(float) * nverts * 4);

      u32 i = 0;
      for (i = 0; i < (nverts * 4); i += 4) {
         colors[i] = RFont_color[0];
         colors[i + 1] = RFont_color[1];
         colors[i + 2] = RFont_color[2];
         colors[i + 3] = RFont_color[3];
      }

      glEnableVertexAttribArray(2);
      glBindBuffer(GL_ARRAY_BUFFER, RFont_gl.cbo);
      glBufferData(GL_ARRAY_BUFFER, nverts * 4 * sizeof(float), colors, GL_DYNAMIC_DRAW);
      glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, 0, NULL);

      free(colors);

      GLushort* indices = malloc(sizeof(GLushort) * 6 * nverts);
      int k = 0;

      u32 j;
      for (j = 0; j < (6 * nverts); j += 6) {
         indices[j] = 4*  k;
         indices[j + 1] = 4*k + 1;
         indices[j + 2] = 4*k + 2;
         indices[j + 3] = 4*k;
         indices[j + 4] = 4*k + 2;
         indices[j + 5] = 4*k + 3;

         k++;
      }

      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, RFont_gl.ebo);
      glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLushort) * 6 * nverts, indices, GL_STATIC_DRAW);

      free(indices);

      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, atlas);

      glDrawArrays(GL_TRIANGLES, 0, nverts);   
      glUseProgram(0);
   }

   glBindTexture(GL_TEXTURE_2D, 0);
	glDisable(GL_TEXTURE_2D);
   glEnable(GL_DEPTH_TEST);
}

void RFont_render_free(u32 atlas) {
   glDeleteTextures(1, &atlas);

   if (RFont_gl.vao == 0 || RFont_gl.legacy)
      return;
   
   /* free vertex array */
   glDeleteVertexArrays(1, &RFont_gl.vao);
   RFont_gl.vao = 0;

   /* free buffers */
   glDeleteBuffers(1, &RFont_gl.tbo);
   glDeleteBuffers(1, &RFont_gl.vbo);

   /* free program data */
   glDeleteShader(RFont_gl.vShader);
   glDeleteShader(RFont_gl.fShader);
   glDeleteProgram(RFont_gl.program);
}

void RFont_render_legacy(u8 legacy) { RFont_gl.legacy = legacy; }

#endif /* !defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL) */
#endif /*  !defined(RFONT_NO_OPENGL) && !defined(RFONT_NO_GRAPHICS) */

/* 
stb_truetype defines and source code required by RFont

you probably don't care about this part if you're reading just the RFont code
*/

#ifndef RFONT_EXTERNAL_STB
   typedef char stbtt__check_size32[sizeof(i32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(i16)==2 ? 1 : -1];

   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
   #ifndef STBTT_malloc
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

#ifdef __cplusplus
extern "C" {
#endif

// as above, but takes one or more glyph indices for greater efficiency

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
                   // (we share this with other code at RAD)
   #define stbtt_vertex_type short // can't use i16 because that's not visible in the header file
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);

// @TODO: don't expose this structure
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

// rasterize a shape with quadratic beziers into a bitmap
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
                               float flatness_in_pixels,     // allowable error of curve in pixels
                               stbtt_vertex *vertices,       // array of vertices defining shape
                               int num_verts,                // number of vertices in above array
                               float scale_x, float scale_y, // scale applied to input vertices
                               float shift_x, float shift_y, // translation applied to input vertices
                               int x_off, int y_off,         // another translation applied to input
                               int invert,                   // if non-zero, vertically flip shape
                               void *userdata);              // context for to STBTT_MALLOC

enum { // platformID
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { // languageID for STBTT_PLATFORM_ID_MAC
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

STBTT_DEF u8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

STBTT_DEF u8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

STBTT_DEF void stbtt__buf_seek(stbtt__buf *b, int o)
{
   assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

STBTT_DEF void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

STBTT_DEF u32 stbtt__buf_get(stbtt__buf *b, int n)
{
   u32 v = 0;
   int i;
   assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

STBTT_DEF stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   assert(size < 0x40000000);
   r.data = (u8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

STBTT_DEF stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

STBTT_DEF stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

STBTT_DEF u32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   assert(0);
   return 0;
}

STBTT_DEF void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

STBTT_DEF stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

STBTT_DEF void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, u32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

STBTT_DEF int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

STBTT_DEF stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   assert(i >= 0 && i < count);
   assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

#define ttBYTE(p)     (* (u8 *) (p))
#define ttCHAR(p)     (* (i8 *) (p))
#define ttFixed(p)    ttLONG(p)

STBTT_DEF i16 ttSHORT(u8 *p)   { return p[0]*256 + p[1]; }
STBTT_DEF u16 ttUSHORT(u8 *p) { return p[0]*256 + p[1]; }
STBTT_DEF u32 ttULONG(u8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)          stbtt_tag4(p,str[0],str[1],str[2],str[3])

// @OPTIMIZE: binary search
STBTT_DEF u32 stbtt__find_table(u8 *data, u32 fontstart, const char *tag)
{
   i32 num_tables = ttUSHORT(data+fontstart+4);
   u32 tabledir = fontstart + 12;
   i32 i;
   for (i=0; i < num_tables; ++i) {
      u32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

STBTT_DEF stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   u32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

STBTT_DEF void stbtt_setvertex(stbtt_vertex *v, u8 type, i32 x, i32 y, i32 cx, i32 cy)
{
   v->type = type;
   v->x = (i16) x;
   v->y = (i16) y;
   v->cx = (i16) cx;
   v->cy = (i16) cy;
}

STBTT_DEF int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    i32 sx, i32 sy, i32 scx, i32 scy, i32 cx, i32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

STBTT_DEF int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index);

STBTT_DEF int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   i16 numberOfContours;
   u8 *endPtsOfContours;
   u8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      u8 flags=0,flagcount;
      i32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      i32 x,y,cx,cy,sx,sy, scx,scy;
      u8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

      // first load flags

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      // now load x coordinates
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            i16 dx = *points++;
            x += (flags & 16) ? dx : -dx; // ???
         } else {
            if (!(flags & 16)) {
               x = x + (i16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (i16) x;
      }

      // now load y coordinates
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            i16 dy = *points++;
            y += (flags & 32) ? dy : -dy; // ???
         } else {
            if (!(flags & 32)) {
               y = y + (i16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (i16) y;
      }

      // now convert them to our format
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (i16) vertices[off+i].x;
         y     = (i16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            // now start the new one
            start_off = !(flags & 1);
            if (start_off) {
               // if we start off with an off-curve point, then when we need to find a point on the curve
               // where we can start, and we need to save some state for when we wraparound.
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  // next point is also a curve point, so interpolate an on-point curve
                  sx = (x + (i32) vertices[off+i+1].x) >> 1;
                  sy = (y + (i32) vertices[off+i+1].y) >> 1;
               } else {
                  // otherwise just use the next point as our start point
                  sx = (i32) vertices[off+i+1].x;
                  sy = (i32) vertices[off+i+1].y;
                  ++i; // we're using point i+1 as the starting point, so skip it
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { // if it's a curve
               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours < 0) {
      // Compound shapes.
      int more = 1;
      u8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         u16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;

         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { // XY values
            if (flags & 1) { // shorts
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            // @TODO handle matching point
            assert(0);
         }
         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }

         // Find transformation scales.
         m = (float) sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         // Get indexed glyph.
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            // Transform vertices.
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            // Append vertices.
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0) memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
            memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         // More components ?
         more = flags & (1<<5);
      }
   } else {
      // numberOfCounters == 0, do nothing
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   i32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

STBTT_DEF void stbtt__track_vertex(stbtt__csctx *c, i32 x, i32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

STBTT_DEF void stbtt__csctx_v(stbtt__csctx *c, u8 type, i32 x, i32 y, i32 cx, i32 cy, i32 cx1, i32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (i16) cx1;
      c->pvertices[c->num_vertices].cy1 = (i16) cy1;
   }
   c->num_vertices++;
}

STBTT_DEF void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

STBTT_DEF void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

STBTT_DEF void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

STBTT_DEF void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

STBTT_DEF stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

STBTT_DEF stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      // untested
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) stbtt__new_buf(NULL, 0);
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

STBTT_DEF int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   // this currently ignores the initial width value, which isn't needed if we have hmtx
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      // @TODO implement hinting
      case 0x13: // hintmask
      case 0x14: // cntrmask
         if (in_header)
            maskbits += (sp / 2); // implicit "vstem"
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: // hstem
      case 0x03: // vstem
      case 0x12: // hstemhm
      case 0x17: // vstemhm
         maskbits += (sp / 2);
         break;

      case 0x15: // rmoveto
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: // vmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: // hmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: // rlineto
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
      // starting from a different place.

      case 0x07: // vlineto
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: // hlineto
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: // hvcurveto
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: // vhcurveto
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: // rrcurveto
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: // rcurveline
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: // rlinecurve
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: // vvcurveto
      case 0x1B: // hhcurveto
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: // callsubr
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         // fallthrough
      case 0x1D: // callgsubr
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: // return
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: // endchar
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { // two-byte escape
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         // @TODO These "flex" implementations ignore the flex-depth and resolution,
         // and always draw beziers.
         case 0x22: // hflex
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: // flex
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            //fd is s[12]
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: // hflex1
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: // flex1
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (fabs(dx) > fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254))
            return STBTT__CSERR("reserved operator");

         // push immediate
         if (b0 == 255) {
            f = (float)(i32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(i16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

STBTT_DEF int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   // runs the charstring twice, once to count and once to output (to avoid realloc)
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   u8 *data = info->data + info->kern;
   u32 needle, straw;
   int l, r, m;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); // note: unaligned read
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

STBTT_DEF i32  stbtt__GetCoverageIndex(u8 *coverageTable, int glyph)
{
    u16 coverageFormat = ttUSHORT(coverageTable);
    switch(coverageFormat) {
        case 1: {
            u16 glyphCount = ttUSHORT(coverageTable + 2);

            // Binary search.
            i32 l=0, r=glyphCount-1, m;
            int straw, needle=glyph;
            while (l <= r) {
                u8 *glyphArray = coverageTable + 4;
                u16 glyphID;
                m = (l + r) >> 1;
                glyphID = ttUSHORT(glyphArray + 2 * m);
                straw = glyphID;
                if (needle < straw)
                    r = m - 1;
                else if (needle > straw)
                    l = m + 1;
                else {
                     return m;
                }
            }
        } break;

        case 2: {
            u16 rangeCount = ttUSHORT(coverageTable + 2);
            u8 *rangeArray = coverageTable + 4;

            // Binary search.
            i32 l=0, r=rangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                u8 *rangeRecord;
                m = (l + r) >> 1;
                rangeRecord = rangeArray + 6 * m;
                strawStart = ttUSHORT(rangeRecord);
                strawEnd = ttUSHORT(rangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else {
                    u16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
                    return startCoverageIndex + glyph - strawStart;
                }
            }
        } break;

        default: {
            // There are no other cases.
            assert(0);
        } break;
    }

    return -1;
}

STBTT_DEF i32  stbtt__GetGlyphClass(u8 *classDefTable, int glyph)
{
    u16 classDefFormat = ttUSHORT(classDefTable);
    switch(classDefFormat)
    {
        case 1: {
            u16 startGlyphID = ttUSHORT(classDefTable + 2);
            u16 glyphCount = ttUSHORT(classDefTable + 4);
            u8 *classDef1ValueArray = classDefTable + 6;

            if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
                return (i32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));

            classDefTable = classDef1ValueArray + 2 * glyphCount;
        } break;

        case 2: {
            u16 classRangeCount = ttUSHORT(classDefTable + 2);
            u8 *classRangeRecords = classDefTable + 4;

            // Binary search.
            i32 l=0, r=classRangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                u8 *classRangeRecord;
                m = (l + r) >> 1;
                classRangeRecord = classRangeRecords + 6 * m;
                strawStart = ttUSHORT(classRangeRecord);
                strawEnd = ttUSHORT(classRangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else
                    return (i32)ttUSHORT(classRangeRecord + 4);
            }

            classDefTable = classRangeRecords + 6 * classRangeCount;
        } break;

        default: {
            // There are no other cases.
            assert(0);
        } break;
    }

    return -1;
}

// Define to assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x) assert(x)

STBTT_DEF i32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
    u16 lookupListOffset;
    u8 *lookupList;
    u16 lookupCount;
    u8 *data;
    i32 i;

    if (!info->gpos) return 0;

    data = info->data + info->gpos;

    if (ttUSHORT(data+0) != 1) return 0; // Major version 1
    if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

    lookupListOffset = ttUSHORT(data+8);
    lookupList = data + lookupListOffset;
    lookupCount = ttUSHORT(lookupList);

    for (i=0; i<lookupCount; ++i) {
        u16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
        u8 *lookupTable = lookupList + lookupOffset;

        u16 lookupType = ttUSHORT(lookupTable);
        u16 subTableCount = ttUSHORT(lookupTable + 4);
        u8 *subTableOffsets = lookupTable + 6;
        switch(lookupType) {
            case 2: { // Pair Adjustment Positioning Subtable
                i32 sti;
                for (sti=0; sti<subTableCount; sti++) {
                    u16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
                    u8 *table = lookupTable + subtableOffset;
                    u16 posFormat = ttUSHORT(table);
                    u16 coverageOffset = ttUSHORT(table + 2);
                    i32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
                    if (coverageIndex == -1) continue;

                    switch (posFormat) {
                        case 1: {
                            i32 l, r, m;
                            int straw, needle;
                            u16 valueFormat1 = ttUSHORT(table + 4);
                            u16 valueFormat2 = ttUSHORT(table + 6);
                            i32 valueRecordPairSizeInBytes = 2;
                            u16 pairSetCount = ttUSHORT(table + 8);
                            u16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                            u8 *pairValueTable = table + pairPosOffset;
                            u16 pairValueCount = ttUSHORT(pairValueTable);
                            u8 *pairValueArray = pairValueTable + 2;
                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            assert(coverageIndex < pairSetCount);
                            STBTT__NOTUSED(pairSetCount);

                            needle=glyph2;
                            r=pairValueCount-1;
                            l=0;

                            // Binary search.
                            while (l <= r) {
                                u16 secondGlyph;
                                u8 *pairValue;
                                m = (l + r) >> 1;
                                pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                                secondGlyph = ttUSHORT(pairValue);
                                straw = secondGlyph;
                                if (needle < straw)
                                    r = m - 1;
                                else if (needle > straw)
                                    l = m + 1;
                                else {
                                    i16 xAdvance = ttSHORT(pairValue + 2);
                                    return xAdvance;
                                }
                            }
                        } break;

                        case 2: {
                            u16 valueFormat1 = ttUSHORT(table + 4);
                            u16 valueFormat2 = ttUSHORT(table + 6);

                            u16 classDef1Offset = ttUSHORT(table + 8);
                            u16 classDef2Offset = ttUSHORT(table + 10);
                            int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                            int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                            u16 class1Count = ttUSHORT(table + 12);
                            u16 class2Count = ttUSHORT(table + 14);
                            assert(glyph1class < class1Count);
                            assert(glyph2class < class2Count);

                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {
                                u8 *class1Records = table + 16;
                                u8 *class2Records = class1Records + 2 * (glyph1class * class2Count);
                                i16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                                return xAdvance;
                            }
                        } break;

                        default: {
                            // There are no other cases.
                            assert(0);
                            break;
                        };
                    }
                }
                break;
            };

            default:
                // TODO: Implement other stuff.
                break;
        }
    }

    return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);
   else if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

STBTT_DEF void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

STBTT_DEF void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

STBTT_DEF void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

STBTT_DEF stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   assert(z != NULL);
   if (!z) return z;

   // round dx down to avoid overshooting
   if (dxdy < 0)
      z->dx = -floor(STBTT_FIX * -dxdy);
   else
      z->dx = floor(STBTT_FIX * dxdy);

   z->x = floor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
STBTT_DEF stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   assert(z != NULL);
   //assert(e->y0 <= start_point);
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1

STBTT_DEF void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   // non-zero winding fill
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         // if we're currently at zero, we need to record the edge start point
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         // if we went to zero, we need to draw
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  // x0,x1 are the same pixel, so compute combined coverage
                  scanline[i] = scanline[i] + (u8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) // add antialiasing for x0
                     scanline[i] = scanline[i] + (u8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; // clip

                  if (j < len) // add antialiasing for x1
                     scanline[j] = scanline[j] + (u8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; // clip

                  for (++i; i < j; ++i) // fill pixels between x0 and x1
                     scanline[i] = scanline[i] + (u8) max_weight;
               }
            }
         }
      }

      e = e->next;
   }
}

STBTT_DEF void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  // weight per vertical scanline
   int s; // vertical subsample index
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         // find center of pixel for this scanline
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         // update all active edges;
         // remove all active edges that terminate before the center of this scanline
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; // delete from list
               assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; // advance to position for current scanline
               step = &((*step)->next); // advance through list
            }
         }

         // resort the list if needed
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  // find insertion point
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     // insert at front
                     z->next = active;
                     active = z;
                  } else {
                     // find thing to insert AFTER
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     // at this point, p->next->x is NOT < z->x
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         // now process all active edges in XOR fashion
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

STBTT_DEF void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   assert(y0 < y1);
   assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      assert(x1 <= x+1);
   else if (x0 == x+1)
      assert(x1 >= x);
   else if (x0 <= x)
      assert(x1 <= x);
   else if (x0 >= x+1)
      assert(x1 >= x+1);
   else
      assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
   }
}

STBTT_DEF void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      // brute force every pixel

      // compute intersection points with top & bottom
      assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         assert(e->sy <= y_bottom && e->ey >= y_top);

         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            // from here on, we don't have to range check x values

            if ((int) x_top == (int) x_bottom) {
               float height;
               // simple case, only spans one pixel
               int x = (int) x_top;
               height = sy1 - sy0;
               assert(x >= 0 && x < len);
               scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;
               scanline_fill[x] += e->direction * height; // everything right of this pixel is filled
            } else {
               int x,x1,x2;
               float y_crossing, step, sign, area;
               // covers 2+ pixels
               if (x_top > x_bottom) {
                  // flip scanline vertically; signed area is the same
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
               }

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               // compute intersection with y axis at x1+1
               y_crossing = (x1+1 - x0) * dy + y_top;

               sign = e->direction;
               // area of the rectangle covered from y0..y_crossing
               area = sign * (y_crossing-sy0);
               // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
               scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

               step = sign * dy;
               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2;
                  area += step;
               }
               y_crossing += dy * (x2 - (x1+1));

               assert(fabs(area) <= 1.01f);

               scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            int x;
            for (x=0; x < len; ++x) {

               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  // one segment
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

// directly AA rasterize edges w/o supersampling
STBTT_DEF void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      // find center of pixel for this scanline
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      memset(scanline , 0, result->w*sizeof(scanline[0]));
      memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      // update all active edges;
      // remove all active edges that terminate before the top of this scanline
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; // delete from list
            assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); // advance through list
         }
      }

      // insert all edges that start before the bottom of this scanline
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               if (j == 0 && off_y != 0) {
                  if (z->ey < scan_y_top) {
                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
                     z->ey = scan_y_top;
                  }
               }
               assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
               // insert at front
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      // now process all active edges
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;
            result->pixels[j*result->stride + i] = (unsigned char) m;
         }
      }
      // advance all the edges
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; // advance to position for current scanline
         step = &((*step)->next); // advance through list
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

STBTT_DEF void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

STBTT_DEF void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

STBTT_DEF void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

STBTT_DEF void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity

   // now we have to blow out the windings into explicit edge lists
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         // skip the edge if horizontal
         if (p[j].y == p[k].y)
            continue;
         // add edge from j to k to the list
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   // now sort the edges by their highest point (should snap to integer, and then by x)
   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
   stbtt__sort_edges(e, n);

   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

STBTT_DEF void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; // during first pass, it's unallocated
   points[n].x = x;
   points[n].y = y;
}

// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
STBTT_DEF int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   // midpoint
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   // versus directly drawn line
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) // 65536 segments on one curve better be enough!
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

STBTT_DEF void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (sqrt(dx0*dx0+dy0*dy0)+sqrt(dx1*dx1+dy1*dy1)+sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) // 65536 segments on one curve better be enough!
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

// returns number of contours
STBTT_DEF stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   // count how many "moves" there are to get the contour count
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   // make two passes through the points so we don't need to realloc
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               // start the next contour
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      // e.g. space character
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
      if (ix0) *ix0 = floor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = floor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = ceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = ceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   // now we get the size
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; // in case we error

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}


STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char* const_data, int fontstart)
{
   unsigned char* data = (unsigned char*)const_data;

   u32 cmap, t;
   i32 i,numTables;

   info->data = (unsigned char*)data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
   info->head = stbtt__find_table(data, fontstart, "head"); // required
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      // required for truetype
      if (!info->loca) return 0;
   } else {
      // initialization for CFF / Type2 fonts (OTF)
      stbtt__buf b, topdict, topdictidx;
      u32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      u32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      // @TODO this should use size from table (not 512MB)
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      // read the header
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

      // @TODO the name INDEX could list multiple fonts,
      // but we just use the first one.
      stbtt__cff_get_index(&b);  // name INDEX
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  // string INDEX
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      // we only support Type 2 charstrings
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         // looks like a CID font
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   info->svg = -1;

   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      u32 encoding_record = cmap + 4 + 8 * i;
      // find an encoding we understand:
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  // MS/Unicode
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            // Mac/iOS has these
            // all the encodingIDs are unicode, so we don't bother to check it
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT((unsigned char*)data + info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint) {
   u8 *data = info->data;
   u32 index_map = info->index_map;

   u16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { // apple byte encoding
      i32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      u32 first = ttUSHORT(data + index_map + 6);
      u32 count = ttUSHORT(data + index_map + 8);
      if ((u32) unicode_codepoint >= first && (u32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      return 0;
   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
      u16 segcount = ttUSHORT(data+index_map+6) >> 1;
      u16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      u16 entrySelector = ttUSHORT(data+index_map+10);
      u16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      // do a binary search of the segments
      u32 endCount = index_map + 14;
      u32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      // they lie from endCount .. endCount + segCount
      // but searchRange is the nearest power of two, so...
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      // now decrement to bias correctly to find smallest
      search -= 2;
      while (entrySelector) {
         u16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         u16 offset, start;
         u16 item = (u16) ((search - endCount) >> 1);

         assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));
         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         if (unicode_codepoint < start)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (u16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      u32 ngroups = ttULONG(data+index_map+12);
      i32 low,high;
      low = 0; high = (i32)ngroups;
      // Binary search the right group.
      while (low < high) {
         i32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
         u32 start_char = ttULONG(data+index_map+16+mid*12);
         u32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((u32) unicode_codepoint < start_char)
            high = mid;
         else if ((u32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            u32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else // format == 13
               return start_glyph;
         }
      }
      return 0; // not found
   }
   // @TODO
   assert(0);
   return 0;
}

STBTT_DEF int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; // if length is 0, return -1
}

STBTT_DEF int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
#endif /* n RFONT_EXTERNAL_STB */

/* 
END of stb_truetype defines and source code required by RFont
*/

#endif /* RFONT_IMPLEMENTATION */
/*
* Copyright (C) 2023-24 ColleagueRiley
*
* libpng license
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not
*    claim that you wrote the original software. If you use this software
*    in a product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*
*
*/

/*
	(MAKE SURE RGFW_IMPLEMENTATION is in exactly one header or you use -D RGFW_IMPLEMENTATION)
	#define RGFW_IMPLEMENTATION - makes it so source code is included with header
*/

/*
	#define RGFW_IMPLEMENTATION - (required) makes it so the source code is included
	#define RGFW_PRINT_ERRORS - (optional) makes it so RGFW prints errors when they're found
	#define RGFW_OSMESA - (optional) use OSmesa as backend (instead of system's opengl api + regular opengl)
	#define RGFW_BUFFER - (optional) just draw directly to (RGFW) window pixel buffer that is drawn to screen (the buffer is in the RGBA format)
	#define RGFW_EGL - (optional) use EGL for loading an OpenGL context (instead of the system's opengl api)
	#define RGFW_OPENGL_ES1 - (optional) use EGL to load and use Opengl ES (version 1) for backend rendering (instead of the system's opengl api)
									This version doesn't work for desktops (I'm pretty sure)
	#define RGFW_OPENGL_ES2 - (optional) use OpenGL ES (version 2)
	#define RGFW_OPENGL_ES3 - (optional) use OpenGL ES (version 3)
	#define RGFW_DIRECTX - (optional) use directX for the rendering backend (rather than opengl) (windows only, defaults to opengl for unix)
	#define RGFW_NO_API - (optional) don't use any rendering API (no opengl, no vulkan, no directX)

	#define RGFW_LINK_EGL (optional) (windows only) if EGL is being used, if EGL functions should be defined dymanically (using GetProcAddress)
	#define RGFW_LINK_OSMESA (optional) (windows only) if EGL is being used, if OS Mesa functions should be defined dymanically  (using GetProcAddress)

	#define RGFW_X11 (optional) (unix only) if X11 should be used. This option is turned on by default by unix systems except for MacOS
	#define RGFW_WGL_LOAD (optional) (windows only) if WGL should be loaded dynamically during runtime
	#define RGFW_NO_X11_CURSOR (optional) (unix only) don't use XCursor
	#define RGFW_NO_X11_CURSOR_PRELOAD (optional) (unix only) Use XCursor, but don't link it in code, (you'll have to link it with -lXcursor)

	#define RGFW_NO_DPI - Do not include calculate DPI (no XRM nor libShcore included)

	#define RGFW_ALLOC_DROPFILES (optional) if room should be allocating for drop files (by default it's global data)
	#define RGFW_MALLOC x - choose what function to use to allocate, by default the standard malloc is used
	#define RGFW_CALLOC x - choose what function to use to allocate (calloc), by default the standard calloc is used
	#define RGFW_FREE x - choose what function to use to allocated memory, by default the standard free is used

 	#define RGFW_EXPORT - Use when building RGFW 
    #define RGFW_IMPORT - Use when linking with RGFW (not as a single-header)
	
	#define RGFW_STD_INT - force the use stdint.h (for systems that might not have stdint.h (msvc)) 
*/

/*
	Credits :
		EimaMei/Sacode : Much of the code for creating windows using winapi, Wrote the Silicon library, helped with MacOS Support, siliapp.h -> referencing 

		stb - This project is heavily inspired by the stb single header files

		GLFW:
			certain parts of winapi and X11 are very poorly documented,
			GLFW's source code was referenced and used throughout the project (used code is marked in some way),
			this mainly includes, code for drag and drops, code for setting the icon to a bitmap and the code for managing the clipboard for X11 (as these parts are not documented very well)

			GLFW Copyright, https::/github.com/GLFW/GLFW

			Copyright (c) 2002-2006 Marcus Geelnard
			Copyright (c) 2006-2019 Camilla Lwy

		contributors : (feel free to put yourself here if you contribute)
		krisvers -> code review
		EimaMei (SaCode) -> code review
		Code-Nycticebus -> bug fixes
		Rob Rohan -> X11 bugs and missing features, MacOS/Cocoa fixing memory issues/bugs 
		AICDG (@THISISAGOODNAME) -> vulkan support (example)
		@Easymode -> support, testing/debugging, bug fixes and reviews
*/

#if _MSC_VER
	#pragma comment(lib, "gdi32")
	#pragma comment(lib, "shell32")
	#pragma comment(lib, "opengl32")
	#pragma comment(lib, "winmm")
	#pragma comment(lib, "user32")
#endif

#ifndef RGFW_MALLOC
	#include <stdlib.h>

	#ifndef __USE_POSIX199309
	#define __USE_POSIX199309
	#endif

	#include <time.h>
	#define RGFW_MALLOC malloc
	#define RGFW_CALLOC calloc
	#define RGFW_FREE free
#endif

#if !_MSC_VER
	#ifndef inline
		#ifndef __APPLE__
			#define inline __inline
		#endif
	#endif
#endif

#ifdef RGFW_WIN95 /* for windows 95 testing (not that it really works) */
	#define RGFW_NO_MONITOR
	#define RGFW_NO_PASSTHROUGH
#endif

#if defined(RGFW_EXPORT) ||  defined(RGFW_IMPORT)
	#if defined(_WIN32)
		#if defined(__TINYC__) && (defined(RGFW_EXPORT) ||  defined(RGFW_IMPORT))
			#define __declspec(x) __attribute__((x))
		#endif

		#if defined(RGFW_EXPORT)
			#define RGFWDEF __declspec(dllexport)
		#else 
			#define RGFWDEF __declspec(dllimport)
		#endif
	#else
		#if defined(RGFW_EXPORT)
			#define RGFWDEF __attribute__((visibility("default")))
		#endif
	#endif
#endif 

#ifndef RGFWDEF
	#ifdef __clang__
		#define RGFWDEF static inline
	#else
		#define RGFWDEF inline
	#endif
#endif

#ifndef RGFW_ENUM
	#define RGFW_ENUM(type, name) type name; enum
#endif

#ifndef RGFW_UNUSED
	#define RGFW_UNUSED(x) (void)(x);
#endif

#if defined(__cplusplus) && !defined(__EMSCRIPTEN__)
	extern "C" {
#endif

	/* makes sure the header file part is only defined once by default */
#ifndef RGFW_HEADER

#define RGFW_HEADER

#if !defined(u8)
	#if ((defined(_MSC_VER) || defined(__SYMBIAN32__)) && !defined(RGFW_STD_INT)) /* MSVC might not have stdint.h */
		typedef unsigned char 	u8;
		typedef signed char		i8;
		typedef unsigned short  u16;
		typedef signed short 	i16;
		typedef unsigned int 	u32;
		typedef signed int		i32;
		typedef unsigned long	u64;
		typedef signed long		i64;
	#else /* use stdint standard types instead of c ""standard"" types */
		#include <stdint.h>

		typedef uint8_t     u8;
		typedef int8_t      i8;
		typedef uint16_t   u16;
		typedef int16_t    i16;
		typedef uint32_t   u32;
		typedef int32_t    i32;
		typedef uint64_t   u64;
		typedef int64_t    i64;
	#endif
#endif

#if !defined(b8) /* RGFW bool type */
	typedef u8 b8;
	typedef u32 b32;
#endif

#define RGFW_TRUE 1
#define RGFW_FALSE 0

/* thse OS macros looks better & are standardized */
/* plus it helps with cross-compiling */

#ifdef __EMSCRIPTEN__
	#define RGFW_WEBASM

	#ifndef RGFW_NO_API
		#define RGFW_OPENGL
	#endif

	#ifdef RGFW_EGL
		#undef RGFW_EGL
	#endif

	#include <emscripten/html5.h>
	#include <emscripten/key_codes.h>
#endif

#if defined(RGFW_X11) && defined(__APPLE__)
	#define RGFW_MACOS_X11
	#undef __APPLE__
#endif

#if defined(_WIN32) && !defined(RGFW_X11) && !defined(RGFW_WEBASM) /* (if you're using X11 on windows some how) */
	#define RGFW_WINDOWS

	/* make sure the correct architecture is defined */
	#if defined(_WIN64)
		#define _AMD64_
		#undef _X86_
	#else
		#undef _AMD64_
		#ifndef _X86_
			#define _X86_
		#endif
	#endif

	#ifndef RGFW_NO_XINPUT
		#ifdef __MINGW32__ /* try to find the right header */
			#include <xinput.h>
		#else
			#include <XInput.h>
		#endif
	#endif

	#if defined(RGFW_DIRECTX)
		#include <d3d11.h>
		#include <dxgi.h>
		#include <dxgi.h>
		#include <d3dcompiler.h>

		#ifndef __cplusplus
			#define __uuidof(T) IID_##T
		#endif
	#endif

#elif defined(RGFW_WAYLAND)
    #if !defined(RGFW_NO_API) && (!defined(RGFW_BUFFER) || defined(RGFW_OPENGL))
		#define RGFW_EGL
		#define RGFW_OPENGL
		#include <wayland-egl.h>
	#endif

	#include <wayland-client.h>
#elif (defined(__unix__) || defined(RGFW_MACOS_X11) || defined(RGFW_X11))  && !defined(RGFW_WEBASM)
	#define RGFW_MACOS_X11
	#define RGFW_X11
	#include <X11/Xlib.h>
#elif defined(__APPLE__) && !defined(RGFW_MACOS_X11) && !defined(RGFW_X11)  && !defined(RGFW_WEBASM)
	#define RGFW_MACOS
#endif

#if (defined(RGFW_OPENGL_ES1) || defined(RGFW_OPENGL_ES2) || defined(RGFW_OPENGL_ES3)) && !defined(RGFW_EGL)
	#define RGFW_EGL
#endif

#if !defined(RGFW_OSMESA) && !defined(RGFW_EGL) && !defined(RGFW_OPENGL) && !defined(RGFW_DIRECTX) && !defined(RGFW_BUFFER) && !defined(RGFW_NO_API)
	#define RGFW_OPENGL
#endif

#ifdef RGFW_EGL
	#if defined(__APPLE__)
		#warning  EGL is not supported for Cocoa, switching back to the native opengl api
		#undef RGFW_EGL
	#endif

	#include <EGL/egl.h>
#elif defined(RGFW_OSMESA)
	#ifndef __APPLE__
		#include <GL/osmesa.h>
	#else
		#include <OpenGL/osmesa.h>
	#endif
#endif

#if defined(RGFW_OPENGL) && defined(RGFW_X11)
	#ifndef GLX_MESA_swap_control
		#define  GLX_MESA_swap_control
	#endif
	#include <GL/glx.h> /* GLX defs, xlib.h, gl.h */
#endif

#ifndef RGFW_ALPHA
	#define RGFW_ALPHA 128 /* alpha value for RGFW_TRANSPARENT_WINDOW (WINAPI ONLY, macOS + linux don't need this) */
#endif

/*! Optional arguments for making a windows */
#define RGFW_TRANSPARENT_WINDOW		(1L<<9) /*!< the window is transparent (only properly works on X11 and MacOS, although it's although for windows) */
#define RGFW_NO_BORDER		(1L<<3) /*!< the window doesn't have border */
#define RGFW_NO_RESIZE		(1L<<4) /*!< the window cannot be resized  by the user */
#define RGFW_ALLOW_DND     (1L<<5) /*!< the window supports drag and drop*/
#define RGFW_HIDE_MOUSE (1L<<6) /*! the window should hide the mouse or not (can be toggled later on) using `RGFW_window_mouseShow*/
#define RGFW_FULLSCREEN (1L<<8) /* the window is fullscreen by default or not */
#define RGFW_CENTER (1L<<10) /*! center the window on the screen */
#define RGFW_OPENGL_SOFTWARE (1L<<11) /*! use OpenGL software rendering */
#define RGFW_COCOA_MOVE_TO_RESOURCE_DIR (1L << 12) /* (cocoa only), move to resource folder */
#define RGFW_SCALE_TO_MONITOR (1L << 13) /* scale the window to the screen */
#define RGFW_NO_INIT_API (1L << 2) /* DO not init an API (mostly for bindings, you should use `#define RGFW_NO_API` in C */

#define RGFW_NO_GPU_RENDER (1L<<14) /* don't render (using the GPU based API)*/
#define RGFW_NO_CPU_RENDER (1L<<15) /* don't render (using the CPU based buffer rendering)*/
#define RGFW_WINDOW_HIDE (1L <<  16)/* the window is hidden */

typedef RGFW_ENUM(u8, RGFW_event_types) {
	/*! event codes */
 	RGFW_keyPressed = 1, /* a key has been pressed */
	RGFW_keyReleased, /*!< a key has been released*/
	/*! key event note
		the code of the key pressed is stored in
		RGFW_Event.keyCode
		!!Keycodes defined at the bottom of the RGFW_HEADER part of this file!!

		while a string version is stored in
		RGFW_Event.KeyString

		RGFW_Event.lockState holds the current lockState
		this means if CapsLock, NumLock are active or not
	*/
	RGFW_mouseButtonPressed, /*!< a mouse button has been pressed (left,middle,right)*/
	RGFW_mouseButtonReleased, /*!< a mouse button has been released (left,middle,right)*/
	RGFW_mousePosChanged, /*!< the position of the mouse has been changed*/
	/*! mouse event note
		the x and y of the mouse can be found in the vector, RGFW_Event.point

		RGFW_Event.button holds which mouse button was pressed
	*/
	RGFW_jsButtonPressed, /*!< a joystick button was pressed */
	RGFW_jsButtonReleased, /*!< a joystick button was released */
	RGFW_jsAxisMove, /*!< an axis of a joystick was moved*/
	/*! joystick event note
		RGFW_Event.joystick holds which joystick was altered, if any
		RGFW_Event.button holds which joystick button was pressed

		RGFW_Event.axis holds the data of all the axis
		RGFW_Event.axisCount says how many axis there are
	*/
	RGFW_windowMoved, /*!< the window was moved (by the user) */
	RGFW_windowResized, /*!< the window was resized (by the user), [on webASM this means the browser was resized] */
	RGFW_focusIn, /*!< window is in focus now */
	RGFW_focusOut, /*!< window is out of focus now */
	RGFW_mouseEnter, /* mouse entered the window */
	RGFW_mouseLeave, /* mouse left the window */
	RGFW_windowRefresh, /* The window content needs to be refreshed */

	/* attribs change event note
		The event data is sent straight to the window structure
		with win->r.x, win->r.y, win->r.w and win->r.h
	*/
	RGFW_quit, /*!< the user clicked the quit button*/ 
	RGFW_dnd, /*!< a file has been dropped into the window*/
	RGFW_dnd_init /*!< the start of a dnd event, when the place where the file drop is known */
	/* dnd data note
		The x and y coords of the drop are stored in the vector RGFW_Event.point

		RGFW_Event.droppedFilesCount holds how many files were dropped

		This is also the size of the array which stores all the dropped file string,
		RGFW_Event.droppedFiles
	*/
};

/*! mouse button codes (RGFW_Event.button) */
#define RGFW_mouseLeft  1 /*!< left mouse button is pressed*/
#define RGFW_mouseMiddle  2 /*!< mouse-wheel-button is pressed*/
#define RGFW_mouseRight  3 /*!< right mouse button is pressed*/
#define RGFW_mouseScrollUp  4 /*!< mouse wheel is scrolling up*/
#define RGFW_mouseScrollDown  5 /*!< mouse wheel is scrolling down*/

#ifndef RGFW_MAX_PATH
#define RGFW_MAX_PATH 260 /* max length of a path (for dnd) */
#endif
#ifndef RGFW_MAX_DROPS
#define RGFW_MAX_DROPS 260 /* max items you can drop at once */
#endif


/* for RGFW_Event.lockstate */
#define RGFW_CAPSLOCK (1L << 1)
#define RGFW_NUMLOCK (1L << 2)

/*! joystick button codes (based on xbox/playstation), you may need to change these values per controller */
#ifndef RGFW_joystick_codes
	typedef RGFW_ENUM(u8, RGFW_joystick_codes) {
		RGFW_JS_A = 0, /*!< or PS X button */
		RGFW_JS_B = 1, /*!< or PS circle button */
		RGFW_JS_Y = 2, /*!< or PS triangle button */
		RGFW_JS_X = 3, /*!< or PS square button */
		RGFW_JS_START = 9, /*!< start button */
		RGFW_JS_SELECT = 8, /*!< select button */
		RGFW_JS_HOME = 10, /*!< home button */
		RGFW_JS_UP = 13, /*!< dpad up */
		RGFW_JS_DOWN = 14, /*!< dpad down*/
		RGFW_JS_LEFT = 15, /*!< dpad left */
		RGFW_JS_RIGHT = 16, /*!< dpad right */
		RGFW_JS_L1 = 4, /*!< left bump */
		RGFW_JS_L2 = 5, /*!< left trigger*/
		RGFW_JS_R1 = 6, /*!< right bumper */
		RGFW_JS_R2 = 7, /*!< right trigger */
	};
#endif

/*! basic vector type, if there's not already a point/vector type of choice */
#ifndef RGFW_point
	typedef struct { i32 x, y; } RGFW_point;
#endif

/*! basic rect type, if there's not already a rect type of choice */
#ifndef RGFW_rect
	typedef struct { i32 x, y, w, h; } RGFW_rect;
#endif

/*! basic area type, if there's not already a area type of choice */
#ifndef RGFW_area
	typedef struct { u32 w, h; } RGFW_area;
#endif

#ifndef __cplusplus
#define RGFW_POINT(x, y) (RGFW_point){(i32)(x), (i32)(y)}
#define RGFW_RECT(x, y, w, h) (RGFW_rect){(i32)(x), (i32)(y), (i32)(w), (i32)(h)}
#define RGFW_AREA(w, h) (RGFW_area){(u32)(w), (u32)(h)}
#else
#define RGFW_POINT(x, y) {(i32)(x), (i32)(y)}
#define RGFW_RECT(x, y, w, h) {(i32)(x), (i32)(y), (i32)(w), (i32)(h)}
#define RGFW_AREA(w, h) {(u32)(w), (u32)(h)}
#endif

#ifndef RGFW_NO_MONITOR
	/*! structure for monitor data */
	typedef struct RGFW_monitor {
		char name[128]; /*!< monitor name */
		RGFW_rect rect; /*!< monitor Workarea */
		float scaleX, scaleY; /*!< monitor content scale*/
		float physW, physH; /*!< monitor physical size */
	} RGFW_monitor;

	/*
		NOTE : Monitor functions should be ran only as many times as needed (not in a loop)
	*/

	/*! get an array of all the monitors (max 6) */
	RGFWDEF RGFW_monitor* RGFW_getMonitors(void);
	/*! get the primary monitor */
	RGFWDEF RGFW_monitor RGFW_getPrimaryMonitor(void);
#endif

/* NOTE: some parts of the data can represent different things based on the event (read comments in RGFW_Event struct) */
/*! Event structure for checking/getting events */
typedef struct RGFW_Event {
	char keyName[16]; /*!< key name of event*/

	/*! drag and drop data */
	/* 260 max paths with a max length of 260 */
#ifdef RGFW_ALLOC_DROPFILES
	char** droppedFiles;
#else
	char droppedFiles[RGFW_MAX_DROPS][RGFW_MAX_PATH]; /*!< dropped files*/
#endif
	u32 droppedFilesCount; /*!< house many files were dropped */

	u32 type; /*!< which event has been sent?*/
	RGFW_point point; /*!< mouse x, y of event (or drop point) */
	
	u8 keyCode; /*!< keycode of event 	!!Keycodes defined at the bottom of the RGFW_HEADER part of this file!! */	
	
	b8 repeat; /*!< key press event repeated (the key is being held) */
	b8 inFocus;  /*!< if the window is in focus or not (this is always true for MacOS windows due to the api being weird) */

	u8 lockState;
	
	u8 button; /* !< which mouse button was pressed */
	double scroll; /*!< the raw mouse scroll value */

	u16 joystick; /*! which joystick this event applies to (if applicable to any) */
	u8 axisesCount; /*!< number of axises */
	RGFW_point axis[2]; /*!< x, y of axises (-100 to 100) */

	u64 frameTime, frameTime2; /*!< this is used for counting the fps */
} RGFW_Event;

/*! source data for the window (used by the APIs) */
typedef struct RGFW_window_src {
#ifdef RGFW_WINDOWS
	HWND window; /*!< source window */
	HDC hdc; /*!< source HDC */
	u32 hOffset; /*!< height offset for window */
	#if (defined(RGFW_OPENGL)) && !defined(RGFW_OSMESA) && !defined(RGFW_EGL)
		HGLRC ctx; /*!< source graphics context */
	#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
	#elif defined(RGFW_DIRECTX)
		IDXGISwapChain* swapchain;
		ID3D11RenderTargetView* renderTargetView;
		ID3D11DepthStencilView* pDepthStencilView;
	#elif defined(RGFW_EGL)
		EGLSurface EGL_surface;
		EGLDisplay EGL_display;
		EGLContext EGL_context;
	#endif

	#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
		HDC hdcMem;
		HBITMAP bitmap;
	#endif
	RGFW_area maxSize, minSize; /*!< for setting max/min resize (RGFW_WINDOWS) */
#elif defined(RGFW_X11)
	Display* display; /*!< source display */
	Window window; /*!< source window */
	#if (defined(RGFW_OPENGL)) && !defined(RGFW_OSMESA) && !defined(RGFW_EGL)
		GLXContext ctx; /*!< source graphics context */
	#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
	#elif defined(RGFW_EGL)
		EGLSurface EGL_surface;
		EGLDisplay EGL_display;
		EGLContext EGL_context;
	#endif

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
		XImage* bitmap;
		GC gc;
#endif
#elif defined(RGFW_WAYLAND)
	struct wl_display* display;
	struct wl_surface* surface;
	struct wl_buffer* wl_buffer;
	struct wl_keyboard* keyboard;

	struct xdg_surface* xdg_surface;
	struct xdg_toplevel* xdg_toplevel;
	struct zxdg_toplevel_decoration_v1* decoration;
	RGFW_Event events[20];
		i32 eventLen;
		size_t eventIndex;
	#if defined(RGFW_EGL)
			struct wl_egl_window* window;
			EGLSurface EGL_surface;
			EGLDisplay EGL_display;
			EGLContext EGL_context;
	#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
	#endif
#elif defined(RGFW_MACOS)
	u32 display;
	void* displayLink;
	void* window;
	b8 dndPassed;
#if (defined(RGFW_OPENGL)) && !defined(RGFW_OSMESA) && !defined(RGFW_EGL)
		void* ctx; /*!< source graphics context */
#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
#elif defined(RGFW_EGL)
		EGLSurface EGL_surface;
		EGLDisplay EGL_display;
		EGLContext EGL_context;
#endif

	void* view; /*apple viewpoint thingy*/

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
		void* bitmap; /*!< API's bitmap for storing or managing */
		void* image;
#endif
#elif defined(RGFW_WEBASM)
	EMSCRIPTEN_WEBGL_CONTEXT_HANDLE ctx;
#endif
} RGFW_window_src;



typedef struct RGFW_window {
	RGFW_window_src src; /*!< src window data */

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
	u8* buffer; /*!< buffer for non-GPU systems (OSMesa, basic software rendering) */
	/* when rendering using RGFW_BUFFER, the buffer is in the RGBA format */
#endif
	void* userPtr; /* ptr for usr data */
	
	RGFW_Event event; /*!< current event */

	RGFW_rect r; /*!< the x, y, w and h of the struct */
	
	RGFW_point _lastMousePoint; /*!< last cusor point (for raw mouse data) */
	
	u32 _winArgs; /*!< windows args (for RGFW to check) */
} RGFW_window; /*!< Window structure for managing the window */

#if defined(RGFW_X11) || defined(RGFW_MACOS)
	typedef u64 RGFW_thread; /*!< thread type unix */
#else
	typedef void* RGFW_thread; /*!< thread type for window */
#endif

/** * @defgroup Window_management
* @{ */ 


/*! 
 * the class name for X11 and WinAPI. apps with the same class will be grouped by the WM
 * by default the class name will == the root window's name
*/
RGFWDEF void RGFW_setClassName(char* name);

/*! this has to be set before createWindow is called, else the fulscreen size is used */
RGFWDEF void RGFW_setBufferSize(RGFW_area size); /*!< the buffer cannot be resized (by RGFW) */

RGFW_window* RGFW_createWindow(
	const char* name, /* name of the window */
	RGFW_rect rect, /* rect of window */
	u16 args /* extra arguments (NULL / (u16)0 means no args used)*/
); /*!< function to create a window struct */

/*! get the size of the screen to an area struct */
RGFWDEF RGFW_area RGFW_getScreenSize(void);

/*!
	this function checks an *individual* event (and updates window structure attributes)
	this means, using this function without a while loop may cause event lag

	ex.

	while (RGFW_window_checkEvent(win) != NULL) [this keeps checking events until it reaches the last one]

	this function is optional if you choose to use event callbacks, 
	although you still need some way to tell RGFW to process events eg. `RGFW_window_checkEvents`
*/

RGFW_Event* RGFW_window_checkEvent(RGFW_window* win); /*!< check current event (returns a pointer to win->event or NULL if there is no event)*/

/*!
	for RGFW_window_eventWait and RGFW_window_checkEvents
	waitMS -> Allows th	e function to keep checking for events even after `RGFW_window_checkEvent == NULL`
			  if waitMS == 0, the loop will not wait for events
			  if waitMS == a positive integer, the loop will wait that many miliseconds after there are no more events until it returns
			  if waitMS == a negative integer, the loop will not return until it gets another event
*/
typedef RGFW_ENUM(i32, RGFW_eventWait) {
	RGFW_NEXT = -1,
	RGFW_NO_WAIT = 0
};

/*! sleep until RGFW gets an event or the timer ends (defined by OS) */
RGFWDEF void RGFW_window_eventWait(RGFW_window* win, i32 waitMS);

/*!
	check all the events until there are none left, 
	this should only be used if you're using callbacks only
*/
RGFWDEF void RGFW_window_checkEvents(RGFW_window* win, i32 waitMS);

/*! 
	Tell RGFW_window_eventWait to stop waiting, to be ran from another thread
*/
RGFWDEF void RGFW_stopCheckEvents(void);

/*! window managment functions*/
RGFWDEF void RGFW_window_close(RGFW_window* win); /*!< close the window and free leftover data */

/*! moves window to a given point */
RGFWDEF void RGFW_window_move(RGFW_window* win,
	RGFW_point v/*!< new pos*/
);

#ifndef RGFW_NO_MONITOR
	/*! move to a specific monitor */
	RGFWDEF void RGFW_window_moveToMonitor(RGFW_window* win, RGFW_monitor m /* monitor */);
#endif

/*! resize window to a current size/area */
RGFWDEF void RGFW_window_resize(RGFW_window* win, /*!< source window */
	RGFW_area a/*!< new size*/
);

/*! set the minimum size a user can shrink a window to a given size/area */
RGFWDEF void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a);
/*! set the minimum size a user can extend a window to a given size/area */
RGFWDEF void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a);

RGFWDEF void RGFW_window_maximize(RGFW_window* win); /*!< maximize the window size */
RGFWDEF void RGFW_window_minimize(RGFW_window* win); /*!< minimize the window (in taskbar (per OS))*/
RGFWDEF void RGFW_window_restore(RGFW_window* win); /*!< restore the window from minimized (per OS)*/

/*! if the window should have a border or not (borderless) based on bool value of `border` */
RGFWDEF void RGFW_window_setBorder(RGFW_window* win, b8 border);

/*! turn on / off dnd (RGFW_ALLOW_DND stil must be passed to the window)*/
RGFWDEF void RGFW_window_setDND(RGFW_window* win, b8 allow);

#ifndef RGFW_NO_PASSTHROUGH
	/*!! turn on / off mouse passthrough */
	RGFWDEF void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough);
#endif 

/*! rename window to a given string */
RGFWDEF void RGFW_window_setName(RGFW_window* win,
	char* name
);

void RGFW_window_setIcon(RGFW_window* win, /*!< source window */
	u8* icon /*!< icon bitmap */,
	RGFW_area a /*!< width and height of the bitmap*/,
	i32 channels /*!< how many channels the bitmap has (rgb : 3, rgba : 4) */
); /*!< image resized by default */

/*!< sets mouse to bitmap (very simular to RGFW_window_setIcon), image NOT resized by default*/
RGFWDEF void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels);

/*!< sets the mouse to a standard API cursor (based on RGFW_MOUSE, as seen at the end of the RGFW_HEADER part of this file) */
RGFWDEF	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse);

RGFWDEF void RGFW_window_setMouseDefault(RGFW_window* win); /*!< sets the mouse to the default mouse icon */
/*
	Locks cursor at the center of the window
	win->event.point become raw mouse movement data 

	this is useful for a 3D camera
*/
RGFWDEF void RGFW_window_mouseHold(RGFW_window* win, RGFW_area area);
/*! stop holding the mouse and let it move freely */
RGFWDEF void RGFW_window_mouseUnhold(RGFW_window* win);

/*! hide the window */
RGFWDEF void RGFW_window_hide(RGFW_window* win);
/*! show the window */
RGFWDEF void RGFW_window_show(RGFW_window* win);

/*
	makes it so `RGFW_window_shouldClose` returns true
	by setting the window event.type to RGFW_quit
*/
RGFWDEF void RGFW_window_setShouldClose(RGFW_window* win);

/*! where the mouse is on the screen */
RGFWDEF RGFW_point RGFW_getGlobalMousePoint(void);

/*! where the mouse is on the window */
RGFWDEF RGFW_point RGFW_window_getMousePoint(RGFW_window* win);

/*! show the mouse or hide the mouse*/
RGFWDEF void RGFW_window_showMouse(RGFW_window* win, i8 show);
/*! move the mouse to a set x, y pos*/
RGFWDEF void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v);

/*! if the window should close (RGFW_close was sent or escape was pressed) */
RGFWDEF b8 RGFW_window_shouldClose(RGFW_window* win);
/*! if window is fullscreen'd */
RGFWDEF b8 RGFW_window_isFullscreen(RGFW_window* win);
/*! if window is hidden */
RGFWDEF b8 RGFW_window_isHidden(RGFW_window* win);
/*! if window is minimized */
RGFWDEF b8 RGFW_window_isMinimized(RGFW_window* win);
/*! if window is maximized */
RGFWDEF b8 RGFW_window_isMaximized(RGFW_window* win);

/** @} */ 

/** * @defgroup Monitor
* @{ */ 

#ifndef RGFW_NO_MONITOR
/*
scale the window to the monitor,
this is run by default if the user uses the arg `RGFW_SCALE_TO_MONITOR` during window creation
*/
RGFWDEF void RGFW_window_scaleToMonitor(RGFW_window* win);
/*! get the struct of the window's monitor  */
RGFWDEF RGFW_monitor RGFW_window_getMonitor(RGFW_window* win);
#endif

/** @} */ 

/** * @defgroup Input
* @{ */ 

/*error handling*/
RGFWDEF b8 RGFW_Error(void); /*!< returns true if an error has occurred (doesn't print errors itself) */

/*! returns true if the key should be shifted */
RGFWDEF b8 RGFW_shouldShift(u32 keycode, u8 lockState);

/*! get char from RGFW keycode (using a LUT), uses shift'd version if shift = true */
RGFWDEF char RGFW_keyCodeToChar(u32 keycode, b8 shift);
/*! get char from RGFW keycode (using a LUT), uses lockState for shouldShift) */
RGFWDEF char RGFW_keyCodeToCharAuto(u32 keycode, u8 lockState);

/*! if window == NULL, it checks if the key is pressed globally. Otherwise, it checks only if the key is pressed while the window in focus.*/
RGFWDEF b8 RGFW_isPressed(RGFW_window* win, u8 key); /*!< if key is pressed (key code)*/

RGFWDEF b8 RGFW_wasPressed(RGFW_window* win, u8 key); /*!< if key was pressed (checks previous state only) (key code)*/

RGFWDEF b8 RGFW_isHeld(RGFW_window* win, u8 key); /*!< if key is held (key code)*/
RGFWDEF b8 RGFW_isReleased(RGFW_window* win, u8 key); /*!< if key is released (key code)*/

/* if a key is pressed and then released, pretty much the same as RGFW_isReleased */
RGFWDEF b8 RGFW_isClicked(RGFW_window* win, u8 key /*!< key code*/);

/*! if a mouse button is pressed */
RGFWDEF b8 RGFW_isMousePressed(RGFW_window* win, u8 button /*!< mouse button code */ );
/*! if a mouse button is held */
RGFWDEF b8 RGFW_isMouseHeld(RGFW_window* win, u8 button /*!< mouse button code */ );
/*! if a mouse button was released */
RGFWDEF b8 RGFW_isMouseReleased(RGFW_window* win, u8 button /*!< mouse button code */ );
/*! if a mouse button was pressed (checks previous state only) */
RGFWDEF b8 RGFW_wasMousePressed(RGFW_window* win, u8 button /*!< mouse button code */ );
/** @} */ 

/** * @defgroup Clipboard
* @{ */ 
RGFWDEF char* RGFW_readClipboard(size_t* size); /*!< read clipboard data */
RGFWDEF void RGFW_clipboardFree(char* str); /*!< the string returned from RGFW_readClipboard must be freed */

RGFWDEF void RGFW_writeClipboard(const char* text, u32 textLen); /*!< write text to the clipboard */
/** @} */ 

/**
	
	
	Event callbacks, 
	these are completely optional, you can use the normal 
	RGFW_checkEvent() method if you prefer that

* @defgroup Callbacks
* @{ 
*/

/*! RGFW_windowMoved, the window and its new rect value  */
typedef void (* RGFW_windowmovefunc)(RGFW_window* win, RGFW_rect r);
/*! RGFW_windowResized, the window and its new rect value  */
typedef void (* RGFW_windowresizefunc)(RGFW_window* win, RGFW_rect r);
/*! RGFW_quit, the window that was closed */
typedef void (* RGFW_windowquitfunc)(RGFW_window* win);
/*! RGFW_focusIn / RGFW_focusOut, the window who's focus has changed and if its inFocus */
typedef void (* RGFW_focusfunc)(RGFW_window* win, b8 inFocus);
/*! RGFW_mouseEnter / RGFW_mouseLeave, the window that changed, the point of the mouse (enter only) and if the mouse has entered */
typedef void (* RGFW_mouseNotifyfunc)(RGFW_window* win, RGFW_point point, b8 status);
/*! RGFW_mousePosChanged, the window that the move happened on and the new point of the mouse  */
typedef void (* RGFW_mouseposfunc)(RGFW_window* win, RGFW_point point);
/*! RGFW_dnd_init, the window, the point of the drop on the windows */
typedef void (* RGFW_dndInitfunc)(RGFW_window* win, RGFW_point point);
/*! RGFW_windowRefresh, the window that needs to be refreshed */
typedef void (* RGFW_windowrefreshfunc)(RGFW_window* win);
/*! RGFW_keyPressed / RGFW_keyReleased, the window that got the event, the keycode, the string version, the state of mod keys, if it was a press (else it's a release) */
typedef void (* RGFW_keyfunc)(RGFW_window* win, u32 keycode, char keyName[16], u8 lockState, b8 pressed);
/*! RGFW_mouseButtonPressed / RGFW_mouseButtonReleased, the window that got the event, the button that was pressed, the scroll value, if it was a press (else it's a release)  */
typedef void (* RGFW_mousebuttonfunc)(RGFW_window* win, u8 button, double scroll, b8 pressed);
/*! RGFW_jsButtonPressed / RGFW_jsButtonReleased, the window that got the event, the button that was pressed, the scroll value, if it was a press (else it's a release) */
typedef void (* RGFW_jsButtonfunc)(RGFW_window* win, u16 joystick, u8 button, b8 pressed);
/*! RGFW_jsAxisMove, the window that got the event, the joystick in question, the axis values and the amount of axises */
typedef void (* RGFW_jsAxisfunc)(RGFW_window* win, u16 joystick, RGFW_point axis[2], u8 axisesCount);


/*!  RGFW_dnd, the window that had the drop, the drop data and the amount files dropped returns previous callback function (if it was set) */
#ifdef RGFW_ALLOC_DROPFILES
	typedef void (* RGFW_dndfunc)(RGFW_window* win, char** droppedFiles, u32 droppedFilesCount);
#else
	typedef void (* RGFW_dndfunc)(RGFW_window* win, char droppedFiles[RGFW_MAX_DROPS][RGFW_MAX_PATH], u32 droppedFilesCount);
#endif
/*! set callback for a window move event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowmovefunc RGFW_setWindowMoveCallback(RGFW_windowmovefunc func);
/*! set callback for a window resize event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowresizefunc RGFW_setWindowResizeCallback(RGFW_windowresizefunc func);
/*! set callback for a window quit event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowquitfunc RGFW_setWindowQuitCallback(RGFW_windowquitfunc func);
/*! set callback for a mouse move event returns previous callback function (if it was set)  */
RGFWDEF RGFW_mouseposfunc RGFW_setMousePosCallback(RGFW_mouseposfunc func);
/*! set callback for a window refresh event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowrefreshfunc RGFW_setWindowRefreshCallback(RGFW_windowrefreshfunc func);
/*! set callback for a window focus change event returns previous callback function (if it was set)  */
RGFWDEF RGFW_focusfunc RGFW_setFocusCallback(RGFW_focusfunc func);
/*! set callback for a mouse notify event returns previous callback function (if it was set)  */
RGFWDEF RGFW_mouseNotifyfunc RGFW_setMouseNotifyCallBack(RGFW_mouseNotifyfunc func);
/*! set callback for a drop event event returns previous callback function (if it was set)  */
RGFWDEF RGFW_dndfunc RGFW_setDndCallback(RGFW_dndfunc func);
/*! set callback for a start of a drop event returns previous callback function (if it was set)  */
RGFWDEF RGFW_dndInitfunc RGFW_setDndInitCallback(RGFW_dndInitfunc func);
/*! set callback for a key (press / release ) event returns previous callback function (if it was set)  */
RGFWDEF RGFW_keyfunc RGFW_setKeyCallback(RGFW_keyfunc func);
/*! set callback for a mouse button (press / release ) event returns previous callback function (if it was set)  */
RGFWDEF RGFW_mousebuttonfunc RGFW_setMouseButtonCallback(RGFW_mousebuttonfunc func);
/*! set callback for a controller button (press / release ) event returns previous callback function (if it was set)  */
RGFWDEF RGFW_jsButtonfunc RGFW_setjsButtonCallback(RGFW_jsButtonfunc func);
/*! set callback for a joystick axis mov event returns previous callback function (if it was set)  */
RGFWDEF RGFW_jsAxisfunc RGFW_setjsAxisCallback(RGFW_jsAxisfunc func);

/** @} */ 

/** * @defgroup Threads
* @{ */ 

#ifndef RGFW_NO_THREADS
	/*! threading functions*/

	/*! NOTE! (for X11/linux) : if you define a window in a thread, it must be run after the original thread's window is created or else there will be a memory error */
	/*
		I'd suggest you use sili's threading functions instead
		if you're going to use sili
		which is a good idea generally
	*/

	#if defined(__unix__) || defined(__APPLE__) || defined(RGFW_WEBASM) 
		typedef void* (* RGFW_threadFunc_ptr)(void*);
	#else
		typedef DWORD (__stdcall *RGFW_threadFunc_ptr) (LPVOID lpThreadParameter);  
	#endif

	RGFWDEF RGFW_thread RGFW_createThread(RGFW_threadFunc_ptr ptr, void* args); /*!< create a thread*/
	RGFWDEF void RGFW_cancelThread(RGFW_thread thread); /*!< cancels a thread*/
	RGFWDEF void RGFW_joinThread(RGFW_thread thread); /*!< join thread to current thread */
	RGFWDEF void RGFW_setThreadPriority(RGFW_thread thread, u8 priority); /*!< sets the priority priority  */
#endif

/** @} */ 

/** * @defgroup joystick
* @{ */ 

/*! joystick count starts at 0*/
/*!< register joystick to window based on a number (the number is based on when it was connected eg. /dev/js0)*/
RGFWDEF u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber);
RGFWDEF u16 RGFW_registerJoystickF(RGFW_window* win, char* file);

RGFWDEF u32 RGFW_isPressedJS(RGFW_window* win, u16 controller, u8 button);

/** @} */ 

/** * @defgroup graphics_API
* @{ */ 

/*!< make the window the current opengl drawing context

	NOTE:
 	if you want to switch the graphics context's thread, 
	you have to run RGFW_window_makeCurrent(NULL); on the old thread
	then RGFW_window_makeCurrent(valid_window) on the new thread
*/
RGFWDEF void RGFW_window_makeCurrent(RGFW_window* win);

/*< updates fps / sets fps to cap (must by ran manually by the user at the end of a frame), returns current fps */
RGFWDEF u32 RGFW_window_checkFPS(RGFW_window* win, u32 fpsCap);

/* supports openGL, directX, OSMesa, EGL and software rendering */
RGFWDEF void RGFW_window_swapBuffers(RGFW_window* win); /*!< swap the rendering buffer */
RGFWDEF void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval);

RGFWDEF void RGFW_window_setGPURender(RGFW_window* win, i8 set);
RGFWDEF void RGFW_window_setCPURender(RGFW_window* win, i8 set);

/*! native API functions */
#if defined(RGFW_OPENGL) || defined(RGFW_EGL)
	/*! OpenGL init hints */
	RGFWDEF void RGFW_setGLStencil(i32 stencil); /*!< set stencil buffer bit size (8 by default) */
	RGFWDEF void RGFW_setGLSamples(i32 samples); /*!< set number of sampiling buffers (4 by default) */
	RGFWDEF void RGFW_setGLStereo(i32 stereo); /*!< use GL_STEREO (GL_FALSE by default) */
	RGFWDEF void RGFW_setGLAuxBuffers(i32 auxBuffers); /*!< number of aux buffers (0 by default) */

	/*! which profile to use for the opengl verion */
	typedef RGFW_ENUM(u8, RGFW_GL_profile)  { RGFW_GL_CORE = 0,  RGFW_GL_COMPATIBILITY  };
	/*! Set OpenGL version hint (core or compatibility profile)*/
	RGFWDEF void RGFW_setGLVersion(RGFW_GL_profile profile, i32 major, i32 minor);
	RGFWDEF void RGFW_setDoubleBuffer(b8 useDoubleBuffer); 
    RGFWDEF void* RGFW_getProcAddress(const char* procname); /*!< get native opengl proc address */
    RGFWDEF void RGFW_window_makeCurrent_OpenGL(RGFW_window* win); /*!< to be called by RGFW_window_makeCurrent */
#elif defined(RGFW_DIRECTX)
	typedef struct {
		IDXGIFactory* pFactory;
		IDXGIAdapter* pAdapter;
		ID3D11Device* pDevice;
		ID3D11DeviceContext* pDeviceContext;
	} RGFW_directXinfo;

	/*
		RGFW stores a global instance of RGFW_directXinfo,
		you can use this function to get a pointer the instance
	*/
	RGFWDEF RGFW_directXinfo* RGFW_getDirectXInfo(void);
#endif

/** @} */ 

/** * @defgroup Supporting
* @{ */ 
RGFWDEF u64 RGFW_getTime(void); /*!< get time in seconds */
RGFWDEF u64 RGFW_getTimeNS(void); /*!< get time in nanoseconds */
RGFWDEF void RGFW_sleep(u64 milisecond); /*!< sleep for a set time */

/*!
	key codes and mouse icon enums
*/

typedef RGFW_ENUM(u8, RGFW_Key) {
	RGFW_KEY_NULL = 0,
	RGFW_Escape,
	RGFW_F1,
	RGFW_F2,
	RGFW_F3,
	RGFW_F4,
	RGFW_F5,
	RGFW_F6,
	RGFW_F7,
	RGFW_F8,
	RGFW_F9,
	RGFW_F10,
	RGFW_F11,
	RGFW_F12,

	RGFW_Backtick,

	RGFW_0,
	RGFW_1,
	RGFW_2,
	RGFW_3,
	RGFW_4,
	RGFW_5,
	RGFW_6,
	RGFW_7,
	RGFW_8,
	RGFW_9,

	RGFW_Minus,
	RGFW_Equals,
	RGFW_BackSpace,
	RGFW_Tab,
	RGFW_CapsLock,
	RGFW_ShiftL,
	RGFW_ControlL,
	RGFW_AltL,
	RGFW_SuperL,
	RGFW_ShiftR,
	RGFW_ControlR,
	RGFW_AltR,
	RGFW_SuperR,
	RGFW_Space,

	RGFW_a,
	RGFW_b,
	RGFW_c,
	RGFW_d,
	RGFW_e,
	RGFW_f,
	RGFW_g,
	RGFW_h,
	RGFW_i,
	RGFW_j,
	RGFW_k,
	RGFW_l,
	RGFW_m,
	RGFW_n,
	RGFW_o,
	RGFW_p,
	RGFW_q,
	RGFW_r,
	RGFW_s,
	RGFW_t,
	RGFW_u,
	RGFW_v,
	RGFW_w,
	RGFW_x,
	RGFW_y,
	RGFW_z,

	RGFW_Period,
	RGFW_Comma,
	RGFW_Slash,
	RGFW_Bracket,
	RGFW_CloseBracket,
	RGFW_Semicolon,
	RGFW_Return,
	RGFW_Quote,
	RGFW_BackSlash,

	RGFW_Up,
	RGFW_Down,
	RGFW_Left,
	RGFW_Right,

	RGFW_Delete,
	RGFW_Insert,
	RGFW_End,
	RGFW_Home,
	RGFW_PageUp,
	RGFW_PageDown,

	RGFW_Numlock,
	RGFW_KP_Slash,
	RGFW_Multiply,
	RGFW_KP_Minus,
	RGFW_KP_1,
	RGFW_KP_2,
	RGFW_KP_3,
	RGFW_KP_4,
	RGFW_KP_5,
	RGFW_KP_6,
	RGFW_KP_7,
	RGFW_KP_8,
	RGFW_KP_9,
	RGFW_KP_0,
	RGFW_KP_Period,
	RGFW_KP_Return,

	final_key,
};


typedef RGFW_ENUM(u8, RGFW_mouseIcons) {
	RGFW_MOUSE_NORMAL = 0,
	RGFW_MOUSE_ARROW,
	RGFW_MOUSE_IBEAM,
	RGFW_MOUSE_CROSSHAIR,
	RGFW_MOUSE_POINTING_HAND,
	RGFW_MOUSE_RESIZE_EW,
	RGFW_MOUSE_RESIZE_NS,
	RGFW_MOUSE_RESIZE_NWSE,
	RGFW_MOUSE_RESIZE_NESW,
	RGFW_MOUSE_RESIZE_ALL,
	RGFW_MOUSE_NOT_ALLOWED,
};

/** @} */ 

#endif /* RGFW_HEADER */

/*
Example to get you started :

linux : gcc main.c -lX11 -lXcursor -lGL
windows : gcc main.c -lopengl32 -lshell32 -lgdi32
macos : gcc main.c -framework Foundation -framework AppKit -framework OpenGL -framework CoreVideo

#define RGFW_IMPLEMENTATION
#include "RGFW.h"

u8 icon[4 * 3 * 3] = {0xFF, 0x00, 0x00, 0xFF,    0xFF, 0x00, 0x00, 0xFF,     0xFF, 0x00, 0x00, 0xFF,   0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF,     0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF};

int main() {
	RGFW_window* win = RGFW_createWindow("name", RGFW_RECT(500, 500, 500, 500), (u64)0);

	RGFW_window_setIcon(win, icon, RGFW_AREA(3, 3), 4);

	for (;;) {
		RGFW_window_checkEvent(win); // NOTE: checking events outside of a while loop may cause input lag
		if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape))
			break;

		RGFW_window_swapBuffers(win);

		glClearColor(0xFF, 0XFF, 0xFF, 0xFF);
		glClear(GL_COLOR_BUFFER_BIT);
	}

	RGFW_window_close(win);
}

	compiling :

	if you wish to compile the library all you have to do is create a new file with this in it

	rgfw.c
	#define RGFW_IMPLEMENTATION
	#include "RGFW.h"

	then you can use gcc (or whatever compile you wish to use) to compile the library into object file

	ex. gcc -c RGFW.c -fPIC

	after you compile the library into an object file, you can also turn the object file into an static or shared library

	(commands ar and gcc can be replaced with whatever equivalent your system uses)
	static : ar rcs RGFW.a RGFW.o
	shared :
		windows:
			gcc -shared RGFW.o -lopengl32 -lshell32 -lgdi32 -o RGFW.dll
		linux:
			gcc -shared RGFW.o -lX11 -lXcursor -lGL -o RGFW.so
		macos:
			gcc -shared RGFW.o -framework Foundation -framework AppKit -framework OpenGL -framework CoreVideo
*/

#ifdef RGFW_X11
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) l
#elif defined(RGFW_WINDOWS)
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) w
#elif defined(RGFW_MACOS)
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) m
#elif defined(RGFW_WEBASM)
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) h
#elif defined(RGFW_WAYLAND)
    #define RGFW_OS_BASED_VALUE(l, w, m, h, ww) ww  
#endif


#ifdef RGFW_IMPLEMENTATION

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <assert.h>

/*
RGFW_IMPLEMENTATION starts with generic RGFW defines

This is the start of keycode data

	Why not use macros instead of the numbers itself?
	Windows -> Not all virtual keys are macros (VK_0 - VK_1, VK_a - VK_z)
	Linux -> Only symcodes are values, (XK_0 - XK_1, XK_a - XK_z) are larger than 0xFF00, I can't find any way to work with them without making the array an unreasonable size
	MacOS -> windows and linux already don't have keycodes as macros, so there's no point
*/



/* 
	the c++ compiler doesn't support setting up an array like, 
	we'll have to do it during runtime using a function & this messy setup
*/
#ifndef __cplusplus
#define RGFW_NEXT ,
#define RGFW_MAP
#else 
#define RGFW_NEXT ;
#define RGFW_MAP RGFW_keycodes
#endif

#ifdef RGFW_WAYLAND
#include <linux/input-event-codes.h>
#endif

u8 RGFW_keycodes [RGFW_OS_BASED_VALUE(136, 337, 128, DOM_VK_WIN_OEM_CLEAR + 1, 130)] = {
#ifdef __cplusplus
	0
};
void RGFW_init_keys(void) {
#endif
	RGFW_MAP [RGFW_OS_BASED_VALUE(49, 192, 50, DOM_VK_BACK_QUOTE, KEY_GRAVE)] = RGFW_Backtick 		RGFW_NEXT

	RGFW_MAP [RGFW_OS_BASED_VALUE(19, 0x30, 29, DOM_VK_0, KEY_0)] = RGFW_0 					RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(10, 0x31, 18, DOM_VK_1, KEY_1)] = RGFW_1						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(11, 0x32, 19, DOM_VK_2, KEY_2)] = RGFW_2						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(12, 0x33, 20, DOM_VK_3, KEY_3)] = RGFW_3						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(13, 0x34, 21, DOM_VK_4, KEY_4)] = RGFW_4						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(14, 0x35, 23, DOM_VK_5, KEY_5)] = RGFW_5                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(15, 0x36, 22, DOM_VK_6, KEY_6)] = RGFW_6                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(16, 0x37, 26, DOM_VK_7, KEY_7)] = RGFW_7                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(17, 0x38, 28, DOM_VK_8, KEY_8)] = RGFW_8                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(18, 0x39, 25, DOM_VK_9, KEY_9)] = RGFW_9,

	RGFW_MAP [RGFW_OS_BASED_VALUE(65, 0x20, 49, DOM_VK_SPACE, KEY_SPACE)] = RGFW_Space,

	RGFW_MAP [RGFW_OS_BASED_VALUE(38, 0x41, 0, DOM_VK_A, KEY_A)] = RGFW_a                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(56, 0x42, 11, DOM_VK_B, KEY_B)] = RGFW_b                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(54, 0x43, 8, DOM_VK_C, KEY_C)] = RGFW_c                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(40, 0x44, 2, DOM_VK_D, KEY_D)] = RGFW_d                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(26, 0x45, 14, DOM_VK_E, KEY_E)] = RGFW_e                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(41, 0x46, 3, DOM_VK_F, KEY_F)] = RGFW_f                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(42, 0x47, 5, DOM_VK_G, KEY_G)] = RGFW_g                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(43, 0x48, 4, DOM_VK_H, KEY_H)] = RGFW_h                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(31, 0x49, 34, DOM_VK_I, KEY_I)] = RGFW_i                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(44, 0x4A, 38, DOM_VK_J, KEY_J)] = RGFW_j                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(45, 0x4B, 40, DOM_VK_K, KEY_K)] = RGFW_k                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(46, 0x4C, 37, DOM_VK_L, KEY_L)] = RGFW_l                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(58, 0x4D, 46, DOM_VK_M, KEY_M)] = RGFW_m                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(57, 0x4E, 45, DOM_VK_N, KEY_N)] = RGFW_n                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(32, 0x4F, 31, DOM_VK_O, KEY_O)] = RGFW_o                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(33, 0x50, 35, DOM_VK_P, KEY_P)] = RGFW_p                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(24, 0x51, 12, DOM_VK_Q, KEY_Q)] = RGFW_q                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(27, 0x52, 15, DOM_VK_R, KEY_R)] = RGFW_r                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(39, 0x53, 1, DOM_VK_S, KEY_S)] = RGFW_s                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(28, 0x54, 17, DOM_VK_T, KEY_T)] = RGFW_t                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(30, 0x55, 32, DOM_VK_U, KEY_U)] = RGFW_u                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(55, 0x56, 9, DOM_VK_V, KEY_V)] = RGFW_v                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(25, 0x57, 13, DOM_VK_W, KEY_W)] = RGFW_w                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(53, 0x58, 7, DOM_VK_X, KEY_X)] = RGFW_x                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(29, 0x59, 16, DOM_VK_Y, KEY_Y)] = RGFW_y                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(52, 0x5A, 6, DOM_VK_Z, KEY_Z)] = RGFW_z,

	RGFW_MAP [RGFW_OS_BASED_VALUE(60, 190, 47, DOM_VK_PERIOD, KEY_DOT)] = RGFW_Period             			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(59, 188, 43, DOM_VK_COMMA, KEY_COMMA)] = RGFW_Comma               			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(61, 191, 44, DOM_VK_SLASH, KEY_SLASH)] = RGFW_Slash               			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(34, 219, 33, DOM_VK_OPEN_BRACKET, KEY_LEFTBRACE)] = RGFW_Bracket      			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(35, 221, 30, DOM_VK_CLOSE_BRACKET, KEY_RIGHTBRACE)] = RGFW_CloseBracket             RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(47, 186, 41, DOM_VK_SEMICOLON, KEY_SEMICOLON)] = RGFW_Semicolon                 RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(48, 222, 39, DOM_VK_QUOTE, KEY_APOSTROPHE)] = RGFW_Quote                 			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(51, 322, 42, DOM_VK_BACK_SLASH, KEY_BACKSLASH)] = RGFW_BackSlash,
	
	RGFW_MAP [RGFW_OS_BASED_VALUE(36, 0x0D, 36, DOM_VK_RETURN, KEY_ENTER)] = RGFW_Return              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(119, 0x2E, 118, DOM_VK_DELETE, KEY_DELETE)] = RGFW_Delete                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(77, 0x90, 72, DOM_VK_NUM_LOCK, KEY_NUMLOCK)] = RGFW_Numlock               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(106, 0x6F, 82, DOM_VK_DIVIDE, KEY_KPSLASH)] = RGFW_KP_Slash               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(63, 0x6A, 76, DOM_VK_MULTIPLY, KEY_KPASTERISK)] = RGFW_Multiply              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(82, 0x6D, 67, DOM_VK_SUBTRACT, KEY_KPMINUS)] = RGFW_KP_Minus              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(87, 0x61, 84, DOM_VK_NUMPAD1, KEY_KP1)] = RGFW_KP_1               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(88, 0x62, 85, DOM_VK_NUMPAD2, KEY_KP2)] = RGFW_KP_2               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(89, 0x63, 86, DOM_VK_NUMPAD3, KEY_KP3)] = RGFW_KP_3               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(83, 0x64, 87, DOM_VK_NUMPAD4, KEY_KP4)] = RGFW_KP_4               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(84, 0x65, 88, DOM_VK_NUMPAD5, KEY_KP5)] = RGFW_KP_5               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(85, 0x66, 89, DOM_VK_NUMPAD6, KEY_KP6)] = RGFW_KP_6               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(79, 0x67, 90, DOM_VK_NUMPAD7, KEY_KP7)] = RGFW_KP_7               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(80, 0x68, 92, DOM_VK_NUMPAD8, KEY_KP8)] = RGFW_KP_8               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(81, 0x69, 93, DOM_VK_NUMPAD9, KEY_KP9)] = RGFW_KP_9               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(90, 0x60, 83, DOM_VK_NUMPAD0, KEY_KP0)] = RGFW_KP_0               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(91, 0x6E, 65, DOM_VK_DECIMAL, KEY_KPDOT)] = RGFW_KP_Period              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(104, 0x92, 77, 0, KEY_KPENTER)] = RGFW_KP_Return,
	
	RGFW_MAP [RGFW_OS_BASED_VALUE(20, 189, 27, DOM_VK_HYPHEN_MINUS, KEY_MINUS)] = RGFW_Minus              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(21, 187, 24, DOM_VK_EQUALS, KEY_EQUAL)] = RGFW_Equals               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(22, 8, 51, DOM_VK_BACK_SPACE, KEY_BACKSPACE)] = RGFW_BackSpace              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(23, 0x09, 48, DOM_VK_TAB, KEY_TAB)] = RGFW_Tab                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(66, 20, 57, DOM_VK_CAPS_LOCK, KEY_CAPSLOCK)] = RGFW_CapsLock               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(50, 0x10, 56, DOM_VK_SHIFT, KEY_LEFTSHIFT)] = RGFW_ShiftL               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(37, 0x11, 59, DOM_VK_CONTROL, KEY_LEFTCTRL)] = RGFW_ControlL               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(64,0x12, 58, DOM_VK_ALT, KEY_LEFTALT)] = RGFW_AltL                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(133, 0x5B, 55, DOM_VK_WIN, KEY_LEFTMETA)] = RGFW_SuperL,
	
	#if !defined(RGFW_WINDOWS) && !defined(RGFW_MACOS) && !defined(RGFW_WEBASM)
	RGFW_MAP [RGFW_OS_BASED_VALUE(105, 0x11, 59, 0, KEY_RIGHTCTRL)] = RGFW_ControlR               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(135, 0xA4, 55, 0, KEY_RIGHTMETA)] = RGFW_SuperR,
	RGFW_MAP [RGFW_OS_BASED_VALUE(62, 0x5C, 56, 0, KEY_RIGHTSHIFT)] = RGFW_ShiftR              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(108, 165, 58, 0, KEY_RIGHTALT)] = RGFW_AltR,
	#endif

	RGFW_MAP [RGFW_OS_BASED_VALUE(67, 0x70, 127, DOM_VK_F1, KEY_F1)] = RGFW_F1                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(68, 0x71, 121, DOM_VK_F2, KEY_F2)] = RGFW_F2                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(69, 0x72, 100, DOM_VK_F3, KEY_F3)] = RGFW_F3                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(70, 0x73, 119, DOM_VK_F4, KEY_F4)] = RGFW_F4                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(71, 0x74, 97, DOM_VK_F5, KEY_F5)] = RGFW_F5              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(72, 0x75, 98, DOM_VK_F6, KEY_F6)] = RGFW_F6              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(73, 0x76, 99, DOM_VK_F7, KEY_F7)] = RGFW_F7              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(74, 0x77, 101, DOM_VK_F8, KEY_F8)] = RGFW_F8                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(75, 0x78, 102, DOM_VK_F9, KEY_F9)] = RGFW_F9                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(76, 0x79, 110, DOM_VK_F10, KEY_F10)] = RGFW_F10               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(95, 0x7A, 104, DOM_VK_F11, KEY_F11)] = RGFW_F11               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(96, 0x7B, 112, DOM_VK_F12, KEY_F12)] = RGFW_F12               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(111, 0x26, 126, DOM_VK_UP, KEY_UP)] = RGFW_Up                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(116, 0x28, 125, DOM_VK_DOWN, KEY_DOWN)] = RGFW_Down                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(113, 0x25, 123, DOM_VK_LEFT, KEY_LEFT)] = RGFW_Left                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(114, 0x27, 124, DOM_VK_RIGHT, KEY_RIGHT)] = RGFW_Right              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(118, 0x2D, 115, DOM_VK_INSERT, KEY_INSERT)] = RGFW_Insert                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(115, 0x23, 120, DOM_VK_END, KEY_END)] = RGFW_End                  		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(112, 336, 117, DOM_VK_PAGE_UP, KEY_PAGEUP)] = RGFW_PageUp                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(117, 325, 122, DOM_VK_PAGE_DOWN, KEY_PAGEDOWN)] = RGFW_PageDown            RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(9, 0x1B, 53, DOM_VK_ESCAPE, KEY_ESC)] = RGFW_Escape                   		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(110, 0x24, 116, DOM_VK_HOME, KEY_HOME)] = RGFW_Home                    		RGFW_NEXT
#ifndef __cplusplus
};
#else 
}
#endif

#undef RGFW_NEXT
#undef RGFW_MAP

typedef struct {
	b8 current  : 1;
	b8 prev  : 1;
} RGFW_keyState;

RGFW_keyState RGFW_keyboard[final_key] = { {0, 0} };

RGFWDEF u32 RGFW_apiKeyCodeToRGFW(u32 keycode);

u32 RGFW_apiKeyCodeToRGFW(u32 keycode) {
	#ifdef __cplusplus
	if (RGFW_OS_BASED_VALUE(49, 192, 50, DOM_VK_BACK_QUOTE, KEY_GRAVE) != RGFW_Backtick) {
		RGFW_init_keys();
	}
	#endif

	/* make sure the key isn't out of bounds */
	if (keycode > sizeof(RGFW_keycodes) / sizeof(u8))
		return 0;
	
	return RGFW_keycodes[keycode];
}

RGFWDEF void RGFW_resetKey(void);
void RGFW_resetKey(void) {
	size_t len = final_key; /*!< last_key == length */
	
	size_t i; /*!< reset each previous state  */
	for (i = 0; i < len; i++)
		RGFW_keyboard[i].prev = 0;
}

b8 RGFW_shouldShift(u32 keycode, u8 lockState) {
    #define RGFW_xor(x, y) (( (x) && (!(y)) ) ||  ((y) && (!(x)) ))
    b8 caps4caps = (lockState & RGFW_CAPSLOCK) && ((keycode >= RGFW_a) && (keycode <= RGFW_z));
    b8 shouldShift = RGFW_xor((RGFW_isPressed(NULL, RGFW_ShiftL) || RGFW_isPressed(NULL, RGFW_ShiftR)), caps4caps);
    #undef RGFW_xor

	return shouldShift;
}	

char RGFW_keyCodeToChar(u32 keycode, b8 shift) {
    static const char map[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '`', '0', '1', '2', '3', '4', '5', '6', '7', '8', 
        '9', '-', '=', 0, '\t',  0, 0, 0, 0, 0, 0, 0, 0, 0, ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
        'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '.', ',', '/', '[', ']',  ';', '\n', '\'', '\\', 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  '/', '*', '-', '1', '2', '3',  '3', '5', '6', '7', '8',  '9', '0', '\n'
    };

    static const char mapCaps[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '~', ')', '!', '@', '#', '$', '%', '^', '&', '*', 
        '(', '_', '+', 0, '0',  0, 0, 0, 0, 0, 0, 0, 0, 0, ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
        'X', 'Y', 'Z', '>', '<', '?', '{', '}',  ':', '\n', '"', '|', 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '?', '*', '-', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    if (shift == RGFW_FALSE)
        return map[keycode]; 
    return mapCaps[keycode];
}

char RGFW_keyCodeToCharAuto(u32 keycode, u8 lockState) { return RGFW_keyCodeToChar(keycode, RGFW_shouldShift(keycode, lockState)); }

/*
	this is the end of keycode data
*/

/* joystick data */
u8 RGFW_jsPressed[4][16]; /*!< if a key is currently pressed or not (per joystick) */

i32 RGFW_joysticks[4]; /*!< limit of 4 joysticks at a time */
u16 RGFW_joystickCount; /*!< the actual amount of joysticks */

/* 
	event callback defines start here
*/


/*
	These exist to avoid the 
	if (func == NULL) check 
	for (allegedly) better performance
*/
void RGFW_windowmovefuncEMPTY(RGFW_window* win, RGFW_rect r) { RGFW_UNUSED(win); RGFW_UNUSED(r); }
void RGFW_windowresizefuncEMPTY(RGFW_window* win, RGFW_rect r) { RGFW_UNUSED(win); RGFW_UNUSED(r); }
void RGFW_windowquitfuncEMPTY(RGFW_window* win) { RGFW_UNUSED(win); }
void RGFW_focusfuncEMPTY(RGFW_window* win, b8 inFocus) {RGFW_UNUSED(win); RGFW_UNUSED(inFocus);}
void RGFW_mouseNotifyfuncEMPTY(RGFW_window* win, RGFW_point point, b8 status) {RGFW_UNUSED(win); RGFW_UNUSED(point); RGFW_UNUSED(status);}
void RGFW_mouseposfuncEMPTY(RGFW_window* win, RGFW_point point) {RGFW_UNUSED(win); RGFW_UNUSED(point);}
void RGFW_dndInitfuncEMPTY(RGFW_window* win, RGFW_point point) {RGFW_UNUSED(win); RGFW_UNUSED(point);}
void RGFW_windowrefreshfuncEMPTY(RGFW_window* win) {RGFW_UNUSED(win); }
void RGFW_keyfuncEMPTY(RGFW_window* win, u32 keycode, char keyName[16], u8 lockState, b8 pressed) {RGFW_UNUSED(win); RGFW_UNUSED(keycode); RGFW_UNUSED(keyName); RGFW_UNUSED(lockState); RGFW_UNUSED(pressed);}
void RGFW_mousebuttonfuncEMPTY(RGFW_window* win, u8 button, double scroll, b8 pressed) {RGFW_UNUSED(win); RGFW_UNUSED(button); RGFW_UNUSED(scroll); RGFW_UNUSED(pressed);}
void RGFW_jsButtonfuncEMPTY(RGFW_window* win, u16 joystick, u8 button, b8 pressed){RGFW_UNUSED(win); RGFW_UNUSED(joystick); RGFW_UNUSED(button); RGFW_UNUSED(pressed); }
void RGFW_jsAxisfuncEMPTY(RGFW_window* win, u16 joystick, RGFW_point axis[2], u8 axisesCount){RGFW_UNUSED(win); RGFW_UNUSED(joystick); RGFW_UNUSED(axis); RGFW_UNUSED(axisesCount); }

#ifdef RGFW_ALLOC_DROPFILES
void RGFW_dndfuncEMPTY(RGFW_window* win, char** droppedFiles, u32 droppedFilesCount) {RGFW_UNUSED(win); RGFW_UNUSED(droppedFiles); RGFW_UNUSED(droppedFilesCount);}
#else
void RGFW_dndfuncEMPTY(RGFW_window* win, char droppedFiles[RGFW_MAX_DROPS][RGFW_MAX_PATH], u32 droppedFilesCount) {RGFW_UNUSED(win); RGFW_UNUSED(droppedFiles); RGFW_UNUSED(droppedFilesCount);}
#endif

RGFW_windowmovefunc RGFW_windowMoveCallback = RGFW_windowmovefuncEMPTY;
RGFW_windowresizefunc RGFW_windowResizeCallback = RGFW_windowresizefuncEMPTY;
RGFW_windowquitfunc RGFW_windowQuitCallback = RGFW_windowquitfuncEMPTY;
RGFW_mouseposfunc RGFW_mousePosCallback = RGFW_mouseposfuncEMPTY;
RGFW_windowrefreshfunc RGFW_windowRefreshCallback = RGFW_windowrefreshfuncEMPTY;
RGFW_focusfunc RGFW_focusCallback = RGFW_focusfuncEMPTY;
RGFW_mouseNotifyfunc RGFW_mouseNotifyCallBack = RGFW_mouseNotifyfuncEMPTY;
RGFW_dndfunc RGFW_dndCallback = RGFW_dndfuncEMPTY;
RGFW_dndInitfunc RGFW_dndInitCallback = RGFW_dndInitfuncEMPTY;
RGFW_keyfunc RGFW_keyCallback = RGFW_keyfuncEMPTY;
RGFW_mousebuttonfunc RGFW_mouseButtonCallback = RGFW_mousebuttonfuncEMPTY;
RGFW_jsButtonfunc RGFW_jsButtonCallback = RGFW_jsButtonfuncEMPTY;
RGFW_jsAxisfunc RGFW_jsAxisCallback = RGFW_jsAxisfuncEMPTY;

void RGFW_window_checkEvents(RGFW_window* win, i32 waitMS) { 
	RGFW_window_eventWait(win, waitMS);

	while (RGFW_window_checkEvent(win) != NULL && RGFW_window_shouldClose(win) == 0) { 
		if (win->event.type == RGFW_quit) return; 
	}
	
	#ifdef RGFW_WEBASM /* webasm needs to run the sleep function for asyncify */
		RGFW_sleep(0);
	#endif
}

RGFW_windowmovefunc RGFW_setWindowMoveCallback(RGFW_windowmovefunc func) { 
	RGFW_windowmovefunc	prev =  (RGFW_windowMoveCallback == RGFW_windowmovefuncEMPTY) ? NULL : RGFW_windowMoveCallback;
	RGFW_windowMoveCallback = func;
	return prev;
}
RGFW_windowresizefunc RGFW_setWindowResizeCallback(RGFW_windowresizefunc func) {
    RGFW_windowresizefunc prev = (RGFW_windowResizeCallback == RGFW_windowresizefuncEMPTY) ? NULL : RGFW_windowResizeCallback;
    RGFW_windowResizeCallback = func;
    return prev;
}
RGFW_windowquitfunc RGFW_setWindowQuitCallback(RGFW_windowquitfunc func) {
    RGFW_windowquitfunc prev = (RGFW_windowQuitCallback == RGFW_windowquitfuncEMPTY) ? NULL : RGFW_windowQuitCallback;
    RGFW_windowQuitCallback = func;
    return prev;
}

RGFW_mouseposfunc RGFW_setMousePosCallback(RGFW_mouseposfunc func) {
    RGFW_mouseposfunc prev = (RGFW_mousePosCallback == RGFW_mouseposfuncEMPTY) ? NULL : RGFW_mousePosCallback;
    RGFW_mousePosCallback = func;
    return prev;
}
RGFW_windowrefreshfunc RGFW_setWindowRefreshCallback(RGFW_windowrefreshfunc func) {
    RGFW_windowrefreshfunc prev = (RGFW_windowRefreshCallback == RGFW_windowrefreshfuncEMPTY) ? NULL : RGFW_windowRefreshCallback;
    RGFW_windowRefreshCallback = func;
    return prev;
}
RGFW_focusfunc RGFW_setFocusCallback(RGFW_focusfunc func) {
    RGFW_focusfunc prev = (RGFW_focusCallback == RGFW_focusfuncEMPTY) ? NULL : RGFW_focusCallback;
    RGFW_focusCallback = func;
    return prev;
}

RGFW_mouseNotifyfunc RGFW_setMouseNotifyCallBack(RGFW_mouseNotifyfunc func) {
    RGFW_mouseNotifyfunc prev = (RGFW_mouseNotifyCallBack == RGFW_mouseNotifyfuncEMPTY) ? NULL : RGFW_mouseNotifyCallBack;
    RGFW_mouseNotifyCallBack = func;
    return prev;
}
RGFW_dndfunc RGFW_setDndCallback(RGFW_dndfunc func) {
    RGFW_dndfunc prev = (RGFW_dndCallback == RGFW_dndfuncEMPTY) ? NULL : RGFW_dndCallback;
    RGFW_dndCallback = func;
    return prev;
}
RGFW_dndInitfunc RGFW_setDndInitCallback(RGFW_dndInitfunc func) {
    RGFW_dndInitfunc prev = (RGFW_dndInitCallback == RGFW_dndInitfuncEMPTY) ? NULL : RGFW_dndInitCallback;
    RGFW_dndInitCallback = func;
    return prev;
}
RGFW_keyfunc RGFW_setKeyCallback(RGFW_keyfunc func) {
    RGFW_keyfunc prev = (RGFW_keyCallback == RGFW_keyfuncEMPTY) ? NULL : RGFW_keyCallback;
    RGFW_keyCallback = func;
    return prev;
}
RGFW_mousebuttonfunc RGFW_setMouseButtonCallback(RGFW_mousebuttonfunc func) {
    RGFW_mousebuttonfunc prev = (RGFW_mouseButtonCallback == RGFW_mousebuttonfuncEMPTY) ? NULL : RGFW_mouseButtonCallback;
    RGFW_mouseButtonCallback = func;
    return prev;
}
RGFW_jsButtonfunc RGFW_setjsButtonCallback(RGFW_jsButtonfunc func) {
    RGFW_jsButtonfunc prev = (RGFW_jsButtonCallback == RGFW_jsButtonfuncEMPTY) ? NULL : RGFW_jsButtonCallback;
    RGFW_jsButtonCallback = func;
    return prev;
}
RGFW_jsAxisfunc RGFW_setjsAxisCallback(RGFW_jsAxisfunc func) {
    RGFW_jsAxisfunc prev = (RGFW_jsAxisCallback == RGFW_jsAxisfuncEMPTY) ? NULL : RGFW_jsAxisCallback;
    RGFW_jsAxisCallback = func;
    return prev;
}
/* 
no more event call back defines
*/

#define RGFW_ASSERT(check, str) {\
	if (!(check)) { \
		printf(str); \
		assert(check); \
	} \
}

b8 RGFW_error = 0;
b8 RGFW_Error(void) { return RGFW_error; }

#define SET_ATTRIB(a, v) { \
    assert(((size_t) index + 1) < sizeof(attribs) / sizeof(attribs[0])); \
    attribs[index++] = a; \
    attribs[index++] = v; \
}
	
RGFW_area RGFW_bufferSize = {0, 0};
void RGFW_setBufferSize(RGFW_area size) {
	RGFW_bufferSize = size;
}


RGFWDEF RGFW_window* RGFW_window_basic_init(RGFW_rect rect, u16 args);

/* do a basic initialization for RGFW_window, this is to standard it for each OS */
RGFW_window* RGFW_window_basic_init(RGFW_rect rect, u16 args) {
	RGFW_window* win = (RGFW_window*) RGFW_MALLOC(sizeof(RGFW_window)); /*!< make a new RGFW struct */

	/* clear out dnd info */
#ifdef RGFW_ALLOC_DROPFILES
	win->event.droppedFiles = (char**) RGFW_MALLOC(sizeof(char*) * RGFW_MAX_DROPS);
	u32 i;
	for (i = 0; i < RGFW_MAX_DROPS; i++)
		win->event.droppedFiles[i] = (char*) RGFW_CALLOC(RGFW_MAX_PATH, sizeof(char));
#endif

	/* X11 requires us to have a display to get the screen size */
	#ifndef RGFW_X11 
	RGFW_area screenR = RGFW_getScreenSize();
	#else
	win->src.display = XOpenDisplay(NULL);
	assert(win->src.display != NULL);

	Screen* scrn = DefaultScreenOfDisplay((Display*)win->src.display);
	RGFW_area screenR = RGFW_AREA((u32)scrn->width, (u32)scrn->height);
	#endif
	
	/* rect based the requested args */
	if (args & RGFW_FULLSCREEN)
		rect = RGFW_RECT(0, 0, screenR.w, screenR.h);

	if (args & RGFW_CENTER)
		rect = RGFW_RECT((screenR.w - rect.w) / 2, (screenR.h - rect.h) / 2, rect.w, rect.h);

	/* set and init the new window's data */
	win->r = rect;
	win->event.inFocus = 1;
	win->event.droppedFilesCount = 0;
	RGFW_joystickCount = 0;
	win->_winArgs = 0;
	win->event.lockState = 0;

	return win;
}

#ifndef RGFW_NO_MONITOR
void RGFW_window_scaleToMonitor(RGFW_window* win) {
	RGFW_monitor monitor = RGFW_window_getMonitor(win);
	
	RGFW_window_resize(win, RGFW_AREA(((u32) monitor.scaleX) * win->r.w, ((u32) monitor.scaleX) * win->r.h));
}
#endif

RGFW_window* RGFW_root = NULL;


#define RGFW_HOLD_MOUSE			(1L<<2) /*!< hold the moues still */
#define RGFW_MOUSE_LEFT 		(1L<<3) /* if mouse left the window */

char* RGFW_className = NULL;
void RGFW_setClassName(char* name) {
	RGFW_className = name;
}

void RGFW_clipboardFree(char* str) { RGFW_FREE(str); }

RGFW_keyState RGFW_mouseButtons[5] = { {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0} };

b8 RGFW_isMousePressed(RGFW_window* win, u8 button) {
	assert(win != NULL);
	return RGFW_mouseButtons[button].current && (win != NULL) && win->event.inFocus; 
}
b8 RGFW_wasMousePressed(RGFW_window* win, u8 button) {
	assert(win != NULL); 
	return RGFW_mouseButtons[button].prev && (win != NULL) && win->event.inFocus; 
}
b8 RGFW_isMouseHeld(RGFW_window* win, u8 button) {
	return (RGFW_isMousePressed(win, button) && RGFW_wasMousePressed(win, button));
}
b8 RGFW_isMouseReleased(RGFW_window* win, u8 button) {
	return (!RGFW_isMousePressed(win, button) && RGFW_wasMousePressed(win, button));	
}

b8 RGFW_isPressed(RGFW_window* win, u8 key) {
	return RGFW_keyboard[key].current && (win == NULL || win->event.inFocus);
}

b8 RGFW_wasPressed(RGFW_window* win, u8 key) {
	return RGFW_keyboard[key].prev && (win == NULL || win->event.inFocus);
}

b8 RGFW_isHeld(RGFW_window* win, u8 key) {
	return (RGFW_isPressed(win, key) && RGFW_wasPressed(win, key));
}

b8 RGFW_isClicked(RGFW_window* win, u8 key) {
	return (RGFW_wasPressed(win, key) && !RGFW_isPressed(win, key));
}

b8 RGFW_isReleased(RGFW_window* win, u8 key) {
	return (!RGFW_isPressed(win, key) && RGFW_wasPressed(win, key));	
}

#if defined(RGFW_WINDOWS)  && defined(RGFW_DIRECTX) /* defines for directX context*/
	RGFW_directXinfo RGFW_dxInfo;
	RGFW_directXinfo* RGFW_getDirectXInfo(void) { return &RGFW_dxInfo; }
#endif

void RGFW_window_makeCurrent(RGFW_window* win) {
#if defined(RGFW_WINDOWS) && defined(RGFW_DIRECTX)
	if (win == NULL)
		RGFW_dxInfo.pDeviceContext->lpVtbl->OMSetRenderTargets(RGFW_dxInfo.pDeviceContext, 1, NULL, NULL);
	else
		RGFW_dxInfo.pDeviceContext->lpVtbl->OMSetRenderTargets(RGFW_dxInfo.pDeviceContext, 1, &win->src.renderTargetView, NULL);
#elif defined(RGFW_OPENGL)
	RGFW_window_makeCurrent_OpenGL(win);
#else
	RGFW_UNUSED(win)
#endif
}

void RGFW_window_setGPURender(RGFW_window* win, i8 set) {
	if (!set && !(win->_winArgs & RGFW_NO_GPU_RENDER))
		win->_winArgs |= RGFW_NO_GPU_RENDER;
		
	else if (set && win->_winArgs & RGFW_NO_GPU_RENDER)
		win->_winArgs ^= RGFW_NO_GPU_RENDER;
}

void RGFW_window_setCPURender(RGFW_window* win, i8 set) {
	if (!set && !(win->_winArgs & RGFW_NO_CPU_RENDER))
		win->_winArgs |= RGFW_NO_CPU_RENDER;

	else if (set && win->_winArgs & RGFW_NO_CPU_RENDER)
		win->_winArgs ^= RGFW_NO_CPU_RENDER;
}

void RGFW_window_maximize(RGFW_window* win) {
	assert(win != NULL);

	RGFW_area screen = RGFW_getScreenSize();

	RGFW_window_move(win, RGFW_POINT(0, 0));
	RGFW_window_resize(win, screen);
}

b8 RGFW_window_shouldClose(RGFW_window* win) {
	assert(win != NULL);
	return (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape));
}

void RGFW_window_setShouldClose(RGFW_window* win) { win->event.type = RGFW_quit; RGFW_windowQuitCallback(win); }

#ifndef RGFW_NO_MONITOR
	void RGFW_window_moveToMonitor(RGFW_window* win, RGFW_monitor m) {
		RGFW_window_move(win, RGFW_POINT(m.rect.x + win->r.x, m.rect.y + win->r.y));
	}
#endif

RGFWDEF void RGFW_captureCursor(RGFW_window* win, RGFW_rect);
RGFWDEF void RGFW_releaseCursor(RGFW_window* win);

void RGFW_window_mouseHold(RGFW_window* win, RGFW_area area) {
	if ((win->_winArgs & RGFW_HOLD_MOUSE))
		return;
	

	if (!area.w && !area.h)
		area = RGFW_AREA(win->r.w / 2, win->r.h / 2);
		
	win->_winArgs |= RGFW_HOLD_MOUSE;
	RGFW_captureCursor(win, win->r);
	RGFW_window_moveMouse(win, RGFW_POINT(win->r.x + (win->r.w / 2), win->r.y + (win->r.h / 2)));
}

void RGFW_window_mouseUnhold(RGFW_window* win) {
	if ((win->_winArgs & RGFW_HOLD_MOUSE)) {
		win->_winArgs ^= RGFW_HOLD_MOUSE;

		RGFW_releaseCursor(win);
	}
}

u32 RGFW_window_checkFPS(RGFW_window* win, u32 fpsCap) {
	u64 deltaTime = RGFW_getTimeNS() - win->event.frameTime;

	u32 output_fps = 0;
	u64 fps = round(1e+9 / deltaTime);
	output_fps= fps;

	if (fpsCap && fps > fpsCap) {
		u64 frameTimeNS = 1e+9 / fpsCap;
		u64 sleepTimeMS = (frameTimeNS - deltaTime) / 1e6;

		if (sleepTimeMS > 0) {
			RGFW_sleep(sleepTimeMS);
			win->event.frameTime = 0;
		}
	}

	win->event.frameTime = RGFW_getTimeNS();
	
	if (fpsCap == 0) 
		return (u32) output_fps;
	
	deltaTime = RGFW_getTimeNS() - win->event.frameTime2;
	output_fps = round(1e+9 / deltaTime);
	win->event.frameTime2 = RGFW_getTimeNS();

	return output_fps;
}

u32 RGFW_isPressedJS(RGFW_window* win, u16 c, u8 button) { 
	RGFW_UNUSED(win);
	return RGFW_jsPressed[c][button]; 
}

#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
	void RGFW_window_showMouse(RGFW_window* win, i8 show) {
		static u8 RGFW_blk[] = { 0, 0, 0, 0 };
		if (show == 0)
			RGFW_window_setMouse(win, RGFW_blk, RGFW_AREA(1, 1), 4);
		else
			RGFW_window_setMouseDefault(win);
	}
#endif

RGFWDEF void RGFW_updateLockState(RGFW_window* win, b8 capital, b8 numlock);	
void RGFW_updateLockState(RGFW_window* win, b8 capital, b8 numlock) {
	if (capital && !(win->event.lockState & RGFW_CAPSLOCK))
		win->event.lockState |= RGFW_CAPSLOCK;
	else if (!capital && (win->event.lockState & RGFW_CAPSLOCK))			
		win->event.lockState ^= RGFW_CAPSLOCK;
	
	if (numlock && !(win->event.lockState & RGFW_NUMLOCK))
		win->event.lockState |= RGFW_NUMLOCK;
	else if (!numlock && (win->event.lockState & RGFW_NUMLOCK))
		win->event.lockState ^= RGFW_NUMLOCK;
}

#if defined(RGFW_X11) || defined(RGFW_MACOS) || defined(RGFW_WEBASM) || defined(RGFW_WAYLAND)
	struct timespec;

	int nanosleep(const struct timespec* duration, struct timespec* rem);
	int clock_gettime(clockid_t clk_id, struct timespec* tp);
	int setenv(const char *name, const char *value, int overwrite);

	void RGFW_window_setDND(RGFW_window* win, b8 allow) {
		if (allow && !(win->_winArgs & RGFW_ALLOW_DND))
			win->_winArgs |= RGFW_ALLOW_DND;

		else if (!allow && (win->_winArgs & RGFW_ALLOW_DND))
			win->_winArgs ^= RGFW_ALLOW_DND;
	}
#endif

/*
	graphics API specific code (end of generic code)
	starts here 
*/


/* 
	OpenGL defines start here   (Normal, EGL, OSMesa)
*/

#if defined(RGFW_OPENGL) || defined(RGFW_EGL) || defined(RGFW_OSMESA)
	#ifdef RGFW_WINDOWS
		#define WIN32_LEAN_AND_MEAN
		#define OEMRESOURCE
		#include <windows.h>
	#endif

	#if !defined(__APPLE__) && !defined(RGFW_NO_GL_HEADER)
		#include <GL/gl.h>
	#elif defined(__APPLE__)
		#ifndef GL_SILENCE_DEPRECATION
			#define GL_SILENCE_DEPRECATION
		#endif
		#include <OpenGL/gl.h>
		#include <OpenGL/OpenGL.h>
	#endif

/* EGL, normal OpenGL only */
#if !defined(RGFW_OSMESA) 
	i32 RGFW_majorVersion = 0, RGFW_minorVersion = 0;
	b8 RGFW_profile = RGFW_GL_CORE;
	
	#ifndef RGFW_EGL
	i32 RGFW_STENCIL = 8, RGFW_SAMPLES = 4, RGFW_STEREO = 0, RGFW_AUX_BUFFERS = 0, RGFW_DOUBLE_BUFFER = 1;
	#else
	i32 RGFW_STENCIL = 0, RGFW_SAMPLES = 0, RGFW_STEREO = 0, RGFW_AUX_BUFFERS = 0, RGFW_DOUBLE_BUFFER = 1;
	#endif


	void RGFW_setGLStencil(i32 stencil) { RGFW_STENCIL = stencil; }
	void RGFW_setGLSamples(i32 samples) { RGFW_SAMPLES = samples; }
	void RGFW_setGLStereo(i32 stereo) { RGFW_STEREO = stereo; }
	void RGFW_setGLAuxBuffers(i32 auxBuffers) { RGFW_AUX_BUFFERS = auxBuffers; }
	void RGFW_setDoubleBuffer(b8 useDoubleBuffer) { RGFW_DOUBLE_BUFFER = useDoubleBuffer; }

	void RGFW_setGLVersion(b8 profile, i32 major, i32 minor) {
        RGFW_profile = profile;
		RGFW_majorVersion = major;
		RGFW_minorVersion = minor;
	}

/* OPENGL normal only (no EGL / OSMesa) */
#ifndef RGFW_EGL

#define RGFW_GL_RENDER_TYPE 		RGFW_OS_BASED_VALUE(GLX_X_VISUAL_TYPE,    	0x2003,		73, 0, 0)
	#define RGFW_GL_ALPHA_SIZE 		RGFW_OS_BASED_VALUE(GLX_ALPHA_SIZE,       	0x201b,		11,     0, 0)
	#define RGFW_GL_DEPTH_SIZE 		RGFW_OS_BASED_VALUE(GLX_DEPTH_SIZE,       	0x2022,		12,     0, 0)
	#define RGFW_GL_DOUBLEBUFFER 		RGFW_OS_BASED_VALUE(GLX_DOUBLEBUFFER,     	0x2011, 	5,  0, 0)   
	#define RGFW_GL_STENCIL_SIZE 		RGFW_OS_BASED_VALUE(GLX_STENCIL_SIZE,	 	0x2023,	13,     0, 0)
	#define RGFW_GL_SAMPLES			RGFW_OS_BASED_VALUE(GLX_SAMPLES, 		 	0x2042,	    55,     0, 0)
	#define RGFW_GL_STEREO 			RGFW_OS_BASED_VALUE(GLX_STEREO,	 		 	0x2012,			6,  0, 0)
	#define RGFW_GL_AUX_BUFFERS		RGFW_OS_BASED_VALUE(GLX_AUX_BUFFERS,	    0x2024,	7, 		    0, 0)

#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
	#define RGFW_GL_DRAW 			RGFW_OS_BASED_VALUE(GLX_X_RENDERABLE,	 	0x2001,					0, 0, 0)
	#define RGFW_GL_DRAW_TYPE 		RGFW_OS_BASED_VALUE(GLX_RENDER_TYPE,     	0x2013,						0, 0, 0)
	#define RGFW_GL_FULL_FORMAT		RGFW_OS_BASED_VALUE(GLX_TRUE_COLOR,   	 	0x2027,						0, 0, 0)
	#define RGFW_GL_RED_SIZE		RGFW_OS_BASED_VALUE(GLX_RED_SIZE,         	0x2015,						0, 0, 0)
	#define RGFW_GL_GREEN_SIZE		RGFW_OS_BASED_VALUE(GLX_GREEN_SIZE,       	0x2017,						0, 0, 0)
	#define RGFW_GL_BLUE_SIZE		RGFW_OS_BASED_VALUE(GLX_BLUE_SIZE, 	 		0x2019,						0, 0, 0)
	#define RGFW_GL_USE_RGBA		RGFW_OS_BASED_VALUE(GLX_RGBA_BIT,   	 	0x202B,						0, 0, 0)
#endif

#ifdef RGFW_WINDOWS
	#define WGL_SUPPORT_OPENGL_ARB                    0x2010
	#define WGL_COLOR_BITS_ARB                        0x2014
	#define WGL_NUMBER_PIXEL_FORMATS_ARB 			0x2000
	#define WGL_CONTEXT_MAJOR_VERSION_ARB             0x2091
	#define WGL_CONTEXT_MINOR_VERSION_ARB             0x2092
	#define WGL_CONTEXT_PROFILE_MASK_ARB              0x9126
	#define WGL_CONTEXT_CORE_PROFILE_BIT_ARB 0x00000001
	#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
	#define WGL_SAMPLE_BUFFERS_ARB               0x2041
	#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB 0x20a9
	#define WGL_PIXEL_TYPE_ARB                        0x2013
	#define WGL_TYPE_RGBA_ARB                         0x202B

	#define WGL_TRANSPARENT_ARB   					  0x200A
#endif
	
/*  The window'ing api needs to know how to render the data we (or opengl) give it 
	MacOS and Windows do this using a structure called a "pixel format" 
	X11 calls it a "Visual"
	This function returns the attributes for the format we want */
	static u32* RGFW_initFormatAttribs(u32 useSoftware) {
		RGFW_UNUSED(useSoftware);
		static u32 attribs[] = {
								#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
								RGFW_GL_RENDER_TYPE,
								RGFW_GL_FULL_FORMAT,
								#endif
								RGFW_GL_ALPHA_SIZE      , 8,
								RGFW_GL_DEPTH_SIZE      , 24,
								#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
								RGFW_GL_DRAW, 1,
								RGFW_GL_RED_SIZE        , 8,
								RGFW_GL_GREEN_SIZE      , 8,
								RGFW_GL_BLUE_SIZE       , 8,
								RGFW_GL_DRAW_TYPE     , RGFW_GL_USE_RGBA,
								#endif 

								#ifdef RGFW_X11
								GLX_DRAWABLE_TYPE   , GLX_WINDOW_BIT,
								#endif	

								#ifdef RGFW_MACOS
								72,
								8, 24,
								#endif

								#ifdef RGFW_WINDOWS
								WGL_SUPPORT_OPENGL_ARB,		1,
								WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
								WGL_COLOR_BITS_ARB,	 32,
								#endif

								0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
		};

		size_t index = (sizeof(attribs) / sizeof(attribs[0])) - 13;

#define RGFW_GL_ADD_ATTRIB(attrib, attVal) \
		if (attVal) { \
			attribs[index] = attrib;\
			attribs[index + 1] = attVal;\
			index += 2;\
		}
         
        RGFW_GL_ADD_ATTRIB(RGFW_GL_DOUBLEBUFFER, 1);
        
        RGFW_GL_ADD_ATTRIB(RGFW_GL_STENCIL_SIZE, RGFW_STENCIL);
		RGFW_GL_ADD_ATTRIB(RGFW_GL_STEREO, RGFW_STEREO);
		RGFW_GL_ADD_ATTRIB(RGFW_GL_AUX_BUFFERS, RGFW_AUX_BUFFERS);

#ifndef RGFW_X11
		RGFW_GL_ADD_ATTRIB(RGFW_GL_SAMPLES, RGFW_SAMPLES);
#endif 

#ifdef RGFW_MACOS
		if (useSoftware) {
			RGFW_GL_ADD_ATTRIB(70, kCGLRendererGenericFloatID);
		} else {
			attribs[index] = RGFW_GL_RENDER_TYPE;
			index += 1;
		}
#endif

#ifdef RGFW_MACOS
		/* macOS has the surface attribs and the opengl attribs connected for some reason
			maybe this is to give macOS more control to limit openGL/the opengl version? */

		attribs[index] = 99;
		attribs[index + 1] = 0x1000;

		if (RGFW_majorVersion >= 4 || RGFW_majorVersion >= 3) {
			attribs[index + 1] = (u32) ((RGFW_majorVersion >= 4) ? 0x4100 : 0x3200);
		}
#endif

		RGFW_GL_ADD_ATTRIB(0, 0);

		return attribs;
	}

/* EGL only (no OSMesa nor normal OPENGL) */
#elif defined(RGFW_EGL)

#include <EGL/egl.h>

#if defined(RGFW_LINK_EGL)
	typedef EGLBoolean(EGLAPIENTRY* PFN_eglInitialize)(EGLDisplay, EGLint*, EGLint*);

	PFNEGLINITIALIZEPROC eglInitializeSource;
	PFNEGLGETCONFIGSPROC eglGetConfigsSource;
	PFNEGLCHOOSECONFIGPROC eglChooseConfigSource;
	PFNEGLCREATEWINDOWSURFACEPROC eglCreateWindowSurfaceSource;
	PFNEGLCREATECONTEXTPROC eglCreateContextSource;
	PFNEGLMAKECURRENTPROC eglMakeCurrentSource;
	PFNEGLGETDISPLAYPROC eglGetDisplaySource;
	PFNEGLSWAPBUFFERSPROC eglSwapBuffersSource;
	PFNEGLSWAPINTERVALPROC eglSwapIntervalSource;
	PFNEGLBINDAPIPROC eglBindAPISource;
	PFNEGLDESTROYCONTEXTPROC eglDestroyContextSource;
	PFNEGLTERMINATEPROC eglTerminateSource;
	PFNEGLDESTROYSURFACEPROC eglDestroySurfaceSource;

#define eglInitialize eglInitializeSource
#define eglGetConfigs eglGetConfigsSource
#define eglChooseConfig eglChooseConfigSource
#define eglCreateWindowSurface eglCreateWindowSurfaceSource
#define eglCreateContext eglCreateContextSource
#define eglMakeCurrent eglMakeCurrentSource
#define eglGetDisplay eglGetDisplaySource
#define eglSwapBuffers eglSwapBuffersSource
#define eglSwapInterval eglSwapIntervalSource
#define eglBindAPI eglBindAPISource
#define eglDestroyContext eglDestroyContextSource
#define eglTerminate eglTerminateSource
#define eglDestroySurface eglDestroySurfaceSource;
#endif


#define EGL_SURFACE_MAJOR_VERSION_KHR 0x3098
#define EGL_SURFACE_MINOR_VERSION_KHR 0x30fb

#ifndef RGFW_GL_ADD_ATTRIB
#define RGFW_GL_ADD_ATTRIB(attrib, attVal) \
	if (attVal) { \
		attribs[index] = attrib;\
		attribs[index + 1] = attVal;\
		index += 2;\
	}
#endif


	void RGFW_createOpenGLContext(RGFW_window* win) {
#if defined(RGFW_LINK_EGL)
		eglInitializeSource = (PFNEGLINITIALIZEPROC) eglGetProcAddress("eglInitialize");
		eglGetConfigsSource = (PFNEGLGETCONFIGSPROC) eglGetProcAddress("eglGetConfigs");
		eglChooseConfigSource = (PFNEGLCHOOSECONFIGPROC) eglGetProcAddress("eglChooseConfig");
		eglCreateWindowSurfaceSource = (PFNEGLCREATEWINDOWSURFACEPROC) eglGetProcAddress("eglCreateWindowSurface");
		eglCreateContextSource = (PFNEGLCREATECONTEXTPROC) eglGetProcAddress("eglCreateContext");
		eglMakeCurrentSource = (PFNEGLMAKECURRENTPROC) eglGetProcAddress("eglMakeCurrent");
		eglGetDisplaySource = (PFNEGLGETDISPLAYPROC) eglGetProcAddress("eglGetDisplay");
		eglSwapBuffersSource = (PFNEGLSWAPBUFFERSPROC) eglGetProcAddress("eglSwapBuffers");
		eglSwapIntervalSource = (PFNEGLSWAPINTERVALPROC) eglGetProcAddress("eglSwapInterval");
		eglBindAPISource = (PFNEGLBINDAPIPROC) eglGetProcAddress("eglBindAPI");
		eglDestroyContextSource = (PFNEGLDESTROYCONTEXTPROC) eglGetProcAddress("eglDestroyContext");
		eglTerminateSource = (PFNEGLTERMINATEPROC) eglGetProcAddress("eglTerminate");
		eglDestroySurfaceSource = (PFNEGLDESTROYSURFACEPROC) eglGetProcAddress("eglDestroySurface");
#endif /* RGFW_LINK_EGL */

		#ifdef RGFW_WINDOWS
		win->src.EGL_display = eglGetDisplay((EGLNativeDisplayType) win->src.hdc);
		#else
		win->src.EGL_display = eglGetDisplay((EGLNativeDisplayType) win->src.display);
		#endif

		EGLint major, minor;

		eglInitialize(win->src.EGL_display, &major, &minor);

		#ifndef EGL_OPENGL_ES1_BIT
		#define EGL_OPENGL_ES1_BIT 0x1
		#endif

		EGLint egl_config[] = {
			EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
			EGL_RENDERABLE_TYPE,
			#ifdef RGFW_OPENGL_ES1
			EGL_OPENGL_ES1_BIT,
			#elif defined(RGFW_OPENGL_ES3)
			EGL_OPENGL_ES3_BIT,
			#elif defined(RGFW_OPENGL_ES2)
			EGL_OPENGL_ES2_BIT,
			#else
			EGL_OPENGL_BIT,
			#endif
			EGL_NONE, EGL_NONE
		};

		EGLConfig config;
		EGLint numConfigs;
		eglChooseConfig(win->src.EGL_display, egl_config, &config, 1, &numConfigs);


		win->src.EGL_surface = eglCreateWindowSurface(win->src.EGL_display, config, (EGLNativeWindowType) win->src.window, NULL);

		EGLint attribs[] = {
			EGL_CONTEXT_CLIENT_VERSION,
			#ifdef RGFW_OPENGL_ES1
			1,
			#else
			2,
			#endif
			EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE
		};

		size_t index = 4;
		RGFW_GL_ADD_ATTRIB(EGL_STENCIL_SIZE, RGFW_STENCIL);
		RGFW_GL_ADD_ATTRIB(EGL_SAMPLES, RGFW_SAMPLES);

        if (RGFW_DOUBLE_BUFFER)
            RGFW_GL_ADD_ATTRIB(EGL_RENDER_BUFFER, EGL_BACK_BUFFER);

		if (RGFW_majorVersion) {
			attribs[1] = RGFW_majorVersion;
	
			RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_MAJOR_VERSION, RGFW_majorVersion);
			RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_MINOR_VERSION, RGFW_minorVersion);

			if (RGFW_profile == RGFW_GL_CORE) {
				RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT);
			}
			else {
				RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT);
			}

		}

		#if defined(RGFW_OPENGL_ES1) || defined(RGFW_OPENGL_ES2) || defined(RGFW_OPENGL_ES3)
		eglBindAPI(EGL_OPENGL_ES_API);
		#else
		eglBindAPI(EGL_OPENGL_API);		
		#endif
      		
		win->src.EGL_context = eglCreateContext(win->src.EGL_display, config, EGL_NO_CONTEXT, attribs);
		
		if (win->src.EGL_context == NULL)
			fprintf(stderr, "failed to create an EGL opengl context\n");

		eglMakeCurrent(win->src.EGL_display, win->src.EGL_surface, win->src.EGL_surface, win->src.EGL_context);
		eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
	}

	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		eglMakeCurrent(win->src.EGL_display, win->src.EGL_surface, win->src.EGL_surface, win->src.EGL_context);
	}

	#ifdef RGFW_APPLE
	void* RGFWnsglFramework = NULL;
	#elif defined(RGFW_WINDOWS)
	static HMODULE wglinstance = NULL;
	#endif

	void* RGFW_getProcAddress(const char* procname) { 
		#if defined(RGFW_WINDOWS)
			void* proc = (void*) GetProcAddress(wglinstance, procname); 

			if (proc)
				return proc;
		#endif

		return (void*) eglGetProcAddress(procname); 
	}

	void RGFW_closeEGL(RGFW_window* win) {
		eglDestroySurface(win->src.EGL_display, win->src.EGL_surface);
		eglDestroyContext(win->src.EGL_display, win->src.EGL_context);

		eglTerminate(win->src.EGL_display);
	}
	
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);
		
		eglSwapInterval(win->src.EGL_display, swapInterval);

	}
#endif /* RGFW_EGL */

/* 
	end of RGFW_EGL defines
*/

/* OPENGL Normal / EGL defines only (no OS MESA)  Ends here */

#elif defined(RGFW_OSMESA) /* OSmesa only */
RGFWDEF void RGFW_OSMesa_reorganize(void);

/* reorganize buffer for osmesa */
void RGFW_OSMesa_reorganize(void) {
	u8* row = (u8*) RGFW_MALLOC(win->r.w * 3);

	i32 half_height = win->r.h / 2;
	i32 stride = win->r.w * 3;

	i32 y;
	for (y = 0; y < half_height; ++y) {
		i32 top_offset = y * stride;
		i32 bottom_offset = (win->r.h - y - 1) * stride;
		memcpy(row, win->buffer + top_offset, stride);
		memcpy(win->buffer + top_offset, win->buffer + bottom_offset, stride);
		memcpy(win->buffer + bottom_offset, row, stride);
	}

	RGFW_FREE(row);
}
#endif /* RGFW_OSMesa */

#endif /* RGFW_GL (OpenGL, EGL, OSMesa )*/

/*
This is where OS specific stuff starts
*/


#if defined(RGFW_WAYLAND) || defined(RGFW_X11)
	int RGFW_eventWait_forceStop[] = {0, 0, 0}; /* for wait events */

	#ifdef __linux__
		#include <linux/joystick.h>
		#include <fcntl.h>
		#include <unistd.h>
		
		RGFW_Event* RGFW_linux_updateJoystick(RGFW_window* win) {
			static int xAxis = 0, yAxis = 0;
			u8 i;
			for (i = 0; i < RGFW_joystickCount; i++) {
				struct js_event e;


				if (RGFW_joysticks[i] == 0)
					continue;

				i32 flags = fcntl(RGFW_joysticks[i], F_GETFL, 0);
				fcntl(RGFW_joysticks[i], F_SETFL, flags | O_NONBLOCK);

				ssize_t bytes;
				while ((bytes = read(RGFW_joysticks[i], &e, sizeof(e))) > 0) {
					switch (e.type) {
					case JS_EVENT_BUTTON:
						win->event.type = e.value ? RGFW_jsButtonPressed : RGFW_jsButtonReleased;
						win->event.button = e.number;
						RGFW_jsPressed[i][e.number] = e.value;
						RGFW_jsButtonCallback(win, i, e.number, e.value);
						return &win->event;
					case JS_EVENT_AXIS:
						ioctl(RGFW_joysticks[i], JSIOCGAXES, &win->event.axisesCount);

						if ((e.number == 0 || e.number % 2) && e.number != 1)
							xAxis = e.value;
						else
							yAxis = e.value;

						win->event.axis[e.number / 2].x = xAxis;
						win->event.axis[e.number / 2].y = yAxis;
						win->event.type = RGFW_jsAxisMove;
						win->event.joystick = i;
						RGFW_jsAxisCallback(win, i, win->event.axis, win->event.axisesCount);
						return &win->event;

						default: break;
					}
				}
			}

			return NULL;
		}

	#endif
#endif

/*


Start of Linux / Unix defines


*/

#ifdef RGFW_X11
#ifndef RGFW_NO_X11_CURSOR
#include <X11/Xcursor/Xcursor.h>
#endif
#include <dlfcn.h>

#ifndef RGFW_NO_DPI
#include <X11/extensions/Xrandr.h>
#include <X11/Xresource.h>
#endif

#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/keysymdef.h>
#include <unistd.h>

#include <X11/XKBlib.h> /* for converting keycode to string */
#include <X11/cursorfont.h> /* for hiding */
#include <X11/extensions/shapeconst.h>
#include <X11/extensions/shape.h>
#include <X11/extensions/XInput2.h>

#include <limits.h> /* for data limits (mainly used in drag and drop functions) */
#include <poll.h>


#ifdef __linux__
#include <linux/joystick.h>
#endif

	u8 RGFW_mouseIconSrc[] = { XC_arrow, XC_left_ptr, XC_xterm, XC_crosshair, XC_hand2, XC_sb_h_double_arrow, XC_sb_v_double_arrow, XC_bottom_left_corner, XC_bottom_right_corner, XC_fleur, XC_X_cursor};  
	/*atoms needed for drag and drop*/
	Atom XdndAware, XdndTypeList, XdndSelection, XdndEnter, XdndPosition, XdndStatus, XdndLeave, XdndDrop, XdndFinished, XdndActionCopy, XtextPlain, XtextUriList;

	Atom wm_delete_window = 0;

#if !defined(RGFW_NO_X11_CURSOR) && !defined(RGFW_NO_X11_CURSOR_PRELOAD)
	typedef XcursorImage* (*PFN_XcursorImageCreate)(int, int);
	typedef void (*PFN_XcursorImageDestroy)(XcursorImage*);
	typedef Cursor(*PFN_XcursorImageLoadCursor)(Display*, const XcursorImage*);
#endif
#ifdef RGFW_OPENGL
	typedef GLXContext(*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);
#endif

#if !defined(RGFW_NO_X11_XI_PRELOAD)
	typedef int (* PFN_XISelectEvents)(Display*,Window,XIEventMask*,int);
	PFN_XISelectEvents XISelectEventsSrc = NULL;
	#define XISelectEvents XISelectEventsSrc

	void* X11Xihandle = NULL;
#endif

#if !defined(RGFW_NO_X11_CURSOR) && !defined(RGFW_NO_X11_CURSOR_PRELOAD)
	PFN_XcursorImageLoadCursor XcursorImageLoadCursorSrc = NULL;
	PFN_XcursorImageCreate XcursorImageCreateSrc = NULL;
	PFN_XcursorImageDestroy XcursorImageDestroySrc = NULL;

#define XcursorImageLoadCursor XcursorImageLoadCursorSrc
#define XcursorImageCreate XcursorImageCreateSrc
#define XcursorImageDestroy XcursorImageDestroySrc

	void* X11Cursorhandle = NULL;
#endif

	u32 RGFW_windowsOpen = 0;

#ifdef RGFW_OPENGL
	void* RGFW_getProcAddress(const char* procname) { return (void*) glXGetProcAddress((GLubyte*) procname); }
#endif

	RGFWDEF void RGFW_init_buffer(RGFW_window* win, XVisualInfo* vi);
	void RGFW_init_buffer(RGFW_window* win, XVisualInfo* vi) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
		if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
			RGFW_bufferSize = RGFW_getScreenSize();
		
		win->buffer = (u8*)RGFW_MALLOC(RGFW_bufferSize.w * RGFW_bufferSize.h * 4);

		#ifdef RGFW_OSMESA
				win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
				OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
		#endif

		win->src.bitmap = XCreateImage(
			win->src.display, XDefaultVisual(win->src.display, vi->screen),
			vi->depth,
			ZPixmap, 0, NULL, RGFW_bufferSize.w, RGFW_bufferSize.h,
			32, 0
		);

		win->src.gc = XCreateGC(win->src.display, win->src.window, 0, NULL);

		#else
		RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
		RGFW_UNUSED(vi)
		#endif
	}



	void RGFW_window_setBorder(RGFW_window* win, u8 border) {
		static Atom _MOTIF_WM_HINTS = 0;
		if (_MOTIF_WM_HINTS == 0 )
			_MOTIF_WM_HINTS = XInternAtom(win->src.display, "_MOTIF_WM_HINTS", False);
		
		struct __x11WindowHints {
			unsigned long flags, functions, decorations, status;
			long input_mode;
		} hints;
		hints.flags = (1L << 1);
		hints.decorations = border;

		XChangeProperty(
			win->src.display, win->src.window,
			_MOTIF_WM_HINTS, _MOTIF_WM_HINTS,
			32, PropModeReplace, (u8*)&hints, 5
		);
	}
	
	void RGFW_releaseCursor(RGFW_window* win) {
		XUngrabPointer(win->src.display, CurrentTime);

		/* disable raw input */
		unsigned char mask[] = { 0 };
		XIEventMask em;
		em.deviceid = XIAllMasterDevices;
		em.mask_len = sizeof(mask);
		em.mask = mask;

		XISelectEvents(win->src.display, XDefaultRootWindow(win->src.display), &em, 1);
	}
	
	void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) { 
		/* enable raw input */
		unsigned char mask[XIMaskLen(XI_RawMotion)] = { 0 };
		XISetMask(mask, XI_RawMotion);

		XIEventMask em;
		em.deviceid = XIAllMasterDevices;
		em.mask_len = sizeof(mask);
		em.mask = mask;
		
		XISelectEvents(win->src.display, XDefaultRootWindow(win->src.display), &em, 1);

		XGrabPointer(win->src.display, win->src.window, True, PointerMotionMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);

		RGFW_window_moveMouse(win, RGFW_POINT(win->r.x + (i32)(r.w / 2), win->r.y + (i32)(r.h / 2)));
	}

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
#if !defined(RGFW_NO_X11_CURSOR) && !defined(RGFW_NO_X11_CURSOR_PRELOAD)
		if (X11Cursorhandle == NULL) {
#if defined(__CYGWIN__)
			X11Cursorhandle = dlopen("libXcursor-1.so", RTLD_LAZY | RTLD_LOCAL);
#elif defined(__OpenBSD__) || defined(__NetBSD__)
			X11Cursorhandle = dlopen("libXcursor.so", RTLD_LAZY | RTLD_LOCAL);
#else
			X11Cursorhandle = dlopen("libXcursor.so.1", RTLD_LAZY | RTLD_LOCAL);
#endif

			XcursorImageCreateSrc = (PFN_XcursorImageCreate) dlsym(X11Cursorhandle, "XcursorImageCreate");
			XcursorImageDestroySrc = (PFN_XcursorImageDestroy) dlsym(X11Cursorhandle, "XcursorImageDestroy");
			XcursorImageLoadCursorSrc = (PFN_XcursorImageLoadCursor) dlsym(X11Cursorhandle, "XcursorImageLoadCursor");
		}
#endif

#if !defined(RGFW_NO_X11_XI_PRELOAD)
		if (X11Xihandle == NULL) {
#if defined(__CYGWIN__)
			X11Xihandle = dlopen("libXi-6.so", RTLD_LAZY | RTLD_LOCAL);
#elif defined(__OpenBSD__) || defined(__NetBSD__)
			X11Xihandle = dlopen("libXi.so", RTLD_LAZY | RTLD_LOCAL);
#else
			X11Xihandle = dlopen("libXi.so.6", RTLD_LAZY | RTLD_LOCAL);
#endif

			XISelectEventsSrc = (PFN_XISelectEvents) dlsym(X11Xihandle, "XISelectEvents");
		}
#endif

		XInitThreads(); /*!< init X11 threading*/

		if (args & RGFW_OPENGL_SOFTWARE)
			setenv("LIBGL_ALWAYS_SOFTWARE", "1", 1);

		RGFW_window* win = RGFW_window_basic_init(rect, args);

		u64 event_mask = KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask | PointerMotionMask | StructureNotifyMask | FocusChangeMask | LeaveWindowMask | EnterWindowMask | ExposureMask; /*!< X11 events accepted*/

#ifdef RGFW_OPENGL
		u32* visual_attribs = RGFW_initFormatAttribs(args & RGFW_OPENGL_SOFTWARE);
		i32 fbcount;
		GLXFBConfig* fbc = glXChooseFBConfig((Display*) win->src.display, DefaultScreen(win->src.display), (i32*) visual_attribs, &fbcount);

		i32 best_fbc = -1;

		if (fbcount == 0) {
			printf("Failed to find any valid GLX visual configs\n");
			return NULL;
		}

		u32 i;
		for (i = 0; i < (u32)fbcount; i++) {
			XVisualInfo* vi = glXGetVisualFromFBConfig((Display*) win->src.display, fbc[i]);
                        if (vi == NULL)
				continue;
                        
			XFree(vi);

			i32 samp_buf, samples;
			glXGetFBConfigAttrib((Display*) win->src.display, fbc[i], GLX_SAMPLE_BUFFERS, &samp_buf);
			glXGetFBConfigAttrib((Display*) win->src.display, fbc[i], GLX_SAMPLES, &samples);
			
			if ((best_fbc < 0 || samp_buf) && (samples == RGFW_SAMPLES || best_fbc == -1)) {
				best_fbc = i;
			}
		}

		if (best_fbc == -1) {
			printf("Failed to get a valid GLX visual\n");
			return NULL;
		}

		GLXFBConfig bestFbc = fbc[best_fbc];

		/* Get a visual */
		XVisualInfo* vi = glXGetVisualFromFBConfig((Display*) win->src.display, bestFbc);
		
		XFree(fbc);
		
		if (args & RGFW_TRANSPARENT_WINDOW) {
			XMatchVisualInfo((Display*) win->src.display, DefaultScreen((Display*) win->src.display), 32, TrueColor, vi); /*!< for RGBA backgrounds*/
		}
		
#else
		XVisualInfo viNorm;

		viNorm.visual = DefaultVisual((Display*) win->src.display, DefaultScreen((Display*) win->src.display));
		
		viNorm.depth = 0;
		XVisualInfo* vi = &viNorm;
		
		XMatchVisualInfo((Display*) win->src.display, DefaultScreen((Display*) win->src.display), 32, TrueColor, vi); /*!< for RGBA backgrounds*/
#endif
		/* make X window attrubutes*/
		XSetWindowAttributes swa;
		Colormap cmap;

		swa.colormap = cmap = XCreateColormap((Display*) win->src.display,
			DefaultRootWindow(win->src.display),
			vi->visual, AllocNone);

		swa.background_pixmap = None;
		swa.border_pixel = 0;
		swa.event_mask = event_mask;
		
		swa.background_pixel = 0;

		/* create the window*/
		win->src.window = XCreateWindow((Display*) win->src.display, DefaultRootWindow((Display*) win->src.display), win->r.x, win->r.y, win->r.w, win->r.h,
			0, vi->depth, InputOutput, vi->visual,
			CWColormap | CWBorderPixel | CWBackPixel | CWEventMask, &swa);

		XFreeColors((Display*) win->src.display, cmap, NULL, 0, 0);

		#ifdef RGFW_OPENGL
		XFree(vi);
		#endif

		// In your .desktop app, if you set the property
		// StartupWMClass=RGFW that will assoicate the launcher icon
		// with your application - robrohan 
		
		if (RGFW_className == NULL)
			RGFW_className = (char*)name;

		XClassHint *hint = XAllocClassHint();
		assert(hint != NULL);
		hint->res_class = (char*)RGFW_className;
		hint->res_name = (char*)name; // just use the window name as the app name
		XSetClassHint((Display*) win->src.display, win->src.window, hint);
		XFree(hint);

		if ((args & RGFW_NO_INIT_API) == 0) {
#ifdef RGFW_OPENGL /* This is the second part of setting up opengl. This is where we ask OpenGL for a specific version. */ 
		i32 context_attribs[7] = { 0, 0, 0, 0, 0, 0, 0 };
		context_attribs[0] = GLX_CONTEXT_PROFILE_MASK_ARB;
		if (RGFW_profile == RGFW_GL_CORE) 
			context_attribs[1] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB;
		else 
			context_attribs[1] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;
		
		if (RGFW_majorVersion || RGFW_minorVersion) {
			context_attribs[2] = GLX_CONTEXT_MAJOR_VERSION_ARB;
			context_attribs[3] = RGFW_majorVersion;
			context_attribs[4] = GLX_CONTEXT_MINOR_VERSION_ARB;
			context_attribs[5] = RGFW_minorVersion;
		}

		glXCreateContextAttribsARBProc glXCreateContextAttribsARB = 0;
		glXCreateContextAttribsARB = (glXCreateContextAttribsARBProc)
			glXGetProcAddressARB((GLubyte*) "glXCreateContextAttribsARB");

		GLXContext ctx = NULL;

		if (RGFW_root != NULL)
			ctx = RGFW_root->src.ctx;

		win->src.ctx = glXCreateContextAttribsARB((Display*) win->src.display, bestFbc, ctx, True, context_attribs);
#endif
		if (RGFW_root == NULL)
			RGFW_root = win;

		RGFW_init_buffer(win, vi);
		}
		

		#ifndef RGFW_NO_MONITOR
		if (args & RGFW_SCALE_TO_MONITOR)
			RGFW_window_scaleToMonitor(win);
		#endif

		if (args & RGFW_NO_RESIZE) { /* make it so the user can't resize the window*/
			XSizeHints* sh = XAllocSizeHints();
			sh->flags = (1L << 4) | (1L << 5);
			sh->min_width = sh->max_width = win->r.w;
			sh->min_height = sh->max_height = win->r.h;

			XSetWMSizeHints((Display*) win->src.display, (Drawable) win->src.window, sh, XA_WM_NORMAL_HINTS);
			XFree(sh);
		}

		if (args & RGFW_NO_BORDER) {
			RGFW_window_setBorder(win, 0);
		}

		XSelectInput((Display*) win->src.display, (Drawable) win->src.window, event_mask); /*!< tell X11 what events we want*/

		/* make it so the user can't close the window until the program does*/
		if (wm_delete_window == 0)
			wm_delete_window = XInternAtom((Display*) win->src.display, "WM_DELETE_WINDOW", False);

		XSetWMProtocols((Display*) win->src.display, (Drawable) win->src.window, &wm_delete_window, 1);

		/* connect the context to the window*/
#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0)
			glXMakeCurrent((Display*) win->src.display, (Drawable) win->src.window, (GLXContext) win->src.ctx);
#endif

		/* set the background*/
		XStoreName((Display*) win->src.display, (Drawable) win->src.window, name); /*!< set the name*/

		XMapWindow((Display*) win->src.display, (Drawable) win->src.window);						  /* draw the window*/
		XMoveWindow((Display*) win->src.display, (Drawable) win->src.window, win->r.x, win->r.y); /*!< move the window to it's proper cords*/

		if (args & RGFW_ALLOW_DND) { /* init drag and drop atoms and turn on drag and drop for this window */
			win->_winArgs |= RGFW_ALLOW_DND;

			XdndTypeList = XInternAtom((Display*) win->src.display, "XdndTypeList", False);
			XdndSelection = XInternAtom((Display*) win->src.display, "XdndSelection", False);

			/* client messages */
			XdndEnter = XInternAtom((Display*) win->src.display, "XdndEnter", False);
			XdndPosition = XInternAtom((Display*) win->src.display, "XdndPosition", False);
			XdndStatus = XInternAtom((Display*) win->src.display, "XdndStatus", False);
			XdndLeave = XInternAtom((Display*) win->src.display, "XdndLeave", False);
			XdndDrop = XInternAtom((Display*) win->src.display, "XdndDrop", False);
			XdndFinished = XInternAtom((Display*) win->src.display, "XdndFinished", False);

			/* actions */
			XdndActionCopy = XInternAtom((Display*) win->src.display, "XdndActionCopy", False);

			XtextUriList = XInternAtom((Display*) win->src.display, "text/uri-list", False); 
			XtextPlain = XInternAtom((Display*) win->src.display, "text/plain", False);

			XdndAware = XInternAtom((Display*) win->src.display, "XdndAware", False);
			const u8 version = 5;

			XChangeProperty((Display*) win->src.display, (Window) win->src.window,
				XdndAware, 4, 32,
				PropModeReplace, &version, 1); /*!< turns on drag and drop */
		}

		#ifdef RGFW_EGL
			if ((args & RGFW_NO_INIT_API) == 0)
				RGFW_createOpenGLContext(win);
		#endif

		RGFW_window_setMouseDefault(win);

		RGFW_windowsOpen++;

		return win; /*return newly created window*/
	}

	RGFW_area RGFW_getScreenSize(void) {
		assert(RGFW_root != NULL);

		Screen* scrn = DefaultScreenOfDisplay((Display*) RGFW_root->src.display);
		return RGFW_AREA(scrn->width, scrn->height);
	}

	RGFW_point RGFW_getGlobalMousePoint(void) {
		assert(RGFW_root != NULL);

		RGFW_point RGFWMouse;

		i32 x, y;
		u32 z;
		Window window1, window2;
		XQueryPointer((Display*) RGFW_root->src.display, XDefaultRootWindow((Display*) RGFW_root->src.display), &window1, &window2, &RGFWMouse.x, &RGFWMouse.y, &x, &y, &z);
 
		return RGFWMouse;
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		assert(win != NULL);

		RGFW_point RGFWMouse;

		i32 x, y;
		u32 z;
		Window window1, window2;
		XQueryPointer((Display*) win->src.display, win->src.window, &window1, &window2, &x, &y, &RGFWMouse.x, &RGFWMouse.y, &z);

		return RGFWMouse;
	}

	int xAxis = 0, yAxis = 0;

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		assert(win != NULL);

		static struct {
			long source, version;
			i32 format;
		} xdnd;

		if (win->event.type == 0) 
			RGFW_resetKey();

		if (win->event.type == RGFW_quit) {
			return NULL;
		}

		win->event.type = 0;

#ifdef __linux__
	RGFW_Event* event = RGFW_linux_updateJoystick(win);
	if (event != NULL)
		return event;
#endif

		XPending(win->src.display);

		XEvent E; /*!< raw X11 event */

		/* if there is no unread qued events, get a new one */
		if ((QLength(win->src.display) || XEventsQueued((Display*) win->src.display, QueuedAlready) + XEventsQueued((Display*) win->src.display, QueuedAfterReading)) 
			&& win->event.type != RGFW_quit
		)
			XNextEvent((Display*) win->src.display, &E);
		else {
			return NULL;
		}

		u32 i;
		win->event.type = 0;


		switch (E.type) {
		case KeyPress:
		case KeyRelease: {
			win->event.repeat = RGFW_FALSE;
			/* check if it's a real key release */
			if (E.type == KeyRelease && XEventsQueued((Display*) win->src.display, QueuedAfterReading)) { /* get next event if there is one*/
				XEvent NE;
				XPeekEvent((Display*) win->src.display, &NE);

				if (E.xkey.time == NE.xkey.time && E.xkey.keycode == NE.xkey.keycode) /* check if the current and next are both the same*/
					win->event.repeat = RGFW_TRUE;
			}

			/* set event key data */
			KeySym sym = (KeySym)XkbKeycodeToKeysym((Display*) win->src.display, E.xkey.keycode, 0, E.xkey.state & ShiftMask ? 1 : 0);
			win->event.keyCode = RGFW_apiKeyCodeToRGFW(E.xkey.keycode);
			
			char* str = (char*)XKeysymToString(sym);
			if (str != NULL)
				strncpy(win->event.keyName, str, 16);

			win->event.keyName[15] = '\0';		

			RGFW_keyboard[win->event.keyCode].prev = RGFW_isPressed(win, win->event.keyCode);
			
			/* get keystate data */
			win->event.type = (E.type == KeyPress) ? RGFW_keyPressed : RGFW_keyReleased;

			XKeyboardState keystate;
			XGetKeyboardControl((Display*) win->src.display, &keystate);

			RGFW_updateLockState(win, (keystate.led_mask & 1), (keystate.led_mask & 2));
			RGFW_keyboard[win->event.keyCode].current = (E.type == KeyPress);
			RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, (E.type == KeyPress));
			break;
		}
		case ButtonPress:
		case ButtonRelease:
			win->event.type = RGFW_mouseButtonPressed + (E.type == ButtonRelease); // the events match 
			
			switch(win->event.button) {
				case RGFW_mouseScrollUp:
					win->event.scroll = 1;
					break;
				case RGFW_mouseScrollDown:
					win->event.scroll = -1;
					break;
				default: break;
			}

			win->event.button = E.xbutton.button;
			RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;

			if (win->event.repeat == RGFW_FALSE)
				win->event.repeat = RGFW_isPressed(win, win->event.keyCode);

			RGFW_mouseButtons[win->event.button].current = (E.type == ButtonPress);
			RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, (E.type == ButtonPress));
			break;

		case MotionNotify:	
			win->event.point.x = E.xmotion.x;
			win->event.point.y = E.xmotion.y;
			
			if ((win->_winArgs & RGFW_HOLD_MOUSE)) {
				win->event.point.y = E.xmotion.y;

				win->event.point.x = win->_lastMousePoint.x - abs(win->event.point.x);
				win->event.point.y = win->_lastMousePoint.y - abs(win->event.point.y);
			}

			win->_lastMousePoint = RGFW_POINT(E.xmotion.x, E.xmotion.y);

			win->event.type = RGFW_mousePosChanged;
			RGFW_mousePosCallback(win, win->event.point);
			break;

		case GenericEvent: {
			/* MotionNotify is used for mouse events if the mouse isn't held */                
			if (!(win->_winArgs & RGFW_HOLD_MOUSE)) {
            	XFreeEventData(win->src.display, &E.xcookie);
				break;
			}
			
            XGetEventData(win->src.display, &E.xcookie);
            if (E.xcookie.evtype == XI_RawMotion) {
				XIRawEvent *raw = (XIRawEvent *)E.xcookie.data;
				if (raw->valuators.mask_len == 0) {
					XFreeEventData(win->src.display, &E.xcookie);
					break;
				}

                double deltaX = 0.0f; 
				double deltaY = 0.0f;

                /* check if relative motion data exists where we think it does */
				if (XIMaskIsSet(raw->valuators.mask, 0) != 0)
					deltaX += raw->raw_values[0];
				if (XIMaskIsSet(raw->valuators.mask, 1) != 0)
					deltaY += raw->raw_values[1];

				win->event.point = RGFW_POINT((i32)deltaX, (i32)deltaY);
				
				RGFW_window_moveMouse(win, RGFW_POINT(win->r.x + (win->r.w / 2), win->r.y + (win->r.h / 2)));

				win->event.type = RGFW_mousePosChanged;
				RGFW_mousePosCallback(win, win->event.point);
            }

            XFreeEventData(win->src.display, &E.xcookie);
			break;
		}
		
		case Expose:
			win->event.type = RGFW_windowRefresh;
			RGFW_windowRefreshCallback(win);
			break;

		case ClientMessage:
			/* if the client closed the window*/
			if (E.xclient.data.l[0] == (i64) wm_delete_window) {
				win->event.type = RGFW_quit;
				RGFW_windowQuitCallback(win);
				break;
			}
			
			/* reset DND values */
			if (win->event.droppedFilesCount) {
				for (i = 0; i < win->event.droppedFilesCount; i++)
					win->event.droppedFiles[i][0] = '\0';
			}

			win->event.droppedFilesCount = 0;

			if ((win->_winArgs & RGFW_ALLOW_DND) == 0)
				break;

			XEvent reply = { ClientMessage };
			reply.xclient.window = xdnd.source;
			reply.xclient.format = 32;
			reply.xclient.data.l[0] = (long) win->src.window;
			reply.xclient.data.l[1] = 0;
			reply.xclient.data.l[2] = None;

			if (E.xclient.message_type == XdndEnter) {
				unsigned long count;
				Atom* formats;
				Atom real_formats[6];

				Bool list = E.xclient.data.l[1] & 1;

				xdnd.source = E.xclient.data.l[0];
				xdnd.version = E.xclient.data.l[1] >> 24;
				xdnd.format = None;

				if (xdnd.version > 5)
					break;

				if (list) {
					Atom actualType;
					i32 actualFormat;
					unsigned long bytesAfter;

					XGetWindowProperty((Display*) win->src.display,
						xdnd.source,
						XdndTypeList,
						0,
						LONG_MAX,
						False,
						4,
						&actualType,
						&actualFormat,
						&count,
						&bytesAfter,
						(u8**) &formats);
				} else {
					count = 0;

					if (E.xclient.data.l[2] != None)
						real_formats[count++] = E.xclient.data.l[2];
					if (E.xclient.data.l[3] != None)
						real_formats[count++] = E.xclient.data.l[3];
					if (E.xclient.data.l[4] != None)
						real_formats[count++] = E.xclient.data.l[4];
					
					formats = real_formats;
				}

				unsigned long i;
				for (i = 0; i < count; i++) {
				    if (formats[i] == XtextUriList || formats[i] == XtextPlain) {
						xdnd.format = formats[i];
						break;
					}
				}

				if (list) {
					XFree(formats);
				}

				break;
			}
			if (E.xclient.message_type == XdndPosition) {
				const i32 xabs = (E.xclient.data.l[2] >> 16) & 0xffff;
				const i32 yabs = (E.xclient.data.l[2]) & 0xffff;
				Window dummy;
				i32 xpos, ypos;

				if (xdnd.version > 5)
					break;

				XTranslateCoordinates((Display*) win->src.display,
					XDefaultRootWindow((Display*) win->src.display),
					(Window) win->src.window,
					xabs, yabs,
					&xpos, &ypos,
					&dummy);

				win->event.point.x = xpos;
				win->event.point.y = ypos;

				reply.xclient.window = xdnd.source;
				reply.xclient.message_type = XdndStatus;

				if (xdnd.format) {
					reply.xclient.data.l[1] = 1;
					if (xdnd.version >= 2)
						reply.xclient.data.l[4] = XdndActionCopy;
				}

				XSendEvent((Display*) win->src.display, xdnd.source, False, NoEventMask, &reply);
				XFlush((Display*) win->src.display);
				break;
			}

			if (E.xclient.message_type != XdndDrop)
				break;

			if (xdnd.version > 5)
				break;

			win->event.type = RGFW_dnd_init;

			if (xdnd.format) {
				Time time = CurrentTime;

				if (xdnd.version >= 1)
					time = E.xclient.data.l[2];

				XConvertSelection((Display*) win->src.display,
					XdndSelection,
					xdnd.format,
					XdndSelection,
					(Window) win->src.window,
					time);
			} else if (xdnd.version >= 2) {
				XEvent reply = { ClientMessage };

				XSendEvent((Display*) win->src.display, xdnd.source,
					False, NoEventMask, &reply);
				XFlush((Display*) win->src.display);
			}

			RGFW_dndInitCallback(win, win->event.point);
			break;
		case SelectionNotify: {
			/* this is only for checking for xdnd drops */
			if (E.xselection.property != XdndSelection || !(win->_winArgs | RGFW_ALLOW_DND))
				break;

			char* data;
			unsigned long result;

			Atom actualType;
			i32 actualFormat;
			unsigned long bytesAfter;

			XGetWindowProperty((Display*) win->src.display, E.xselection.requestor, E.xselection.property, 0, LONG_MAX, False, E.xselection.target, &actualType, &actualFormat, &result, &bytesAfter, (u8**) &data);

			if (result == 0)
				break;

			/*
			SOURCED FROM GLFW _glfwParseUriList
			Copyright (c) 2002-2006 Marcus Geelnard
			Copyright (c) 2006-2019 Camilla Lwy
			*/

			const char* prefix = (const char*)"file://";

			char* line;

			win->event.droppedFilesCount = 0;

			win->event.type = RGFW_dnd;

			while ((line = strtok(data, "\r\n"))) {
				char path[RGFW_MAX_PATH];

				data = NULL;

				if (line[0] == '#')
					continue;

				char* l;
				for (l = line; 1; l++) {
					if ((l - line) > 7)
						break;
					else if (*l != prefix[(l - line)])
						break;
					else if (*l == '\0' && prefix[(l - line)] == '\0') {
						line += 7;
						while (*line != '/')
							line++;
						break;
					} else if (*l == '\0')
						break;
				}

				win->event.droppedFilesCount++;

				size_t index = 0;
				while (*line) {
					if (line[0] == '%' && line[1] && line[2]) {
						const char digits[3] = { line[1], line[2], '\0' };
						path[index] = (char) strtol(digits, NULL, 16);
						line += 2;
					} else
						path[index] = *line;

					index++;
					line++;
				}
				path[index] = '\0';
				strncpy(win->event.droppedFiles[win->event.droppedFilesCount - 1], path, index + 1);
			}

			if (data)
				XFree(data);

			if (xdnd.version >= 2) {
				reply.xclient.message_type = XdndFinished;
				reply.xclient.data.l[1] = result;
				reply.xclient.data.l[2] = XdndActionCopy;

				XSendEvent((Display*) win->src.display, xdnd.source, False, NoEventMask, &reply);
				XFlush((Display*) win->src.display);
			}

			RGFW_dndCallback(win, win->event.droppedFiles, win->event.droppedFilesCount);
			break;
		}
		case FocusIn:
			win->event.inFocus = 1;
			win->event.type = RGFW_focusIn;
			RGFW_focusCallback(win, 1);
			break;

			break;
		case FocusOut:
			win->event.inFocus = 0;
			win->event.type = RGFW_focusOut;
			RGFW_focusCallback(win, 0);
			break;
		
		case EnterNotify: {
			win->event.type = RGFW_mouseEnter;
			win->event.point.x = E.xcrossing.x;
			win->event.point.y = E.xcrossing.y;
			RGFW_mouseNotifyCallBack(win, win->event.point, 1);
			break;
		}

		case LeaveNotify: {
			win->event.type = RGFW_mouseLeave;
			RGFW_mouseNotifyCallBack(win, win->event.point, 0);
			break;
		}

		case ConfigureNotify: {
				/* detect resize */
      			if (E.xconfigure.width != win->r.w || E.xconfigure.height != win->r.h) {
					win->event.type = RGFW_windowResized;
					win->r = RGFW_RECT(win->r.x, win->r.y, E.xconfigure.width, E.xconfigure.height);
					RGFW_windowResizeCallback(win, win->r);
					break;
      			}  
      
      			/* detect move */
      			if (E.xconfigure.x != win->r.x || E.xconfigure.y != win->r.y) {
					win->event.type = RGFW_windowMoved;
					win->r = RGFW_RECT(E.xconfigure.x, E.xconfigure.y, win->r.w, win->r.h);
					RGFW_windowMoveCallback(win, win->r);
					break;
				} 

				break;
		}
		default: {
			break;
		}
		}

		XFlush((Display*) win->src.display);

		if (win->event.type)
			return &win->event;
		else
			return NULL;
	}

	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);
		win->r.x = v.x;
		win->r.y = v.y;

		XMoveWindow((Display*) win->src.display, (Window) win->src.window, v.x, v.y);
	}


	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);
		win->r.w = a.w;
		win->r.h = a.h;

		XResizeWindow((Display*) win->src.display, (Window) win->src.window, a.w, a.h);
	}

	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		if (a.w == 0 && a.h == 0)
			return;

		XSizeHints hints;
		long flags;

		XGetWMNormalHints(win->src.display, (Window) win->src.window, &hints, &flags);

		hints.flags |= PMinSize;
		
		hints.min_width = a.w;
		hints.min_height = a.h;

		XSetWMNormalHints(win->src.display, (Window) win->src.window, &hints);
	}

	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		if (a.w == 0 && a.h == 0)
			return;

		XSizeHints hints;
		long flags;

		XGetWMNormalHints(win->src.display, (Window) win->src.window, &hints, &flags);

		hints.flags |= PMaxSize;

		hints.max_width = a.w;
		hints.max_height = a.h;

		XSetWMNormalHints(win->src.display, (Window) win->src.window, &hints);
	}


	void RGFW_window_minimize(RGFW_window* win) {
		assert(win != NULL);

		XIconifyWindow(win->src.display, (Window) win->src.window, DefaultScreen(win->src.display));
		XFlush(win->src.display);
	}

	void RGFW_window_restore(RGFW_window* win) {
		assert(win != NULL);

		XMapWindow(win->src.display, (Window) win->src.window);
		XFlush(win->src.display);
	}	

	void RGFW_window_setName(RGFW_window* win, char* name) {
		assert(win != NULL);

		XStoreName((Display*) win->src.display, (Window) win->src.window, name);
	}
	
	void* RGFW_libxshape = NULL;

	#ifndef RGFW_NO_PASSTHROUGH
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		assert(win != NULL);
		
		#if defined(__CYGWIN__)
			RGFW_libxshape = dlopen("libXext-6.so", RTLD_LAZY | RTLD_LOCAL);
		#elif defined(__OpenBSD__) || defined(__NetBSD__)
			RGFW_libxshape = dlopen("libXext.so", RTLD_LAZY | RTLD_LOCAL);
		#else
    		RGFW_libxshape = dlopen("libXext.so.6", RTLD_LAZY | RTLD_LOCAL);
		#endif
		
		typedef void (* PFN_XShapeCombineMask)(Display*,Window,int,int,int,Pixmap,int);
		static PFN_XShapeCombineMask XShapeCombineMask;
		
		typedef void (* PFN_XShapeCombineRegion)(Display*,Window,int,int,int,Region,int);
		static PFN_XShapeCombineRegion XShapeCombineRegion;
		
		if (XShapeCombineMask != NULL)
			XShapeCombineMask = (PFN_XShapeCombineMask) dlsym(RGFW_libxshape, "XShapeCombineMask");

		if (XShapeCombineRegion != NULL)
			XShapeCombineRegion = (PFN_XShapeCombineRegion) dlsym(RGFW_libxshape, "XShapeCombineMask");

		if (passthrough) {
			Region region = XCreateRegion();
			XShapeCombineRegion(win->src.display, win->src.window, ShapeInput, 0, 0, region, ShapeSet);
			XDestroyRegion(region);

			return;
		}

		XShapeCombineMask(win->src.display, win->src.window, ShapeInput, 0, 0, None, ShapeSet);
	}
	#endif

	/*
		the majority function is sourced from GLFW
	*/

	void RGFW_window_setIcon(RGFW_window* win, u8* icon, RGFW_area a, i32 channels) {
		assert(win != NULL);

		i32 longCount = 2 + a.w * a.h;

		u64* X11Icon = (u64*) RGFW_MALLOC(longCount * sizeof(u64));
		u64* target = X11Icon;

		*target++ = a.w;
		*target++ = a.h;

		u32 i;

		for (i = 0; i < a.w * a.h; i++) {
			if (channels == 3)
				*target++ = ((icon[i * 3 + 0]) << 16) |
				((icon[i * 3 + 1]) << 8) |
				((icon[i * 3 + 2]) << 0) |
				(0xFF << 24);

			else if (channels == 4)
				*target++ = ((icon[i * 4 + 0]) << 16) |
				((icon[i * 4 + 1]) << 8) |
				((icon[i * 4 + 2]) << 0) |
				((icon[i * 4 + 3]) << 24);
		}

		static Atom NET_WM_ICON = 0;
		if (NET_WM_ICON == 0)
			NET_WM_ICON = XInternAtom((Display*) win->src.display, "_NET_WM_ICON", False);

		XChangeProperty((Display*) win->src.display, (Window) win->src.window,
			NET_WM_ICON,
			6, 32,
			PropModeReplace,
			(u8*) X11Icon,
			longCount);

		RGFW_FREE(X11Icon);

		XFlush((Display*) win->src.display);
	}

	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		assert(win != NULL);

#ifndef RGFW_NO_X11_CURSOR
		XcursorImage* native = XcursorImageCreate(a.w, a.h);
		native->xhot = 0;
		native->yhot = 0;

		u8* source = (u8*) image;
		XcursorPixel* target = native->pixels;

		u32 i;
		for (i = 0; i < a.w * a.h; i++, target++, source += 4) {
			u8 alpha = 0xFF;
			if (channels == 4)
				alpha = source[3];

			*target = (alpha << 24) | (((source[0] * alpha) / 255) << 16) | (((source[1] * alpha) / 255) << 8) | (((source[2] * alpha) / 255) << 0);
		}

		Cursor cursor = XcursorImageLoadCursor((Display*) win->src.display, native);
		XDefineCursor((Display*) win->src.display, (Window) win->src.window, (Cursor) cursor);

		XFreeCursor((Display*) win->src.display, (Cursor) cursor);
		XcursorImageDestroy(native);
#else
	RGFW_UNUSED(image) RGFW_UNUSED(a.w) RGFW_UNUSED(channels)
#endif
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);

		XEvent event;
		XQueryPointer(win->src.display, DefaultRootWindow(win->src.display),
			&event.xbutton.root, &event.xbutton.window,
			&event.xbutton.x_root, &event.xbutton.y_root,
			&event.xbutton.x, &event.xbutton.y,
			&event.xbutton.state);

		if (event.xbutton.x == v.x && event.xbutton.y == v.y)
			return;

		XWarpPointer(win->src.display, None, win->src.window, 0, 0, 0, 0, (int) v.x - win->r.x, (int) v.y - win->r.y);
	}

	RGFWDEF void RGFW_window_disableMouse(RGFW_window* win) {
		RGFW_UNUSED(win);
	}

	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_ARROW);
	}

	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
		assert(win != NULL);
		 
		if (mouse > (sizeof(RGFW_mouseIconSrc) / sizeof(u8)))
			return;
		
		mouse = RGFW_mouseIconSrc[mouse];

		Cursor cursor = XCreateFontCursor((Display*) win->src.display, mouse);
		XDefineCursor((Display*) win->src.display, (Window) win->src.window, (Cursor) cursor);

		XFreeCursor((Display*) win->src.display, (Cursor) cursor);
	}

	void RGFW_window_hide(RGFW_window* win) {
		XMapWindow(win->src.display, win->src.window);
	}

	void RGFW_window_show(RGFW_window* win) {
		XUnmapWindow(win->src.display, win->src.window);
	}

	/*
		the majority function is sourced from GLFW
	*/
	char* RGFW_readClipboard(size_t* size) {
		static Atom UTF8 = 0;
		if (UTF8 == 0)
			UTF8 = XInternAtom(RGFW_root->src.display, "UTF8_STRING", True);

		XEvent event;
		int format;
		unsigned long N, sizeN;
		char* data, * s = NULL;
		Atom target;
		Atom CLIPBOARD = 0, XSEL_DATA = 0;

		if (CLIPBOARD == 0) {
			CLIPBOARD = XInternAtom(RGFW_root->src.display, "CLIPBOARD", 0);
			XSEL_DATA = XInternAtom(RGFW_root->src.display, "XSEL_DATA", 0);
		}

		XConvertSelection(RGFW_root->src.display, CLIPBOARD, UTF8, XSEL_DATA, RGFW_root->src.window, CurrentTime);
		XSync(RGFW_root->src.display, 0);
		XNextEvent(RGFW_root->src.display, &event);

		if (event.type != SelectionNotify || event.xselection.selection != CLIPBOARD || event.xselection.property == 0)
			return NULL;

		XGetWindowProperty(event.xselection.display, event.xselection.requestor,
			event.xselection.property, 0L, (~0L), 0, AnyPropertyType, &target,
			&format, &sizeN, &N, (unsigned char**) &data);

		if (target == UTF8 || target == XA_STRING) {
			s = (char*)RGFW_MALLOC(sizeof(char) * sizeN);
			strncpy(s, data, sizeN);
			s[sizeN] = '\0';
			XFree(data);
		}

		XDeleteProperty(event.xselection.display, event.xselection.requestor, event.xselection.property);

		if (s != NULL && size != NULL)
			*size = sizeN;

		return s;
	}

	/*
		almost all of this function is sourced from GLFW
	*/
	void RGFW_writeClipboard(const char* text, u32 textLen) {
		static Atom CLIPBOARD = 0,
			UTF8_STRING = 0,
			SAVE_TARGETS = 0,
			TARGETS = 0,
			MULTIPLE = 0,
			ATOM_PAIR = 0,
			CLIPBOARD_MANAGER = 0;

		if (CLIPBOARD == 0) {
			CLIPBOARD = XInternAtom((Display*) RGFW_root->src.display, "CLIPBOARD", False);
			UTF8_STRING = XInternAtom((Display*) RGFW_root->src.display, "UTF8_STRING", False);
			SAVE_TARGETS = XInternAtom((Display*) RGFW_root->src.display, "SAVE_TARGETS", False);
			TARGETS = XInternAtom((Display*) RGFW_root->src.display, "TARGETS", False);
			MULTIPLE = XInternAtom((Display*) RGFW_root->src.display, "MULTIPLE", False);
			ATOM_PAIR = XInternAtom((Display*) RGFW_root->src.display, "ATOM_PAIR", False);
			CLIPBOARD_MANAGER = XInternAtom((Display*) RGFW_root->src.display, "CLIPBOARD_MANAGER", False);
		}
		
		XSetSelectionOwner((Display*) RGFW_root->src.display, CLIPBOARD, (Window) RGFW_root->src.window, CurrentTime);

		XConvertSelection((Display*) RGFW_root->src.display, CLIPBOARD_MANAGER, SAVE_TARGETS, None, (Window) RGFW_root->src.window, CurrentTime);
		for (;;) {
			XEvent event;

			XNextEvent((Display*) RGFW_root->src.display, &event);
			if (event.type != SelectionRequest) {
				break;
			}

			const XSelectionRequestEvent* request = &event.xselectionrequest;

			XEvent reply = { SelectionNotify };
			reply.xselection.property = 0;

			if (request->target == TARGETS) {
				const Atom targets[] = { TARGETS,
										MULTIPLE,
										UTF8_STRING,
										XA_STRING };

				XChangeProperty((Display*) RGFW_root->src.display,
					request->requestor,
					request->property,
					4,
					32,
					PropModeReplace,
					(u8*) targets,
					sizeof(targets) / sizeof(targets[0]));

				reply.xselection.property = request->property;
			}

			if (request->target == MULTIPLE) {
				Atom* targets = NULL;

				Atom actualType = 0;
				int actualFormat = 0;
				unsigned long count = 0, bytesAfter = 0;

				XGetWindowProperty((Display*) RGFW_root->src.display, request->requestor, request->property, 0, LONG_MAX, False, ATOM_PAIR, &actualType, &actualFormat, &count, &bytesAfter, (u8**) &targets);

				unsigned long i;
				for (i = 0; i < (u32)count; i += 2) {
					if (targets[i] == UTF8_STRING || targets[i] == XA_STRING) {
						XChangeProperty((Display*) RGFW_root->src.display,
							request->requestor,
							targets[i + 1],
							targets[i],
							8,
							PropModeReplace,
							(u8*) text,
							textLen);
						XFlush(RGFW_root->src.display);
					} else {
						targets[i + 1] = None;
					}
				}

				XChangeProperty((Display*) RGFW_root->src.display,
					request->requestor,
					request->property,
					ATOM_PAIR,
					32,
					PropModeReplace,
					(u8*) targets,
					count);

				XFlush(RGFW_root->src.display);
				XFree(targets);

				reply.xselection.property = request->property;
			}

			reply.xselection.display = request->display;
			reply.xselection.requestor = request->requestor;
			reply.xselection.selection = request->selection;
			reply.xselection.target = request->target;
			reply.xselection.time = request->time;

			XSendEvent((Display*) RGFW_root->src.display, request->requestor, False, 0, &reply);
			XFlush(RGFW_root->src.display);
		}
	}

	u8 RGFW_window_isFullscreen(RGFW_window* win) {
		assert(win != NULL);

		XWindowAttributes windowAttributes;
		XGetWindowAttributes(win->src.display, (Window) win->src.window, &windowAttributes);

		/* check if the window is visable */
		if (windowAttributes.map_state != IsViewable)
			return 0;

		/* check if the window covers the full screen */
		return (windowAttributes.x == 0 && windowAttributes.y == 0 &&
			windowAttributes.width == XDisplayWidth(win->src.display, DefaultScreen(win->src.display)) &&
			windowAttributes.height == XDisplayHeight(win->src.display, DefaultScreen(win->src.display)));
	}

	u8 RGFW_window_isHidden(RGFW_window* win) {
		assert(win != NULL);

		XWindowAttributes windowAttributes;
		XGetWindowAttributes(win->src.display, (Window) win->src.window, &windowAttributes);

		return (windowAttributes.map_state == IsUnmapped && !RGFW_window_isMinimized(win));
	}

	u8 RGFW_window_isMinimized(RGFW_window* win) {
		assert(win != NULL);

		static Atom prop = 0;
		if (prop == 0)
			prop = XInternAtom(win->src.display, "WM_STATE", False);

		Atom actual_type;
		i32 actual_format;
		unsigned long nitems, bytes_after;
		unsigned char* prop_data;

		i16 status = XGetWindowProperty(win->src.display, (Window) win->src.window, prop, 0, 2, False,
			AnyPropertyType, &actual_type, &actual_format,
			&nitems, &bytes_after, &prop_data);

		if (status == Success && nitems >= 1 && *((int*) prop_data) == IconicState) {
			XFree(prop_data);
			return 1;
		}

		if (prop_data != NULL)
			XFree(prop_data);

		return 0;
	}

	u8 RGFW_window_isMaximized(RGFW_window* win) {
		assert(win != NULL);

		static Atom net_wm_state = 0;
		static Atom net_wm_state_maximized_horz = 0;
		static Atom net_wm_state_maximized_vert = 0;

		if (net_wm_state == 0) {
			net_wm_state = XInternAtom(win->src.display, "_NET_WM_STATE", False);
			net_wm_state_maximized_vert = XInternAtom(win->src.display, "_NET_WM_STATE_MAXIMIZED_VERT", False);
			net_wm_state_maximized_horz = XInternAtom(win->src.display, "_NET_WM_STATE_MAXIMIZED_HORZ", False);
		}

		Atom actual_type;
		i32 actual_format;
		unsigned long nitems, bytes_after;
		unsigned char* prop_data;

		i16 status = XGetWindowProperty(win->src.display, (Window) win->src.window, net_wm_state, 0, 1024, False,
			XA_ATOM, &actual_type, &actual_format,
			&nitems, &bytes_after, &prop_data);

		if (status != Success) {
			if (prop_data != NULL)
				XFree(prop_data);

			return 0;
		}

		Atom* atoms = (Atom*) prop_data;
		u64 i;
		for (i = 0; i < nitems; ++i) {
			if (atoms[i] == net_wm_state_maximized_horz ||
				atoms[i] == net_wm_state_maximized_vert) {
				XFree(prop_data);
				return 1;
			}
		}

		return 0;
	}

	static void XGetSystemContentScale(Display* display, float* xscale, float* yscale) {
		float xdpi = 96.f, ydpi = 96.f;

#ifndef RGFW_NO_DPI
		char* rms = XResourceManagerString(display);
		XrmDatabase db = NULL;

		if (rms && db)
			db = XrmGetStringDatabase(rms);

		if (db == 0) {
			*xscale = xdpi / 96.f;
			*yscale = ydpi / 96.f;
			return;
		}

		XrmValue value;
		char* type = NULL;

		if (XrmGetResource(db, "Xft.dpi", "Xft.Dpi", &type, &value) && type && strncmp(type, "String", 7) == 0)
			xdpi = ydpi = atof(value.addr);
		XrmDestroyDatabase(db);
#endif

		* xscale = xdpi / 96.f;
		*yscale = ydpi / 96.f;
	}

	RGFW_monitor RGFW_XCreateMonitor(i32 screen) {
		RGFW_monitor monitor;

		Display* display = XOpenDisplay(NULL);

		monitor.rect = RGFW_RECT(0, 0, DisplayWidth(display, screen), DisplayHeight(display, screen));
		monitor.physW = (monitor.rect.w * 25.4f / 96.f);
		monitor.physH = (monitor.rect.h * 25.4f / 96.f);

		strncpy(monitor.name, DisplayString(display), 128);

		XGetSystemContentScale(display, &monitor.scaleX, &monitor.scaleY);

		XRRScreenResources* sr = XRRGetScreenResourcesCurrent(display, RootWindow(display, screen));

		XRRCrtcInfo* ci = NULL;
		int crtc = 0;

		if (sr->ncrtc > crtc) {
			ci = XRRGetCrtcInfo(display, sr, sr->crtcs[crtc]);
		}

		if (ci == NULL) {
			XRRFreeScreenResources(sr);
			XCloseDisplay(display);
			return monitor;
		}

		monitor.rect.x = ci->x;
		monitor.rect.y = ci->y;

		XRRFreeCrtcInfo(ci);
		XRRFreeScreenResources(sr);

		XCloseDisplay(display);

		return monitor;
	}

	RGFW_monitor RGFW_monitors[6];
	RGFW_monitor* RGFW_getMonitors(void) {
		size_t i;
		for (i = 0; i < (size_t)ScreenCount(RGFW_root->src.display) && i < 6; i++)
			RGFW_monitors[i] = RGFW_XCreateMonitor(i);

		return RGFW_monitors;
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
		assert(RGFW_root != NULL);

		i32 primary = -1;
		Window root = DefaultRootWindow(RGFW_root->src.display);
		XRRScreenResources* res = XRRGetScreenResources(RGFW_root->src.display, root);

		for (int i = 0; i < res->noutput; i++) {
			XRROutputInfo* output_info = XRRGetOutputInfo(RGFW_root->src.display, res, res->outputs[i]);
			if (output_info->connection == RR_Connected && output_info->crtc) {
				XRRCrtcInfo* crtc_info = XRRGetCrtcInfo(RGFW_root->src.display, res, output_info->crtc);
				if (crtc_info->mode != None && crtc_info->x == 0 && crtc_info->y == 0) {
					primary = i;
					XRRFreeCrtcInfo(crtc_info);
					XRRFreeOutputInfo(output_info);
					break;
				}
				XRRFreeCrtcInfo(crtc_info);
			}
			XRRFreeOutputInfo(output_info);
		}

		XRRFreeScreenResources(res);

		return RGFW_XCreateMonitor(primary);
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		return RGFW_XCreateMonitor(DefaultScreen(win->src.display));
	}

	#ifdef RGFW_OPENGL
	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		if (win == NULL)
			glXMakeCurrent((Display*) NULL, (Drawable)NULL, (GLXContext) NULL);
		else
			glXMakeCurrent((Display*) win->src.display, (Drawable) win->src.window, (GLXContext) win->src.ctx);
	}
	#endif


	void RGFW_window_swapBuffers(RGFW_window* win) {
		assert(win != NULL);

		/* clear the window*/
		if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			#ifdef RGFW_OSMESA
			RGFW_OSMesa_reorganize();
			#endif
			RGFW_area area = RGFW_bufferSize;

#ifndef RGFW_X11_DONT_CONVERT_BGR
			win->src.bitmap->data = (char*) win->buffer;
			u32 x, y;
			for (y = 0; y < (u32)win->r.h; y++) {
				for (x = 0; x < (u32)win->r.w; x++) {
					u32 index = (y * 4 * area.w) + x * 4;

					u8 red = win->src.bitmap->data[index];
					win->src.bitmap->data[index] = win->buffer[index + 2];
					win->src.bitmap->data[index + 2] = red;

				}
			}
#endif	
			XPutImage(win->src.display, (Window) win->src.window, win->src.gc, win->src.bitmap, 0, 0, 0, 0, RGFW_bufferSize.w, RGFW_bufferSize.h);
#endif
		}

		if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) {
			#ifdef RGFW_EGL
					eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
			#elif defined(RGFW_OPENGL)
					glXSwapBuffers((Display*) win->src.display, (Window) win->src.window);
			#endif
		}
	}

	#if !defined(RGFW_EGL)	
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);

		#if defined(RGFW_OPENGL)	
		((PFNGLXSWAPINTERVALEXTPROC) glXGetProcAddress((GLubyte*) "glXSwapIntervalEXT"))((Display*) win->src.display, (Window) win->src.window, swapInterval);
		#else
		RGFW_UNUSED(swapInterval);
		#endif
	}
	#endif


	void RGFW_window_close(RGFW_window* win) {
		/* ungrab pointer if it was grabbed */
		if (win->_winArgs & RGFW_HOLD_MOUSE) 
			XUngrabPointer(win->src.display, CurrentTime);
			
		assert(win != NULL);
#ifdef RGFW_EGL
		RGFW_closeEGL(win);
#endif

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
		if (win->buffer != NULL) {
			XDestroyImage((XImage*) win->src.bitmap);
			XFreeGC(win->src.display, win->src.gc);
		}
#endif

		if ((Display*) win->src.display) {
#ifdef RGFW_OPENGL
			glXDestroyContext((Display*) win->src.display, win->src.ctx);
#endif

			if (win == RGFW_root)
				RGFW_root = NULL;

			if ((Drawable) win->src.window)
				XDestroyWindow((Display*) win->src.display, (Drawable) win->src.window); /*!< close the window*/
			
			XCloseDisplay((Display*) win->src.display); /*!< kill the display*/
		}

#ifdef RGFW_ALLOC_DROPFILES
		{
			u32 i;
			for (i = 0; i < RGFW_MAX_DROPS; i++)
				RGFW_FREE(win->event.droppedFiles[i]);


			RGFW_FREE(win->event.droppedFiles);
		}
#endif

		RGFW_windowsOpen--;
#if !defined(RGFW_NO_X11_CURSOR_PRELOAD) && !defined(RGFW_NO_X11_CURSOR)
		if (X11Cursorhandle != NULL && RGFW_windowsOpen <= 0) {
			dlclose(X11Cursorhandle);

			X11Cursorhandle = NULL;
		}
#endif
#if !defined(RGFW_NO_X11_XI_PRELOAD)
		if (X11Xihandle != NULL && RGFW_windowsOpen <= 0) {
			dlclose(X11Xihandle);

			X11Xihandle = NULL;
		}
#endif

		if (RGFW_libxshape != NULL && RGFW_windowsOpen <= 0) {
			dlclose(RGFW_libxshape);
			RGFW_libxshape = NULL;
		}

		if (RGFW_windowsOpen <= 0) {
			if (RGFW_eventWait_forceStop[0] || RGFW_eventWait_forceStop[1]){
				close(RGFW_eventWait_forceStop[0]);
				close(RGFW_eventWait_forceStop[1]);
			}

			u8 i;
			for (i = 0; i < RGFW_joystickCount; i++)
				close(RGFW_joysticks[i]);
		}

		/* set cleared display / window to NULL for error checking */
		win->src.display = (Display*) 0;
		win->src.window = (Window) 0;

		RGFW_FREE(win); /*!< free collected window data */
	}
	

/* 
	End of X11 linux / unix defines
*/

#endif /* RGFW_X11 */


/* wayland or X11 defines*/
#if defined(RGFW_WAYLAND) || defined(RGFW_X11)
#include <fcntl.h>
#include <poll.h>
#include <unistd.h>
	u16 RGFW_registerJoystickF(RGFW_window* win, char* file) {
		assert(win != NULL);

#ifdef __linux__

		i32 js = open(file, O_RDONLY);

		if (js && RGFW_joystickCount < 4) {
			RGFW_joystickCount++;

			RGFW_joysticks[RGFW_joystickCount - 1] = open(file, O_RDONLY);

			u8 i;
			for (i = 0; i < 16; i++)
				RGFW_jsPressed[RGFW_joystickCount - 1][i] = 0;

		}

		else {
#ifdef RGFW_PRINT_ERRORS
			RGFW_error = 1;
			fprintf(stderr, "Error RGFW_registerJoystickF : Cannot open file %s\n", file);
#endif
		}

		return RGFW_joystickCount - 1;
#endif
	}
	
	u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber) {
		assert(win != NULL);

#ifdef __linux__
		char file[15];
		sprintf(file, "/dev/input/js%i", jsNumber);

		return RGFW_registerJoystickF(win, file);
#endif
	}
	
	void RGFW_stopCheckEvents(void) { 
		RGFW_eventWait_forceStop[2] = 1;
		while (1) {
			const char byte = 0;
			const ssize_t result = write(RGFW_eventWait_forceStop[1], &byte, 1);
			if (result == 1 || result == -1)
				break;
		}
	}

	void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
		if (waitMS == 0)
			return;
		
		u8 i;

		if (RGFW_eventWait_forceStop[0] == 0 || RGFW_eventWait_forceStop[1] == 0) {
			if (pipe(RGFW_eventWait_forceStop) != -1) {
				fcntl(RGFW_eventWait_forceStop[0], F_GETFL, 0);
				fcntl(RGFW_eventWait_forceStop[0], F_GETFD, 0);
				fcntl(RGFW_eventWait_forceStop[1], F_GETFL, 0);
				fcntl(RGFW_eventWait_forceStop[1], F_GETFD, 0);
			}
		}

		struct pollfd fds[] = {
			#ifdef RGFW_WAYLAND
			{ wl_display_get_fd(win->src.display), POLLIN, 0 },
			#else
			{ ConnectionNumber(win->src.display), POLLIN, 0 },
			#endif
			{ RGFW_eventWait_forceStop[0], POLLIN, 0 },
			#ifdef __linux__ /* blank space for 4 joystick files*/
			{ -1, POLLIN, 0 }, {-1, POLLIN, 0 }, {-1, POLLIN, 0 },  {-1, POLLIN, 0} 
			#endif
		};

		u8 index = 2;
		
		#if defined(__linux__)
			for (i = 0; i < RGFW_joystickCount; i++) {
				if (RGFW_joysticks[i] == 0)
					continue;

				fds[index].fd = RGFW_joysticks[i];
				index++;
			}
		#endif


		u64 start = RGFW_getTimeNS();

		#ifdef RGFW_WAYLAND
		while (wl_display_dispatch(win->src.display) <= 0 && waitMS >= -1) {
		#else
		while (XPending(win->src.display) == 0 && waitMS >= -1) {
		#endif
			if (poll(fds, index, waitMS) <= 0)
				break;

			if (waitMS > 0) {
				waitMS -= (RGFW_getTimeNS() - start) / 1e+6;
			}
		}

		/* drain any data in the stop request */
		if (RGFW_eventWait_forceStop[2]) {	
			char data[64];
			(void)!read(RGFW_eventWait_forceStop[0], data, sizeof(data));
			
			RGFW_eventWait_forceStop[2] = 0;
		}
	}

	u64 RGFW_getTimeNS(void) { 
		struct timespec ts = { 0 };
		clock_gettime(1, &ts);
		unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;

		return nanoSeconds;
	}

	u64 RGFW_getTime(void) {
		struct timespec ts = { 0 };
		clock_gettime(1, &ts);
		unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;

		return (double)(nanoSeconds) * 1e-9;
	}
#endif /* end of wayland or X11 time defines*/


/*

	Start of Wayland defines


*/

#ifdef RGFW_WAYLAND
/*
Wayland TODO:
- fix RGFW_keyPressed lock state

	RGFW_windowMoved, 		the window was moved (by the user)
	RGFW_windowResized  	the window was resized (by the user), [on webASM this means the browser was resized]
	RGFW_windowRefresh	 	The window content needs to be refreshed

	RGFW_dnd 				a file has been dropped into the window
	RGFW_dnd_init

- window args:
	#define RGFW_NO_RESIZE	 			the window cannot be resized  by the user
	#define RGFW_ALLOW_DND     			the window supports drag and drop
	#define RGFW_SCALE_TO_MONITOR 			scale the window to the screen 

- other missing functions functions ("TODO wayland") (~30 functions)
- fix buffer rendering weird behavior
*/
	#include <errno.h>
	#include <unistd.h>
	#include <sys/mman.h>
	#include <xkbcommon/xkbcommon.h>
	#include <xkbcommon/xkbcommon-keysyms.h>
	#include <dirent.h>
	#include <linux/kd.h> 
	#include <wayland-cursor.h>

RGFW_window* RGFW_key_win = NULL;

void RGFW_eventPipe_push(RGFW_window* win, RGFW_Event event) {
	if (win == NULL) {
		win = RGFW_key_win;

		if (win == NULL) return;
	}
	
	if (win->src.eventLen >= (i32)(sizeof(win->src.events) / sizeof(win->src.events[0])))
		return;

	win->src.events[win->src.eventLen] = event;
	win->src.eventLen += 1;
}

RGFW_Event RGFW_eventPipe_pop(RGFW_window* win) {
	RGFW_Event ev;
	ev.type = 0;
	
	if (win->src.eventLen > -1)
		win->src.eventLen -= 1;
	
	if (win->src.eventLen >= 0)  
		ev = win->src.events[win->src.eventLen];
	else {
		printf("H2\n");
	}

	return ev;	
}

/* wayland global garbage (wayland bad, X11 is fine (ish) (not really)) */
#include "xdg-shell.h"
#include "xdg-decoration-unstable-v1.h"

struct xdg_wm_base *xdg_wm_base;
struct wl_compositor* RGFW_compositor = NULL;
struct wl_shm* shm = NULL;
struct wl_shell* RGFW_shell = NULL;
static struct wl_seat *seat = NULL;
static struct xkb_context *xkb_context;
static struct xkb_keymap *keymap = NULL;
static struct xkb_state *xkb_state = NULL;
enum zxdg_toplevel_decoration_v1_mode client_preferred_mode, RGFW_current_mode;
static struct zxdg_decoration_manager_v1 *decoration_manager = NULL;

struct wl_cursor_theme* RGFW_wl_cursor_theme = NULL;
struct wl_surface* RGFW_cursor_surface = NULL;
struct wl_cursor_image* RGFW_cursor_image = NULL;

static void xdg_wm_base_ping_handler(void *data,
        struct xdg_wm_base *wm_base, uint32_t serial)
{
	RGFW_UNUSED(data);
    xdg_wm_base_pong(wm_base, serial);
}

static const struct xdg_wm_base_listener xdg_wm_base_listener = {
    .ping = xdg_wm_base_ping_handler,
};

b8 RGFW_wl_configured = 0;

static void xdg_surface_configure_handler(void *data,
        struct xdg_surface *xdg_surface, uint32_t serial)
{	
	RGFW_UNUSED(data);
    xdg_surface_ack_configure(xdg_surface, serial);
	#ifdef RGFW_DEBUG
	printf("Surface configured\n");
	#endif
	RGFW_wl_configured = 1;
}

static const struct xdg_surface_listener xdg_surface_listener = {
    .configure = xdg_surface_configure_handler,
};

static void xdg_toplevel_configure_handler(void *data,
        struct xdg_toplevel *toplevel, int32_t width, int32_t height,
        struct wl_array *states)
{
	RGFW_UNUSED(data); RGFW_UNUSED(toplevel); RGFW_UNUSED(states)
    fprintf(stderr, "XDG toplevel configure: %dx%d\n", width, height);
}

static void xdg_toplevel_close_handler(void *data,
        struct xdg_toplevel *toplevel)
{
	RGFW_UNUSED(data);
	RGFW_window* win = (RGFW_window*)xdg_toplevel_get_user_data(toplevel);
	if (win == NULL)
		win = RGFW_key_win;
	
	RGFW_Event ev;
	ev.type = RGFW_quit;

	RGFW_eventPipe_push(win, ev); 	

	RGFW_windowQuitCallback(win);
}

static void shm_format_handler(void *data,
        struct wl_shm *shm, uint32_t format)
{
	RGFW_UNUSED(data); RGFW_UNUSED(shm);
    fprintf(stderr, "Format %d\n", format);
}

static const struct wl_shm_listener shm_listener = {
    .format = shm_format_handler,
};

static const struct xdg_toplevel_listener xdg_toplevel_listener = {
    .configure = xdg_toplevel_configure_handler,
    .close = xdg_toplevel_close_handler,
};

RGFW_window* RGFW_mouse_win = NULL;

static void pointer_enter(void *data, struct wl_pointer *pointer, uint32_t serial, struct wl_surface *surface, wl_fixed_t surface_x, wl_fixed_t surface_y) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(serial); RGFW_UNUSED(surface_x); RGFW_UNUSED(surface_y);
	RGFW_window* win = (RGFW_window*)wl_surface_get_user_data(surface);
	RGFW_mouse_win = win;

	RGFW_Event ev;
	ev.type = RGFW_mouseEnter;
	ev.point = win->event.point;

	RGFW_eventPipe_push(win, ev); 	

	RGFW_mouseNotifyCallBack(win, win->event.point, RGFW_TRUE);
}
static void pointer_leave(void *data, struct wl_pointer *pointer, uint32_t serial, struct wl_surface *surface) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(serial); RGFW_UNUSED(surface);
	RGFW_window* win = (RGFW_window*)wl_surface_get_user_data(surface);
	if (RGFW_mouse_win == win)
		RGFW_mouse_win = NULL;
	
	RGFW_Event ev;
	ev.type = RGFW_mouseLeave;
	ev.point = win->event.point;
	RGFW_eventPipe_push(win, ev);

	RGFW_mouseNotifyCallBack(win,  win->event.point, RGFW_FALSE);
}
static void pointer_motion(void *data, struct wl_pointer *pointer, uint32_t time, wl_fixed_t x, wl_fixed_t y) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(time); RGFW_UNUSED(x); RGFW_UNUSED(y);

	assert(RGFW_mouse_win != NULL);
	
	RGFW_Event ev;
	ev.type = RGFW_mousePosChanged;
	ev.point = RGFW_POINT(wl_fixed_to_double(x), wl_fixed_to_double(y));
	RGFW_eventPipe_push(RGFW_mouse_win, ev);
	
	RGFW_mousePosCallback(RGFW_mouse_win, RGFW_POINT(wl_fixed_to_double(x), wl_fixed_to_double(y)));
}
static void pointer_button(void *data, struct wl_pointer *pointer, uint32_t serial, uint32_t time, uint32_t button, uint32_t state) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(time); RGFW_UNUSED(serial);
	assert(RGFW_mouse_win != NULL);

	u32 b = (button - 0x110) + 1;

	/* flip right and middle button codes */
	if (b == 2) b = 3;
	else if (b == 3) b = 2;
	
	RGFW_mouseButtons[b].prev = RGFW_mouseButtons[b].current;
	RGFW_mouseButtons[b].current = state;

	RGFW_Event ev;
	ev.type = RGFW_mouseButtonPressed + state;
	ev.button = b;
	RGFW_eventPipe_push(RGFW_mouse_win, ev);

	RGFW_mouseButtonCallback(RGFW_mouse_win, b, 0, state);
}
static void pointer_axis(void *data, struct wl_pointer *pointer, uint32_t time, uint32_t axis, wl_fixed_t value) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(time);  RGFW_UNUSED(axis);
	assert(RGFW_mouse_win != NULL); 

	double scroll = wl_fixed_to_double(value);

	RGFW_Event ev;
	ev.type = RGFW_mouseButtonPressed;
	ev.button = RGFW_mouseScrollUp + (scroll < 0);
	RGFW_eventPipe_push(RGFW_mouse_win, ev);

	RGFW_mouseButtonCallback(RGFW_mouse_win, RGFW_mouseScrollUp + (scroll < 0), scroll, 1);
}

void RGFW_doNothing(void) { }
static struct wl_pointer_listener pointer_listener = (struct wl_pointer_listener){&pointer_enter, &pointer_leave, &pointer_motion, &pointer_button, &pointer_axis, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing};

static void keyboard_keymap (void *data, struct wl_keyboard *keyboard, uint32_t format, int32_t fd, uint32_t size) {
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(format);

	char *keymap_string = mmap (NULL, size, PROT_READ, MAP_SHARED, fd, 0);
	xkb_keymap_unref (keymap);
	keymap = xkb_keymap_new_from_string (xkb_context, keymap_string, XKB_KEYMAP_FORMAT_TEXT_V1, XKB_KEYMAP_COMPILE_NO_FLAGS);
	
	munmap (keymap_string, size);
	close (fd);
	xkb_state_unref (xkb_state);
	xkb_state = xkb_state_new (keymap);
}
static void keyboard_enter (void *data, struct wl_keyboard *keyboard, uint32_t serial, struct wl_surface *surface, struct wl_array *keys) { 
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial); RGFW_UNUSED(keys);

	RGFW_key_win = (RGFW_window*)wl_surface_get_user_data(surface);

	RGFW_Event ev;
	ev.type = RGFW_focusIn;
	ev.inFocus = RGFW_TRUE;
	RGFW_key_win->event.inFocus = RGFW_TRUE;

	RGFW_eventPipe_push((RGFW_window*)RGFW_mouse_win, ev);

	RGFW_focusCallback(RGFW_key_win, RGFW_TRUE);
}
static void keyboard_leave (void *data, struct wl_keyboard *keyboard, uint32_t serial, struct wl_surface *surface) { 
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial);

	RGFW_window* win = (RGFW_window*)wl_surface_get_user_data(surface);
	if (RGFW_key_win == win)
		RGFW_key_win = NULL;	

	RGFW_Event ev;
	ev.type = RGFW_focusOut;
	ev.inFocus = RGFW_FALSE;
	win->event.inFocus = RGFW_FALSE;
	RGFW_eventPipe_push(win, ev);

	RGFW_focusCallback(win, RGFW_FALSE);
}
static void keyboard_key (void *data, struct wl_keyboard *keyboard, uint32_t serial, uint32_t time, uint32_t key, uint32_t state) {
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial); RGFW_UNUSED(time); 

	assert(RGFW_key_win != NULL);

	xkb_keysym_t keysym = xkb_state_key_get_one_sym (xkb_state, key+8);
	char name[16];
	xkb_keysym_get_name(keysym, name, 16);

	u32 RGFW_key = RGFW_apiKeyCodeToRGFW(key);
	RGFW_keyboard[RGFW_key].prev = RGFW_keyboard[RGFW_key].current;
	RGFW_keyboard[RGFW_key].current = state;
	RGFW_Event ev;
	ev.type = RGFW_keyPressed + state;
	ev.keyCode = RGFW_key;
	strcpy(ev.keyName, name);
	ev.repeat = RGFW_isHeld(RGFW_key_win, RGFW_key);
	RGFW_eventPipe_push(RGFW_key_win, ev);
	
	RGFW_updateLockState(RGFW_key_win, xkb_keymap_mod_get_index(keymap, "Lock"), xkb_keymap_mod_get_index(keymap, "Mod2"));

	RGFW_keyCallback(RGFW_key_win, RGFW_key, name, RGFW_key_win->event.lockState, state);
}
static void keyboard_modifiers (void *data, struct wl_keyboard *keyboard, uint32_t serial, uint32_t mods_depressed, uint32_t mods_latched, uint32_t mods_locked, uint32_t group) {
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial); RGFW_UNUSED(time); 
	xkb_state_update_mask (xkb_state, mods_depressed, mods_latched, mods_locked, 0, 0, group);
}
static struct wl_keyboard_listener keyboard_listener = {&keyboard_keymap, &keyboard_enter, &keyboard_leave, &keyboard_key, &keyboard_modifiers, (void*)&RGFW_doNothing};

static void seat_capabilities (void *data, struct wl_seat *seat, uint32_t capabilities) {
	RGFW_UNUSED(data);

	if (capabilities & WL_SEAT_CAPABILITY_POINTER) {
		struct wl_pointer *pointer = wl_seat_get_pointer (seat);
		wl_pointer_add_listener (pointer, &pointer_listener, NULL);
	}
	if (capabilities & WL_SEAT_CAPABILITY_KEYBOARD) {
		struct wl_keyboard *keyboard = wl_seat_get_keyboard (seat);
		wl_keyboard_add_listener (keyboard, &keyboard_listener, NULL);
	}
}
static struct wl_seat_listener seat_listener = {&seat_capabilities, (void*)&RGFW_doNothing};

static void wl_global_registry_handler(void *data,
		struct wl_registry *registry, uint32_t id, const char *interface,
		uint32_t version)
{
	RGFW_UNUSED(data); RGFW_UNUSED(version);

    if (strcmp(interface, "wl_compositor") == 0) {
		RGFW_compositor = wl_registry_bind(registry,
			id, &wl_compositor_interface, 4);
	} else if (strcmp(interface, "xdg_wm_base") == 0) {
	xdg_wm_base = wl_registry_bind(registry,
		id, &xdg_wm_base_interface, 1);
	} else if (strcmp(interface, zxdg_decoration_manager_v1_interface.name) == 0) {
		decoration_manager = wl_registry_bind(registry, id, &zxdg_decoration_manager_v1_interface, 1);
    } else if (strcmp(interface, "wl_shm") == 0) {
        shm = wl_registry_bind(registry,
            id, &wl_shm_interface, 1);
        wl_shm_add_listener(shm, &shm_listener, NULL);
	} else if (strcmp(interface,"wl_seat") == 0) {
		seat = wl_registry_bind(registry, id, &wl_seat_interface, 1);
		wl_seat_add_listener(seat, &seat_listener, NULL);
	}

	else {
		#ifdef RGFW_DEBUG
		printf("did not register %s\n", interface);
		return;
		#endif
	}

		#ifdef RGFW_DEBUG
		printf("registered %s\n", interface);
		#endif
}

static void wl_global_registry_remove(void *data, struct wl_registry *registry, uint32_t name) { RGFW_UNUSED(data); RGFW_UNUSED(registry); RGFW_UNUSED(name); }
static const struct wl_registry_listener registry_listener = {
	.global = wl_global_registry_handler,
	.global_remove = wl_global_registry_remove,
};

static const char *get_mode_name(enum zxdg_toplevel_decoration_v1_mode mode) {
	switch (mode) {
	case ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE:
		return "client-side decorations";
	case ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE:
		return "server-side decorations";
	}
	abort();
}


static void decoration_handle_configure(void *data,
		struct zxdg_toplevel_decoration_v1 *decoration,
		enum zxdg_toplevel_decoration_v1_mode mode) {
	RGFW_UNUSED(data); RGFW_UNUSED(decoration);
	printf("Using %s\n", get_mode_name(mode));
	RGFW_current_mode = mode;
}

static const struct zxdg_toplevel_decoration_v1_listener decoration_listener = {
	.configure = decoration_handle_configure,
};

static void randname(char *buf) {
	struct timespec ts;
	clock_gettime(CLOCK_REALTIME, &ts);
	long r = ts.tv_nsec;
	for (int i = 0; i < 6; ++i) {
		buf[i] = 'A'+(r&15)+(r&16)*2;
		r >>= 5;
	}
}

static int anonymous_shm_open(void) {
	char name[] = "/RGFW-wayland-XXXXXX";
	int retries = 100;

	do {
		randname(name + strlen(name) - 6);

		--retries;
		// shm_open guarantees that O_CLOEXEC is set
		int fd = shm_open(name, O_RDWR | O_CREAT | O_EXCL, 0600);
		if (fd >= 0) {
			shm_unlink(name);
			return fd;
		}
	} while (retries > 0 && errno == EEXIST);

	return -1;
}

int create_shm_file(off_t size) {
	int fd = anonymous_shm_open();
	if (fd < 0) {
		return fd;
	}

	if (ftruncate(fd, size) < 0) {
		close(fd);
		return -1;
	}

	return fd;
}

static void wl_surface_frame_done(void *data, struct wl_callback *cb, uint32_t time) {
	#ifdef RGFW_BUFFER
		RGFW_window* win = (RGFW_window*)data;
		if ((win->_winArgs & RGFW_NO_CPU_RENDER))
			return;	
		
		#ifndef RGFW_X11_DONT_CONVERT_BGR
			u32 x, y;
			for (y = 0; y < (u32)win->r.h; y++) {
				for (x = 0; x < (u32)win->r.w; x++) {
					u32 index = (y * 4 * win->r.w) + x * 4;

					u8 red = win->buffer[index];
					win->buffer[index] = win->buffer[index + 2];
					win->buffer[index + 2] = red;

				}
			}
		#endif	
	
		wl_surface_attach(win->src.surface, win->src.wl_buffer, 0, 0);
		wl_surface_damage_buffer(win->src.surface, 0, 0, win->r.w, win->r.h);
		wl_surface_commit(win->src.surface);
	#endif
}

static const struct wl_callback_listener wl_surface_frame_listener = {
	.done = wl_surface_frame_done,
};


	/* normal wayland RGFW stuff */
	
	RGFW_area RGFW_getScreenSize(void) {
		RGFW_area area = {};

		if (RGFW_root != NULL)
			/* this isn't right but it's here for buffers */
			area = RGFW_AREA(RGFW_root->r.w, RGFW_root->r.h);
		
		/* TODO wayland */
		return area;
	}
	
	void RGFW_releaseCursor(RGFW_window* win) {
		RGFW_UNUSED(win);
	}

	void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) {
		RGFW_UNUSED(win); RGFW_UNUSED(r);

		/* TODO wayland */
	}


	RGFWDEF void RGFW_init_buffer(RGFW_window* win);
	void RGFW_init_buffer(RGFW_window* win) {
		#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)	
			size_t size = win->r.w * win->r.h * 4;
			int fd = create_shm_file(size);
			if (fd < 0) {
				fprintf(stderr, "Failed to create a buffer. size: %ld\n", size);
				exit(1);
			}

			win->buffer = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
			if (win->buffer == MAP_FAILED) {
				fprintf(stderr, "mmap failed!\n");
				close(fd);
				exit(1);
			}

			struct wl_shm_pool* pool = wl_shm_create_pool(shm, fd, size);
			win->src.wl_buffer = wl_shm_pool_create_buffer(pool, 0, win->r.w, win->r.h, win->r.w * 4,
				WL_SHM_FORMAT_ARGB8888);
			wl_shm_pool_destroy(pool);

			close(fd);
			
			wl_surface_attach(win->src.surface, win->src.wl_buffer, 0, 0);
			wl_surface_commit(win->src.surface);

			u8 color[] = {0x00, 0x00, 0x00, 0xFF};

			size_t i;
			for (i = 0; i < size; i += 4) {
				memcpy(&win->buffer[i], color, 4);
			}
	
			#if defined(RGFW_OSMESA)
					win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
					OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
			#endif
		#else
		RGFW_UNUSED(win);
		#endif
	}
   

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
		RGFW_window* win = RGFW_window_basic_init(rect, args);
		
		fprintf(stderr, "Warning: RGFW Wayland support is experimental\n");
		
		win->src.display = wl_display_connect(NULL);
		if (win->src.display == NULL) {
			#ifdef RGFW_DEBUG
				fprintf(stderr, "Failed to load Wayland display\n");
			#endif
			return NULL;
		}
		
		struct wl_registry *registry = wl_display_get_registry(win->src.display);
		wl_registry_add_listener(registry, &registry_listener, NULL);
			
		wl_display_dispatch(win->src.display);
		wl_display_roundtrip(win->src.display);

		if (RGFW_compositor == NULL) {
			#ifdef RGFW_DEBUG
				fprintf(stderr, "Can't find compositor.\n");
			#endif
			
			return NULL;
		}
		
		if (RGFW_wl_cursor_theme == NULL) {
			RGFW_wl_cursor_theme = wl_cursor_theme_load(NULL, 24, shm);
			RGFW_cursor_surface = wl_compositor_create_surface(RGFW_compositor); 
			
			struct wl_cursor* cursor = wl_cursor_theme_get_cursor(RGFW_wl_cursor_theme, "left_ptr");
			RGFW_cursor_image = cursor->images[0];
			struct wl_buffer* cursor_buffer	= wl_cursor_image_get_buffer(RGFW_cursor_image);

			wl_surface_attach(RGFW_cursor_surface, cursor_buffer, 0, 0);
			wl_surface_commit(RGFW_cursor_surface); 
		}

		if (RGFW_root == NULL)
			xdg_wm_base_add_listener(xdg_wm_base, &xdg_wm_base_listener, NULL);
		
		xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);

		win->src.surface = wl_compositor_create_surface(RGFW_compositor);
		wl_surface_set_user_data(win->src.surface, win);

		win->src.xdg_surface = xdg_wm_base_get_xdg_surface(xdg_wm_base, win->src.surface);
		xdg_surface_add_listener(win->src.xdg_surface, &xdg_surface_listener, NULL);
	
		xdg_wm_base_set_user_data(xdg_wm_base, win);

		win->src.xdg_toplevel = xdg_surface_get_toplevel(win->src.xdg_surface);
		xdg_toplevel_set_user_data(win->src.xdg_toplevel, win);
		xdg_toplevel_set_title(win->src.xdg_toplevel, name);
		xdg_toplevel_add_listener(win->src.xdg_toplevel, &xdg_toplevel_listener, NULL);

		xdg_surface_set_window_geometry(win->src.xdg_surface, 0, 0, win->r.w, win->r.h);
		
		if (!(args & RGFW_NO_BORDER)) {
			win->src.decoration = zxdg_decoration_manager_v1_get_toplevel_decoration(
						decoration_manager, win->src.xdg_toplevel);
		}


		if (args & RGFW_OPENGL_SOFTWARE)
			setenv("LIBGL_ALWAYS_SOFTWARE", "1", 1);

		wl_display_roundtrip(win->src.display);

		wl_surface_commit(win->src.surface);
		
		/* wait for the surface to be configured */
		while (wl_display_dispatch(win->src.display) != -1 && !RGFW_wl_configured) { }
		
		
		#ifdef RGFW_OPENGL
			if ((args & RGFW_NO_INIT_API) == 0) {
				win->src.window = wl_egl_window_create(win->src.surface, win->r.w, win->r.h);
				RGFW_createOpenGLContext(win);
			}
		#endif	

		RGFW_init_buffer(win);

		struct wl_callback* callback = wl_surface_frame(win->src.surface);
   		wl_callback_add_listener(callback, &wl_surface_frame_listener, win);	
		wl_surface_commit(win->src.surface);

		if (args & RGFW_HIDE_MOUSE) {
			RGFW_window_showMouse(win, 0);
		}
		
		if (RGFW_root == NULL) {
			RGFW_root = win;
		}
		
		win->src.eventIndex = 0;
		win->src.eventLen = 0;
		
		return win;
	}

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		if (win->_winArgs & RGFW_WINDOW_HIDE)
			return NULL;

		if (win->src.eventIndex == 0) {
			if (wl_display_roundtrip(win->src.display) == -1) {
				return NULL;
			}
			RGFW_resetKey();
		}

		#ifdef __linux__
			RGFW_Event* event = RGFW_linux_updateJoystick(win);
			if (event != NULL)
				return event;
		#endif
		
		if (win->src.eventLen == 0) {
				return NULL;
		}

		RGFW_Event ev = RGFW_eventPipe_pop(win);
		
		if (ev.type ==  0 || win->event.type == RGFW_quit) {
			return NULL;
		}
        
		ev.frameTime = win->event.frameTime;
        ev.frameTime2 = win->event.frameTime2;
        ev.inFocus = win->event.inFocus;
        win->event = ev;
		
		return &win->event;
	}


	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		RGFW_UNUSED(win); RGFW_UNUSED(a);

		/* TODO wayland */
	}

	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		RGFW_UNUSED(win); RGFW_UNUSED(v);

		/* TODO wayland */
	}

	void RGFW_window_setIcon(RGFW_window* win, u8* src, RGFW_area a, i32 channels) {
		RGFW_UNUSED(win); RGFW_UNUSED(src); RGFW_UNUSED(a); RGFW_UNUSED(channels)
		/* TODO wayland */
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) {
		RGFW_UNUSED(win); RGFW_UNUSED(v);

		/* TODO wayland */
	}

	void RGFW_window_showMouse(RGFW_window* win, i8 show) {
		RGFW_UNUSED(win);

		if (show) {

		}
		else {
			
		}

		/* TODO wayland */
	}

	b8 RGFW_window_isMaximized(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	b8 RGFW_window_isMinimized(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	b8 RGFW_window_isHidden(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	b8 RGFW_window_isFullscreen(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return RGFW_POINT(0, 0);
	}
			
	RGFW_point RGFW_getGlobalMousePoint(void) {
		/* TODO wayland */
		return RGFW_POINT(0, 0);
	}
			
	void RGFW_window_show(RGFW_window* win) {
		//wl_surface_attach(win->src.surface, win->rc., 0, 0);
        wl_surface_commit(win->src.surface);
		
		if (win->_winArgs & RGFW_WINDOW_HIDE)
			win->_winArgs ^= RGFW_WINDOW_HIDE;
	}
		
	void RGFW_window_hide(RGFW_window* win) {
		wl_surface_attach(win->src.surface, NULL, 0, 0);
        wl_surface_commit(win->src.surface);
		win->_winArgs |= RGFW_WINDOW_HIDE;
	}
		
	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_UNUSED(win);
	
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_NORMAL);
	}
		
	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
		RGFW_UNUSED(win);
		
		static const char* iconStrings[] = { "left_ptr", "left_ptr", "text", "cross", "pointer", "e-resize", "n-resize", "nw-resize", "ne-resize", "all-resize", "not-allowed" };

		struct wl_cursor* cursor = wl_cursor_theme_get_cursor(RGFW_wl_cursor_theme, iconStrings[mouse]);
		RGFW_cursor_image = cursor->images[0];
		struct wl_buffer* cursor_buffer	= wl_cursor_image_get_buffer(RGFW_cursor_image);

		wl_surface_attach(RGFW_cursor_surface, cursor_buffer, 0, 0);
		wl_surface_commit(RGFW_cursor_surface); 
	}
		
	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		RGFW_UNUSED(win); RGFW_UNUSED(image); RGFW_UNUSED(a); RGFW_UNUSED(channels)
		//struct wl_cursor* cursor = wl_cursor_theme_get_cursor(RGFW_wl_cursor_theme, iconStrings[mouse]);
		//RGFW_cursor_image = image;
		struct wl_buffer* cursor_buffer	= wl_cursor_image_get_buffer(RGFW_cursor_image);

		wl_surface_attach(RGFW_cursor_surface, cursor_buffer, 0, 0);
		wl_surface_commit(RGFW_cursor_surface); 
	}
		
	void RGFW_window_setName(RGFW_window* win, char* name) {
		xdg_toplevel_set_title(win->src.xdg_toplevel, name);
	}
		
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		RGFW_UNUSED(win); RGFW_UNUSED(passthrough);

	/* TODO wayland */
	}
		
	void RGFW_window_setBorder(RGFW_window* win, b8 border) {
		RGFW_UNUSED(win); RGFW_UNUSED(border);

	/* TODO wayland */
	}
		
	void RGFW_window_restore(RGFW_window* win) {
		RGFW_UNUSED(win);

	/* TODO wayland */
	}
		
	void RGFW_window_minimize(RGFW_window* win) {
		RGFW_UNUSED(win);

	/* TODO wayland */
	}
		
	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		RGFW_UNUSED(win); RGFW_UNUSED(a);

	/* TODO wayland */
	}
		
	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		RGFW_UNUSED(win); RGFW_UNUSED(a);

	/* TODO wayland */
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		RGFW_monitor m = {};
		RGFW_UNUSED(win);
		RGFW_UNUSED(m);
		/* TODO wayland */

		return m;
	}


	#ifndef RGFW_EGL
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) { RGFW_UNUSED(win); RGFW_UNUSED(swapInterval); }
	#endif

	void RGFW_window_swapBuffers(RGFW_window* win) {
		assert(win != NULL);

		/* clear the window*/
		#ifdef RGFW_BUFFER	
			wl_surface_frame_done(win, NULL, 0);
			if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) 
		#endif
		{
		#ifdef RGFW_OPENGL
			eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
		#endif
		}
		
		wl_display_flush(win->src.display);
	}

	void RGFW_window_close(RGFW_window* win) {
		#ifdef RGFW_EGL
			RGFW_closeEGL(win);
		#endif

		if (RGFW_root == win) {
			RGFW_root = NULL;
		}

		xdg_toplevel_destroy(win->src.xdg_toplevel);
		xdg_surface_destroy(win->src.xdg_surface);
		wl_surface_destroy(win->src.surface);

		#ifdef RGFW_BUFFER
		wl_buffer_destroy(win->src.wl_buffer);
		#endif
		
		wl_display_disconnect(win->src.display);
		RGFW_FREE(win);
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
		/* TODO wayland */

		return (RGFW_monitor){};
	}
						
	RGFW_monitor* RGFW_getMonitors(void) {
		/* TODO wayland */

		return NULL;
	}

	void RGFW_writeClipboard(const char* text, u32 textLen) {
		RGFW_UNUSED(text); RGFW_UNUSED(textLen);

		/* TODO wayland */
	}

	char* RGFW_readClipboard(size_t* size) {
		RGFW_UNUSED(size);

		/* TODO wayland */

		return NULL;
	}
#endif /* RGFW_WAYLAND */

/* 
	End of Wayland defines
*/


/*

	Start of Windows defines


*/

#ifdef RGFW_WINDOWS
	#define WIN32_LEAN_AND_MEAN
	#define OEMRESOURCE
	#include <windows.h>
	
	#include <processthreadsapi.h>
	#include <wchar.h>
	#include <locale.h>
	#include <windowsx.h>
	#include <shellapi.h>
	#include <shellscalingapi.h>

	#include <winuser.h>

	__declspec(dllimport) int __stdcall WideCharToMultiByte( UINT CodePage, DWORD dwFlags, const WCHAR* lpWideCharStr, int cchWideChar,  LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
	
	#ifndef RGFW_NO_XINPUT
	typedef DWORD (WINAPI * PFN_XInputGetState)(DWORD,XINPUT_STATE*);
	PFN_XInputGetState XInputGetStateSRC = NULL;
	#define XInputGetState XInputGetStateSRC

	typedef DWORD (WINAPI * PFN_XInputGetKeystroke)(DWORD, DWORD, PXINPUT_KEYSTROKE);
	PFN_XInputGetKeystroke XInputGetKeystrokeSRC = NULL;
	#define XInputGetKeystroke XInputGetKeystrokeSRC

	static HMODULE RGFW_XInput_dll = NULL;
	#endif

	u32 RGFW_mouseIconSrc[] = {OCR_NORMAL, OCR_NORMAL, OCR_IBEAM, OCR_CROSS, OCR_HAND, OCR_SIZEWE, OCR_SIZENS, OCR_SIZENWSE, OCR_SIZENESW, OCR_SIZEALL, OCR_NO};

	char* createUTF8FromWideStringWin32(const WCHAR* source);

#define GL_FRONT				0x0404
#define GL_BACK					0x0405
#define GL_LEFT					0x0406
#define GL_RIGHT				0x0407

#if defined(RGFW_OSMESA) && defined(RGFW_LINK_OSMESA)

	typedef void (GLAPIENTRY* PFN_OSMesaDestroyContext)(OSMesaContext);
	typedef i32(GLAPIENTRY* PFN_OSMesaMakeCurrent)(OSMesaContext, void*, int, int, int);
	typedef OSMesaContext(GLAPIENTRY* PFN_OSMesaCreateContext)(GLenum, OSMesaContext);

	PFN_OSMesaMakeCurrent OSMesaMakeCurrentSource;
	PFN_OSMesaCreateContext OSMesaCreateContextSource;
	PFN_OSMesaDestroyContext OSMesaDestroyContextSource;

#define OSMesaCreateContext OSMesaCreateContextSource
#define OSMesaMakeCurrent OSMesaMakeCurrentSource
#define OSMesaDestroyContext OSMesaDestroyContextSource
#endif

	typedef int (*PFN_wglGetSwapIntervalEXT)(void);
	PFN_wglGetSwapIntervalEXT wglGetSwapIntervalEXTSrc = NULL;
#define wglGetSwapIntervalEXT wglGetSwapIntervalEXTSrc


	void* RGFWjoystickApi = NULL;

	/* these two wgl functions need to be preloaded */
	typedef HGLRC (WINAPI *PFNWGLCREATECONTEXTATTRIBSARBPROC)(HDC hdc, HGLRC hglrc, const int *attribList);
	PFNWGLCREATECONTEXTATTRIBSARBPROC wglCreateContextAttribsARB = NULL;

	/* defines for creating ARB attributes */
#define WGL_NUMBER_PIXEL_FORMATS_ARB 0x2000
#define WGL_CONTEXT_MAJOR_VERSION_ARB             0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB             0x2092
#define WGL_DRAW_TO_WINDOW_ARB                    0x2001
#define WGL_ACCELERATION_ARB                      0x2003
#define WGL_NO_ACCELERATION_ARB 0x2025
#define WGL_DOUBLE_BUFFER_ARB                     0x2011
#define WGL_COLOR_BITS_ARB                        0x2014
#define WGL_RED_BITS_ARB 0x2015
#define WGL_RED_SHIFT_ARB 0x2016
#define WGL_GREEN_BITS_ARB 0x2017
#define WGL_GREEN_SHIFT_ARB 0x2018
#define WGL_BLUE_BITS_ARB 0x2019
#define WGL_BLUE_SHIFT_ARB 0x201a
#define WGL_ALPHA_BITS_ARB 0x201b
#define WGL_ALPHA_SHIFT_ARB 0x201c
#define WGL_ACCUM_BITS_ARB 0x201d
#define WGL_ACCUM_RED_BITS_ARB 0x201e
#define WGL_ACCUM_GREEN_BITS_ARB 0x201f
#define WGL_ACCUM_BLUE_BITS_ARB 0x2020
#define WGL_ACCUM_ALPHA_BITS_ARB 0x2021
#define WGL_DEPTH_BITS_ARB 0x2022
#define WGL_AUX_BUFFERS_ARB 0x2024
#define WGL_STEREO_ARB 0x2012
#define WGL_DEPTH_BITS_ARB                        0x2022
#define WGL_STENCIL_BITS_ARB 					  0x2023
#define WGL_FULL_ACCELERATION_ARB                 0x2027
#define WGL_CONTEXT_FLAGS_ARB                     0x2094
#define WGL_CONTEXT_PROFILE_MASK_ARB              0x9126
#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
#define WGL_SAMPLE_BUFFERS_ARB               0x2041
#define WGL_SAMPLES_ARB 0x2042
#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB 0x20a9

#ifndef RGFW_EGL
static HMODULE wglinstance = NULL;
#endif

#ifdef RGFW_WGL_LOAD
	typedef HGLRC(WINAPI* PFN_wglCreateContext)(HDC);
	typedef BOOL(WINAPI* PFN_wglDeleteContext)(HGLRC);
	typedef PROC(WINAPI* PFN_wglGetProcAddress)(LPCSTR);
	typedef BOOL(WINAPI* PFN_wglMakeCurrent)(HDC, HGLRC);
	typedef HDC(WINAPI* PFN_wglGetCurrentDC)();
	typedef HGLRC(WINAPI* PFN_wglGetCurrentContext)();

	PFN_wglCreateContext wglCreateContextSRC;
	PFN_wglDeleteContext wglDeleteContextSRC;
	PFN_wglGetProcAddress wglGetProcAddressSRC;
	PFN_wglMakeCurrent wglMakeCurrentSRC;
	PFN_wglGetCurrentDC wglGetCurrentDCSRC;
	PFN_wglGetCurrentContext wglGetCurrentContextSRC;

	#define wglCreateContext wglCreateContextSRC
	#define wglDeleteContext wglDeleteContextSRC
	#define wglGetProcAddress wglGetProcAddressSRC
	#define wglMakeCurrent wglMakeCurrentSRC

	#define wglGetCurrentDC wglGetCurrentDCSRC
	#define wglGetCurrentContext wglGetCurrentContextSRC
#endif

#ifdef RGFW_OPENGL
	void* RGFW_getProcAddress(const char* procname) { 
		void* proc = (void*) wglGetProcAddress(procname);
		if (proc)
			return proc;

		return (void*) GetProcAddress(wglinstance, procname); 
	}

	typedef HRESULT (APIENTRY* PFNWGLCHOOSEPIXELFORMATARBPROC)(HDC hdc, const int* piAttribIList, const FLOAT* pfAttribFList, UINT nMaxFormats, int* piFormats, UINT* nNumFormats);
	static PFNWGLCHOOSEPIXELFORMATARBPROC wglChoosePixelFormatARB = NULL;
#endif

	RGFW_window RGFW_eventWindow;

	LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
		switch (message) {
		case WM_MOVE:
			RGFW_eventWindow.r.x = LOWORD(lParam);
			RGFW_eventWindow.r.y = HIWORD(lParam);
			RGFW_eventWindow.src.window = hWnd;
			return DefWindowProcA(hWnd, message, wParam, lParam);
		case WM_SIZE:
			RGFW_eventWindow.r.w = LOWORD(lParam);
			RGFW_eventWindow.r.h = HIWORD(lParam);
			RGFW_eventWindow.src.window = hWnd;
			return DefWindowProcA(hWnd, message, wParam, lParam); // Call DefWindowProc after handling
		default:
			return DefWindowProcA(hWnd, message, wParam, lParam);
		}
	}
	
	#ifndef RGFW_NO_DPI
	static HMODULE RGFW_Shcore_dll = NULL;
	typedef HRESULT (WINAPI * PFN_GetDpiForMonitor)(HMONITOR,MONITOR_DPI_TYPE,UINT*,UINT*);
	PFN_GetDpiForMonitor GetDpiForMonitorSRC = NULL;
	#define GetDpiForMonitor GetDpiForMonitorSRC
	#endif

	__declspec(dllimport) u32 __stdcall timeBeginPeriod(u32 uPeriod);
	
	#ifndef RGFW_NO_XINPUT
	void RGFW_loadXInput(void) {
		u32 i;
		static const char* names[] = { 
			"xinput1_4.dll",
			"xinput1_3.dll",
			"xinput9_1_0.dll",
			"xinput1_2.dll",
			"xinput1_1.dll"
		};

		for (i = 0; i < sizeof(names) / sizeof(const char*);  i++) {
			RGFW_XInput_dll = LoadLibraryA(names[i]);

			if (RGFW_XInput_dll) {
				XInputGetStateSRC = (PFN_XInputGetState)(void*)GetProcAddress(RGFW_XInput_dll, "XInputGetState");
			
				if (XInputGetStateSRC == NULL)
					printf("Failed to load XInputGetState");
			}
		}
	}
	#endif

	RGFWDEF void RGFW_init_buffer(RGFW_window* win);
	void RGFW_init_buffer(RGFW_window* win) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
	if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
		RGFW_bufferSize = RGFW_getScreenSize();
	
	BITMAPV5HEADER bi = { 0 };
	ZeroMemory(&bi, sizeof(bi));
	bi.bV5Size = sizeof(bi);
	bi.bV5Width = RGFW_bufferSize.w;
	bi.bV5Height = -((LONG) RGFW_bufferSize.h);
	bi.bV5Planes = 1;
	bi.bV5BitCount = 32;
	bi.bV5Compression = BI_BITFIELDS;
	bi.bV5BlueMask = 0x00ff0000;
	bi.bV5GreenMask = 0x0000ff00;
	bi.bV5RedMask = 0x000000ff;
	bi.bV5AlphaMask = 0xff000000;

	win->src.bitmap = CreateDIBSection(win->src.hdc,
		(BITMAPINFO*) &bi,
		DIB_RGB_COLORS,
		(void**) &win->buffer,
		NULL,
		(DWORD) 0);
	
	win->src.hdcMem = CreateCompatibleDC(win->src.hdc);

	#if defined(RGFW_OSMESA)
	win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
	OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
	#endif
#else
RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
#endif
	}

	void RGFW_window_setDND(RGFW_window* win, b8 allow) {
		DragAcceptFiles(win->src.window, allow);
	}

	void RGFW_releaseCursor(RGFW_window* win) {
		RGFW_UNUSED(win);
		ClipCursor(NULL);
    	const RAWINPUTDEVICE id = { 0x01, 0x02, RIDEV_REMOVE, NULL };
    	RegisterRawInputDevices(&id, 1, sizeof(id));	
	}

	void RGFW_captureCursor(RGFW_window* win, RGFW_rect rect) {
		RGFW_UNUSED(win)
		
		RECT clipRect;
		GetClientRect(win->src.window, &clipRect);
		ClientToScreen(win->src.window, (POINT*) &clipRect.left);
		ClientToScreen(win->src.window, (POINT*) &clipRect.right);
		ClipCursor(&clipRect);

	    const RAWINPUTDEVICE id = { 0x01, 0x02, 0, win->src.window };
		RegisterRawInputDevices(&id, 1, sizeof(id));
	}

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
		#ifndef RGFW_NO_XINPUT
		if (RGFW_XInput_dll == NULL)
			RGFW_loadXInput();
		#endif

		#ifndef RGFW_NO_DPI
		if (RGFW_Shcore_dll == NULL) {
			RGFW_Shcore_dll = LoadLibraryA("shcore.dll");
			GetDpiForMonitorSRC = (PFN_GetDpiForMonitor)(void*)GetProcAddress(RGFW_Shcore_dll, "GetDpiForMonitor");
		}
		#endif

		if (wglinstance == NULL) {
			wglinstance = LoadLibraryA("opengl32.dll");
#ifdef RGFW_WGL_LOAD
			wglCreateContextSRC = (PFN_wglCreateContext) GetProcAddress(wglinstance, "wglCreateContext");
			wglDeleteContextSRC = (PFN_wglDeleteContext) GetProcAddress(wglinstance, "wglDeleteContext");
			wglGetProcAddressSRC = (PFN_wglGetProcAddress) GetProcAddress(wglinstance, "wglGetProcAddress");
			wglMakeCurrentSRC = (PFN_wglMakeCurrent) GetProcAddress(wglinstance, "wglMakeCurrent");
			wglGetCurrentDCSRC = (PFN_wglGetCurrentDC) GetProcAddress(wglinstance, "wglGetCurrentDC");
			wglGetCurrentContextSRC = (PFN_wglGetCurrentContext) GetProcAddress(wglinstance, "wglGetCurrentContext");
#endif
		}
	
		if (name[0] == 0) name = (char*) " ";

		RGFW_eventWindow.r = RGFW_RECT(-1, -1, -1, -1);
		RGFW_eventWindow.src.window = NULL;

		RGFW_window* win = RGFW_window_basic_init(rect, args);

		win->src.maxSize = RGFW_AREA(0, 0);
		win->src.minSize = RGFW_AREA(0, 0);


		HINSTANCE inh = GetModuleHandleA(NULL);

		#ifndef __cplusplus
		WNDCLASSA Class = { 0 }; /*!< Setup the Window class. */
		#else
		WNDCLASSA Class = { };
		#endif

		if (RGFW_className == NULL)
			RGFW_className = (char*)name;

		Class.lpszClassName = RGFW_className;
		Class.hInstance = inh;
		Class.hCursor = LoadCursor(NULL, IDC_ARROW);
		Class.lpfnWndProc = WndProc;

		RegisterClassA(&Class);

		DWORD window_style = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;

		RECT windowRect, clientRect;

		if (!(args & RGFW_NO_BORDER)) {
			window_style |= WS_CAPTION | WS_SYSMENU | WS_BORDER | WS_MINIMIZEBOX;

			if (!(args & RGFW_NO_RESIZE))
				window_style |= WS_SIZEBOX | WS_MAXIMIZEBOX | WS_THICKFRAME;
		} else
			window_style |= WS_POPUP | WS_VISIBLE | WS_SYSMENU | WS_MINIMIZEBOX;

		HWND dummyWin = CreateWindowA(Class.lpszClassName, name, window_style, win->r.x, win->r.y, win->r.w, win->r.h, 0, 0, inh, 0);

		GetWindowRect(dummyWin, &windowRect);
		GetClientRect(dummyWin, &clientRect);

		win->src.hOffset = (windowRect.bottom - windowRect.top) - (clientRect.bottom - clientRect.top);
		win->src.window = CreateWindowA(Class.lpszClassName, name, window_style, win->r.x, win->r.y, win->r.w, win->r.h + win->src.hOffset, 0, 0, inh, 0);

		if (args & RGFW_ALLOW_DND) {
			win->_winArgs |= RGFW_ALLOW_DND;
			RGFW_window_setDND(win, 1);
		}
		win->src.hdc = GetDC(win->src.window);

		if ((args & RGFW_NO_INIT_API) == 0) {
#ifdef RGFW_DIRECTX
		assert(FAILED(CreateDXGIFactory(&__uuidof(IDXGIFactory), (void**) &RGFW_dxInfo.pFactory)) == 0);

		if (FAILED(RGFW_dxInfo.pFactory->lpVtbl->EnumAdapters(RGFW_dxInfo.pFactory, 0, &RGFW_dxInfo.pAdapter))) {
			fprintf(stderr, "Failed to enumerate DXGI adapters\n");
			RGFW_dxInfo.pFactory->lpVtbl->Release(RGFW_dxInfo.pFactory);
			return NULL;
		}

		D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_11_0 };

		if (FAILED(D3D11CreateDevice(RGFW_dxInfo.pAdapter, D3D_DRIVER_TYPE_UNKNOWN, NULL, 0, featureLevels, 1, D3D11_SDK_VERSION, &RGFW_dxInfo.pDevice, NULL, &RGFW_dxInfo.pDeviceContext))) {
			fprintf(stderr, "Failed to create Direct3D device\n");
			RGFW_dxInfo.pAdapter->lpVtbl->Release(RGFW_dxInfo.pAdapter);
			RGFW_dxInfo.pFactory->lpVtbl->Release(RGFW_dxInfo.pFactory);
			return NULL;
		}

		DXGI_SWAP_CHAIN_DESC swapChainDesc = { 0 };
		swapChainDesc.BufferCount = 1;
		swapChainDesc.BufferDesc.Width = win->r.w;
		swapChainDesc.BufferDesc.Height = win->r.h;
		swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		swapChainDesc.OutputWindow = win->src.window;
		swapChainDesc.SampleDesc.Count = 1;
		swapChainDesc.SampleDesc.Quality = 0;
		swapChainDesc.Windowed = TRUE;
		RGFW_dxInfo.pFactory->lpVtbl->CreateSwapChain(RGFW_dxInfo.pFactory, (IUnknown*) RGFW_dxInfo.pDevice, &swapChainDesc, &win->src.swapchain);

		ID3D11Texture2D* pBackBuffer;
		win->src.swapchain->lpVtbl->GetBuffer(win->src.swapchain, 0, &__uuidof(ID3D11Texture2D), (LPVOID*) &pBackBuffer);
		RGFW_dxInfo.pDevice->lpVtbl->CreateRenderTargetView(RGFW_dxInfo.pDevice, (ID3D11Resource*) pBackBuffer, NULL, &win->src.renderTargetView);
		pBackBuffer->lpVtbl->Release(pBackBuffer);

		D3D11_TEXTURE2D_DESC depthStencilDesc = { 0 };
		depthStencilDesc.Width = win->r.w;
		depthStencilDesc.Height = win->r.h;
		depthStencilDesc.MipLevels = 1;
		depthStencilDesc.ArraySize = 1;
		depthStencilDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
		depthStencilDesc.SampleDesc.Count = 1;
		depthStencilDesc.SampleDesc.Quality = 0;
		depthStencilDesc.Usage = D3D11_USAGE_DEFAULT;
		depthStencilDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;

		ID3D11Texture2D* pDepthStencilTexture = NULL;
		RGFW_dxInfo.pDevice->lpVtbl->CreateTexture2D(RGFW_dxInfo.pDevice, &depthStencilDesc, NULL, &pDepthStencilTexture);

		D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc = { 0 };
		depthStencilViewDesc.Format = depthStencilDesc.Format;
		depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
		depthStencilViewDesc.Texture2D.MipSlice = 0;

		RGFW_dxInfo.pDevice->lpVtbl->CreateDepthStencilView(RGFW_dxInfo.pDevice, (ID3D11Resource*) pDepthStencilTexture, &depthStencilViewDesc, &win->src.pDepthStencilView);

		pDepthStencilTexture->lpVtbl->Release(pDepthStencilTexture);

		RGFW_dxInfo.pDeviceContext->lpVtbl->OMSetRenderTargets(RGFW_dxInfo.pDeviceContext, 1, &win->src.renderTargetView, win->src.pDepthStencilView);
#endif

#ifdef RGFW_OPENGL 
		HDC dummy_dc = GetDC(dummyWin);
        
        u32 pfd_flags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL; 
        
        //if (RGFW_DOUBLE_BUFFER)    
             pfd_flags |= PFD_DOUBLEBUFFER;
		
        PIXELFORMATDESCRIPTOR pfd = {
			sizeof(pfd),
			1, /* version */
			pfd_flags,
		    PFD_TYPE_RGBA, /* ipixel type */
			24, /* color bits */
			0, 0, 0, 0, 0, 0,
			8, /* alpha bits */
			0, 0, 0, 0, 0, 0,
			32, /* depth bits */
			8, /* stencil bits */ 
			0,
			PFD_MAIN_PLANE, /* Layer type */
			0, 0, 0, 0
		};

		int pixel_format = ChoosePixelFormat(dummy_dc, &pfd);
		SetPixelFormat(dummy_dc, pixel_format, &pfd);

		HGLRC dummy_context = wglCreateContext(dummy_dc);
		wglMakeCurrent(dummy_dc, dummy_context);

		if (wglChoosePixelFormatARB == NULL) {
			wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC) (void*) wglGetProcAddress("wglCreateContextAttribsARB");
			wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC) (void*)wglGetProcAddress("wglChoosePixelFormatARB");
		}

		wglMakeCurrent(dummy_dc, 0);
		wglDeleteContext(dummy_context);
		ReleaseDC(dummyWin, dummy_dc);
		
		/* try to create the pixel format we want for opengl and then try to create an opengl context for the specified version */ 
		if (wglCreateContextAttribsARB != NULL) {
			PIXELFORMATDESCRIPTOR pfd = {sizeof(pfd), 1, pfd_flags, PFD_TYPE_RGBA, 32, 8, PFD_MAIN_PLANE, 24, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

			if (args & RGFW_OPENGL_SOFTWARE)
				pfd.dwFlags |= PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED;

			if (wglChoosePixelFormatARB != NULL) {
				i32* pixel_format_attribs = (i32*)RGFW_initFormatAttribs(args & RGFW_OPENGL_SOFTWARE);

				int pixel_format;
				UINT num_formats;
				wglChoosePixelFormatARB(win->src.hdc, pixel_format_attribs, 0, 1, &pixel_format, &num_formats);
				if (!num_formats) {
					printf("Failed to create a pixel format for WGL.\n");
				}

				DescribePixelFormat(win->src.hdc, pixel_format, sizeof(pfd), &pfd);
				if (!SetPixelFormat(win->src.hdc, pixel_format, &pfd)) {
					printf("Failed to set the WGL pixel format.\n");
				}
			}
			
			/* create opengl/WGL context for the specified version */ 
			u32 index = 0;
			i32 attribs[40];

			if (RGFW_profile == RGFW_GL_CORE) {
				SET_ATTRIB(WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB);
			}
			else {
				SET_ATTRIB(WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB);
			}
			
			if (RGFW_majorVersion || RGFW_minorVersion) {
				SET_ATTRIB(WGL_CONTEXT_MAJOR_VERSION_ARB, RGFW_majorVersion);
				SET_ATTRIB(WGL_CONTEXT_MINOR_VERSION_ARB, RGFW_minorVersion);
			}

			SET_ATTRIB(0, 0);

			win->src.ctx = (HGLRC)wglCreateContextAttribsARB(win->src.hdc, NULL, attribs);
		} else { /* fall back to a default context (probably opengl 2 or something) */
			fprintf(stderr, "Failed to create an accelerated OpenGL Context\n");

			int pixel_format = ChoosePixelFormat(win->src.hdc, &pfd);
			SetPixelFormat(win->src.hdc, pixel_format, &pfd);

			win->src.ctx = wglCreateContext(win->src.hdc);
		}
		
		wglMakeCurrent(win->src.hdc, win->src.ctx);
#endif
	}

#ifdef RGFW_OSMESA
#ifdef RGFW_LINK_OSM ESA
		OSMesaMakeCurrentSource = (PFN_OSMesaMakeCurrent) GetProcAddress(win->src.hdc, "OSMesaMakeCurrent");
		OSMesaCreateContextSource = (PFN_OSMesaCreateContext) GetProcAddress(win->src.hdc, "OSMesaCreateContext");
		OSMesaDestroyContextSource = (PFN_OSMesaDestroyContext) GetProcAddress(win->src.hdc, "OSMesaDestroyContext");
#endif
#endif

#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0) {
			ReleaseDC(win->src.window, win->src.hdc);
			win->src.hdc = GetDC(win->src.window);
			wglMakeCurrent(win->src.hdc, win->src.ctx);
		}
#endif

		DestroyWindow(dummyWin);
		RGFW_init_buffer(win);


		#ifndef RGFW_NO_MONITOR
		if (args & RGFW_SCALE_TO_MONITOR)
			RGFW_window_scaleToMonitor(win);
		#endif

#ifdef RGFW_EGL
		if ((args & RGFW_NO_INIT_API) == 0)
			RGFW_createOpenGLContext(win);
#endif

		if (args & RGFW_HIDE_MOUSE)
			RGFW_window_showMouse(win, 0);

		if (args & RGFW_TRANSPARENT_WINDOW) {
			SetWindowLong(win->src.window, GWL_EXSTYLE, GetWindowLong(win->src.window, GWL_EXSTYLE) | WS_EX_LAYERED);
			SetLayeredWindowAttributes(win->src.window, RGB(255, 255, 255), RGFW_ALPHA, LWA_ALPHA);
		}

		ShowWindow(win->src.window, SW_SHOWNORMAL);
		
		if (RGFW_root == NULL)
			RGFW_root = win;
		
		#ifdef RGFW_OPENGL
		else 
			wglShareLists(RGFW_root->src.ctx, win->src.ctx);
		#endif

		return win;
	}

	void RGFW_window_setBorder(RGFW_window* win, u8 border) {
		DWORD style = GetWindowLong(win->src.window, GWL_STYLE);

		if (border == 0) {
			SetWindowLong(win->src.window, GWL_STYLE, style & ~WS_OVERLAPPEDWINDOW);
			SetWindowPos(
				win->src.window, HWND_TOP, 0, 0, 0, 0,
				SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE
			);
		}
		else {
			SetWindowLong(win->src.window, GWL_STYLE, style | WS_OVERLAPPEDWINDOW);
			SetWindowPos(
				win->src.window, HWND_TOP, 0, 0, 0, 0,
				SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE
			);
		}
	}


	RGFW_area RGFW_getScreenSize(void) {
		return RGFW_AREA(GetDeviceCaps(GetDC(NULL), HORZRES), GetDeviceCaps(GetDC(NULL), VERTRES));
	}

	RGFW_point RGFW_getGlobalMousePoint(void) {
		POINT p;
		GetCursorPos(&p);

		return RGFW_POINT(p.x, p.y);
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		POINT p;
		GetCursorPos(&p);
		ScreenToClient(win->src.window, &p);

		return RGFW_POINT(p.x, p.y);
	}

	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);
		win->src.minSize = a;
	}

	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);
		win->src.maxSize = a;
	}


	void RGFW_window_minimize(RGFW_window* win) {
		assert(win != NULL);

		ShowWindow(win->src.window, SW_MINIMIZE);
	}

	void RGFW_window_restore(RGFW_window* win) {
		assert(win != NULL);

		ShowWindow(win->src.window, SW_RESTORE);
	}


	u8 RGFW_xinput2RGFW[] = {
		RGFW_JS_A, /* or PS X button */
		RGFW_JS_B, /* or PS circle button */
		RGFW_JS_X, /* or PS square button */
		RGFW_JS_Y, /* or PS triangle button */
		RGFW_JS_R1, /* right bumper */
		RGFW_JS_L1, /* left bump */
		RGFW_JS_L2, /* left trigger*/
		RGFW_JS_R2, /* right trigger */
		0, 0, 0, 0, 0, 0, 0, 0,
		RGFW_JS_UP, /* dpad up */
		RGFW_JS_DOWN, /* dpad down*/
		RGFW_JS_LEFT, /* dpad left */
		RGFW_JS_RIGHT, /* dpad right */
		RGFW_JS_START, /* start button */
		RGFW_JS_SELECT/* select button */
	};

	static i32 RGFW_checkXInput(RGFW_window* win, RGFW_Event* e) {
		RGFW_UNUSED(win)
		
		size_t i;
		for (i = 0; i < 4; i++) {
			XINPUT_KEYSTROKE keystroke;

			if (XInputGetKeystroke == NULL)
				return 0;

			DWORD result = XInputGetKeystroke((DWORD)i, 0, &keystroke);

			if ((keystroke.Flags & XINPUT_KEYSTROKE_REPEAT) == 0 && result != ERROR_EMPTY) {
				if (result != ERROR_SUCCESS)
					return 0;

				if (keystroke.VirtualKey > VK_PAD_BACK)
					continue;

				// RGFW_jsButtonPressed + 1 = RGFW_jsButtonReleased
				e->type = RGFW_jsButtonPressed + !(keystroke.Flags & XINPUT_KEYSTROKE_KEYDOWN);
				e->button = RGFW_xinput2RGFW[keystroke.VirtualKey - 0x5800];
				RGFW_jsPressed[i][e->button] = !(keystroke.Flags & XINPUT_KEYSTROKE_KEYDOWN);

				return 1;
			}

			XINPUT_STATE state;
			if (XInputGetState == NULL ||
				XInputGetState((DWORD) i, &state) == ERROR_DEVICE_NOT_CONNECTED
			)
				return 0;
#define INPUT_DEADZONE  ( 0.24f * (float)(0x7FFF) )  // Default to 24% of the +/- 32767 range.   This is a reasonable default value but can be altered if needed.

			if ((state.Gamepad.sThumbLX < INPUT_DEADZONE &&
				state.Gamepad.sThumbLX > -INPUT_DEADZONE) &&
				(state.Gamepad.sThumbLY < INPUT_DEADZONE &&
					state.Gamepad.sThumbLY > -INPUT_DEADZONE))
			{
				state.Gamepad.sThumbLX = 0;
				state.Gamepad.sThumbLY = 0;
			}

			if ((state.Gamepad.sThumbRX < INPUT_DEADZONE &&
				state.Gamepad.sThumbRX > -INPUT_DEADZONE) &&
				(state.Gamepad.sThumbRY < INPUT_DEADZONE &&
					state.Gamepad.sThumbRY > -INPUT_DEADZONE))
			{
				state.Gamepad.sThumbRX = 0;
				state.Gamepad.sThumbRY = 0;
			}

			e->axisesCount = 2;
			RGFW_point axis1 = RGFW_POINT(state.Gamepad.sThumbLX, state.Gamepad.sThumbLY);
			RGFW_point axis2 = RGFW_POINT(state.Gamepad.sThumbRX, state.Gamepad.sThumbRY);

			if (axis1.x != e->axis[0].x || axis1.y != e->axis[0].y || axis2.x != e->axis[1].x || axis2.y != e->axis[1].y) {
				e->type = RGFW_jsAxisMove;

				e->axis[0] = axis1;
				e->axis[1] = axis2;

				return 1;
			}

			e->axis[0] = axis1;
			e->axis[1] = axis2;
		}

		return 0;
	}

	void RGFW_stopCheckEvents(void) { 
		PostMessageW(RGFW_root->src.window, WM_NULL, 0, 0);
	}

	void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
		RGFW_UNUSED(win);

		MsgWaitForMultipleObjects(0, NULL, FALSE, (DWORD) (waitMS * 1e3), QS_ALLINPUT);
	}

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		assert(win != NULL);

		if (win->event.type == RGFW_quit) {
			return NULL;
		}

		MSG msg;

		if (RGFW_eventWindow.src.window == win->src.window) {
			if (RGFW_eventWindow.r.x != -1) {
				win->r.x = RGFW_eventWindow.r.x;
				win->r.y = RGFW_eventWindow.r.y;
				win->event.type = RGFW_windowMoved;
				RGFW_windowMoveCallback(win, win->r);
			}

			if (RGFW_eventWindow.r.w != -1) {
				win->r.w = RGFW_eventWindow.r.w;
				win->r.h = RGFW_eventWindow.r.h;
				win->event.type = RGFW_windowResized;
				RGFW_windowResizeCallback(win, win->r);
			}

			RGFW_eventWindow.src.window = NULL;
			RGFW_eventWindow.r = RGFW_RECT(-1, -1, -1, -1);

			return &win->event;
		}


		static HDROP drop;
		
		if (win->event.type == RGFW_dnd_init) {
			if (win->event.droppedFilesCount) {
				u32 i;
				for (i = 0; i < win->event.droppedFilesCount; i++)
					win->event.droppedFiles[i][0] = '\0';
			}

			win->event.droppedFilesCount = 0;
			win->event.droppedFilesCount = DragQueryFileW(drop, 0xffffffff, NULL, 0);
			//win->event.droppedFiles = (char**)RGFW_CALLOC(win->event.droppedFilesCount, sizeof(char*));

			u32 i;
			for (i = 0; i < win->event.droppedFilesCount; i++) {
				const UINT length = DragQueryFileW(drop, i, NULL, 0);
				WCHAR* buffer = (WCHAR*) RGFW_CALLOC((size_t) length + 1, sizeof(WCHAR));

				DragQueryFileW(drop, i, buffer, length + 1);
				strncpy(win->event.droppedFiles[i], createUTF8FromWideStringWin32(buffer), RGFW_MAX_PATH);
				win->event.droppedFiles[i][RGFW_MAX_PATH - 1] = '\0';
				RGFW_FREE(buffer);
			}

			DragFinish(drop);
			RGFW_dndCallback(win, win->event.droppedFiles, win->event.droppedFilesCount);
			
			win->event.type = RGFW_dnd;
			return &win->event;
		}

		win->event.inFocus = (GetForegroundWindow() == win->src.window);

		if (RGFW_checkXInput(win, &win->event))
			return &win->event;

		static BYTE keyboardState[256];

		if (PeekMessageA(&msg, win->src.window, 0u, 0u, PM_REMOVE)) {
			switch (msg.message) {
			case WM_CLOSE:
			case WM_QUIT:
				RGFW_windowQuitCallback(win);
				win->event.type = RGFW_quit;
				break;

			case WM_ACTIVATE:
				win->event.inFocus = (LOWORD(msg.wParam) == WA_INACTIVE);

				if (win->event.inFocus) {
					win->event.type = RGFW_focusIn;
					RGFW_focusCallback(win, 1);
				}
				else {
					win->event.type = RGFW_focusOut;
					RGFW_focusCallback(win, 0);
				}

				break;
			
			case WM_PAINT:
				win->event.type = RGFW_windowRefresh;
				RGFW_windowRefreshCallback(win);
				break;
			
			case WM_MOUSELEAVE:
				win->event.type = RGFW_mouseLeave;
				win->_winArgs |= RGFW_MOUSE_LEFT;
				RGFW_mouseNotifyCallBack(win, win->event.point, 0);
				break;
			
			case WM_KEYUP: {
				win->event.keyCode = RGFW_apiKeyCodeToRGFW((u32) msg.wParam);
								
				RGFW_keyboard[win->event.keyCode].prev = RGFW_isPressed(win, win->event.keyCode);

				static char keyName[16];
				
				{
					GetKeyNameTextA((LONG) msg.lParam, keyName, 16);

					if ((!(GetKeyState(VK_CAPITAL) & 0x0001) && !(GetKeyState(VK_SHIFT) & 0x8000)) ||
						((GetKeyState(VK_CAPITAL) & 0x0001) && (GetKeyState(VK_SHIFT) & 0x8000))) {
						CharLowerBuffA(keyName, 16);
					}
				}

				RGFW_updateLockState(win, (GetKeyState(VK_CAPITAL) & 0x0001), (GetKeyState(VK_NUMLOCK) & 0x0001));

				strncpy(win->event.keyName, keyName, 16);

				if (RGFW_isPressed(win, RGFW_ShiftL)) {
					ToAscii((UINT) msg.wParam, MapVirtualKey((UINT) msg.wParam, MAPVK_VK_TO_CHAR),
						keyboardState, (LPWORD) win->event.keyName, 0);
				}

				win->event.type = RGFW_keyReleased;
				RGFW_keyboard[win->event.keyCode].current = 0;
				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 0);
				break;
			}
			case WM_KEYDOWN: {
				win->event.keyCode = RGFW_apiKeyCodeToRGFW((u32) msg.wParam);

				RGFW_keyboard[win->event.keyCode].prev = RGFW_isPressed(win, win->event.keyCode);

				static char keyName[16];
				
				{
					GetKeyNameTextA((LONG) msg.lParam, keyName, 16);

					if ((!(GetKeyState(VK_CAPITAL) & 0x0001) && !(GetKeyState(VK_SHIFT) & 0x8000)) ||
						((GetKeyState(VK_CAPITAL) & 0x0001) && (GetKeyState(VK_SHIFT) & 0x8000))) {
						CharLowerBuffA(keyName, 16);
					}
				}
				
				RGFW_updateLockState(win, (GetKeyState(VK_CAPITAL) & 0x0001), (GetKeyState(VK_NUMLOCK) & 0x0001));

				strncpy(win->event.keyName, keyName, 16);

				if (RGFW_isPressed(win, RGFW_ShiftL) & 0x8000) {
					ToAscii((UINT) msg.wParam, MapVirtualKey((UINT) msg.wParam, MAPVK_VK_TO_CHAR),
						keyboardState, (LPWORD) win->event.keyName, 0);
				}

				win->event.type = RGFW_keyPressed;
				win->event.repeat = RGFW_isPressed(win, win->event.keyCode);
				RGFW_keyboard[win->event.keyCode].current = 1;
				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 1);
				break;
			}

			case WM_MOUSEMOVE:
				if ((win->_winArgs & RGFW_HOLD_MOUSE))
					break;

				win->event.type = RGFW_mousePosChanged;

				win->event.point.x = GET_X_LPARAM(msg.lParam);
				win->event.point.y = GET_Y_LPARAM(msg.lParam);
				
				RGFW_mousePosCallback(win, win->event.point);

				if (win->_winArgs & RGFW_MOUSE_LEFT) {
					win->_winArgs ^= RGFW_MOUSE_LEFT;
					win->event.type = RGFW_mouseEnter;
					RGFW_mouseNotifyCallBack(win, win->event.point, 1);
				}

				break;

			case WM_INPUT: {
				if (!(win->_winArgs & RGFW_HOLD_MOUSE))
					break;
				
				unsigned size = sizeof(RAWINPUT);
				static RAWINPUT raw[sizeof(RAWINPUT)];
				GetRawInputData((HRAWINPUT)msg.lParam, RID_INPUT, raw, &size, sizeof(RAWINPUTHEADER));

				if (raw->header.dwType != RIM_TYPEMOUSE || (raw->data.mouse.lLastX == 0 && raw->data.mouse.lLastY == 0) )
					break;
				
				win->event.type = RGFW_mousePosChanged;
				win->event.point.x = raw->data.mouse.lLastX;
				win->event.point.y = raw->data.mouse.lLastY;
				break;
			}

			case WM_LBUTTONDOWN:
				win->event.button = RGFW_mouseLeft;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;
			case WM_RBUTTONDOWN:
				win->event.button = RGFW_mouseRight;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;
			case WM_MBUTTONDOWN:
				win->event.button = RGFW_mouseMiddle;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case WM_MOUSEWHEEL:
				if (msg.wParam > 0)
					win->event.button = RGFW_mouseScrollUp;
				else
					win->event.button = RGFW_mouseScrollDown;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;

				win->event.scroll = (SHORT) HIWORD(msg.wParam) / (double) WHEEL_DELTA;

				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case WM_LBUTTONUP:
			
				win->event.button = RGFW_mouseLeft;
				win->event.type = RGFW_mouseButtonReleased;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;
			case WM_RBUTTONUP:
				win->event.button = RGFW_mouseRight;
				win->event.type = RGFW_mouseButtonReleased;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;
			case WM_MBUTTONUP:
				win->event.button = RGFW_mouseMiddle;
				win->event.type = RGFW_mouseButtonReleased;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

				/*
					much of this event is source from glfw
				*/
			case WM_DROPFILES: {				
				win->event.type = RGFW_dnd_init;

				drop = (HDROP) msg.wParam;
				POINT pt;

				/* Move the mouse to the position of the drop */
				DragQueryPoint(drop, &pt);

				win->event.point.x = pt.x;
				win->event.point.y = pt.y;

				RGFW_dndInitCallback(win, win->event.point);
			}
				break;
			case WM_GETMINMAXINFO:
			{
				if (win->src.maxSize.w == 0 && win->src.maxSize.h == 0)
					break;

				MINMAXINFO* mmi = (MINMAXINFO*) msg.lParam;
				mmi->ptMinTrackSize.x = win->src.minSize.w;
				mmi->ptMinTrackSize.y = win->src.minSize.h;
				mmi->ptMaxTrackSize.x = win->src.maxSize.w;
				mmi->ptMaxTrackSize.y = win->src.maxSize.h;
				return 0;
			}
			default:
				win->event.type = 0;
				break;
			}

			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}

		else
			win->event.type = 0;

		if (!IsWindow(win->src.window)) {
			win->event.type = RGFW_quit;
			RGFW_windowQuitCallback(win);
		}

		if (win->event.type)
			return &win->event;
		else
			return NULL;
	}

	u8 RGFW_window_isFullscreen(RGFW_window* win) {
		assert(win != NULL);

		#ifndef __cplusplus
		WINDOWPLACEMENT placement = { 0 };
		#else
		WINDOWPLACEMENT placement = {  };
		#endif
		GetWindowPlacement(win->src.window, &placement);
		return placement.showCmd == SW_SHOWMAXIMIZED;
	}

	u8 RGFW_window_isHidden(RGFW_window* win) {
		assert(win != NULL);

		return IsWindowVisible(win->src.window) == 0 && !RGFW_window_isMinimized(win);
	}

	u8 RGFW_window_isMinimized(RGFW_window* win) {
		assert(win != NULL);

		#ifndef __cplusplus
		WINDOWPLACEMENT placement = { 0 };
		#else
		WINDOWPLACEMENT placement = {  };
		#endif
		GetWindowPlacement(win->src.window, &placement);
		return placement.showCmd == SW_SHOWMINIMIZED;
	}

	u8 RGFW_window_isMaximized(RGFW_window* win) {
		assert(win != NULL);

		#ifndef __cplusplus
		WINDOWPLACEMENT placement = { 0 };
		#else
		WINDOWPLACEMENT placement = {  };
		#endif
		GetWindowPlacement(win->src.window, &placement);
		return placement.showCmd == SW_SHOWMAXIMIZED;
	}

	typedef struct { int iIndex; HMONITOR hMonitor; } RGFW_mInfo;
	BOOL CALLBACK GetMonitorByHandle(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {
		RGFW_UNUSED(hdcMonitor)
		RGFW_UNUSED(lprcMonitor)

		RGFW_mInfo* info = (RGFW_mInfo*) dwData;
		if (info->hMonitor == hMonitor)
			return FALSE;

		info->iIndex++;
		return TRUE;
	}
	
	#ifndef RGFW_NO_MONITOR
	RGFW_monitor win32CreateMonitor(HMONITOR src) {
		RGFW_monitor monitor;
		MONITORINFO monitorInfo;

		monitorInfo.cbSize = sizeof(MONITORINFO);
		GetMonitorInfoA(src, &monitorInfo);

		RGFW_mInfo info;
		info.iIndex = 0;
		info.hMonitor = src;

		/* get the monitor's index */
		if (EnumDisplayMonitors(NULL, NULL, GetMonitorByHandle, (LPARAM) &info)) {
			DISPLAY_DEVICEA dd;
			dd.cb = sizeof(dd);

			/* loop through the devices until you find a device with the monitor's index */
			size_t deviceIndex;
			for (deviceIndex = 0; EnumDisplayDevicesA(0, (DWORD) deviceIndex, &dd, 0); deviceIndex++) {
				char* deviceName = dd.DeviceName;
				if (EnumDisplayDevicesA(deviceName, info.iIndex, &dd, 0)) {
					strncpy(monitor.name, dd.DeviceString, 128); /*!< copy the monitor's name */
					break;
				}
			}
		}

		monitor.rect.x = monitorInfo.rcWork.left;
		monitor.rect.y = monitorInfo.rcWork.top;
		monitor.rect.w = monitorInfo.rcWork.right - monitorInfo.rcWork.left;
		monitor.rect.h = monitorInfo.rcWork.bottom - monitorInfo.rcWork.top;

#ifndef RGFW_NO_DPI
		#ifndef USER_DEFAULT_SCREEN_DPI
		#define USER_DEFAULT_SCREEN_DPI 96
		#endif

		if (GetDpiForMonitor != NULL) {
			u32 x, y;
			GetDpiForMonitor(src, MDT_ANGULAR_DPI, &x, &y);
			monitor.scaleX = (float) (x) / (float) USER_DEFAULT_SCREEN_DPI;
			monitor.scaleY = (float) (y) / (float) USER_DEFAULT_SCREEN_DPI;
		}
#endif

		HDC hdc = GetDC(NULL);
		/* get pixels per inch */
		i32 ppiX = GetDeviceCaps(hdc, LOGPIXELSX);
		i32 ppiY = GetDeviceCaps(hdc, LOGPIXELSY);
		ReleaseDC(NULL, hdc);

		/* Calculate physical height in inches */
		monitor.physW = GetSystemMetrics(SM_CYSCREEN) / (float) ppiX;
		monitor.physH = GetSystemMetrics(SM_CXSCREEN) / (float) ppiY;

		return monitor;
	}
	#endif /* RGFW_NO_MONITOR */
	

	#ifndef RGFW_NO_MONITOR
	RGFW_monitor RGFW_monitors[6];
	BOOL CALLBACK GetMonitorHandle(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {
		RGFW_UNUSED(hdcMonitor)
		RGFW_UNUSED(lprcMonitor)

		RGFW_mInfo* info = (RGFW_mInfo*) dwData;

		if (info->iIndex >= 6)
			return FALSE;

		RGFW_monitors[info->iIndex] = win32CreateMonitor(hMonitor);
		info->iIndex++;

		return TRUE;
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
        #ifdef __cplusplus
        return win32CreateMonitor(MonitorFromPoint({ 0, 0 }, MONITOR_DEFAULTTOPRIMARY));
        #else
		return win32CreateMonitor(MonitorFromPoint((POINT) { 0, 0 }, MONITOR_DEFAULTTOPRIMARY));
	    #endif
    }

	RGFW_monitor* RGFW_getMonitors(void) {
		RGFW_mInfo info;
		info.iIndex = 0;
		while (EnumDisplayMonitors(NULL, NULL, GetMonitorHandle, (LPARAM) &info));

		return RGFW_monitors;
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		HMONITOR src = MonitorFromWindow(win->src.window, MONITOR_DEFAULTTOPRIMARY);
		return win32CreateMonitor(src);
	}
	#endif

	HICON RGFW_loadHandleImage(RGFW_window* win, u8* src, RGFW_area a, BOOL icon) {
		assert(win != NULL);

		u32 i;
		HDC dc;
		HICON handle;
		HBITMAP color, mask;
		BITMAPV5HEADER bi;
		ICONINFO ii;
		u8* target = NULL;
		u8* source = src;

		ZeroMemory(&bi, sizeof(bi));
		bi.bV5Size = sizeof(bi);
		bi.bV5Width = a.w;
		bi.bV5Height = -((LONG) a.h);
		bi.bV5Planes = 1;
		bi.bV5BitCount = 32;
		bi.bV5Compression = BI_BITFIELDS;
		bi.bV5RedMask = 0x00ff0000;
		bi.bV5GreenMask = 0x0000ff00;
		bi.bV5BlueMask = 0x000000ff;
		bi.bV5AlphaMask = 0xff000000;

		dc = GetDC(NULL);
		color = CreateDIBSection(dc,
			(BITMAPINFO*) &bi,
			DIB_RGB_COLORS,
			(void**) &target,
			NULL,
			(DWORD) 0);
		ReleaseDC(NULL, dc);

		mask = CreateBitmap(a.w, a.h, 1, 1, NULL);

		for (i = 0; i < a.w * a.h; i++) {
			target[0] = source[2];
			target[1] = source[1];
			target[2] = source[0];
			target[3] = source[3];
			target += 4;
			source += 4;
		}

		ZeroMemory(&ii, sizeof(ii));
		ii.fIcon = icon;
		ii.xHotspot = 0;
		ii.yHotspot = 0;
		ii.hbmMask = mask;
		ii.hbmColor = color;

		handle = CreateIconIndirect(&ii);

		DeleteObject(color);
		DeleteObject(mask);

		return handle;
	}

	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		assert(win != NULL);
		RGFW_UNUSED(channels)

		HCURSOR cursor = (HCURSOR) RGFW_loadHandleImage(win, image, a, FALSE);
		SetClassLongPtrA(win->src.window, GCLP_HCURSOR, (LPARAM) cursor);
		SetCursor(cursor);
		DestroyCursor(cursor);
	}

	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_ARROW);
	}

	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
		assert(win != NULL);

		if (mouse > (sizeof(RGFW_mouseIconSrc) / sizeof(u32)))
			return;

		char* icon = MAKEINTRESOURCEA(RGFW_mouseIconSrc[mouse]);

		SetClassLongPtrA(win->src.window, GCLP_HCURSOR, (LPARAM) LoadCursorA(NULL, icon));
		SetCursor(LoadCursorA(NULL, icon));
	}

	void RGFW_window_hide(RGFW_window* win) {
		ShowWindow(win->src.window, SW_HIDE);
	}

	void RGFW_window_show(RGFW_window* win) {
		ShowWindow(win->src.window, SW_RESTORE);
	}

	void RGFW_window_close(RGFW_window* win) {
		assert(win != NULL);

#ifdef RGFW_EGL
		RGFW_closeEGL(win);
#endif

		if (win == RGFW_root) {
#ifdef RGFW_DIRECTX
			RGFW_dxInfo.pDeviceContext->lpVtbl->Release(RGFW_dxInfo.pDeviceContext);
			RGFW_dxInfo.pDevice->lpVtbl->Release(RGFW_dxInfo.pDevice);
			RGFW_dxInfo.pAdapter->lpVtbl->Release(RGFW_dxInfo.pAdapter);
			RGFW_dxInfo.pFactory->lpVtbl->Release(RGFW_dxInfo.pFactory);
#endif
		
			if (RGFW_XInput_dll != NULL) {
				FreeLibrary(RGFW_XInput_dll);
				RGFW_XInput_dll = NULL;
			}

			#ifndef RGFW_NO_DPI
			if (RGFW_Shcore_dll != NULL) {
				FreeLibrary(RGFW_Shcore_dll);
				RGFW_Shcore_dll = NULL;
			}
			#endif

			if (wglinstance != NULL) {
				FreeLibrary(wglinstance);
				wglinstance = NULL;
			}

			RGFW_root = NULL;
		}

#ifdef RGFW_DIRECTX
		win->src.swapchain->lpVtbl->Release(win->src.swapchain);
		win->src.renderTargetView->lpVtbl->Release(win->src.renderTargetView);
		win->src.pDepthStencilView->lpVtbl->Release(win->src.pDepthStencilView);
#endif

#ifdef RGFW_BUFFER
		DeleteDC(win->src.hdcMem);
		DeleteObject(win->src.bitmap);
#endif

#ifdef RGFW_OPENGL
		wglDeleteContext((HGLRC) win->src.ctx); /*!< delete opengl context */
#endif
		DeleteDC(win->src.hdc); /*!< delete device context */
		DestroyWindow(win->src.window); /*!< delete window */

#if defined(RGFW_OSMESA)
		if (win->buffer != NULL)
			RGFW_FREE(win->buffer);
#endif

#ifdef RGFW_ALLOC_DROPFILES
		{
			u32 i;
			for (i = 0; i < RGFW_MAX_DROPS; i++)
				RGFW_FREE(win->event.droppedFiles[i]);


			RGFW_FREE(win->event.droppedFiles);
		}
#endif

		RGFW_FREE(win);
	}

	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);

		win->r.x = v.x;
		win->r.y = v.y;
		SetWindowPos(win->src.window, HWND_TOP, win->r.x, win->r.y, 0, 0, SWP_NOSIZE);
	}

	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		win->r.w = a.w;
		win->r.h = a.h;
		SetWindowPos(win->src.window, HWND_TOP, 0, 0, win->r.w, win->r.h + win->src.hOffset, SWP_NOMOVE);
	}


	void RGFW_window_setName(RGFW_window* win, char* name) {
		assert(win != NULL);

		SetWindowTextA(win->src.window, name);
	}

	/* sourced from GLFW */
	#ifndef RGFW_NO_PASSTHROUGH
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		assert(win != NULL);
		
		COLORREF key = 0;
		BYTE alpha = 0;
		DWORD flags = 0;
		DWORD exStyle = GetWindowLongW(win->src.window, GWL_EXSTYLE);
		
		if (exStyle & WS_EX_LAYERED)
			GetLayeredWindowAttributes(win->src.window, &key, &alpha, &flags);

		if (passthrough)
			exStyle |= (WS_EX_TRANSPARENT | WS_EX_LAYERED);
		else
		{
			exStyle &= ~WS_EX_TRANSPARENT;
			// NOTE: Window opacity also needs the layered window style so do not
			//       remove it if the window is alpha blended
			if (exStyle & WS_EX_LAYERED)
			{
				if (!(flags & LWA_ALPHA))
					exStyle &= ~WS_EX_LAYERED;
			}
		}

		SetWindowLongW(win->src.window, GWL_EXSTYLE, exStyle);

		if (passthrough) {
			SetLayeredWindowAttributes(win->src.window, key, alpha, flags);
		}
	}
	#endif

	/* much of this function is sourced from GLFW */
	void RGFW_window_setIcon(RGFW_window* win, u8* src, RGFW_area a, i32 channels) {
		assert(win != NULL);
		#ifndef RGFW_WIN95
		RGFW_UNUSED(channels)

		HICON handle = RGFW_loadHandleImage(win, src, a, TRUE);

		SetClassLongPtrA(win->src.window, GCLP_HICON, (LPARAM) handle);

		DestroyIcon(handle);
		#else
		RGFW_UNUSED(src)
		RGFW_UNUSED(a)
		RGFW_UNUSED(channels)
		#endif
	}

	char* RGFW_readClipboard(size_t* size) {
		/* Open the clipboard */
		if (OpenClipboard(NULL) == 0)
			return (char*) "";

		/* Get the clipboard data as a Unicode string */
		HANDLE hData = GetClipboardData(CF_UNICODETEXT);
		if (hData == NULL) {
			CloseClipboard();
			return (char*) "";
		}

		wchar_t* wstr = (wchar_t*) GlobalLock(hData);

		char* text;

		{
			setlocale(LC_ALL, "en_US.UTF-8");

			size_t textLen = wcstombs(NULL, wstr, 0);
			if (textLen == 0)
				return (char*) "";

			text = (char*) RGFW_MALLOC((textLen * sizeof(char)) + 1);

			wcstombs(text, wstr, (textLen) +1);

			if (size != NULL)
				*size = textLen + 1;

			text[textLen] = '\0';
		}

		/* Release the clipboard data */
		GlobalUnlock(hData);
		CloseClipboard();

		return text;
	}

	void RGFW_writeClipboard(const char* text, u32 textLen) {
		HANDLE object;
		WCHAR* buffer;

		object = GlobalAlloc(GMEM_MOVEABLE, (1 + textLen) * sizeof(WCHAR));
		if (!object)
			return;

		buffer = (WCHAR*) GlobalLock(object);
		if (!buffer) {
			GlobalFree(object);
			return;
		}

		MultiByteToWideChar(CP_UTF8, 0, text, -1, buffer, textLen);
		GlobalUnlock(object);

		if (!OpenClipboard(RGFW_root->src.window)) {
			GlobalFree(object);
			return;
		}

		EmptyClipboard();
		SetClipboardData(CF_UNICODETEXT, object);
		CloseClipboard();
	}

	u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber) {
		assert(win != NULL);

		RGFW_UNUSED(jsNumber)

		return RGFW_registerJoystickF(win, (char*) "");
	}

	u16 RGFW_registerJoystickF(RGFW_window* win, char* file) {
		assert(win != NULL);
		RGFW_UNUSED(file)

		return RGFW_joystickCount - 1;
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point p) {
		assert(win != NULL);

		SetCursorPos(p.x, p.y);
	}

	#ifdef RGFW_OPENGL
	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		if (win == NULL)
			wglMakeCurrent(NULL, NULL);
		else
			wglMakeCurrent(win->src.hdc, (HGLRC) win->src.ctx);
	}
	#endif

	#ifndef RGFW_EGL
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);
		
		#if defined(RGFW_OPENGL)
		typedef BOOL(APIENTRY* PFNWGLSWAPINTERVALEXTPROC)(int interval);
		static PFNWGLSWAPINTERVALEXTPROC wglSwapIntervalEXT = NULL;
		static void* loadSwapFunc = (void*) 1;

		if (loadSwapFunc == NULL) {
			fprintf(stderr, "wglSwapIntervalEXT not supported\n");
			return;
		}

		if (wglSwapIntervalEXT == NULL) {
			loadSwapFunc = (void*) wglGetProcAddress("wglSwapIntervalEXT");
			wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC) loadSwapFunc;
		}

		if (wglSwapIntervalEXT(swapInterval) == FALSE)
			fprintf(stderr, "Failed to set swap interval\n");
		#else
        RGFW_UNUSED(swapInterval);
        #endif

	}
	#endif

	void RGFW_window_swapBuffers(RGFW_window* win) {
		//assert(win != NULL);
		/* clear the window*/

		if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			#ifdef RGFW_OSMESA
			RGFW_OSMesa_reorganize();
			#endif

			HGDIOBJ oldbmp = SelectObject(win->src.hdcMem, win->src.bitmap);
			BitBlt(win->src.hdc, 0, 0, win->r.w, win->r.h, win->src.hdcMem, 0, 0, SRCCOPY);
			SelectObject(win->src.hdcMem, oldbmp);
#endif
		}

		if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) {
			#ifdef RGFW_EGL
					eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
			#elif defined(RGFW_OPENGL)
					SwapBuffers(win->src.hdc);
			#endif

			#if defined(RGFW_WINDOWS) && defined(RGFW_DIRECTX)
					win->src.swapchain->lpVtbl->Present(win->src.swapchain, 0, 0);
			#endif
		}
	}

	char* createUTF8FromWideStringWin32(const WCHAR* source) {
		char* target;
		i32 size;

		size = WideCharToMultiByte(CP_UTF8, 0, source, -1, NULL, 0, NULL, NULL);
		if (!size) {
			return NULL;
		}

		target = (char*) RGFW_CALLOC(size, 1);

		if (!WideCharToMultiByte(CP_UTF8, 0, source, -1, target, size, NULL, NULL)) {
			RGFW_FREE(target);
			return NULL;
		}

		return target;
	}
	
    static inline LARGE_INTEGER RGFW_win32_initTimer(void) {
		static LARGE_INTEGER frequency = {{0, 0}};
		if (frequency.QuadPart == 0) {
			timeBeginPeriod(1);
			QueryPerformanceFrequency(&frequency);
		}

		return frequency;
	}

	u64 RGFW_getTimeNS(void) {
		LARGE_INTEGER frequency = RGFW_win32_initTimer();

		LARGE_INTEGER counter;
		QueryPerformanceCounter(&counter);

		return (u64) ((counter.QuadPart * 1e9) / frequency.QuadPart);
	}

	u64 RGFW_getTime(void) {
		LARGE_INTEGER frequency = RGFW_win32_initTimer();

		LARGE_INTEGER counter;
		QueryPerformanceCounter(&counter);
		return (u64) (counter.QuadPart / (double) frequency.QuadPart);
	}
	
	void RGFW_sleep(u64 ms) {
		Sleep(ms);
	}

#ifndef RGFW_NO_THREADS
	RGFW_thread RGFW_createThread(RGFW_threadFunc_ptr ptr, void* args) { return CreateThread(NULL, 0, ptr, args, 0, NULL); }
	void RGFW_cancelThread(RGFW_thread thread) { CloseHandle((HANDLE) thread); }
	void RGFW_joinThread(RGFW_thread thread) { WaitForSingleObject((HANDLE) thread, INFINITE); }
	void RGFW_setThreadPriority(RGFW_thread thread, u8 priority) { SetThreadPriority((HANDLE) thread, priority); }
#endif
#endif /* RGFW_WINDOWS */

/*
	End of Windows defines
*/



/* 

	Start of MacOS defines


*/

#if defined(RGFW_MACOS)
	/*
		based on silicon.h
		start of cocoa wrapper
	*/

#include <CoreVideo/CVDisplayLink.h>
#include <ApplicationServices/ApplicationServices.h>
#include <objc/runtime.h>
#include <objc/message.h>
#include <mach/mach_time.h>

	typedef CGRect NSRect;
	typedef CGPoint NSPoint;
	typedef CGSize NSSize;

	typedef void NSBitmapImageRep;
	typedef void NSCursor;
	typedef void NSDraggingInfo;
	typedef void NSWindow;
	typedef void NSApplication;
	typedef void NSScreen;
	typedef void NSEvent;
	typedef void NSString;
	typedef void NSOpenGLContext;
	typedef void NSPasteboard;
	typedef void NSColor;
	typedef void NSArray;
	typedef void NSImageRep;
	typedef void NSImage;
	typedef void NSOpenGLView;


	typedef const char* NSPasteboardType;
	typedef unsigned long NSUInteger;
	typedef long NSInteger;
	typedef NSInteger NSModalResponse;

#ifdef __arm64__
	/* ARM just uses objc_msgSend */
#define abi_objc_msgSend_stret objc_msgSend
#define abi_objc_msgSend_fpret objc_msgSend
#else /* __i386__ */ 
	/* x86 just uses abi_objc_msgSend_fpret and (NSColor *)objc_msgSend_id respectively */
#define abi_objc_msgSend_stret objc_msgSend_stret
#define abi_objc_msgSend_fpret objc_msgSend_fpret
#endif

#define NSAlloc(nsclass) objc_msgSend_id((id)nsclass, sel_registerName("alloc"))
#define objc_msgSend_bool			((BOOL (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void			((void (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void_id		((void (*)(id, SEL, id))objc_msgSend)
#define objc_msgSend_uint			((NSUInteger (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void_bool		((void (*)(id, SEL, BOOL))objc_msgSend)
#define objc_msgSend_bool_void		((BOOL (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void_SEL		((void (*)(id, SEL, SEL))objc_msgSend)
#define objc_msgSend_id				((id (*)(id, SEL))objc_msgSend)
#define objc_msgSend_id_id				((id (*)(id, SEL, id))objc_msgSend)
#define objc_msgSend_id_bool			((BOOL (*)(id, SEL, id))objc_msgSend)
#define objc_msgSend_int ((id (*)(id, SEL, int))objc_msgSend)
#define objc_msgSend_arr ((id (*)(id, SEL, int))objc_msgSend)
#define objc_msgSend_ptr ((id (*)(id, SEL, void*))objc_msgSend)
#define objc_msgSend_class ((id (*)(Class, SEL))objc_msgSend)
#define objc_msgSend_class_char ((id (*)(Class, SEL, char*))objc_msgSend)

	NSApplication* NSApp = NULL;

	void NSRelease(id obj) {
		objc_msgSend_void(obj, sel_registerName("release"));
	}

	#define release NSRelease

	NSString* NSString_stringWithUTF8String(const char* str) {	
		return ((id(*)(id, SEL, const char*))objc_msgSend)
			((id)objc_getClass("NSString"), sel_registerName("stringWithUTF8String:"), str);
	}

	const char* NSString_to_char(NSString* str) {
		return ((const char* (*)(id, SEL)) objc_msgSend) (str, sel_registerName("UTF8String"));
	}

	void si_impl_func_to_SEL_with_name(const char* class_name, const char* register_name, void* function) {
		Class selected_class;

		if (strcmp(class_name, "NSView") == 0) {
			selected_class = objc_getClass("ViewClass");
		} else if (strcmp(class_name, "NSWindow") == 0) {
			selected_class = objc_getClass("WindowClass");
		} else {
			selected_class = objc_getClass(class_name);
		}

		class_addMethod(selected_class, sel_registerName(register_name), (IMP) function, 0);
	}

	/* Header for the array. */
	typedef struct siArrayHeader {
		size_t count;
		/* TODO(EimaMei): Add a `type_width` later on. */
	} siArrayHeader;

	/* Gets the header of the siArray. */
#define SI_ARRAY_HEADER(s) ((siArrayHeader*)s - 1)

	void* si_array_init_reserve(size_t sizeof_element, size_t count) {
		siArrayHeader* ptr = malloc(sizeof(siArrayHeader) + (sizeof_element * count));
		void* array = ptr + sizeof(siArrayHeader);

		siArrayHeader* header = SI_ARRAY_HEADER(array);
		header->count = count;

		return array;
	}

#define si_array_len(array) (SI_ARRAY_HEADER(array)->count)
#define si_func_to_SEL(class_name, function) si_impl_func_to_SEL_with_name(class_name, #function":", function)
	/* Creates an Objective-C method (SEL) from a regular C function with the option to set the register name.*/
#define si_func_to_SEL_with_name(class_name, register_name, function) si_impl_func_to_SEL_with_name(class_name, register_name":", function)
	
	unsigned char* NSBitmapImageRep_bitmapData(NSBitmapImageRep* imageRep) {
		return ((unsigned char* (*)(id, SEL))objc_msgSend)
			(imageRep, sel_registerName("bitmapData"));
	}

#define NS_ENUM(type, name) type name; enum

	typedef NS_ENUM(NSUInteger, NSBitmapFormat) {
		NSBitmapFormatAlphaFirst = 1 << 0,       // 0 means is alpha last (RGBA, CMYKA, etc.)
			NSBitmapFormatAlphaNonpremultiplied = 1 << 1,       // 0 means is premultiplied
			NSBitmapFormatFloatingPointSamples = 1 << 2,  // 0 is integer

			NSBitmapFormatSixteenBitLittleEndian API_AVAILABLE(macos(10.10)) = (1 << 8),
			NSBitmapFormatThirtyTwoBitLittleEndian API_AVAILABLE(macos(10.10)) = (1 << 9),
			NSBitmapFormatSixteenBitBigEndian API_AVAILABLE(macos(10.10)) = (1 << 10),
			NSBitmapFormatThirtyTwoBitBigEndian API_AVAILABLE(macos(10.10)) = (1 << 11)
	};

	NSBitmapImageRep* NSBitmapImageRep_initWithBitmapData(unsigned char** planes, NSInteger width, NSInteger height, NSInteger bps, NSInteger spp, bool alpha, bool isPlanar, const char* colorSpaceName, NSBitmapFormat bitmapFormat, NSInteger rowBytes, NSInteger pixelBits) {
		void* func = sel_registerName("initWithBitmapDataPlanes:pixelsWide:pixelsHigh:bitsPerSample:samplesPerPixel:hasAlpha:isPlanar:colorSpaceName:bitmapFormat:bytesPerRow:bitsPerPixel:");

		return (NSBitmapImageRep*) ((id(*)(id, SEL, unsigned char**, NSInteger, NSInteger, NSInteger, NSInteger, bool, bool, const char*, NSBitmapFormat, NSInteger, NSInteger))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSBitmapImageRep")), func, planes, width, height, bps, spp, alpha, isPlanar, NSString_stringWithUTF8String(colorSpaceName), bitmapFormat, rowBytes, pixelBits);
	}

	NSColor* NSColor_colorWithSRGB(CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha) {
		void* nsclass = objc_getClass("NSColor");
		void* func = sel_registerName("colorWithSRGBRed:green:blue:alpha:");
		return ((id(*)(id, SEL, CGFloat, CGFloat, CGFloat, CGFloat))objc_msgSend)
			(nsclass, func, red, green, blue, alpha);
	}

	NSCursor* NSCursor_initWithImage(NSImage* newImage, NSPoint aPoint) {
		void* func = sel_registerName("initWithImage:hotSpot:");
		void* nsclass = objc_getClass("NSCursor");

		return (NSCursor*) ((id(*)(id, SEL, id, NSPoint))objc_msgSend)
			(NSAlloc(nsclass), func, newImage, aPoint);
	}

	void NSImage_addRepresentation(NSImage* image, NSImageRep* imageRep) {
		void* func = sel_registerName("addRepresentation:");
		objc_msgSend_void_id(image, func, imageRep);
	}

	NSImage* NSImage_initWithSize(NSSize size) {
		void* func = sel_registerName("initWithSize:");
		return ((id(*)(id, SEL, NSSize))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSImage")), func, size);
	}
#define NS_OPENGL_ENUM_DEPRECATED(minVers, maxVers) API_AVAILABLE(macos(minVers))
	typedef NS_ENUM(NSInteger, NSOpenGLContextParameter) {
		NSOpenGLContextParameterSwapInterval           NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 222, /* 1 param.  0 -> Don't sync, 1 -> Sync to vertical retrace     */
			NSOpenGLContextParametectxaceOrder           NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 235, /* 1 param.  1 -> Above Window (default), -1 -> Below Window    */
			NSOpenGLContextParametectxaceOpacity         NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 236, /* 1 param.  1-> Surface is opaque (default), 0 -> non-opaque   */
			NSOpenGLContextParametectxaceBackingSize     NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 304, /* 2 params.  Width/height of surface backing size              */
			NSOpenGLContextParameterReclaimResources       NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 308, /* 0 params.                                                    */
			NSOpenGLContextParameterCurrentRendererID      NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 309, /* 1 param.   Retrieves the current renderer ID                 */
			NSOpenGLContextParameterGPUVertexProcessing    NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 310, /* 1 param.   Currently processing vertices with GPU (get)      */
			NSOpenGLContextParameterGPUFragmentProcessing  NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 311, /* 1 param.   Currently processing fragments with GPU (get)     */
			NSOpenGLContextParameterHasDrawable            NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 314, /* 1 param.   Boolean returned if drawable is attached          */
			NSOpenGLContextParameterMPSwapsInFlight        NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 315, /* 1 param.   Max number of swaps queued by the MP GL engine    */

			NSOpenGLContextParameterSwapRectangle API_DEPRECATED("", macos(10.0, 10.14)) = 200, /* 4 params.  Set or get the swap rectangle {x, y, w, h} */
			NSOpenGLContextParameterSwapRectangleEnable API_DEPRECATED("", macos(10.0, 10.14)) = 201, /* Enable or disable the swap rectangle */
			NSOpenGLContextParameterRasterizationEnable API_DEPRECATED("", macos(10.0, 10.14)) = 221, /* Enable or disable all rasterization */
			NSOpenGLContextParameterStateValidation API_DEPRECATED("", macos(10.0, 10.14)) = 301, /* Validate state for multi-screen functionality */
			NSOpenGLContextParametectxaceSurfaceVolatile API_DEPRECATED("", macos(10.0, 10.14)) = 306, /* 1 param.   Surface volatile state */
	};


	void NSOpenGLContext_setValues(NSOpenGLContext* context, const int* vals, NSOpenGLContextParameter param) {
		void* func = sel_registerName("setValues:forParameter:");
		((void (*)(id, SEL, const int*, NSOpenGLContextParameter))objc_msgSend)
			(context, func, vals, param);
	}

	void* NSOpenGLPixelFormat_initWithAttributes(const uint32_t* attribs) {
		void* func = sel_registerName("initWithAttributes:");
		return (void*) ((id(*)(id, SEL, const uint32_t*))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSOpenGLPixelFormat")), func, attribs);
	}

	NSOpenGLView* NSOpenGLView_initWithFrame(NSRect frameRect, uint32_t* format) {
		void* func = sel_registerName("initWithFrame:pixelFormat:");
		return (NSOpenGLView*) ((id(*)(id, SEL, NSRect, uint32_t*))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSOpenGLView")), func, frameRect, format);
	}

	void NSCursor_performSelector(NSCursor* cursor, void* selector) {
		void* func = sel_registerName("performSelector:");
		objc_msgSend_void_SEL(cursor, func, selector);
	}

	NSPasteboard* NSPasteboard_generalPasteboard(void) {
		return (NSPasteboard*) objc_msgSend_id((id)objc_getClass("NSPasteboard"), sel_registerName("generalPasteboard"));
	}

	NSString** cstrToNSStringArray(char** strs, size_t len) {
		static NSString* nstrs[6];
		size_t i;
		for (i = 0; i < len; i++)
			nstrs[i] = NSString_stringWithUTF8String(strs[i]);

		return nstrs;
	}

	const char* NSPasteboard_stringForType(NSPasteboard* pasteboard, NSPasteboardType dataType) {
		void* func = sel_registerName("stringForType:");
		return (const char*) NSString_to_char(((id(*)(id, SEL, const char*))objc_msgSend)(pasteboard, func, NSString_stringWithUTF8String(dataType)));
	}

	NSArray* c_array_to_NSArray(void* array, size_t len) {
		SEL func = sel_registerName("initWithObjects:count:");
		void* nsclass = objc_getClass("NSArray");
		return ((id (*)(id, SEL, void*, NSUInteger))objc_msgSend)
					(NSAlloc(nsclass), func, array, len);
	}
 
	void NSregisterForDraggedTypes(void* view, NSPasteboardType* newTypes, size_t len) {
		NSString** ntypes = cstrToNSStringArray((char**)newTypes, len);

		NSArray* array = c_array_to_NSArray(ntypes, len);
		objc_msgSend_void_id(view, sel_registerName("registerForDraggedTypes:"), array);
		NSRelease(array);
	}

	NSInteger NSPasteBoard_declareTypes(NSPasteboard* pasteboard, NSPasteboardType* newTypes, size_t len, void* owner) {
		NSString** ntypes = cstrToNSStringArray((char**)newTypes, len);

		void* func = sel_registerName("declareTypes:owner:");

		NSArray* array = c_array_to_NSArray(ntypes, len);

		NSInteger output = ((NSInteger(*)(id, SEL, id, void*))objc_msgSend)
			(pasteboard, func, array, owner);
		NSRelease(array);

		return output;
	}

	bool NSPasteBoard_setString(NSPasteboard* pasteboard, const char* stringToWrite, NSPasteboardType dataType) {
		void* func = sel_registerName("setString:forType:");
		return ((bool (*)(id, SEL, id, NSPasteboardType))objc_msgSend)
			(pasteboard, func, NSString_stringWithUTF8String(stringToWrite), NSString_stringWithUTF8String(dataType));
	}

	void NSRetain(id obj) { objc_msgSend_void(obj, sel_registerName("retain")); }

	typedef enum NSApplicationActivationPolicy {
		NSApplicationActivationPolicyRegular,
		NSApplicationActivationPolicyAccessory,
		NSApplicationActivationPolicyProhibited
	} NSApplicationActivationPolicy;

	typedef NS_ENUM(u32, NSBackingStoreType) {
		NSBackingStoreRetained = 0,
			NSBackingStoreNonretained = 1,
			NSBackingStoreBuffered = 2
	};

	typedef NS_ENUM(u32, NSWindowStyleMask) {
		NSWindowStyleMaskBorderless = 0,
			NSWindowStyleMaskTitled = 1 << 0,
			NSWindowStyleMaskClosable = 1 << 1,
			NSWindowStyleMaskMiniaturizable = 1 << 2,
			NSWindowStyleMaskResizable = 1 << 3,
			NSWindowStyleMaskTexturedBackground = 1 << 8, /* deprecated */
			NSWindowStyleMaskUnifiedTitleAndToolbar = 1 << 12,
			NSWindowStyleMaskFullScreen = 1 << 14,
			NSWindowStyleMaskFullSizeContentView = 1 << 15,
			NSWindowStyleMaskUtilityWindow = 1 << 4,
			NSWindowStyleMaskDocModalWindow = 1 << 6,
			NSWindowStyleMaskNonactivatingPanel = 1 << 7,
			NSWindowStyleMaskHUDWindow = 1 << 13
	};

	NSPasteboardType const NSPasteboardTypeString = "public.utf8-plain-text"; // Replaces NSStringPboardType


	typedef NS_ENUM(i32, NSDragOperation) {
		NSDragOperationNone = 0,
			NSDragOperationCopy = 1,
			NSDragOperationLink = 2,
			NSDragOperationGeneric = 4,
			NSDragOperationPrivate = 8,
			NSDragOperationMove = 16,
			NSDragOperationDelete = 32,
			NSDragOperationEvery = ULONG_MAX,

			//NSDragOperationAll_Obsolete	API_DEPRECATED("", macos(10.0,10.10)) = 15, // Use NSDragOperationEvery
			//NSDragOperationAll API_DEPRECATED("", macos(10.0,10.10)) = NSDragOperationAll_Obsolete, // Use NSDragOperationEvery
	};

	void* NSArray_objectAtIndex(NSArray* array, NSUInteger index) {
		void* func = sel_registerName("objectAtIndex:");
		return ((id(*)(id, SEL, NSUInteger))objc_msgSend)(array, func, index);
	}

	const char** NSPasteboard_readObjectsForClasses(NSPasteboard* pasteboard, Class* classArray, size_t len, void* options) {
		void* func = sel_registerName("readObjectsForClasses:options:");

		NSArray* array = c_array_to_NSArray(classArray, len);

		NSArray* output = (NSArray*) ((id(*)(id, SEL, id, void*))objc_msgSend)
			(pasteboard, func, array, options);

		NSRelease(array);
		NSUInteger count = ((NSUInteger(*)(id, SEL))objc_msgSend)(output, sel_registerName("count"));

		const char** res = si_array_init_reserve(sizeof(const char*), count);

		void* path_func = sel_registerName("path");

		for (NSUInteger i = 0; i < count; i++) {
			void* url = NSArray_objectAtIndex(output, i);
			NSString* url_str = ((id(*)(id, SEL))objc_msgSend)(url, path_func);
			res[i] = NSString_to_char(url_str);
		}

		return res;
	}

	void* NSWindow_contentView(NSWindow* window) {
		void* func = sel_registerName("contentView");
		return objc_msgSend_id(window, func);
	}

	/*
		End of cocoa wrapper
	*/

	char* RGFW_mouseIconSrc[] = {"arrowCursor", "arrowCursor", "IBeamCursor", "crosshairCursor", "pointingHandCursor", "resizeLeftRightCursor", "resizeUpDownCursor", "_windowResizeNorthWestSouthEastCursor", "_windowResizeNorthEastSouthWestCursor", "closedHandCursor", "operationNotAllowedCursor"};

	void* RGFWnsglFramework = NULL;

#ifdef RGFW_OPENGL
	void* RGFW_getProcAddress(const char* procname) {
		if (RGFWnsglFramework == NULL)
			RGFWnsglFramework = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.opengl"));

		CFStringRef symbolName = CFStringCreateWithCString(kCFAllocatorDefault, procname, kCFStringEncodingASCII);

		void* symbol = CFBundleGetFunctionPointerForName(RGFWnsglFramework, symbolName);

		CFRelease(symbolName);

		return symbol;
	}
#endif

	CVReturn displayCallback(CVDisplayLinkRef displayLink, const CVTimeStamp* inNow, const CVTimeStamp* inOutputTime, CVOptionFlags flagsIn, CVOptionFlags* flagsOut, void* displayLinkContext) { 
		RGFW_UNUSED(displayLink) RGFW_UNUSED(inNow) RGFW_UNUSED(inOutputTime) RGFW_UNUSED(flagsIn) RGFW_UNUSED(flagsOut) RGFW_UNUSED(displayLinkContext)
		return kCVReturnSuccess; 
	}

	id NSWindow_delegate(RGFW_window* win) {
		return (id) objc_msgSend_id(win->src.window, sel_registerName("delegate"));
	}

	u32 RGFW_OnClose(void* self) {
		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return true;

		win->event.type = RGFW_quit;
		RGFW_windowQuitCallback(win);

		return true;
	}

	/* NOTE(EimaMei): Fixes the constant clicking when the app is running under a terminal. */
	bool acceptsFirstResponder(void) { return true; }
	bool performKeyEquivalent(NSEvent* event) { RGFW_UNUSED(event); return true; }

	NSDragOperation draggingEntered(id self, SEL sel, id sender) { 
		RGFW_UNUSED(sender); RGFW_UNUSED(self); RGFW_UNUSED(sel);  

		return NSDragOperationCopy; 
	}
	NSDragOperation draggingUpdated(id self, SEL sel, id sender) { 
		RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return 0;
		
		if (!(win->_winArgs & RGFW_ALLOW_DND)) {
			return 0;
		}

		win->event.type = RGFW_dnd_init;
		win->src.dndPassed = 0;

		NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(sender, sel_registerName("draggingLocation"));

		win->event.point = RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));
		RGFW_dndInitCallback(win, win->event.point);

		return NSDragOperationCopy; 
	}
	bool prepareForDragOperation(id self) {
		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return true;
		
		if (!(win->_winArgs & RGFW_ALLOW_DND)) {
			return false;
		}

		return true;
	}

	void RGFW__osxDraggingEnded(id self, SEL sel, id sender) { RGFW_UNUSED(sender); RGFW_UNUSED(self); RGFW_UNUSED(sel);  return; }

	/* NOTE(EimaMei): Usually, you never need 'id self, SEL cmd' for C -> Obj-C methods. This isn't the case. */
	bool performDragOperation(id self, SEL sel, id sender) {
		RGFW_UNUSED(sender); RGFW_UNUSED(self); RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);

        if (win == NULL)
			return false;

		// NSPasteboard* pasteBoard = objc_msgSend_id(sender, sel_registerName("draggingPasteboard"));

        /////////////////////////////
        id pasteBoard = objc_msgSend_id(sender, sel_registerName("draggingPasteboard"));

        // Get the types of data available on the pasteboard
        id types = objc_msgSend_id(pasteBoard, sel_registerName("types"));

        // Get the string type for file URLs
        id fileURLsType = objc_msgSend_class_char(objc_getClass("NSString"), sel_registerName("stringWithUTF8String:"), "NSFilenamesPboardType");

        // Check if the pasteboard contains file URLs
        if (objc_msgSend_id_bool(types, sel_registerName("containsObject:"), fileURLsType) == 0) {
		    #ifdef RGFW_DEBUG
            printf("No files found on the pasteboard.\n");
			#endif

			return 0;
		}

		id fileURLs = objc_msgSend_id_id(pasteBoard, sel_registerName("propertyListForType:"), fileURLsType);
		int count = ((int (*)(id, SEL))objc_msgSend)(fileURLs, sel_registerName("count"));

		if (count == 0)
			return 0;

		for (int i = 0; i < count; i++) {
			id fileURL = objc_msgSend_arr(fileURLs, sel_registerName("objectAtIndex:"), i);
			const char *filePath = ((const char* (*)(id, SEL))objc_msgSend)(fileURL, sel_registerName("UTF8String"));
			// printf("File: %s\n", filePath);
			strncpy(win->event.droppedFiles[i], filePath, RGFW_MAX_PATH);
			win->event.droppedFiles[i][RGFW_MAX_PATH - 1] = '\0';
		}
		win->event.droppedFilesCount = count;

		win->event.type = RGFW_dnd;
		win->src.dndPassed = 0;
		
		NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(sender, sel_registerName("draggingLocation"));
		win->event.point = RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));
		
		RGFW_dndCallback(win, win->event.droppedFiles, win->event.droppedFilesCount);
	
    	return false;
	}

	static void NSMoveToResourceDir(void) {
		/* sourced from glfw */
		char resourcesPath[255];

		CFBundleRef bundle = CFBundleGetMainBundle();
		if (!bundle)
			return;

		CFURLRef resourcesURL = CFBundleCopyResourcesDirectoryURL(bundle);
		CFStringRef last = CFURLCopyLastPathComponent(resourcesURL);

		if (
			CFStringCompare(CFSTR("Resources"), last, 0) != kCFCompareEqualTo ||
			CFURLGetFileSystemRepresentation(resourcesURL, true, (u8*) resourcesPath, 255) == 0
			) {
			CFRelease(last);
			CFRelease(resourcesURL);
			return;
		}

		CFRelease(last);
		CFRelease(resourcesURL);

		chdir(resourcesPath);
	}


	NSSize RGFW__osxWindowResize(void* self, SEL sel, NSSize frameSize) {
		RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return frameSize;
		
		win->r.w = frameSize.width;
		win->r.h = frameSize.height;
		win->event.type = RGFW_windowResized;
		RGFW_windowResizeCallback(win, win->r);
		return frameSize;
	}

	void RGFW__osxWindowMove(void* self, SEL sel) {
		RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return;
		
		NSRect frame = ((NSRect(*)(id, SEL))abi_objc_msgSend_stret)(win->src.window, sel_registerName("frame"));
		win->r.x = (i32) frame.origin.x;
		win->r.y = (i32) frame.origin.y;

		win->event.type = RGFW_windowMoved;
		RGFW_windowMoveCallback(win, win->r);
	}

	void RGFW__osxUpdateLayer(void* self, SEL sel) {
		RGFW_UNUSED(sel);

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return;
		
		win->event.type = RGFW_windowRefresh;
		RGFW_windowRefreshCallback(win);
	}

	RGFWDEF void RGFW_init_buffer(RGFW_window* win);
	void RGFW_init_buffer(RGFW_window* win) {
		#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
				RGFW_bufferSize = RGFW_getScreenSize();
				
			win->buffer = RGFW_MALLOC(RGFW_bufferSize.w * RGFW_bufferSize.h * 4);

		#ifdef RGFW_OSMESA
				win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
				OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
		#endif
		#else
		RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
		#endif
	}

	NSPasteboardType const NSPasteboardTypeURL = "public.url";
	NSPasteboardType const NSPasteboardTypeFileURL  = "public.file-url";

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
		static u8 RGFW_loaded = 0;

		/* NOTE(EimaMei): Why does Apple hate good code? Like wtf, who thought of methods being a great idea???
		Imagine a universe, where MacOS had a proper system API (we would probably have like 20% better performance).
		*/
		si_func_to_SEL_with_name("NSObject", "windowShouldClose", RGFW_OnClose);

		/* NOTE(EimaMei): Fixes the 'Boop' sfx from constantly playing each time you click a key. Only a problem when running in the terminal. */
		si_func_to_SEL("NSWindow", acceptsFirstResponder);
		si_func_to_SEL("NSWindow", performKeyEquivalent);

		// RR Create an autorelease pool
		id pool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
		pool = objc_msgSend_id(pool, sel_registerName("init"));

		if (NSApp == NULL) {
			NSApp = objc_msgSend_id((id)objc_getClass("NSApplication"), sel_registerName("sharedApplication"));

			((void (*)(id, SEL, NSUInteger))objc_msgSend)
				(NSApp, sel_registerName("setActivationPolicy:"), NSApplicationActivationPolicyRegular);
		}

		RGFW_window* win = RGFW_window_basic_init(rect, args);
		
		RGFW_window_setMouseDefault(win);

		NSRect windowRect;
		windowRect.origin.x = win->r.x;
		windowRect.origin.y = win->r.y;
		windowRect.size.width = win->r.w;
		windowRect.size.height = win->r.h;

		NSBackingStoreType macArgs = NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable | NSBackingStoreBuffered | NSWindowStyleMaskTitled;

		if (!(args & RGFW_NO_RESIZE))
			macArgs |= NSWindowStyleMaskResizable;
		if (!(args & RGFW_NO_BORDER))
			macArgs |= NSWindowStyleMaskTitled;
		else
			macArgs = NSWindowStyleMaskBorderless;
		{
			void* nsclass = objc_getClass("NSWindow");
			void* func = sel_registerName("initWithContentRect:styleMask:backing:defer:");

			win->src.window = ((id(*)(id, SEL, NSRect, NSWindowStyleMask, NSBackingStoreType, bool))objc_msgSend)
				(NSAlloc(nsclass), func, windowRect, macArgs, macArgs, false);
		}

		NSString* str = NSString_stringWithUTF8String(name);
		objc_msgSend_void_id(win->src.window, sel_registerName("setTitle:"), str);

#ifdef RGFW_OPENGL
	if ((args & RGFW_NO_INIT_API) == 0) {
		void* attrs = RGFW_initFormatAttribs(args & RGFW_OPENGL_SOFTWARE);
		void* format = NSOpenGLPixelFormat_initWithAttributes(attrs);

		if (format == NULL) {
			printf("Failed to load pixel format for OpenGL\n");

			void* attrs = RGFW_initFormatAttribs(1);
			format = NSOpenGLPixelFormat_initWithAttributes(attrs);
			if (format == NULL)
				printf("and loading software rendering OpenGL failed\n");
			else
				printf("Switching to software rendering\n");
		}
		
		/* the pixel format can be passed directly to opengl context creation to create a context 
			this is because the format also includes information about the opengl version (which may be a bad thing) */
		win->src.view = NSOpenGLView_initWithFrame((NSRect){{0, 0}, {win->r.w, win->r.h}}, format);
		objc_msgSend_void(win->src.view, sel_registerName("prepareOpenGL"));
		win->src.ctx = objc_msgSend_id(win->src.view, sel_registerName("openGLContext"));
	} else
#endif
	{
		NSRect contentRect = (NSRect){{0, 0}, {win->r.w, win->r.h}};
		win->src.view = ((id(*)(id, SEL, NSRect))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSView")), sel_registerName("initWithFrame:"),
				contentRect);
	}

		void* contentView = NSWindow_contentView(win->src.window);
		objc_msgSend_void_bool(contentView, sel_registerName("setWantsLayer:"), true);

		objc_msgSend_void_id(win->src.window, sel_registerName("setContentView:"), win->src.view);

#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0)
			objc_msgSend_void(win->src.ctx, sel_registerName("makeCurrentContext"));
#endif
		if (args & RGFW_TRANSPARENT_WINDOW) {
#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0) {
			i32 opacity = 0;
			#define NSOpenGLCPSurfaceOpacity 236
			NSOpenGLContext_setValues(win->src.ctx, &opacity, NSOpenGLCPSurfaceOpacity);
		}
#endif

			objc_msgSend_void_bool(win->src.window, sel_registerName("setOpaque:"), false);

			objc_msgSend_void_id(win->src.window, sel_registerName("setBackgroundColor:"),
				NSColor_colorWithSRGB(0, 0, 0, 0));
		}

		win->src.display = CGMainDisplayID();
		CVDisplayLinkCreateWithCGDisplay(win->src.display, (CVDisplayLinkRef*)&win->src.displayLink);
		CVDisplayLinkSetOutputCallback(win->src.displayLink, displayCallback, win);
		CVDisplayLinkStart(win->src.displayLink);

		RGFW_init_buffer(win);

		#ifndef RGFW_NO_MONITOR
		if (args & RGFW_SCALE_TO_MONITOR)
			RGFW_window_scaleToMonitor(win);
		#endif

		if (args & RGFW_HIDE_MOUSE)
			RGFW_window_showMouse(win, 0);

		if (args & RGFW_COCOA_MOVE_TO_RESOURCE_DIR)
			NSMoveToResourceDir();

		Class delegateClass = objc_allocateClassPair(objc_getClass("NSObject"), "WindowDelegate", 0);

		class_addIvar(
			delegateClass, "RGFW_window",
			sizeof(RGFW_window*), rint(log2(sizeof(RGFW_window*))),
			"L"
		);

		class_addMethod(delegateClass, sel_registerName("windowWillResize:toSize:"), (IMP) RGFW__osxWindowResize, "{NSSize=ff}@:{NSSize=ff}");
		class_addMethod(delegateClass, sel_registerName("updateLayer:"), (IMP) RGFW__osxUpdateLayer, "");
		class_addMethod(delegateClass, sel_registerName("windowWillMove:"), (IMP) RGFW__osxWindowMove, "");
		class_addMethod(delegateClass, sel_registerName("windowDidMove:"), (IMP) RGFW__osxWindowMove, "");
		class_addMethod(delegateClass, sel_registerName("draggingEntered:"), (IMP)draggingEntered, "l@:@");
		class_addMethod(delegateClass, sel_registerName("draggingUpdated:"), (IMP)draggingUpdated, "l@:@");
		class_addMethod(delegateClass, sel_registerName("draggingExited:"), (IMP)RGFW__osxDraggingEnded, "v@:@");
		class_addMethod(delegateClass, sel_registerName("draggingEnded:"), (IMP)RGFW__osxDraggingEnded, "v@:@");
		class_addMethod(delegateClass, sel_registerName("prepareForDragOperation:"), (IMP)prepareForDragOperation, "B@:@");
		class_addMethod(delegateClass, sel_registerName("performDragOperation:"), (IMP)performDragOperation, "B@:@");

		id delegate = objc_msgSend_id(NSAlloc(delegateClass), sel_registerName("init"));

		object_setInstanceVariable(delegate, "RGFW_window", win);

		objc_msgSend_void_id(win->src.window, sel_registerName("setDelegate:"), delegate);

		if (args & RGFW_ALLOW_DND) {
			win->_winArgs |= RGFW_ALLOW_DND;

			NSPasteboardType types[] = {NSPasteboardTypeURL, NSPasteboardTypeFileURL, NSPasteboardTypeString};
			NSregisterForDraggedTypes(win->src.window, types, 3);
		}

		// Show the window
		objc_msgSend_void_bool(NSApp, sel_registerName("activateIgnoringOtherApps:"), true);
		((id(*)(id, SEL, SEL))objc_msgSend)(win->src.window, sel_registerName("makeKeyAndOrderFront:"), NULL);
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIsVisible:"), true);

		if (!RGFW_loaded) {
			objc_msgSend_void(win->src.window, sel_registerName("makeMainWindow"));

			RGFW_loaded = 1;
		}

		objc_msgSend_void(win->src.window, sel_registerName("makeKeyWindow"));

		objc_msgSend_void(NSApp, sel_registerName("finishLaunching"));

		if (RGFW_root == NULL)
			RGFW_root = win;

		NSRetain(win->src.window);
		NSRetain(NSApp);

		return win;
	}

	void RGFW_window_setBorder(RGFW_window* win, u8 border) {
		NSBackingStoreType storeType = NSWindowStyleMaskBorderless;
		if (!border) {
			storeType = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable;
		}
		if (!(win->_winArgs & RGFW_NO_RESIZE)) {
			storeType |= NSWindowStyleMaskResizable;
		}
		
		((void (*)(id, SEL, NSBackingStoreType))objc_msgSend)(win->src.window, sel_registerName("setStyleMask:"), storeType);

		objc_msgSend_void_bool(win->src.window, sel_registerName("setHasShadow:"), border);
	}

	RGFW_area RGFW_getScreenSize(void) {
		static CGDirectDisplayID display = 0;

		if (display == 0)
			display = CGMainDisplayID();

		return RGFW_AREA(CGDisplayPixelsWide(display), CGDisplayPixelsHigh(display));
	}

	RGFW_point RGFW_getGlobalMousePoint(void) {
		assert(RGFW_root != NULL);

		CGEventRef e = CGEventCreate(NULL);
		CGPoint point = CGEventGetLocation(e);
		CFRelease(e);

		return RGFW_POINT((u32) point.x, (u32) point.y); /*!< the point is loaded during event checks */
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		NSPoint p =  ((NSPoint(*)(id, SEL)) objc_msgSend)(win->src.window, sel_registerName("mouseLocationOutsideOfEventStream"));

		return RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));
	}

	u32 RGFW_keysPressed[10]; /*10 keys at a time*/
	typedef NS_ENUM(u32, NSEventType) {        /* various types of events */
		NSEventTypeLeftMouseDown = 1,
			NSEventTypeLeftMouseUp = 2,
			NSEventTypeRightMouseDown = 3,
			NSEventTypeRightMouseUp = 4,
			NSEventTypeMouseMoved = 5,
			NSEventTypeLeftMouseDragged = 6,
			NSEventTypeRightMouseDragged = 7,
			NSEventTypeMouseEntered = 8,
			NSEventTypeMouseExited = 9,
			NSEventTypeKeyDown = 10,
			NSEventTypeKeyUp = 11,
			NSEventTypeFlagsChanged = 12,
			NSEventTypeAppKitDefined = 13,
			NSEventTypeSystemDefined = 14,
			NSEventTypeApplicationDefined = 15,
			NSEventTypePeriodic = 16,
			NSEventTypeCursorUpdate = 17,
			NSEventTypeScrollWheel = 22,
			NSEventTypeTabletPoint = 23,
			NSEventTypeTabletProximity = 24,
			NSEventTypeOtherMouseDown = 25,
			NSEventTypeOtherMouseUp = 26,
			NSEventTypeOtherMouseDragged = 27,
			/* The following event types are available on some hardware on 10.5.2 and later */
			NSEventTypeGesture API_AVAILABLE(macos(10.5)) = 29,
			NSEventTypeMagnify API_AVAILABLE(macos(10.5)) = 30,
			NSEventTypeSwipe   API_AVAILABLE(macos(10.5)) = 31,
			NSEventTypeRotate  API_AVAILABLE(macos(10.5)) = 18,
			NSEventTypeBeginGesture API_AVAILABLE(macos(10.5)) = 19,
			NSEventTypeEndGesture API_AVAILABLE(macos(10.5)) = 20,

			NSEventTypeSmartMagnify API_AVAILABLE(macos(10.8)) = 32,
			NSEventTypeQuickLook API_AVAILABLE(macos(10.8)) = 33,

			NSEventTypePressure API_AVAILABLE(macos(10.10.3)) = 34,
			NSEventTypeDirectTouch API_AVAILABLE(macos(10.10)) = 37,

			NSEventTypeChangeMode API_AVAILABLE(macos(10.15)) = 38,
	};

	typedef NS_ENUM(unsigned long long, NSEventMask) { /* masks for the types of events */
		NSEventMaskLeftMouseDown = 1ULL << NSEventTypeLeftMouseDown,
			NSEventMaskLeftMouseUp = 1ULL << NSEventTypeLeftMouseUp,
			NSEventMaskRightMouseDown = 1ULL << NSEventTypeRightMouseDown,
			NSEventMaskRightMouseUp = 1ULL << NSEventTypeRightMouseUp,
			NSEventMaskMouseMoved = 1ULL << NSEventTypeMouseMoved,
			NSEventMaskLeftMouseDragged = 1ULL << NSEventTypeLeftMouseDragged,
			NSEventMaskRightMouseDragged = 1ULL << NSEventTypeRightMouseDragged,
			NSEventMaskMouseEntered = 1ULL << NSEventTypeMouseEntered,
			NSEventMaskMouseExited = 1ULL << NSEventTypeMouseExited,
			NSEventMaskKeyDown = 1ULL << NSEventTypeKeyDown,
			NSEventMaskKeyUp = 1ULL << NSEventTypeKeyUp,
			NSEventMaskFlagsChanged = 1ULL << NSEventTypeFlagsChanged,
			NSEventMaskAppKitDefined = 1ULL << NSEventTypeAppKitDefined,
			NSEventMaskSystemDefined = 1ULL << NSEventTypeSystemDefined,
			NSEventMaskApplicationDefined = 1ULL << NSEventTypeApplicationDefined,
			NSEventMaskPeriodic = 1ULL << NSEventTypePeriodic,
			NSEventMaskCursorUpdate = 1ULL << NSEventTypeCursorUpdate,
			NSEventMaskScrollWheel = 1ULL << NSEventTypeScrollWheel,
			NSEventMaskTabletPoint = 1ULL << NSEventTypeTabletPoint,
			NSEventMaskTabletProximity = 1ULL << NSEventTypeTabletProximity,
			NSEventMaskOtherMouseDown = 1ULL << NSEventTypeOtherMouseDown,
			NSEventMaskOtherMouseUp = 1ULL << NSEventTypeOtherMouseUp,
			NSEventMaskOtherMouseDragged = 1ULL << NSEventTypeOtherMouseDragged,
			/* The following event masks are available on some hardware on 10.5.2 and later */
			NSEventMaskGesture API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeGesture,
			NSEventMaskMagnify API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeMagnify,
			NSEventMaskSwipe API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeSwipe,
			NSEventMaskRotate API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeRotate,
			NSEventMaskBeginGesture API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeBeginGesture,
			NSEventMaskEndGesture API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeEndGesture,

			/* Note: You can only use these event masks on 64 bit. In other words, you cannot setup a local, nor global, event monitor for these event types on 32 bit. Also, you cannot search the event queue for them (nextEventMatchingMask:...) on 32 bit.
			 */
			NSEventMaskSmartMagnify API_AVAILABLE(macos(10.8)) = 1ULL << NSEventTypeSmartMagnify,
			NSEventMaskPressure API_AVAILABLE(macos(10.10.3)) = 1ULL << NSEventTypePressure,
			NSEventMaskDirectTouch API_AVAILABLE(macos(10.12.2)) = 1ULL << NSEventTypeDirectTouch,

			NSEventMaskChangeMode API_AVAILABLE(macos(10.15)) = 1ULL << NSEventTypeChangeMode,

			NSEventMaskAny = ULONG_MAX,

	};

	typedef enum NSEventModifierFlags {
		NSEventModifierFlagCapsLock = 1 << 16,
		NSEventModifierFlagShift = 1 << 17,
		NSEventModifierFlagControl = 1 << 18,
		NSEventModifierFlagOption = 1 << 19,
		NSEventModifierFlagCommand = 1 << 20,
		NSEventModifierFlagNumericPad = 1 << 21
	} NSEventModifierFlags;

	void RGFW_stopCheckEvents(void) { 
		id eventPool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
        eventPool = objc_msgSend_id(eventPool, sel_registerName("init"));

		NSEvent* e = (NSEvent*) ((id(*)(id, SEL, NSEventType, NSPoint, NSEventModifierFlags, void*, NSInteger, void**, short, NSInteger, NSInteger))objc_msgSend)
			(NSApp, sel_registerName("otherEventWithType:location:modifierFlags:timestamp:windowNumber:context:subtype:data1:data2:"), 
				NSEventTypeApplicationDefined, (NSPoint){0, 0}, 0, 0, 0, NULL, 0, 0, 0);

		((void (*)(id, SEL, id, bool))objc_msgSend)
			(NSApp, sel_registerName("postEvent:atStart:"), e, 1);

		objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
	}

	void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
		RGFW_UNUSED(win);
		
		id eventPool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
        eventPool = objc_msgSend_id(eventPool, sel_registerName("init"));

		void* date = (void*) ((id(*)(Class, SEL, double))objc_msgSend)
					(objc_getClass("NSDate"), sel_registerName("dateWithTimeIntervalSinceNow:"), waitMS);

		NSEvent* e = (NSEvent*) ((id(*)(id, SEL, NSEventMask, void*, NSString*, bool))objc_msgSend)
			(NSApp, sel_registerName("nextEventMatchingMask:untilDate:inMode:dequeue:"), 
				ULONG_MAX, date, NSString_stringWithUTF8String("kCFRunLoopDefaultMode"), true);


		if (e) {
			objc_msgSend_void_id(NSApp, sel_registerName("sendEvent:"), e);
		}

		objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
	}

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		assert(win != NULL);
		
		if (win->event.type == RGFW_quit)
			return NULL;
		
		if ((win->event.type == RGFW_dnd || win->event.type == RGFW_dnd_init) && win->src.dndPassed == 0) {
			win->src.dndPassed = 1;
			return &win->event;
		}

		id eventPool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
        eventPool = objc_msgSend_id(eventPool, sel_registerName("init"));

		static void* eventFunc = NULL;
		if (eventFunc == NULL) 
			eventFunc = sel_registerName("nextEventMatchingMask:untilDate:inMode:dequeue:");

		if ((win->event.type == RGFW_windowMoved || win->event.type == RGFW_windowResized || win->event.type == RGFW_windowRefresh) && win->event.keyCode != 120) {
			win->event.keyCode = 120;
			objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
			return &win->event;
		}

		void* date = NULL;

		NSEvent* e = (NSEvent*) ((id(*)(id, SEL, NSEventMask, void*, NSString*, bool))objc_msgSend)
			(NSApp, eventFunc, ULONG_MAX, date, NSString_stringWithUTF8String("kCFRunLoopDefaultMode"), true);

		if (e == NULL) {
			objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
			return NULL;
		}
		
		if (objc_msgSend_id(e, sel_registerName("window")) != win->src.window) {
			((void (*)(id, SEL, id, bool))objc_msgSend)
				(NSApp, sel_registerName("postEvent:atStart:"), e, 0);
						
			objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
			return NULL;
		}

		if (win->event.droppedFilesCount) {
			u32 i;
			for (i = 0; i < win->event.droppedFilesCount; i++)
				win->event.droppedFiles[i][0] = '\0';
		}

		win->event.droppedFilesCount = 0;
		win->event.type = 0;
		
		switch (objc_msgSend_uint(e, sel_registerName("type"))) {
			case NSEventTypeMouseEntered: {
				win->event.type = RGFW_mouseEnter;
				NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(e, sel_registerName("locationInWindow"));

				win->event.point = RGFW_POINT((i32) p.x, (i32) (win->r.h - p.y));
				RGFW_mouseNotifyCallBack(win, win->event.point, 1);
				break;
			}
			
			case NSEventTypeMouseExited:
				win->event.type = RGFW_mouseLeave;
				RGFW_mouseNotifyCallBack(win, win->event.point, 0);
				break;

			case NSEventTypeKeyDown: {
				u32 key = (u16) objc_msgSend_uint(e, sel_registerName("keyCode"));
				win->event.keyCode = RGFW_apiKeyCodeToRGFW(key);
				RGFW_keyboard[win->event.keyCode].prev = RGFW_keyboard[win->event.keyCode].current;

				win->event.type = RGFW_keyPressed;
				char* str = (char*)(const char*) NSString_to_char(objc_msgSend_id(e, sel_registerName("characters")));
				strncpy(win->event.keyName, str, 16);
				win->event.repeat = RGFW_isPressed(win, win->event.keyCode);
				RGFW_keyboard[win->event.keyCode].current = 1;

				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 1);
				break;
			}

			case NSEventTypeKeyUp: {
				u32 key = (u16) objc_msgSend_uint(e, sel_registerName("keyCode"));
				win->event.keyCode = RGFW_apiKeyCodeToRGFW(key);;

				RGFW_keyboard[win->event.keyCode].prev = RGFW_keyboard[win->event.keyCode].current;

				win->event.type = RGFW_keyReleased;
				char* str = (char*)(const char*) NSString_to_char(objc_msgSend_id(e, sel_registerName("characters")));
				strncpy(win->event.keyName, str, 16);

				RGFW_keyboard[win->event.keyCode].current = 0;
				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 0);
				break;
			}

			case NSEventTypeFlagsChanged: {
				u32 flags = objc_msgSend_uint(e, sel_registerName("modifierFlags"));
				RGFW_updateLockState(win, ((u32)(flags & NSEventModifierFlagCapsLock) % 255), ((flags & NSEventModifierFlagNumericPad) % 255));
				
				u8 i;
				for (i = 0; i < 9; i++)
					RGFW_keyboard[i + RGFW_CapsLock].prev = 0;
				
				for (i = 0; i < 5; i++) {
					u32 shift = (1 << (i + 16));
					u32 key = i + RGFW_CapsLock;

					if ((flags & shift) && !RGFW_wasPressed(win, key)) {
						RGFW_keyboard[key].current = 1;

						if (key != RGFW_CapsLock)
							RGFW_keyboard[key+ 4].current = 1;
						
						win->event.type = RGFW_keyPressed;
						win->event.keyCode = key;
						break;
					} 
					
					if (!(flags & shift) && RGFW_wasPressed(win, key)) {
						RGFW_keyboard[key].current = 0;
						
						if (key != RGFW_CapsLock)
							RGFW_keyboard[key + 4].current = 0;

						win->event.type = RGFW_keyReleased;
						win->event.keyCode = key;
						break;
					}
				}

				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, win->event.type == RGFW_keyPressed);

				break;
			}
			case NSEventTypeLeftMouseDragged:
			case NSEventTypeOtherMouseDragged:
			case NSEventTypeRightMouseDragged:
			case NSEventTypeMouseMoved:
				win->event.type = RGFW_mousePosChanged;
				NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(e, sel_registerName("locationInWindow"));
				win->event.point = RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));

				if ((win->_winArgs & RGFW_HOLD_MOUSE)) {
					p.x = ((CGFloat(*)(id, SEL))abi_objc_msgSend_fpret)(e, sel_registerName("deltaX"));
					p.y = ((CGFloat(*)(id, SEL))abi_objc_msgSend_fpret)(e, sel_registerName("deltaY"));
					
					win->event.point = RGFW_POINT((i32)p.x, (i32)p.y);
				}

				RGFW_mousePosCallback(win, win->event.point);
				break;

			case NSEventTypeLeftMouseDown:
				win->event.button = RGFW_mouseLeft;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case NSEventTypeOtherMouseDown:
				win->event.button = RGFW_mouseMiddle;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case NSEventTypeRightMouseDown:
				win->event.button = RGFW_mouseRight;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case NSEventTypeLeftMouseUp:
				win->event.button = RGFW_mouseLeft;
				win->event.type = RGFW_mouseButtonReleased;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

			case NSEventTypeOtherMouseUp:
				win->event.button = RGFW_mouseMiddle;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				win->event.type = RGFW_mouseButtonReleased;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

			case NSEventTypeRightMouseUp:
				win->event.button = RGFW_mouseRight;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				win->event.type = RGFW_mouseButtonReleased;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

			case NSEventTypeScrollWheel: {
				double deltaY = ((CGFloat(*)(id, SEL))abi_objc_msgSend_fpret)(e, sel_registerName("deltaY"));

				if (deltaY > 0) {
					win->event.button = RGFW_mouseScrollUp;
				}
				else if (deltaY < 0) {
					win->event.button = RGFW_mouseScrollDown;
				}

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;

				win->event.scroll = deltaY;

				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;
			}

			default:
				break;
		}

		objc_msgSend_void_id(NSApp, sel_registerName("sendEvent:"), e);
		((void(*)(id, SEL))objc_msgSend)(NSApp, sel_registerName("updateWindows"));
				
		objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
		return &win->event;
	}


	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);

		win->r.x = v.x;
		win->r.y = v.y;
		((void(*)(id, SEL, NSRect, bool, bool))objc_msgSend)
			(win->src.window, sel_registerName("setFrame:display:animate:"), (NSRect){{win->r.x, win->r.y}, {win->r.w, win->r.h}}, true, true);
	}

	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		win->r.w = a.w;
		win->r.h = a.h;
		((void(*)(id, SEL, NSRect, bool, bool))objc_msgSend)
			(win->src.window, sel_registerName("setFrame:display:animate:"), (NSRect){{win->r.x, win->r.y}, {win->r.w, win->r.h}}, true, true);
	}

	void RGFW_window_minimize(RGFW_window* win) {
		assert(win != NULL);

		objc_msgSend_void_SEL(win->src.window, sel_registerName("performMiniaturize:"), NULL);
	}

	void RGFW_window_restore(RGFW_window* win) {
		assert(win != NULL);

		objc_msgSend_void_SEL(win->src.window, sel_registerName("deminiaturize:"), NULL);
	}

	void RGFW_window_setName(RGFW_window* win, char* name) {
		assert(win != NULL);

		NSString* str = NSString_stringWithUTF8String(name);
		objc_msgSend_void_id(win->src.window, sel_registerName("setTitle:"), str);
	}

	#ifndef RGFW_NO_PASSTHROUGH
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIgnoresMouseEvents:"), passthrough);
	}
	#endif

	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		if (a.w == 0 && a.h == 0)
			return;

		((void (*)(id, SEL, NSSize))objc_msgSend)
			(win->src.window, sel_registerName("setMinSize:"), (NSSize){a.w, a.h});
	}

	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		if (a.w == 0 && a.h == 0)
			return;

		((void (*)(id, SEL, NSSize))objc_msgSend)
			(win->src.window, sel_registerName("setMaxSize:"), (NSSize){a.w, a.h});
	}

	void RGFW_window_setIcon(RGFW_window* win, u8* data, RGFW_area area, i32 channels) {
		assert(win != NULL);

		/* code by EimaMei  */
		// Make a bitmap representation, then copy the loaded image into it.
		void* representation = NSBitmapImageRep_initWithBitmapData(NULL, area.w, area.h, 8, channels, (channels == 4), false, "NSCalibratedRGBColorSpace", 1 << 1, area.w * channels, 8 * channels);
		memcpy(NSBitmapImageRep_bitmapData(representation), data, area.w * area.h * channels);

		// Add ze representation.
		void* dock_image = NSImage_initWithSize((NSSize){area.w, area.h});
		NSImage_addRepresentation(dock_image, (void*) representation);

		// Finally, set the dock image to it.
		objc_msgSend_void_id(NSApp, sel_registerName("setApplicationIconImage:"), dock_image);
		// Free the garbage.
		release(dock_image);
		release(representation);
	}

	NSCursor* NSCursor_arrowStr(char* str) {
		void* nclass = objc_getClass("NSCursor");
		void* func = sel_registerName(str);
		return (NSCursor*) objc_msgSend_id(nclass, func);
	}

	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		assert(win != NULL);

		if (image == NULL) {
			objc_msgSend_void(NSCursor_arrowStr("arrowCursor"), sel_registerName("set"));
			return;
		}

		/* NOTE(EimaMei): Code by yours truly. */
		// Make a bitmap representation, then copy the loaded image into it.
		void* representation = NSBitmapImageRep_initWithBitmapData(NULL, a.w, a.h, 8, channels, (channels == 4), false, "NSCalibratedRGBColorSpace", 1 << 1, a.w * channels, 8 * channels);
		memcpy(NSBitmapImageRep_bitmapData(representation), image, a.w * a.h * channels);

		// Add ze representation.
		void* cursor_image = NSImage_initWithSize((NSSize){a.w, a.h});
		NSImage_addRepresentation(cursor_image, representation);

		// Finally, set the cursor image.
		void* cursor = NSCursor_initWithImage(cursor_image, (NSPoint){0.0, 0.0});

		objc_msgSend_void(cursor, sel_registerName("set"));

		// Free the garbage.
		release(cursor_image);
		release(representation);
	}

	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_ARROW);
	}

	void RGFW_window_showMouse(RGFW_window* win, i8 show) {
		RGFW_UNUSED(win);

		if (show) {
			CGDisplayShowCursor(kCGDirectMainDisplay);
		}
		else {
			CGDisplayHideCursor(kCGDirectMainDisplay);
		}
	}

	void RGFW_window_setMouseStandard(RGFW_window* win, u8 stdMouses) {
		if (stdMouses > ((sizeof(RGFW_mouseIconSrc)) / (sizeof(char*))))
			return;
		
		char* mouseStr = RGFW_mouseIconSrc[stdMouses];
		void* mouse = NSCursor_arrowStr(mouseStr);

		if (mouse == NULL)
			return;

		RGFW_UNUSED(win);
		CGDisplayShowCursor(kCGDirectMainDisplay);
		objc_msgSend_void(mouse, sel_registerName("set"));
	}
	
	void RGFW_releaseCursor(RGFW_window* win) {
		RGFW_UNUSED(win);
		CGAssociateMouseAndMouseCursorPosition(1);	
	}

	void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) { 
		RGFW_UNUSED(win)

		CGWarpMouseCursorPosition(CGPointMake(r.x + (r.w / 2), r.y + (r.h / 2)));
		CGAssociateMouseAndMouseCursorPosition(0);
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) {
		RGFW_UNUSED(win);
		
		CGWarpMouseCursorPosition(CGPointMake(v.x, v.y));		
	}


	void RGFW_window_hide(RGFW_window* win) {
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIsVisible:"), false);
	}

	void RGFW_window_show(RGFW_window* win) {
		((id(*)(id, SEL, SEL))objc_msgSend)(win->src.window, sel_registerName("makeKeyAndOrderFront:"), NULL);
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIsVisible:"), true);
	}

	u8 RGFW_window_isFullscreen(RGFW_window* win) {
		assert(win != NULL);

		NSWindowStyleMask mask = (NSWindowStyleMask) objc_msgSend_uint(win->src.window, sel_registerName("styleMask"));
		return (mask & NSWindowStyleMaskFullScreen) == NSWindowStyleMaskFullScreen;
	}

	u8 RGFW_window_isHidden(RGFW_window* win) {
		assert(win != NULL);

		bool visible = objc_msgSend_bool(win->src.window, sel_registerName("isVisible"));
		return visible == NO && !RGFW_window_isMinimized(win);
	}

	u8 RGFW_window_isMinimized(RGFW_window* win) {
		assert(win != NULL);

		return objc_msgSend_bool(win->src.window, sel_registerName("isMiniaturized")) == YES;
	}

	u8 RGFW_window_isMaximized(RGFW_window* win) {
		assert(win != NULL);

		return objc_msgSend_bool(win->src.window, sel_registerName("isZoomed"));
	}

	static RGFW_monitor RGFW_NSCreateMonitor(CGDirectDisplayID display) {
		RGFW_monitor monitor;

		CGRect bounds = CGDisplayBounds(display);
		monitor.rect = RGFW_RECT((int) bounds.origin.x, (int) bounds.origin.y, (int) bounds.size.width, (int) bounds.size.height);

		CGSize screenSizeMM = CGDisplayScreenSize(display);
		monitor.physW = screenSizeMM.width / 25.4;
		monitor.physH = screenSizeMM.height / 25.4;

		monitor.scaleX = (monitor.rect.w / (screenSizeMM.width)) / 2.6;
		monitor.scaleY = (monitor.rect.h / (screenSizeMM.height)) / 2.6;

		snprintf(monitor.name, 128, "%i %i %i", CGDisplayModelNumber(display), CGDisplayVendorNumber(display), CGDisplaySerialNumber(display));

		return monitor;
	}


	static RGFW_monitor RGFW_monitors[7];

	RGFW_monitor* RGFW_getMonitors(void) {
		static CGDirectDisplayID displays[7];
		u32 count;

		if (CGGetActiveDisplayList(6, displays, &count) != kCGErrorSuccess)
			return NULL;

		for (u32 i = 0; i < count; i++)
			RGFW_monitors[i] = RGFW_NSCreateMonitor(displays[i]);

		return RGFW_monitors;
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
		CGDirectDisplayID primary = CGMainDisplayID();
		return RGFW_NSCreateMonitor(primary);
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		return RGFW_NSCreateMonitor(win->src.display);
	}

	char* RGFW_readClipboard(size_t* size) {
		char* clip = (char*)NSPasteboard_stringForType(NSPasteboard_generalPasteboard(), NSPasteboardTypeString);
		
		size_t clip_len = 1;

		if (clip != NULL) {
			clip_len = strlen(clip) + 1; 
		}

		char* str = (char*)RGFW_MALLOC(sizeof(char) * clip_len);
		
		if (clip != NULL) {
			strncpy(str, clip, clip_len);
		}

		str[clip_len] = '\0';
		
		if (size != NULL)
			*size = clip_len;
		return str;
	}

	void RGFW_writeClipboard(const char* text, u32 textLen) {
		RGFW_UNUSED(textLen);

		NSPasteboardType array[] = { NSPasteboardTypeString, NULL };
		NSPasteBoard_declareTypes(NSPasteboard_generalPasteboard(), array, 1, NULL);

		NSPasteBoard_setString(NSPasteboard_generalPasteboard(), text, NSPasteboardTypeString);
	}

	u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber) {
		RGFW_UNUSED(jsNumber);

		assert(win != NULL);

		return RGFW_registerJoystickF(win, (char*) "");
	}

	u16 RGFW_registerJoystickF(RGFW_window* win, char* file) {
		RGFW_UNUSED(file);

		assert(win != NULL);

		return RGFW_joystickCount - 1;
	}

	#ifdef RGFW_OPENGL
	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		assert(win != NULL);
		objc_msgSend_void(win->src.ctx, sel_registerName("makeCurrentContext"));
	}
	#endif

	#if !defined(RGFW_EGL)
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);
		#if defined(RGFW_OPENGL)
		
		NSOpenGLContext_setValues(win->src.ctx, &swapInterval, 222);
		#else
		RGFW_UNUSED(swapInterval);
		#endif
	}
	#endif
	
	// Function to create a CGImageRef from an array of bytes
	CGImageRef createImageFromBytes(unsigned char *buffer, int width, int height)
	{
		// Define color space
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        // Create bitmap context
        CGContextRef context = CGBitmapContextCreate(
        		buffer, 
        		width, height,
        		8,
        		RGFW_bufferSize.w * 4, 
        		colorSpace,
        		kCGImageAlphaPremultipliedLast);
        // Create image from bitmap context
        CGImageRef image = CGBitmapContextCreateImage(context);
        // Release the color space and context
        CGColorSpaceRelease(colorSpace);
        CGContextRelease(context);
                         
        return image;
    }

	void RGFW_window_swapBuffers(RGFW_window* win) {
		assert(win != NULL);
		/* clear the window*/

		if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			#ifdef RGFW_OSMESA
			RGFW_OSMesa_reorganize();
			#endif

			void* view = NSWindow_contentView(win->src.window);
			void* layer = objc_msgSend_id(view, sel_registerName("layer"));

			((void(*)(id, SEL, NSRect))objc_msgSend)(layer,
				sel_registerName("setFrame:"),
				(NSRect){{0, 0}, {win->r.w, win->r.h}});

            CGImageRef image = createImageFromBytes(win->buffer, win->r.w, win->r.h);
            // Get the current graphics context
            id graphicsContext = objc_msgSend_class(objc_getClass("NSGraphicsContext"), sel_registerName("currentContext"));
            // Get the CGContext from the current NSGraphicsContext
            id cgContext = objc_msgSend_id(graphicsContext, sel_registerName("graphicsPort"));
			// Draw the image in the context
			NSRect bounds = (NSRect){{0,0}, {win->r.w, win->r.h}};
		    CGContextDrawImage((void*)cgContext, *(CGRect*)&bounds, image);
          	// Flush the graphics context to ensure the drawing is displayed
            objc_msgSend_id(graphicsContext, sel_registerName("flushGraphics"));
            
            objc_msgSend_void_id(layer, sel_registerName("setContents:"), (id)image);
            objc_msgSend_id(layer, sel_registerName("setNeedsDisplay"));
            
            CGImageRelease(image);
#endif
		}

		if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) {
			#ifdef RGFW_EGL
					eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
			#elif defined(RGFW_OPENGL)
					objc_msgSend_void(win->src.ctx, sel_registerName("flushBuffer"));
			#endif
		}
	}

	void RGFW_window_close(RGFW_window* win) {
		assert(win != NULL);
		release(win->src.view);

#ifdef RGFW_ALLOC_DROPFILES
		{
			u32 i;
			for (i = 0; i < RGFW_MAX_DROPS; i++)
				RGFW_FREE(win->event.droppedFiles[i]);


			RGFW_FREE(win->event.droppedFiles);
		}
#endif
	
#ifdef RGFW_BUFFER
		release(win->src.bitmap);
		release(win->src.image);
#endif

		CVDisplayLinkStop(win->src.displayLink);
		CVDisplayLinkRelease(win->src.displayLink);

		RGFW_FREE(win);
	}

	u64 RGFW_getTimeNS(void) {
		static mach_timebase_info_data_t timebase_info;
		if (timebase_info.denom == 0) {
			mach_timebase_info(&timebase_info);
		}
		return mach_absolute_time() * timebase_info.numer / timebase_info.denom;
	}

	u64 RGFW_getTime(void) {
		static mach_timebase_info_data_t timebase_info;
		if (timebase_info.denom == 0) {
			mach_timebase_info(&timebase_info);
		}
		return (double) mach_absolute_time() * (double) timebase_info.numer / ((double) timebase_info.denom * 1e9);
	}
#endif /* RGFW_MACOS */

/*
	End of MaOS defines
*/

/*
	WEBASM defines
*/

#ifdef RGFW_WEBASM
RGFW_Event RGFW_events[20];
size_t RGFW_eventLen = 0;

EM_BOOL Emscripten_on_keydown(int eventType, const EmscriptenKeyboardEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);
	
	RGFW_events[RGFW_eventLen].type = RGFW_keyPressed;
	memcpy(RGFW_events[RGFW_eventLen].keyName, e->key, 16);
	RGFW_events[RGFW_eventLen].keyCode = RGFW_apiKeyCodeToRGFW(e->keyCode);
	RGFW_events[RGFW_eventLen].lockState = 0;
	RGFW_eventLen++;

	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].prev = RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current;
	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current = 1;
	RGFW_keyCallback(RGFW_root, RGFW_apiKeyCodeToRGFW(e->keyCode), RGFW_events[RGFW_eventLen].keyName, 0, 1);
	
    return EM_TRUE;
}

EM_BOOL Emscripten_on_keyup(int eventType, const EmscriptenKeyboardEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_keyReleased;
	memcpy(RGFW_events[RGFW_eventLen].keyName, e->key, 16);
	RGFW_events[RGFW_eventLen].keyCode = RGFW_apiKeyCodeToRGFW(e->keyCode);
	RGFW_events[RGFW_eventLen].lockState = 0;
	RGFW_eventLen++;

	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].prev = RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current;
	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current = 0;

	RGFW_keyCallback(RGFW_root, RGFW_apiKeyCodeToRGFW(e->keyCode), RGFW_events[RGFW_eventLen].keyName, 0, 0);

    return EM_TRUE;
}

EM_BOOL Emscripten_on_resize(int eventType, const EmscriptenUiEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_windowResized;
	RGFW_eventLen++;

	RGFW_windowResizeCallback(RGFW_root, RGFW_RECT(0, 0, e->windowInnerWidth, e->windowInnerHeight));
    return EM_TRUE;
}

EM_BOOL Emscripten_on_fullscreenchange(int eventType, const EmscriptenFullscreenChangeEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_windowResized;
	RGFW_eventLen++;

	RGFW_root->r = RGFW_RECT(0, 0, e->elementWidth, e->elementHeight);
	RGFW_windowResizeCallback(RGFW_root, RGFW_root->r);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_focusin(int eventType, const EmscriptenFocusEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData); RGFW_UNUSED(e);

	RGFW_events[RGFW_eventLen].type = RGFW_focusIn;
	RGFW_eventLen++;

	RGFW_root->event.inFocus = 1;
	RGFW_focusCallback(RGFW_root, 1);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_focusout(int eventType, const EmscriptenFocusEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData); RGFW_UNUSED(e);

	RGFW_events[RGFW_eventLen].type = RGFW_focusOut;
	RGFW_eventLen++;

	RGFW_root->event.inFocus = 0;
	RGFW_focusCallback(RGFW_root, 0);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_mousemove(int eventType, const EmscriptenMouseEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mousePosChanged;

	if ((RGFW_root->_winArgs & RGFW_HOLD_MOUSE)) {
		RGFW_point p = RGFW_POINT(e->movementX, e->movementY);
		RGFW_events[RGFW_eventLen].point = p;
	}
	else
		RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->targetX, e->targetY);
	RGFW_eventLen++;
	
	RGFW_mousePosCallback(RGFW_root, RGFW_events[RGFW_eventLen].point);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_mousedown(int eventType, const EmscriptenMouseEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonPressed;
	RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->targetX, e->targetY);
	RGFW_events[RGFW_eventLen].button = e->button + 1; 
	RGFW_events[RGFW_eventLen].scroll = 0;

	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 1;

	RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 1);
	RGFW_eventLen++;
	
    return EM_TRUE;
}

EM_BOOL Emscripten_on_mouseup(int eventType, const EmscriptenMouseEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonReleased;
	RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->targetX, e->targetY);
	RGFW_events[RGFW_eventLen].button = e->button + 1; 
	RGFW_events[RGFW_eventLen].scroll = 0;

	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 0;

	RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 0);
	RGFW_eventLen++;
    return EM_TRUE;
}

EM_BOOL Emscripten_on_wheel(int eventType, const EmscriptenWheelEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonPressed;
	RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->mouse.targetX, e->mouse.targetY);
	RGFW_events[RGFW_eventLen].button = RGFW_mouseScrollUp + (e->deltaY < 0); 
	RGFW_events[RGFW_eventLen].scroll = e->deltaY;

	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 1;

	RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 1);
	RGFW_eventLen++;

    return EM_TRUE;
}

EM_BOOL Emscripten_on_touchstart(int eventType, const EmscriptenTouchEvent* e, void* userData) { 
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

    size_t i; 
    for (i = 0; i < (size_t)e->numTouches; i++) { 
	    RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonPressed;
	    RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->touches[i].targetX, e->touches[i].targetY);
	    RGFW_events[RGFW_eventLen].button = 1; 
	    RGFW_events[RGFW_eventLen].scroll = 0;


	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 1;

        RGFW_mousePosCallback(RGFW_root, RGFW_events[RGFW_eventLen].point);

	    RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 1);
    	RGFW_eventLen++;
    }

	return EM_TRUE;
}
EM_BOOL Emscripten_on_touchmove(int eventType, const EmscriptenTouchEvent* e, void* userData) { 
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);
    
    size_t i; 
    for (i = 0; i < (size_t)e->numTouches; i++) { 
   	    RGFW_events[RGFW_eventLen].type = RGFW_mousePosChanged;
	    RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->touches[i].targetX, e->touches[i].targetY);

        RGFW_mousePosCallback(RGFW_root, RGFW_events[RGFW_eventLen].point);
	    RGFW_eventLen++;
    }
    return EM_TRUE;
}

EM_BOOL Emscripten_on_touchend(int eventType, const EmscriptenTouchEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);
	
    size_t i; 
    for (i = 0; i < (size_t)e->numTouches; i++) { 
	    RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonReleased;
	    RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->touches[i].targetX, e->touches[i].targetY);
	    RGFW_events[RGFW_eventLen].button = 1; 
	    RGFW_events[RGFW_eventLen].scroll = 0;

	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 0;
        
	    RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 0);
	    RGFW_eventLen++;
    }
	return EM_TRUE;
}

EM_BOOL Emscripten_on_touchcancel(int eventType, const EmscriptenTouchEvent* e, void* userData) { RGFW_UNUSED(eventType); RGFW_UNUSED(userData); RGFW_UNUSED(e); return EM_TRUE; }

EM_BOOL Emscripten_on_gamepad(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData) {	
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	if (gamepadEvent->index >= 4)
		return 0;

	RGFW_joysticks[gamepadEvent->index] = gamepadEvent->connected;

    return 1; // The event was consumed by the callback handler
}

void EMSCRIPTEN_KEEPALIVE Emscripten_onDrop(size_t count) {
	if (!(RGFW_root->_winArgs & RGFW_ALLOW_DND))
		return;

	RGFW_events[RGFW_eventLen].droppedFilesCount = count;	
	RGFW_dndCallback(RGFW_root, RGFW_events[RGFW_eventLen].droppedFiles, count);
	RGFW_eventLen++;
}

b8 RGFW_stopCheckEvents_bool = RGFW_FALSE;
void RGFW_stopCheckEvents(void) { 
	RGFW_stopCheckEvents_bool = RGFW_TRUE;
}

void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
	RGFW_UNUSED(win);

	if (waitMS == 0)
		return;
	
	u32 start = (u32)(((u64)RGFW_getTimeNS()) / 1e+6);

	while ((RGFW_eventLen == 0) && RGFW_stopCheckEvents_bool == RGFW_FALSE && 
		(waitMS < 0 || (RGFW_getTimeNS() / 1e+6) - start < waitMS)
	) {
		emscripten_sleep(0);
	}
	
	RGFW_stopCheckEvents_bool = RGFW_FALSE;
}

RGFWDEF void RGFW_init_buffer(RGFW_window* win);
void RGFW_init_buffer(RGFW_window* win) {
	#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
		if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
			RGFW_bufferSize = RGFW_getScreenSize();
		
		win->buffer = RGFW_MALLOC(RGFW_bufferSize.w * RGFW_bufferSize.h * 4);
	#ifdef RGFW_OSMESA
			win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
			OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
	#endif
	#else
	RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
	#endif
}

void EMSCRIPTEN_KEEPALIVE RGFW_makeSetValue(size_t index, char* file) { 
	/* This seems like a terrible idea, don't replicate this unless you hate yourself or the OS */
	/* TODO: find a better way to do this, 
		strcpy doesn't seem to work, maybe because of asyncio
	*/

	RGFW_events[RGFW_eventLen].type = RGFW_dnd;
	char** arr = (char**)&RGFW_events[RGFW_eventLen].droppedFiles[index];
	*arr = file;
}

#include <sys/stat.h>
#include <sys/types.h>
#include <errno.h>

void EMSCRIPTEN_KEEPALIVE RGFW_mkdir(char* name) { mkdir(name, 0755); }

void EMSCRIPTEN_KEEPALIVE RGFW_writeFile(const char *path, const char *data, size_t len) {
    FILE* file = fopen(path, "w+");
	if (file == NULL)
		return;

    fwrite(data, sizeof(char), len, file);
    fclose(file);
}

RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
	RGFW_UNUSED(name) 

	RGFW_UNUSED(RGFW_initFormatAttribs);
	
    RGFW_window* win = RGFW_window_basic_init(rect, args);

    EmscriptenWebGLContextAttributes attrs;
    attrs.alpha = EM_TRUE;
    attrs.depth = EM_TRUE;
	attrs.alpha = EM_TRUE;
    attrs.stencil = RGFW_STENCIL;
    attrs.antialias = RGFW_SAMPLES;
    attrs.premultipliedAlpha = EM_TRUE;
    attrs.preserveDrawingBuffer = EM_FALSE;
	
    if (RGFW_DOUBLE_BUFFER == 0)
        attrs.renderViaOffscreenBackBuffer = 0;
    else
        attrs.renderViaOffscreenBackBuffer = RGFW_AUX_BUFFERS;
    
    attrs.failIfMajorPerformanceCaveat = EM_FALSE;
	attrs.majorVersion = (RGFW_majorVersion == 0) ? 1 : RGFW_majorVersion;
	attrs.minorVersion = RGFW_minorVersion;
	
    attrs.enableExtensionsByDefault = EM_TRUE;
    attrs.explicitSwapControl = EM_TRUE;

    emscripten_webgl_init_context_attributes(&attrs);
    win->src.ctx = emscripten_webgl_create_context("#canvas", &attrs);
    emscripten_webgl_make_context_current(win->src.ctx);

	#ifdef LEGACY_GL_EMULATION
	EM_ASM("Module.useWebGL = true; GLImmediate.init();");	
	#endif

	emscripten_set_canvas_element_size("#canvas", rect.w, rect.h);
	emscripten_set_window_title(name);

	/* load callbacks */
    emscripten_set_keydown_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_keydown);
    emscripten_set_keyup_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_keyup);
    emscripten_set_resize_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_resize);
    emscripten_set_fullscreenchange_callback(EMSCRIPTEN_EVENT_TARGET_DOCUMENT, NULL, EM_FALSE, Emscripten_on_fullscreenchange);
    emscripten_set_mousemove_callback("#canvas", NULL, EM_FALSE, Emscripten_on_mousemove);
    emscripten_set_touchstart_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchstart);
    emscripten_set_touchend_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchend);
    emscripten_set_touchmove_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchmove);
    emscripten_set_touchcancel_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchcancel);
    emscripten_set_mousedown_callback("#canvas", NULL, EM_FALSE, Emscripten_on_mousedown);
    emscripten_set_mouseup_callback("#canvas", NULL, EM_FALSE, Emscripten_on_mouseup);
    emscripten_set_wheel_callback("#canvas", NULL, EM_FALSE, Emscripten_on_wheel);
    emscripten_set_focusin_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_focusin);
    emscripten_set_focusout_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_focusout);
	emscripten_set_gamepadconnected_callback(NULL, 1, Emscripten_on_gamepad);
	emscripten_set_gamepaddisconnected_callback(NULL, 1, Emscripten_on_gamepad);
	
	if (args & RGFW_ALLOW_DND)  {
		win->_winArgs |= RGFW_ALLOW_DND;
	}

    EM_ASM({
		var canvas = document.getElementById('canvas');
        canvas.addEventListener('drop', function(e) {
            e.preventDefault();
            if (e.dataTransfer.file < 0)
				return;

			var filenamesArray = [];
			var count = e.dataTransfer.files.length;

			/* Read and save the files to emscripten's files */
			var drop_dir = '.rgfw_dropped_files';
			Module._RGFW_mkdir(drop_dir);

			for (var i = 0; i < count; i++) {
				var file = e.dataTransfer.files[i];

				var path = '/' + drop_dir + '/' + file.name.replace("//", '_');
				var reader = new FileReader();
				
				reader.onloadend = (e) => {
					if (reader.readyState != 2) {
						out('failed to read dropped file: '+file.name+': '+reader.error);
					}
					else {
						var data = e.target.result;
						
						_RGFW_writeFile(path, new Uint8Array(data), file.size);
					}
				};

				reader.readAsArrayBuffer(file);		
				// This works weird on modern opengl
				var filename = stringToNewUTF8(path);

				filenamesArray.push(filename);
				
				Module._RGFW_makeSetValue(i, filename);
			}
			
			Module._Emscripten_onDrop(count);
			
			for (var i = 0; i < count; ++i) {
				_free(filenamesArray[i]);
			}
        }, true);

        canvas.addEventListener('dragover', function(e) { e.preventDefault(); return false; }, true);
    });

	RGFW_init_buffer(win);
	glViewport(0, 0, rect.w, rect.h);
	
	RGFW_root = win; 

	if (args & RGFW_HIDE_MOUSE) {
		RGFW_window_showMouse(win, 0);
	}

	if (args & RGFW_FULLSCREEN) {
		RGFW_window_resize(win, RGFW_getScreenSize());
	}

    return win;
}

RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
	static u8 index = 0;
	
	if (index == 0) 
		RGFW_resetKey();

	/* check gamepads */
    for (int i = 0; (i < emscripten_get_num_gamepads()) && (i < 4); i++) {
		if (RGFW_joysticks[i] == 0)
			continue;;
		
        EmscriptenGamepadEvent gamepadState;

        if (emscripten_get_gamepad_status(i, &gamepadState) != EMSCRIPTEN_RESULT_SUCCESS)
			break;

		// Register buttons data for every connected gamepad
		for (int j = 0; (j < gamepadState.numButtons) && (j < 16); j++) {
			u32 map[] = {
				RGFW_JS_A, RGFW_JS_X, RGFW_JS_B, RGFW_JS_Y,
				RGFW_JS_L1, RGFW_JS_R1, RGFW_JS_L2, RGFW_JS_R2,
				RGFW_JS_SELECT, RGFW_JS_START,
				0, 0,
				RGFW_JS_UP, RGFW_JS_DOWN, RGFW_JS_LEFT, RGFW_JS_RIGHT
			};

			u32 button = map[j]; 
			if (RGFW_jsPressed[i][button] != gamepadState.digitalButton[j]) {
				win->event.type = RGFW_jsButtonPressed;
				win->event.joystick = i;
				win->event.button = map[j];
				return &win->event;
			}

			RGFW_jsPressed[i][button] = gamepadState.digitalButton[j];
		}

		for (int j = 0; (j < gamepadState.numAxes) && (j < 4); j += 2) {
			win->event.axisesCount = gamepadState.numAxes;
			if (win->event.axis[j].x != gamepadState.axis[j] || 
				win->event.axis[j].y != gamepadState.axis[j + 1]
			) {
				win->event.axis[j].x = gamepadState.axis[j];
				win->event.axis[j].y = gamepadState.axis[j + 1];
				win->event.type = RGFW_jsAxisMove;
				win->event.joystick = i;
				return &win->event;
			}
		}
    }

	/* check queued events */
	if (RGFW_eventLen == 0)
		return NULL;
	
	RGFW_events[index].frameTime = win->event.frameTime;
	RGFW_events[index].frameTime2 = win->event.frameTime2;
	RGFW_events[index].inFocus = win->event.inFocus;

	win->event = RGFW_events[index];

	RGFW_eventLen--;

	if (RGFW_eventLen)
		index++;
	else
		index = 0;

	return &win->event;
}

void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
	RGFW_UNUSED(win)
	emscripten_set_canvas_element_size("#canvas", a.w, a.h);
}

/* NOTE: I don't know if this is possible */
void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) { RGFW_UNUSED(win); RGFW_UNUSED(v); }
/* this one might be possible but it looks iffy */
void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) { RGFW_UNUSED(win); RGFW_UNUSED(channels) RGFW_UNUSED(a) RGFW_UNUSED(image) }

const char RGFW_CURSORS[11][12] = {
    "default",
    "default",
    "text",
    "crosshair",
    "pointer",
    "ew-resize",
    "ns-resize",
    "nwse-resize",
    "nesw-resize",
    "move",
    "not-allowed"
};

void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
	RGFW_UNUSED(win)
	EM_ASM( { document.getElementById("canvas").style.cursor = UTF8ToString($0); }, RGFW_CURSORS[mouse]);
}

void RGFW_window_setMouseDefault(RGFW_window* win) {
	RGFW_window_setMouseStandard(win, RGFW_MOUSE_NORMAL);
}

void RGFW_window_showMouse(RGFW_window* win, i8 show) {
	if (show)
		RGFW_window_setMouseDefault(win);
	else
		EM_ASM(document.getElementById('canvas').style.cursor = 'none';);
}

RGFW_point RGFW_getGlobalMousePoint(void) {
    RGFW_point point;
    point.x = EM_ASM_INT({
        return window.mouseX || 0;
    });
    point.y = EM_ASM_INT({
        return window.mouseY || 0;
    });
    return point;
}

RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
	RGFW_UNUSED(win);
	
	EmscriptenMouseEvent mouseEvent;
    emscripten_get_mouse_status(&mouseEvent);
	return RGFW_POINT( mouseEvent.targetX,  mouseEvent.targetY);
}

void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
	RGFW_UNUSED(win);

    EM_ASM_({
        var canvas = document.getElementById('canvas');
        if ($0) {
            canvas.style.pointerEvents = 'none';
        } else {
            canvas.style.pointerEvents = 'auto';
        }
    }, passthrough);
}

void RGFW_writeClipboard(const char* text, u32 textLen) {
	RGFW_UNUSED(textLen)
	EM_ASM({ navigator.clipboard.writeText(UTF8ToString($0)); }, text);
}


char* RGFW_readClipboard(size_t* size) {
	/*
		placeholder code for later
		I'm not sure if this is possible do the the async stuff
	*/
	
	if (size != NULL)
		*size = 0;
	
	char* str = (char*)malloc(1);
	str[0] = '\0';

	return str;
}

void RGFW_window_swapBuffers(RGFW_window* win) {
	RGFW_UNUSED(win);
	
	#ifdef RGFW_BUFFER
	if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {		
		glEnable(GL_TEXTURE_2D);

		GLuint texture;
		glGenTextures(1,&texture);

		glBindTexture(GL_TEXTURE_2D,texture);
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, RGFW_bufferSize.w, RGFW_bufferSize.h, 0, GL_RGBA, GL_UNSIGNED_BYTE, win->buffer);
		
		float ratioX = ((float)win->r.w / (float)RGFW_bufferSize.w);
		float ratioY = ((float)win->r.h / (float)RGFW_bufferSize.h);

		// Set up the viewport
		glClear(GL_COLOR_BUFFER_BIT);

		glBegin(GL_TRIANGLES);
			glTexCoord2f(0, ratioY); glColor3f(1, 1, 1); glVertex2f(-1, -1);
			glTexCoord2f(0, 0); glColor3f(1, 1, 1); glVertex2f(-1, 1);
			glTexCoord2f(ratioX, ratioY); glColor3f(1, 1, 1); glVertex2f(1, -1);

			glTexCoord2f(ratioX, 0); glColor3f(1, 1, 1); glVertex2f(1, 1);
			glTexCoord2f(ratioX, ratioY); glColor3f(1, 1, 1); glVertex2f(1, -1);
			glTexCoord2f(0, 0); glColor3f(1, 1, 1); glVertex2f(-1, 1);
		glEnd();

		glDeleteTextures(1, &texture);
	}
	#endif

	emscripten_webgl_commit_frame();
	emscripten_sleep(0);
}


void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
	if (win == NULL)
	    emscripten_webgl_make_context_current(0);
	else
	    emscripten_webgl_make_context_current(win->src.ctx);
}

#ifndef RGFW_EGL
void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) { RGFW_UNUSED(win); RGFW_UNUSED(swapInterval); }
#endif

void RGFW_window_close(RGFW_window* win) {
    emscripten_webgl_destroy_context(win->src.ctx);

    free(win);
}

int RGFW_innerWidth(void) {   return EM_ASM_INT({ return window.innerWidth; });  }
int RGFW_innerHeight(void) {  return EM_ASM_INT({ return window.innerHeight; });  }

RGFW_area RGFW_getScreenSize(void) {
	return RGFW_AREA(RGFW_innerWidth(), RGFW_innerHeight());
}

void* RGFW_getProcAddress(const char* procname) { 
	return emscripten_webgl_get_proc_address(procname);
}

void RGFW_sleep(u64 milisecond) {
	emscripten_sleep(milisecond);
}

u64 RGFW_getTimeNS(void) {
	return emscripten_get_now() * 1e+6;
}

u64 RGFW_getTime(void) {
	return emscripten_get_now() * 1000;
}

void RGFW_releaseCursor(RGFW_window* win) {
	RGFW_UNUSED(win);
	emscripten_exit_pointerlock();
}

void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) { 
	RGFW_UNUSED(win); RGFW_UNUSED(r);

	emscripten_request_pointerlock("#canvas", 1);
}


void RGFW_window_setName(RGFW_window* win, char* name) {
	RGFW_UNUSED(win);
	emscripten_set_window_title(name);
}

/* unsupported functions */
RGFW_monitor* RGFW_getMonitors(void) { return NULL; }
RGFW_monitor RGFW_getPrimaryMonitor(void) { return (RGFW_monitor){}; }
void RGFW_window_move(RGFW_window* win, RGFW_point v) { RGFW_UNUSED(win) RGFW_UNUSED(v) }
void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) { RGFW_UNUSED(win) RGFW_UNUSED(a)  }
void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) { RGFW_UNUSED(win) RGFW_UNUSED(a)  }
void RGFW_window_minimize(RGFW_window* win) { RGFW_UNUSED(win)}
void RGFW_window_restore(RGFW_window* win) { RGFW_UNUSED(win) }
void RGFW_window_setBorder(RGFW_window* win, b8 border) { RGFW_UNUSED(win) RGFW_UNUSED(border)  }
void RGFW_window_setIcon(RGFW_window* win, u8* icon, RGFW_area a, i32 channels) { RGFW_UNUSED(win) RGFW_UNUSED(icon) RGFW_UNUSED(a) RGFW_UNUSED(channels)  }
void RGFW_window_hide(RGFW_window* win) { RGFW_UNUSED(win) }
void RGFW_window_show(RGFW_window* win) {RGFW_UNUSED(win) }
b8 RGFW_window_isHidden(RGFW_window* win) { RGFW_UNUSED(win) return 0; }
b8 RGFW_window_isMinimized(RGFW_window* win) { RGFW_UNUSED(win) return 0; }
b8 RGFW_window_isMaximized(RGFW_window* win) { RGFW_UNUSED(win) return 0; }
RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) { RGFW_UNUSED(win) return (RGFW_monitor){}; }

#endif

/* end of web asm defines */

/* unix (macOS, linux, web asm) only stuff */
#if defined(RGFW_X11) || defined(RGFW_MACOS) || defined(RGFW_WEBASM)  || defined(RGFW_WAYLAND)
/* unix threading */
#ifndef RGFW_NO_THREADS
#include <pthread.h>

	RGFW_thread RGFW_createThread(RGFW_threadFunc_ptr ptr, void* args) {
		RGFW_UNUSED(args);
		
		RGFW_thread t;
		pthread_create((pthread_t*) &t, NULL, *ptr, NULL);
		return t;
	}
	void RGFW_cancelThread(RGFW_thread thread) { pthread_cancel((pthread_t) thread); }
	void RGFW_joinThread(RGFW_thread thread) { pthread_join((pthread_t) thread, NULL); }
#ifdef __linux__
	void RGFW_setThreadPriority(RGFW_thread thread, u8 priority) { pthread_setschedprio((pthread_t)thread, priority); }
#endif
#endif

#ifndef RGFW_WEBASM
/* unix sleep */
	void RGFW_sleep(u64 ms) {
		struct timespec time;
		time.tv_sec = 0;
		time.tv_nsec = ms * 1e+6;

		nanosleep(&time, NULL);
	}
#endif

#endif /* end of unix / mac stuff*/
#endif /*RGFW_IMPLEMENTATION*/

#if defined(__cplusplus) && !defined(__EMSCRIPTEN__)
}
#endif
#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_vector rotateAroundCenter(RSoft_vector v, RSoft_vector center, RSoft_vector player, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_simpleRotateMatrix(m, angle);
	m = RSoft_translateMatrix(m, center);
	m = RSoft_translateMatrix(m, RSOFT_VECTOR3D(-player.x, -player.y, -player.z));
	return RSoft_applyMatrix(m, v);
}

void drawLine(RGFW_window* win, RSoft_vector center, RSoft_vector player, float angle, RSoft_vector v1, RSoft_vector v2) {
	v1 = rotateAroundCenter(v1, center, player, angle);
	v2 = rotateAroundCenter(v2, center, player, angle);

	RSoft_setMatrix(RSoft_initMatrix());

	if (RGFW_isPressed(win, RGFW_Tab)) {
		RSoft_drawLineF(win->buffer, v1, v2, (u8[4]){255, 225, 225, 255});
	} else {
		v1.x = (-(v1.x * 200)) / (v1.y - (center.y));
		v1.y = (v1.z * 200) / (v1.y - (center.y)) + center.y;	

		v2.x = (-(v2.x * 200)) / (v2.y - (center.y));	
		v2.y = (v2.z * 200) / (v2.y - (center.y)) + center.y;	
		
		if (v1.x >= 0 && v1.y >= 0 && v2.x >= 0 && v2.y >= 0) 
			RSoft_drawLineF(win->buffer, v1, v2, (u8[4]){255, 225, 225, 255});
	}
}

u8* buffer = NULL;
int w, h, c;

void drawWall(RGFW_window* win, RSoft_vector center, RSoft_vector player, float angle, RSoft_rectF rect) {
	for (float i = 0; i < rect.h; i += 0.1) {
		RSoft_setTexture(buffer, RSOFT_RECT(0, i, w, h), RSOFT_AREA(w, h));
		drawLine(win, center, player, angle, RSOFT_VECTOR3D(rect.x, rect.y, i), RSOFT_VECTOR3D(rect.x + rect.w, rect.y, i));
	}
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Doom-Like example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));

	buffer = stbi_load("wall2.jpg", &w, &h, &c, 4);

	float angle = 0;
	float fov = 120;

	RSoft_vector center = RSOFT_VECTOR2D(win->r.w / 2, win->r.h / 2);

	RSoft_vector player = RSOFT_VECTOR3D(0, 0, 10);

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        } 
			
		if (RGFW_isPressed(win, RGFW_w)) {
			RSoft_vector next = RSOFT_VECTOR3D(player.x - RSoft_cos(angle + 90), 
											   player.y - RSoft_sin(angle + 90),
											   player.z);

			player = next;
		}
		if (RGFW_isPressed(win, RGFW_s)){
			RSoft_vector next = RSOFT_VECTOR3D(player.x + RSoft_cos(angle + 90), 
											   player.y + RSoft_sin(angle + 90),
											   player.z);
			player = next;
		}

		if (RGFW_isPressed(win, RGFW_a)) {
			RSoft_vector next = RSOFT_VECTOR3D(player.x + RSoft_cos(angle), 
											   player.y + RSoft_sin(angle),
											   player.z);

			player = next;
		}

		if (RGFW_isPressed(win, RGFW_d)) {
			RSoft_vector next = RSOFT_VECTOR3D(player.x - RSoft_cos(angle), 
											   player.y - RSoft_sin(angle),
											   player.z);
			
			player = next;
		}

		if (RGFW_isPressed(win, RGFW_Left))
			angle += 0.5;	
		if (RGFW_isPressed(win, RGFW_Right))
			angle -= 0.5;

		if (RGFW_isPressed(win, RGFW_Up))
			player.z -= 5;	
		if (RGFW_isPressed(win, RGFW_Down))
			player.z += 5;

		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 255});
		RSoft_setMatrix(RSoft_initMatrix());
		
		if (RGFW_isPressed(win, RGFW_Tab)) {
			RSoft_matrix m = RSoft_initMatrix();
			m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
			m = RSoft_simpleRotateMatrix(m, angle - 90);
			m = RSoft_translateMatrix(m, center);
			RSoft_setMatrix(m);
			
			RSoft_drawPolygon(win->buffer, RSOFT_RECT(center.x - 10, center.y - 5, 20, 10), 3, (u8[4]){255, 0, 0, 255});
		}

		drawWall(win, center, player, angle, RSOFT_RECTF(200, 200, 200, 20));

		RGFW_window_swapBuffers(win);
    }
	
	free(buffer);
    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/doom-like.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="doom-like.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_matrix rotateAroundCenter(RSoft_vector center, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_rotateMatrix(m, angle, 1, 1, 1);
	m = RSoft_translateMatrix(m, center);
	return m;
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Raycaster example", RGFW_RECT(0, 0, 1100, 800), RGFW_CENTER);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));

	int w, h, c;
	u8* buffer = stbi_load("wall.jpg", &w, &h, &c, 4);

	const u32 map_width = 20;
	const u32 map_height = 20;
	
	u8 map[] = {
		1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
		1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
		1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	};

	float angle = 0;
	float fov = 120;
	float precision = 64; 

	RSoft_vector player = RSOFT_VECTOR2D(5, 7);

	RGFW_window_mouseHold(win, RGFW_AREA(0, 0));
	RGFW_window_showMouse(win, 0);

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_mousePosChanged) {
				angle += (win->event.point.x / 15);	
				if (angle >= 360)
					angle -= 360;
				if (angle < 0)
					angle += 360;

			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        }
		
		if (RGFW_isPressed(win, RGFW_w)) {
			RSoft_vector next = RSOFT_VECTOR2D(player.x + RSoft_cos(angle) / 20, 
											   player.y + RSoft_sin(angle) / 20);

			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}
		if (RGFW_isPressed(win, RGFW_s)){
			RSoft_vector next = RSOFT_VECTOR2D(player.x - RSoft_cos(angle) / 20, 
											   player.y - RSoft_sin(angle) / 20);
			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}

		if (RGFW_isPressed(win, RGFW_a)) {
			RSoft_vector next = RSOFT_VECTOR2D(player.x - RSoft_cos(angle + 90) / 20, 
											   player.y - RSoft_sin(angle + 90) / 20);

			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}

		if (RGFW_isPressed(win, RGFW_d)) {
			RSoft_vector next = RSOFT_VECTOR2D(player.x + RSoft_cos(angle + 90) / 20, 
											   player.y + RSoft_sin(angle + 90) / 20);

			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}

		if (RGFW_isPressed(win, RGFW_Left)) {
			angle -= 5;
;
			if (angle < 0)
				angle += 360;
		}
		if (RGFW_isPressed(win, RGFW_Right)) {
			angle += 5;
			if (angle >= 360)
				angle -= 360;
		}
	

		RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 1, 1), RSOFT_AREA(w, h));
		RSoft_clear(win->buffer, (u8[4]){30, 130, 180, 255});
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(0, win->r.h / 3, win->r.w, win->r.h), (u8[4]){10, 100, 10, 255});	

		float rayAngle = angle - (fov / 2);
		for (size_t i = 0; i < win->r.w; i++) {
			RSoft_vector ray = player;
			rayAngle += (fov / win->r.w);
			
			while (map[(size_t)((size_t)ray.y * map_width) + (size_t)ray.x] == 0) {
				ray.x += cos(rayAngle * DEG2RAD) / precision;
				ray.y += sin(rayAngle * DEG2RAD) / precision;
			}


			if (RGFW_isPressed(win, RGFW_Tab)) {
				RSoft_drawLineF(win->buffer, RSOFT_VECTOR2D(player.x * 50, player.y * 50), RSOFT_VECTOR2D(ray.x * 50, ray.y * 50),  (u8[4]){200, 100, 20, 255});
				continue;
			}

			float dist = (sqrt(pow(player.x - ray.x, 2) + pow(player.y - ray.y, 2)));
			dist *= cos((rayAngle - angle) * DEG2RAD);
			dist += 1;
			
			float height = (win->r.h / 1) / dist;	
			
			if ((rayAngle >= -(fov / 2) && rayAngle <= (fov / 2)) || (rayAngle >= 300))
				RSoft_setTexture(buffer, RSOFT_RECT(sin(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));
			
			if (rayAngle >= 180 - (fov / 2) && rayAngle <= 180 + (fov / 2))
				RSoft_setTexture(buffer, RSOFT_RECT(-sin(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));

			if (rayAngle >= 90 - (fov / 2) && rayAngle <= 90 + (fov / 2))
				RSoft_setTexture(buffer, RSOFT_RECT(-cos(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));

			if (rayAngle >= 220 && rayAngle <= 300)
				RSoft_setTexture(buffer, RSOFT_RECT(cos(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));

			RSoft_drawRectF(win->buffer, RSOFT_RECTF(i, win->r.h / 3.5, 1, height), (u8[4]){255, 255, 255, 255});	
		}
			

		if (RGFW_isPressed(win, RGFW_Tab)) {
			for (size_t y = 0; y < map_height; y++) {
				for (size_t x = 0; x < map_width; x++) {
					if (map[(y * map_width) + x]) {
						RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 50, 50), RSOFT_AREA(w, h));
						RSoft_drawRect(win->buffer, RSOFT_RECT(x * 50, y * 50, 50, 50), (u8[4]){255, 255, 255, 255});	
					}
				}
			}

			RSoft_drawRect(win->buffer, RSOFT_RECT((player.x * 50) - 10, (player.y * 50) - 10, 20, 20), (u8[4]){255, 0, 0, 255});	
		}

		RGFW_window_swapBuffers(win);
    }
	
	free(buffer);
    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/raycaster.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="raycaster.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_matrix rotateAroundCenter(RSoft_vector center, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_rotateMatrix(m, angle, 1, 1, 1);
	m = RSoft_translateMatrix(m, center);
	return m;
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Shapes example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
	
	float angle = 0;

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        } 
		
		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 15});
		RSoft_vector v1 = RSOFT_VECTOR2D(700, 100);	
		RSoft_vector v2 = RSOFT_VECTOR2D(500, 100);	
		RSoft_vector v3 = RSOFT_VECTOR2D(600, 200);

		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 150), angle));
		RSoft_drawTriangleF(win->buffer, (RSoft_vector[3]){v1, v2, v3}, (u8[4]){0, 255, 0, 255});
	
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(250, 250), angle));
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(150, 150, 200, 200), (u8[4]){0, 255, 0, 255}); 
		
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(200, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(200, 600, 100, 100), 6, (u8[4]){0, 255, 0, 255});
	
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(500, 600, 100, 100), 36, (u8[4]){0, 255, 0, 255});

		angle++;
		RGFW_window_swapBuffers(win);
    }

    RGFW_window_close(win);
}

/*
* Copyright (c) 2021-24 ColleagueRiley ColleagueRiley@gmail.com
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following r estrictions:
*
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*
*
*/

/*
preprocessor args

make sure 

** #define RFONT_IMPLEMENTATION ** - include function defines

is in exactly one of your files or arguments

#define RFONT_NO_OPENGL - do not define graphics functions (that use opengl)
#define RFONT_NO_STDIO - do not include stdio.h
#define RFONT_EXTERNAL_STB - load stb_truetype from stb_truetype.h instead of using the internal version
#define RFONT_NO_GRAPHICS - do not include any graphics functions at all
#define RFONT_RENDER_RGL - use RGL functions for rendering
#define RFONT_RENDER_LEGACY - use opengl legacy functions for rendering (if RGL is not chosen)
-- NOTE: By default, opengl 3.3 vbos are used for rendering --
*/

/*
credits :

stb_truetype.h - a dependency for RFont, most of (a slightly motified version of) stb_truetype.h is included directly into RFont.h
http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ - UTF-8 decoding function
fontstash - fontstash was used as a refference for some parts
*/

/*

... = [add code here]

BASIC TEMPLATE :
#define RFONT_IMPLEMENTATION
#include "RFont.h"

...

int main () {
   ...

   RFont_init(window_width, window_height);

   RFont_font* font = RFont_font_init("font.ttf");

   while (1) {
      ...
      RFont_draw_text(font, "text", 100, 100, 20);
      ...
   }

   RFont_font_free(font);
   RFont_close();
   ...
}
*/


#ifndef RFONT_NO_STDIO
#include <stdio.h>
#endif

#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <string.h>

#if !defined(u8)
	#if defined(_MSC_VER) || defined(__SYMBIAN32__)
		typedef unsigned char 	u8;
		typedef signed char		i8;
		typedef unsigned short  u16;
		typedef signed short 	i16;
		typedef unsigned int 	u32;
		typedef signed int		i32;
		typedef unsigned long	u64;
		typedef signed long		i64;
	#else
		#include <stdint.h>

		typedef uint8_t     u8;
		typedef int8_t      i8;
		typedef uint16_t   u16;
		typedef int16_t    i16;
		typedef uint32_t   u32;
		typedef int32_t    i32;
		typedef uint64_t   u64;
		typedef int64_t    i64;
	#endif
#endif

#if !defined(b8)
	typedef u8 b8;
#endif
/* 
You can define these yourself if 
you want to change anything
*/

#ifndef RFONT_MAX_GLYPHS
#define RFONT_MAX_GLYPHS 652
#endif

#ifndef RFONT_ATLAS_WIDTH
#define RFONT_ATLAS_WIDTH 6000
#endif

#ifndef RFONT_ATLAS_HEIGHT
#define RFONT_ATLAS_HEIGHT 400
#endif

#ifndef RFONT_INIT_TEXT_SIZE
#define RFONT_INIT_TEXT_SIZE 500
#endif

#ifndef RFONT_INIT_VERTS
#define RFONT_INIT_VERTS 1024
#endif

#ifndef RFONT_TEXTFORMAT_MAX_SIZE
   #define RFONT_TEXTFORMAT_MAX_SIZE 923
#endif

#ifndef RFONT_VSNPRINTF
#define RFONT_VSNPRINTF vsnprintf
#endif

#ifndef RFONT_UNUSED
#define RFONT_UNUSED(x) (void) (x);
#endif

/* make sure RFont declares aren't declared twice */
#ifndef RFONT_H
#define RFONT_H

#ifndef RFont_area
typedef struct { u32 w, h; } RFont_area;
#endif

typedef struct RFont_font RFont_font;

typedef struct {
   u32 codepoint; /* the character (for checking) */
   size_t size; /* the size of the glyph */
   i32 x, x2;  /* coords of the character on the texture */

   /* source glyph data */
   i32 src;
   float w, h, x1, y1, advance;
} RFont_glyph;

/**
 * @brief Sets the framebuffer size AND runs the graphics init function.
 * @param width The framebuffer width.
 * @param height The framebuffer height.
*/
inline void RFont_init(size_t width, size_t height);
/**
 * @brief Frees data allocated by the RFont for the RFont
*/
inline void RFont_close(void);
/**
 * @brief Just updates the framebuffer size.
 * @param width The framebuffer width.
 * @param height The framebuffer height.
*/
inline void RFont_update_framebuffer(size_t width, size_t height);

#ifndef RFONT_NO_STDIO
/**
 * @brief Init font stucture with a TTF file path.
 * @param font_name The TTF file path.
 * @return The `RFont_font` created using the TTF file data.
*/
inline RFont_font* RFont_font_init(const char* font_name);
#endif


/**
 * @brief Init font stucture with raw TTF data.
 * @param font_data The raw TTF data.
 * @param auto_free If the memory should be automatically freed by `RFont_font_free`.
 * @return The `RFont_font` created from the data.
*/
inline RFont_font* RFont_font_init_data(u8* font_data, b8 auto_free);

/**
 * @brief Free data from the font stucture, including the stucture itself
 * @param font The font stucture to free
*/
inline void RFont_font_free(RFont_font* font);

/**
 * @brief Add a character to the font's atlas.
 * @param font The font to use.
 * @param ch The character to add to the atlas.
 * @param size The size of the character.
 * @return The `RFont_glyph` created from the data and added to the atlas.
*/
inline RFont_glyph RFont_font_add_char(RFont_font* font, char ch, size_t size);

#ifndef RFONT_NO_FMT
/**
 * @brief Formats a string.
 * @param string The source string
 * @param ... format data
 * @return The formatted string 
*/
inline const char* RFont_fmt(const char* string, ...);
#endif

/**
 * @brief Add a string to the font's atlas.
 * @param font The font to use.
 * @param ch The character to add to the atlas.
 * @param sizes The supported sizes of the character.
 * @param sizeLen length of the size array
*/
inline void RFont_font_add_string(RFont_font* font, const char* string, size_t* sizes, size_t sizeLen);

/**
 * @brief Add a string to the font's atlas based on a given string length.
 * @param font The font to use.
 * @param ch The character to add to the atlas.
 * @param strLen length of the string
 * @param sizes The supported sizes of the character.
 * @param sizeLen length of the size array
*/
inline void RFont_font_add_string_len(RFont_font* font, const char* string, size_t strLen, size_t* sizes, size_t sizeLen);

/**
 * @brief Get the area of the text based on the size using the font.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param size The size of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_text_area(RFont_font* font, const char* text, u32 size);

/**
 * @brief Get the area of the text based on the size using the font, using a given length.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param size The size of the text
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_text_area_spacing(RFont_font* font, const char* text, float spacing, u32 size);

/**
 * @brief Get the area of the text based on the size using the font, using a given length.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param len The length of the string
 * @param size The size of the text
 * @param stopNL the number of \n s until it stops (0 = don't stop until the end)
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_text_area_len(RFont_font* font, const char* text, size_t len, u32 size, size_t stopNL, float spacing);

/**
 * @brief Draw a text string using the font.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param x The x position of the text
 * @param y The y position of the text
 * @param size The size of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_draw_text(RFont_font* font, const char* text, float x, float y, u32 size);

/**
 * @brief Draw a text string using the font and a given spacing.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param x The x position of the text
 * @param y The y position of the text
 * @param size The size of the text
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_draw_text_spacing(RFont_font* font, const char* text, float x, float y, u32 size, float spacing);

/**
 * @brief Draw a text string using the font using a given length and a given spacing.
 * @param font The font stucture to use for drawing
 * @param text The string to draw 
 * @param len The length of the string
 * @param x The x position of the text
 * @param y The y position of the text
 * @param size The size of the text
 * @param spacing The spacing of the text
 * @return The area of the text based on the size
*/
inline RFont_area RFont_draw_text_len(RFont_font* font, const char* text, size_t len, float x, float y, u32 size, float spacing);

#define RFont_set_color RFont_render_set_color

#ifndef RFONT_NO_GRAPHICS
/* 
    if you do not want to use opengl (or want to create your own implemntation of these functions), 
    you'll have to define these yourself 
    and add `#define RFONT_NO_OPENGL`
*/
inline void RFont_render_set_color(float r, float g, float b, float a); /* set the current rendering color */
inline void RFont_render_init(void); /* any initalizations the renderer needs to do */
inline u32 RFont_create_atlas(u32 atlasWidth, u32 atlasHeight); /* create a bitmap texture based on the given size */
inline void RFont_bitmap_to_atlas(u32 atlas, u8* bitmap, float x, float y, float w, float h); /* add the given bitmap to the texture based on the given coords and size data */
inline void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts); /* render the text, using the vertices, atlas texture, and texture coords given. */
inline void RFont_render_free(u32 atlas); /* free any memory the renderer might need to free */

/* (if modern opengl is being used) switch to rendering using opengl legacy or not */
inline void RFont_render_legacy(u8 legacy);
#endif

#endif /* RFONT_H */

#ifdef RFONT_IMPLEMENTATION

#ifdef RFONT_EXTERNAL_STB
#define STB_TRUETYPE_IMPLEMENTATION
#include "stb_truetype.h"
#endif

#ifndef RFONT_GET_TEXPOSX 
#define RFONT_GET_TEXPOSX(x) (float)((float)(x) / (float)(RFONT_ATLAS_WIDTH))
#define RFONT_GET_TEXPOSY(y) (float)((float)(y) / (float)(RFONT_ATLAS_HEIGHT))
#endif

#ifndef RFONT_GET_WORLD_X
#define RFONT_GET_WORLD_X(x, w) (float)((x) / (((w) / 2.0f)) - 1.0f)
#define RFONT_GET_WORLD_Y(y, h) (float)(1.0f - ((y) / ((h) / 2.0f)))
#endif

/* 
stb defines required by RFont

you probably don't care about this part if you're reading just the RFont code
*/

#ifndef RFONT_EXTERNAL_STB
// private structure
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

typedef struct stbtt_fontinfo stbtt_fontinfo;

struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              // pointer to .ttf file
   int              fontstart;         // offset of start of font

   int numGlyphs;                     // number of glyphs, needed for range checking

   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf
   int index_map;                     // a cmap mapping for our chosen character encoding
   int indexToLocFormat;              // format needed to map from glyph index to glyph

   stbtt__buf cff;                    // cff font data
   stbtt__buf charstrings;            // the charstring index
   stbtt__buf gsubrs;                 // global charstring subroutines index
   stbtt__buf subrs;                  // private charstring subroutines index
   stbtt__buf fontdicts;              // array of font dicts
   stbtt__buf fdselect;               // map from glyph to fontdict
};

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern inline
#endif

STBTT_DEF i16 ttSHORT(u8 *p);
STBTT_DEF u16 ttUSHORT(u8 *p); 
STBTT_DEF u32 ttULONG(u8 *p);

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);

STBTT_DEF unsigned char* stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
#endif /* RFONT_EXTERNAL_STB */

/* 
END of stb defines required by RFont

you probably care about this part 
*/

#ifndef RFONT_NO_FMT
#include <stdarg.h>

const char* RFont_fmt(const char* string, ...) {
   static char output[RFONT_TEXTFORMAT_MAX_SIZE];

   va_list args;
   va_start(args, string);
   
   RFONT_VSNPRINTF(output, RFONT_TEXTFORMAT_MAX_SIZE, string, args);
   va_end(args);

   return output;
}
#endif

struct RFont_font {
   stbtt_fontinfo info; /* source stb font */
   b8 free_font_memory;
   float fheight; /* font height from stb */
   float descent; /* font descent */
   float numOfLongHorMetrics;
   float space_adv;

   RFont_glyph glyphs[RFONT_MAX_GLYPHS]; /* glyphs */
   size_t glyph_len;

   u32 atlas; /* atlas texture */
   float atlasX; /* the current x position inside the atlas */
};

size_t RFont_width = 0, RFont_height = 0;

float* RFont_verts;
float* RFont_tcoords;

RFont_font* font2;

void RFont_update_framebuffer(size_t width, size_t height) {
   /* set size of the framebuffer (for rendering later on) */
   RFont_width = width;
   RFont_height = height;
}

void RFont_init(size_t width, size_t height) {
    RFont_update_framebuffer(width, height);

    #ifndef RFONT_NO_GRAPHICS
    /* init any rendering stuff that needs to be initalized (eg. vbo objects) */
    RFont_render_init();
    #endif

   RFont_verts = malloc(sizeof(float) * RFONT_INIT_VERTS * 600);
   RFont_tcoords = malloc(sizeof(float) * RFONT_INIT_VERTS * 600);
}

#ifndef RFONT_NO_STDIO
RFont_font* RFont_font_init(const char* font_name) {
   FILE* ttf_file = fopen(font_name, "rb");

   fseek(ttf_file, 0U, SEEK_END);
   size_t size = ftell(ttf_file);

   char* ttf_buffer = (char*)malloc(sizeof(char) * size); 
   fseek(ttf_file, 0U, SEEK_SET);

   size_t out = fread(ttf_buffer, 1, size, ttf_file);
   RFONT_UNUSED(out)


   return RFont_font_init_data((u8*)ttf_buffer, 1);
}
#endif

RFont_font* RFont_font_init_data(u8* font_data, b8 auto_free) {
   RFont_font* font = (RFont_font*)malloc(sizeof(RFont_font));

   stbtt_InitFont(&font->info, font_data, 0);

   font->fheight = ttSHORT(font->info.data + font->info.hhea + 4) - ttSHORT(font->info.data + font->info.hhea + 6);
   font->descent = ttSHORT(font->info.data + font->info.hhea + 6);

   font->numOfLongHorMetrics = ttUSHORT(font->info.data + font->info.hhea + 34);
   font->space_adv = ttSHORT(font->info.data + font->info.hmtx + 4 * (u32)(font->numOfLongHorMetrics - 1));
 

   #ifndef RFONT_NO_GRAPHICS
   font->atlas = RFont_create_atlas(RFONT_ATLAS_WIDTH, RFONT_ATLAS_HEIGHT);
   #endif
   font->atlasX = 0;
   font->glyph_len = 0;

   font->free_font_memory = auto_free;
   
   return font;
}

void RFont_font_free(RFont_font* font) {
   #ifndef RFONT_NO_GRAPHICS
   RFont_render_free(font->atlas);
   #endif

   if (font->free_font_memory)
      free(font->info.data);
   
   free(font);
}

void RFont_close(void) {
   free(RFont_verts);
   free(RFont_tcoords);
}


/*
decode utf8 character to codepoint 
*/

// Copyright (c) 2008-2010 Bjoern Hoehrmann <bjoern@hoehrmann.de>
// See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.

#define RFONT_UTF8_ACCEPT 0
#define RFont_UTF8_REJECT 12

inline static u32 RFont_decode_utf8(u32* state, u32* codep, u32 byte);

static u32 RFont_decode_utf8(u32* state, u32* codep, u32 byte) {
   static const uint8_t utf8d[] = {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..1f
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 20..3f
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40..5f
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60..7f
      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, // 80..9f
      7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, // a0..bf
      8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // c0..df
      0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, // e0..ef
      0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, // f0..ff
      0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, // s0..s0
      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, // s1..s2
      1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, // s3..s4
      1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, // s5..s6
      1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // s7..s8
   };

   uint32_t type = utf8d[byte];

   *codep = (*state != RFONT_UTF8_ACCEPT) ?
      (byte & 0x3fu) | (*codep << 6) :
      (0xff >> type) & (byte);

   *state = utf8d[256 + *state * 16 + type];
   return *state;
}

void RFont_font_add_string(RFont_font* font, const char* string, size_t* sizes, size_t sizeLen) {
   RFont_font_add_string_len(font, string, 0, sizes, sizeLen);
}

void RFont_font_add_string_len(RFont_font* font, const char* string, size_t strLen, size_t* sizes, size_t sizeLen) {
   u32 i;
   char* str;
   for (str = (char*)string; (!strLen || (size_t)(str - string) < strLen) && *str; str++)
      for (i = 0; i < sizeLen; i++)
         RFont_font_add_char(font, *str, sizes[i]);
}


RFont_glyph RFont_font_add_char(RFont_font* font, char ch, size_t size) {
   static u32 utf8state = 0, codepoint = 0; 

   if (RFont_decode_utf8(&utf8state, &codepoint, (u8)ch) != RFONT_UTF8_ACCEPT)
      return (RFont_glyph){0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

	u32 i;
   for (i = 0; i < font->glyph_len; i++)
      if (font->glyphs[i].codepoint == codepoint && font->glyphs[i].size == size)
         return font->glyphs[i];

   RFont_glyph* glyph = &font->glyphs[i];

   glyph->src = stbtt_FindGlyphIndex(&font->info, codepoint);

   if (glyph->src == 0 && font2 != NULL && font2->info.data != font->info.data) {
      stbtt_fontinfo saveInfo = font->info;

      RFont_font* fakeFont = font;
      fakeFont->info = font2->info;

      RFont_glyph g = RFont_font_add_char(fakeFont, 't', size);

      fakeFont->info = saveInfo;

      return g;
   }

   font->glyph_len++;

   i32 x0, y0, x1, y1, w = 0, h = 0;
   if (stbtt_GetGlyphBox(&font->info, glyph->src, &x0, &y0, &x1, &y1) == 0)
      return (RFont_glyph){0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

   float scale = ((float)size) / font->fheight;

   u8* bitmap =  stbtt_GetGlyphBitmapSubpixel(&font->info, 0, scale, 0.0f, 0.0f, glyph->src, &w, &h, 0, 0);

   glyph->w = (float)w;
   glyph->h = (float)h;

   glyph->codepoint = codepoint;
   glyph->size = size;
   glyph->x = font->atlasX;
   glyph->x2 = font->atlasX + glyph->w;
   glyph->x1 = floorf(x0 * scale);
   glyph->y1 = floor(-y1 * scale);

   #ifndef RFONT_NO_GRAPHICS
   RFont_bitmap_to_atlas(font->atlas, bitmap, font->atlasX, 0, glyph->w, glyph->h);
   #endif

   font->atlasX += glyph->w;

   free(bitmap);

   i32 advanceX;
   
   if (glyph->src < font->numOfLongHorMetrics)
      advanceX = ttSHORT(font->info.data + font->info.hmtx + 4 * glyph->src);
   else
      advanceX = ttSHORT(font->info.data + font->info.hmtx + 4 * (u32)(font->numOfLongHorMetrics - 1));

   glyph->advance = advanceX * scale;

   return *glyph;
}

RFont_area RFont_text_area(RFont_font* font, const char* text, u32 size) {
   return RFont_text_area_len(font, text, 0, size, 0, 0.0f);
}

RFont_area RFont_text_area_spacing(RFont_font* font, const char* text, float spacing, u32 size) {
   return RFont_text_area_len(font, text, 0, size, 0, spacing);
}

RFont_area RFont_text_area_len(RFont_font* font, const char* text, size_t len, u32 size, size_t stopNL, float spacing) {
   float x = 0;
   size_t y = 1;

   char* str;

   float scale = (((float)size) / font->fheight);

   float space_adv = (scale * font->space_adv) / 2;
   
   for (str = (char*)text; (len == 0 || (size_t)(str - text) < len) && *str; str++) {        
      if (*str == '\n') { 
         if (y == stopNL)
            return (RFont_area){(u32)x, y * size};
         
         y++;
         x = 0;
         continue;
      }
      
      if (*str == ' ' || *str == '\t') {
         x += space_adv + spacing;
         continue;
      }

      RFont_glyph glyph = RFont_font_add_char(font,  *str, size);

      if (glyph.codepoint == 0 && glyph.size == 0)
         continue;
      
      x += (float)glyph.advance + spacing;
   }

   return (RFont_area){(u32)x, y * size};
}

RFont_area RFont_draw_text(RFont_font* font, const char* text, float x, float y, u32 size) {
   return RFont_draw_text_len(font, text, 0, x, y, size, 0.0f);
}

RFont_area RFont_draw_text_spacing(RFont_font* font, const char* text, float x, float y, u32 size, float spacing) {
   return RFont_draw_text_len(font, text, 0, x, y, size, spacing);
}

RFont_area RFont_draw_text_len(RFont_font* font, const char* text, size_t len, float x, float y, u32 size, float spacing) {
   float* verts = RFont_verts;
   float* tcoords = RFont_tcoords;

   float startX = x;
   float startY = y;
   
   y += size;

   u32 i = 0;
   u32 tIndex = 0;

   char* str;

   float scale = (((float)size) / font->fheight);
   float space_adv = (scale * font->space_adv) / 2;

   y -= (-font->descent * scale);

   for (str = (char*)text; (len == 0 || (size_t)(str - text) < len) && *str; str++) {        
      if (*str == '\n') { 
         x = startX;
         y += size;
         continue;
      }

      if (*str == ' ' || *str == '\t') {
         x += space_adv + spacing;
         continue;
      }

      RFont_glyph glyph = RFont_font_add_char(font, *str, size);

      if (glyph.codepoint == 0 && glyph.size == 0)
         continue;

      float realX = x + glyph.x1;
      float realY = y + glyph.y1;

      verts[i] = RFONT_GET_WORLD_X((i32)realX, RFont_width); 
      verts[i + 1] = RFONT_GET_WORLD_Y(realY, RFont_height);
      verts[i + 2] = 0;
      /*  */
      verts[i + 3] = RFONT_GET_WORLD_X((i32)realX, RFont_width);
      verts[i + 4] = RFONT_GET_WORLD_Y(realY + glyph.h , RFont_height);
      verts[i + 5] = 0;
      /*  */
      verts[i + 6] = RFONT_GET_WORLD_X((i32)(realX + glyph.w), RFont_width);
      verts[i + 7] = RFONT_GET_WORLD_Y(realY + glyph.h , RFont_height);
      verts[i + 8] = 0;
      /*  */
      /*  */
      verts[i + 9] = RFONT_GET_WORLD_X((i32)(realX + glyph.w), RFont_width);
      verts[i + 10] = RFONT_GET_WORLD_Y(realY, RFont_height);
      verts[i + 11] = 0;
      /*  */
      verts[i + 12] = RFONT_GET_WORLD_X((i32)realX, RFont_width); 
      verts[i + 13] = RFONT_GET_WORLD_Y(realY, RFont_height);
      verts[i + 14] = 0;
      /*  */

      verts[i + 15] = RFONT_GET_WORLD_X((i32)(realX + glyph.w), RFont_width);
      verts[i + 16] = RFONT_GET_WORLD_Y(realY + glyph.h , RFont_height);
      verts[i + 17] = 0;

      /* texture coords */

      //#if defined(RFONT_RENDER_LEGACY) || defined(RFONT_RENDER_RGL)
      tcoords[tIndex] = RFONT_GET_TEXPOSX(glyph.x);
      tcoords[tIndex + 1] = 0;
      //#endif

      /*  */
      tcoords[tIndex + 2] = RFONT_GET_TEXPOSX(glyph.x); 
      tcoords[tIndex + 3] = RFONT_GET_TEXPOSY(glyph.h);
      /*  */
      tcoords[tIndex + 4] = RFONT_GET_TEXPOSX(glyph.x2);
      tcoords[tIndex + 5] = RFONT_GET_TEXPOSY(glyph.h);
      /*  */
      /*  */
      tcoords[tIndex + 6] = RFONT_GET_TEXPOSX(glyph.x2);
      tcoords[tIndex + 7] = 0;
      /*  */
      tcoords[tIndex + 8] = RFONT_GET_TEXPOSX(glyph.x);
      tcoords[tIndex + 9] = 0;
      /*  */ 
      tcoords[tIndex + 10] = RFONT_GET_TEXPOSX(glyph.x2);
      tcoords[tIndex + 11] = RFONT_GET_TEXPOSY(glyph.h);

      i += 18;
      tIndex += 12;

      x += glyph.advance + spacing;
   }

   #ifndef RFONT_NO_GRAPHICS
   RFont_render_text(font->atlas, verts, tcoords, i / 3);
   #endif
   
   return (RFont_area){(u32)(x - startX), (u32)(y - startY) + (-font->descent * scale)};
}

#ifndef __APPLE__
#include <GL/gl.h>
#else
#include <OpenGL/gl.h>
#endif

#if !defined(RFONT_NO_OPENGL) && !defined(RFONT_NO_GRAPHICS)

#if !defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL)
#define GL_GLEXT_PROTOTYPES
#endif

#ifndef GL_PERSPECTIVE_CORRECTION_HINT
#define GL_PERSPECTIVE_CORRECTION_HINT		0x0C50
#endif

#ifndef GL_TEXTURE_SWIZZLE_RGBA
#define GL_TEXTURE_SWIZZLE_RGBA           0x8E46
#endif

#ifndef GL_TEXTURE0
#define GL_TEXTURE0				0x84C0
#endif

#ifndef GL_CLAMP_TO_EDGE
#define GL_CLAMP_TO_EDGE			0x812F
#endif

#ifdef RFONT_DEBUG

#ifndef GL_DEBUG_TYPE_ERROR
#define GL_DEBUG_TYPE_ERROR               0x824C
#define GL_DEBUG_OUTPUT                   0x92E0
#define GL_DEBUG_OUTPUT_SYNCHRONOUS       0x8242
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_INFO_LOG_LENGTH                0x8B84 
#endif

void RFont_debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char* message, const void* userParam) {
    RFONT_UNUSED(source) RFONT_UNUSED(id) RFONT_UNUSED(severity) RFONT_UNUSED(length) RFONT_UNUSED(userParam)

    if (type != GL_DEBUG_TYPE_ERROR)
        return;

    printf("OpenGL Debug Message: %s\n", message);
}

void RFont_opengl_getError(void) {
    GLenum err;
    while ((err = glGetError()) != GL_NO_ERROR) {
         switch (err) {
            case GL_INVALID_ENUM:
                  printf("OpenGL error: GL_INVALID_ENUM\n");
                  break;
            case GL_INVALID_VALUE:
                  printf("OpenGL error: GL_INVALID_VALUE\n");
                  break;
            case GL_INVALID_OPERATION:
                  printf("OpenGL error: GL_INVALID_OPERATION\n");
                  break;
            case GL_STACK_OVERFLOW:
                  printf("OpenGL error: GL_STACK_OVERFLOW\n");
                  break;
            case GL_STACK_UNDERFLOW:
                  printf("OpenGL error: GL_STACK_UNDERFLOW\n");
                  break;	
            default:
                  printf("OpenGL error: Unknown error code 0x%x\n", err);
                  break;
         }
         exit(1);
    }
}

#endif

u32 RFont_create_atlas(u32 atlasWidth, u32 atlasHeight) {
 #if defined(RFONT_DEBUG) && !defined(RFONT_RENDER_LEGACY)
   glEnable(GL_DEBUG_OUTPUT);
   #endif
   
   u32 id = 0;
   glEnable(GL_TEXTURE_2D);
   
   glBindTexture(GL_TEXTURE_2D, 0);
   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
   glGenTextures(1, &id);

   glBindTexture(GL_TEXTURE_2D, id);

   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
   
   u8* data = (u8*)calloc(atlasWidth * atlasHeight * 4, sizeof(u8));

   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, atlasWidth, atlasHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

   free(data);

   glBindTexture(GL_TEXTURE_2D, id);
	static GLint swizzleRgbaParams[4] = {GL_ONE, GL_ONE, GL_ONE, GL_RED};
	glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_RGBA, swizzleRgbaParams);

   glBindTexture(GL_TEXTURE_2D, 0);
   return id;
}

#ifndef GL_UNPACK_ROW_LENGTH
#define GL_UNPACK_ROW_LENGTH 0x0CF2
#define GL_UNPACK_SKIP_PIXELS 0x0CF4
#define GL_UNPACK_SKIP_ROWS 0x0CF3
#endif


void RFont_push_pixel_values(GLint alignment, GLint rowLength, GLint skipPixels, GLint skipRows);
void RFont_push_pixel_values(GLint alignment, GLint rowLength, GLint skipPixels, GLint skipRows) {
	glPixelStorei(GL_UNPACK_ALIGNMENT, alignment);
	glPixelStorei(GL_UNPACK_ROW_LENGTH, rowLength);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS, skipPixels);
	glPixelStorei(GL_UNPACK_SKIP_ROWS, skipRows);
}

void RFont_bitmap_to_atlas(u32 atlas, u8* bitmap, float x, float y, float w, float h) {
   glEnable(GL_TEXTURE_2D);
   
	GLint alignment, rowLength, skipPixels, skipRows;
   glGetIntegerv(GL_UNPACK_ALIGNMENT, &alignment);
	glGetIntegerv(GL_UNPACK_ROW_LENGTH, &rowLength);
	glGetIntegerv(GL_UNPACK_SKIP_PIXELS, &skipPixels);
	glGetIntegerv(GL_UNPACK_SKIP_ROWS, &skipRows);
   
   #if !defined(RFONT_RENDER_LEGACY)
   glActiveTexture(GL_TEXTURE0 + atlas - 1);
   #endif

	glBindTexture(GL_TEXTURE_2D, atlas);

	RFont_push_pixel_values(1, w, 0, 0);

	glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, w, h, GL_RED, GL_UNSIGNED_BYTE, bitmap);

	RFont_push_pixel_values(alignment, rowLength, skipPixels, skipRows);

   glBindTexture(GL_TEXTURE_2D, 0);
}

#if defined(RFONT_RENDER_RGL) && !defined(RFONT_CUSTOM_GL)

void RFont_render_set_color(float r, float g, float b, float a) {
   rglColor4f(r, g, b, a);
}

void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
   glEnable(GL_TEXTURE_2D);
   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
   glShadeModel(GL_SMOOTH);

   rglMatrixMode(RGL_MODELVIEW);
   rglLoadIdentity();
	rglPushMatrix();

   glDisable(GL_DEPTH_TEST);
   glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_CULL_FACE);    

   glEnable(GL_BLEND);
   glEnable(GL_TEXTURE_2D);
   
   glActiveTexture(GL_TEXTURE0);

   rglSetTexture(atlas);
   
	rglBegin(RGL_TRIANGLES_2D);

	size_t i;
   size_t tIndex = 0;

	for (i = 0; i < (nverts * 3); i += 3) {
		rglTexCoord2f(tcoords[tIndex], tcoords[tIndex + 1]);
      tIndex += 2;
		
      rglVertex2f(verts[i], verts[i + 1]);
	}
	rglEnd();
	rglPopMatrix();
   
   rglSetTexture(0);
   glBindTexture(GL_TEXTURE_2D, 0);
   glEnable(GL_DEPTH_TEST);
}

void RFont_render_free(u32 atlas) { glDeleteTextures(1, &atlas); }
void RFont_render_legacy(u8 legacy) { rglLegacy(legacy); }
void RFont_render_init() {}
#endif /* RFONT_RENDER_RGL */

#if defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL) && !defined(RFONT_CUSTOM_GL)

void RFont_render_set_color(float r, float g, float b, float a) {
   glColor4f(r, g, b, a);
}

void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
   glEnable(GL_TEXTURE_2D);
   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
   glShadeModel(GL_SMOOTH);

   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   glDisable(GL_DEPTH_TEST);
   glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_CULL_FACE);    

   glEnable(GL_BLEND);
   glEnable(GL_TEXTURE_2D);
   #if !defined(RFONT_RENDER_LEGACY)
   glActiveTexture(GL_TEXTURE0 + atlas - 1);
   #endif

   glBindTexture(GL_TEXTURE_2D, atlas);

	glPushMatrix();

	glBegin(GL_TRIANGLES);

	size_t i;
   size_t tIndex = 0;

	for (i = 0; i < (nverts * 3); i += 3) {
		glTexCoord2f(tcoords[tIndex], tcoords[tIndex + 1]);
		tIndex += 2;

      glVertex2f(verts[i], verts[i + 1]);
	}
	glEnd();
	glPopMatrix();

   glBindTexture(GL_TEXTURE_2D, 0);
   glEnable(GL_DEPTH_TEST);
}

void RFont_render_free(u32 atlas) { glDeleteTextures(1, &atlas); }
void RFont_render_legacy(u8 legacy) { RFONT_UNUSED(legacy) }
void RFont_render_init() {}
#endif /* defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL)  */

#if !defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL)
typedef struct {
   GLuint vao, vbo, tbo, cbo, ebo,
            program, vShader, fShader;
   
   u8 legacy;
} RFont_gl_info;

RFont_gl_info RFont_gl = { 0 };

float RFont_color[4] = {0, 0, 0, 1};

#ifdef RFONT_DEBUG
inline void RFont_debug_shader(u32 src, const char* shader, const char* action);
void RFont_debug_shader(u32 src, const char* shader, const char* action) {
    GLint status;
    if (action[0] == 'l')
        glGetProgramiv(src, GL_LINK_STATUS, &status);
    else
        glGetShaderiv(src, GL_COMPILE_STATUS, &status);

    if (status == GL_TRUE) 
        printf("%s Shader %s successfully.\n", shader, action);
    else {
        printf("%s Shader failed to %s.\n", shader, action);

        if (action[0] == 'c') {
            GLint infoLogLength;
            glGetShaderiv(src, GL_INFO_LOG_LENGTH, &infoLogLength);

            if (infoLogLength > 0) {
                GLchar* infoLog = (GLchar*)malloc(infoLogLength);
                glGetShaderInfoLog(src, infoLogLength, NULL, infoLog);
                printf("%s Shader info log:\n%s\n", shader, infoLog);
                free(infoLog);
            }
        }
        
        RFont_opengl_getError();
    }
}
#endif

#define RFONT_MULTILINE_STR(...) #__VA_ARGS__

void RFont_render_set_color(float r, float g, float b, float a) {
   if (RFont_gl.legacy)
      return glColor4f(r, g, b, a);
   
   RFont_color[0] = r;
   RFont_color[1] = g;
   RFont_color[2] = b;
   RFont_color[3] = a;
}

void RFont_render_init() {
   if (RFont_gl.vao != 0 || RFont_gl.legacy)
      return;

   static const char* defaultVShaderCode = RFONT_MULTILINE_STR(
      \x23version 330 core       \n
      layout (location = 0) in vec3 vertexPosition;
      layout (location = 1) in vec2 vertexTexCoord;
      layout (location = 2) in vec4 inColor;
      out vec2 fragTexCoord;
      out vec4 fragColor;

      uniform mat4 mvp;          \n
      void main() {
         fragColor = inColor;
         gl_Position = vec4(vertexPosition, 1.0);
         fragTexCoord = vertexTexCoord;
      }
   );

   static const char* defaultFShaderCode = RFONT_MULTILINE_STR(
      \x23version 330 core                \n
      out vec4 FragColor;
      
      in vec4 fragColor;
      in vec2 fragTexCoord;

      uniform sampler2D texture0;

      void main() {
         FragColor = texture(texture0, fragTexCoord) * fragColor;
      }
   );
   
   glGenVertexArrays(1, &RFont_gl.vao);
   glBindVertexArray(RFont_gl.vao);

   glGenBuffers(1, &RFont_gl.vbo);
   glGenBuffers(1, &RFont_gl.tbo);
   glGenBuffers(1, &RFont_gl.cbo);
   glGenBuffers(1, &RFont_gl.ebo);
   /* compile vertex shader */
   RFont_gl.vShader = glCreateShader(GL_VERTEX_SHADER);
   glShaderSource(RFont_gl.vShader, 1, &defaultVShaderCode, NULL);
   glCompileShader(RFont_gl.vShader);

   #ifdef RFONT_DEBUG
   RFont_debug_shader(RFont_gl.vShader, "Vertex", "compile");
   #endif

   /* compile fragment shader */
   RFont_gl.fShader = glCreateShader(GL_FRAGMENT_SHADER);
   glShaderSource(RFont_gl.fShader, 1, &defaultFShaderCode, NULL);
   glCompileShader(RFont_gl.fShader);


   #ifdef RFONT_DEBUG
   RFont_debug_shader(RFont_gl.fShader, "Fragment", "compile");
   #endif

   /* create program and link vertex and fragment shaders */
   RFont_gl.program = glCreateProgram();

   glAttachShader(RFont_gl.program, RFont_gl.vShader);
   glAttachShader(RFont_gl.program, RFont_gl.fShader);

   glBindAttribLocation(RFont_gl.program, 0, "vertexPosition");
   glBindAttribLocation(RFont_gl.program, 1, "vertexTexCoord");
   glBindAttribLocation(RFont_gl.program, 2, "inColor");

   glLinkProgram(RFont_gl.program);

   #ifdef RFONT_DEBUG
   RFont_debug_shader(RFont_gl.program, "Both", "link to the program");
   #endif
}
     
void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
   glEnable(GL_TEXTURE_2D);
   glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

   glDisable(GL_DEPTH_TEST);
   glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_CULL_FACE);    

   glEnable(GL_BLEND);
   glShadeModel(GL_SMOOTH);

   if (RFont_gl.legacy) {
      glMatrixMode(GL_MODELVIEW);
      glLoadIdentity();

      glBindTexture(GL_TEXTURE_2D, atlas);
      glPushMatrix();

      glBegin(GL_TRIANGLES);

      size_t i;
      size_t tIndex = 0;

      for (i = 0; i < (nverts * 3); i += 3) {
         glTexCoord2f(tcoords[tIndex], tcoords[tIndex + 1]);
         tIndex += 2;
         
         glVertex2f(verts[i], verts[i + 1]);
      }
      glEnd();
      glPopMatrix();
   } else {
      glBindVertexArray(RFont_gl.vao);

      glUseProgram(RFont_gl.program);

      glEnableVertexAttribArray(0);
      glBindBuffer(GL_ARRAY_BUFFER, RFont_gl.vbo);
      glBufferData(GL_ARRAY_BUFFER, nverts * 3 * sizeof(float), verts, GL_DYNAMIC_DRAW);
      glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL);

      glEnableVertexAttribArray(1);
      glBindBuffer(GL_ARRAY_BUFFER, RFont_gl.tbo);
      glBufferData(GL_ARRAY_BUFFER, nverts * 2 * sizeof(float), tcoords, GL_DYNAMIC_DRAW);
      glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, NULL);

      float* colors = malloc(sizeof(float) * nverts * 4);

      u32 i = 0;
      for (i = 0; i < (nverts * 4); i += 4) {
         colors[i] = RFont_color[0];
         colors[i + 1] = RFont_color[1];
         colors[i + 2] = RFont_color[2];
         colors[i + 3] = RFont_color[3];
      }

      glEnableVertexAttribArray(2);
      glBindBuffer(GL_ARRAY_BUFFER, RFont_gl.cbo);
      glBufferData(GL_ARRAY_BUFFER, nverts * 4 * sizeof(float), colors, GL_DYNAMIC_DRAW);
      glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, 0, NULL);

      free(colors);

      GLushort* indices = malloc(sizeof(GLushort) * 6 * nverts);
      int k = 0;

      u32 j;
      for (j = 0; j < (6 * nverts); j += 6) {
         indices[j] = 4*  k;
         indices[j + 1] = 4*k + 1;
         indices[j + 2] = 4*k + 2;
         indices[j + 3] = 4*k;
         indices[j + 4] = 4*k + 2;
         indices[j + 5] = 4*k + 3;

         k++;
      }

      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, RFont_gl.ebo);
      glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLushort) * 6 * nverts, indices, GL_STATIC_DRAW);

      free(indices);

      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, atlas);

      glDrawArrays(GL_TRIANGLES, 0, nverts);   
      glUseProgram(0);
   }

   glBindTexture(GL_TEXTURE_2D, 0);
	glDisable(GL_TEXTURE_2D);
   glEnable(GL_DEPTH_TEST);
}

void RFont_render_free(u32 atlas) {
   glDeleteTextures(1, &atlas);

   if (RFont_gl.vao == 0 || RFont_gl.legacy)
      return;
   
   /* free vertex array */
   glDeleteVertexArrays(1, &RFont_gl.vao);
   RFont_gl.vao = 0;

   /* free buffers */
   glDeleteBuffers(1, &RFont_gl.tbo);
   glDeleteBuffers(1, &RFont_gl.vbo);

   /* free program data */
   glDeleteShader(RFont_gl.vShader);
   glDeleteShader(RFont_gl.fShader);
   glDeleteProgram(RFont_gl.program);
}

void RFont_render_legacy(u8 legacy) { RFont_gl.legacy = legacy; }

#endif /* !defined(RFONT_RENDER_LEGACY) && !defined(RFONT_RENDER_RGL) */
#endif /*  !defined(RFONT_NO_OPENGL) && !defined(RFONT_NO_GRAPHICS) */

/* 
stb_truetype defines and source code required by RFont

you probably don't care about this part if you're reading just the RFont code
*/

#ifndef RFONT_EXTERNAL_STB
   typedef char stbtt__check_size32[sizeof(i32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(i16)==2 ? 1 : -1];

   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
   #ifndef STBTT_malloc
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

#ifdef __cplusplus
extern "C" {
#endif

// as above, but takes one or more glyph indices for greater efficiency

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
                   // (we share this with other code at RAD)
   #define stbtt_vertex_type short // can't use i16 because that's not visible in the header file
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);

// @TODO: don't expose this structure
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

// rasterize a shape with quadratic beziers into a bitmap
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
                               float flatness_in_pixels,     // allowable error of curve in pixels
                               stbtt_vertex *vertices,       // array of vertices defining shape
                               int num_verts,                // number of vertices in above array
                               float scale_x, float scale_y, // scale applied to input vertices
                               float shift_x, float shift_y, // translation applied to input vertices
                               int x_off, int y_off,         // another translation applied to input
                               int invert,                   // if non-zero, vertically flip shape
                               void *userdata);              // context for to STBTT_MALLOC

enum { // platformID
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { // languageID for STBTT_PLATFORM_ID_MAC
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

STBTT_DEF u8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

STBTT_DEF u8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

STBTT_DEF void stbtt__buf_seek(stbtt__buf *b, int o)
{
   assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

STBTT_DEF void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

STBTT_DEF u32 stbtt__buf_get(stbtt__buf *b, int n)
{
   u32 v = 0;
   int i;
   assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

STBTT_DEF stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   assert(size < 0x40000000);
   r.data = (u8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

STBTT_DEF stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

STBTT_DEF stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

STBTT_DEF u32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   assert(0);
   return 0;
}

STBTT_DEF void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

STBTT_DEF stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

STBTT_DEF void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, u32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

STBTT_DEF int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

STBTT_DEF stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   assert(i >= 0 && i < count);
   assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

#define ttBYTE(p)     (* (u8 *) (p))
#define ttCHAR(p)     (* (i8 *) (p))
#define ttFixed(p)    ttLONG(p)

STBTT_DEF i16 ttSHORT(u8 *p)   { return p[0]*256 + p[1]; }
STBTT_DEF u16 ttUSHORT(u8 *p) { return p[0]*256 + p[1]; }
STBTT_DEF u32 ttULONG(u8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)          stbtt_tag4(p,str[0],str[1],str[2],str[3])

// @OPTIMIZE: binary search
STBTT_DEF u32 stbtt__find_table(u8 *data, u32 fontstart, const char *tag)
{
   i32 num_tables = ttUSHORT(data+fontstart+4);
   u32 tabledir = fontstart + 12;
   i32 i;
   for (i=0; i < num_tables; ++i) {
      u32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

STBTT_DEF stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   u32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

STBTT_DEF void stbtt_setvertex(stbtt_vertex *v, u8 type, i32 x, i32 y, i32 cx, i32 cy)
{
   v->type = type;
   v->x = (i16) x;
   v->y = (i16) y;
   v->cx = (i16) cx;
   v->cy = (i16) cy;
}

STBTT_DEF int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    i32 sx, i32 sy, i32 scx, i32 scy, i32 cx, i32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

STBTT_DEF int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index);

STBTT_DEF int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   i16 numberOfContours;
   u8 *endPtsOfContours;
   u8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      u8 flags=0,flagcount;
      i32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      i32 x,y,cx,cy,sx,sy, scx,scy;
      u8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

      // first load flags

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      // now load x coordinates
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            i16 dx = *points++;
            x += (flags & 16) ? dx : -dx; // ???
         } else {
            if (!(flags & 16)) {
               x = x + (i16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (i16) x;
      }

      // now load y coordinates
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            i16 dy = *points++;
            y += (flags & 32) ? dy : -dy; // ???
         } else {
            if (!(flags & 32)) {
               y = y + (i16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (i16) y;
      }

      // now convert them to our format
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (i16) vertices[off+i].x;
         y     = (i16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            // now start the new one
            start_off = !(flags & 1);
            if (start_off) {
               // if we start off with an off-curve point, then when we need to find a point on the curve
               // where we can start, and we need to save some state for when we wraparound.
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  // next point is also a curve point, so interpolate an on-point curve
                  sx = (x + (i32) vertices[off+i+1].x) >> 1;
                  sy = (y + (i32) vertices[off+i+1].y) >> 1;
               } else {
                  // otherwise just use the next point as our start point
                  sx = (i32) vertices[off+i+1].x;
                  sy = (i32) vertices[off+i+1].y;
                  ++i; // we're using point i+1 as the starting point, so skip it
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { // if it's a curve
               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours < 0) {
      // Compound shapes.
      int more = 1;
      u8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         u16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;

         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { // XY values
            if (flags & 1) { // shorts
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            // @TODO handle matching point
            assert(0);
         }
         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }

         // Find transformation scales.
         m = (float) sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         // Get indexed glyph.
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            // Transform vertices.
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            // Append vertices.
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0) memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
            memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         // More components ?
         more = flags & (1<<5);
      }
   } else {
      // numberOfCounters == 0, do nothing
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   i32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

STBTT_DEF void stbtt__track_vertex(stbtt__csctx *c, i32 x, i32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

STBTT_DEF void stbtt__csctx_v(stbtt__csctx *c, u8 type, i32 x, i32 y, i32 cx, i32 cy, i32 cx1, i32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (i16) cx1;
      c->pvertices[c->num_vertices].cy1 = (i16) cy1;
   }
   c->num_vertices++;
}

STBTT_DEF void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

STBTT_DEF void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

STBTT_DEF void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

STBTT_DEF void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

STBTT_DEF stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

STBTT_DEF stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      // untested
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) stbtt__new_buf(NULL, 0);
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

STBTT_DEF int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   // this currently ignores the initial width value, which isn't needed if we have hmtx
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      // @TODO implement hinting
      case 0x13: // hintmask
      case 0x14: // cntrmask
         if (in_header)
            maskbits += (sp / 2); // implicit "vstem"
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: // hstem
      case 0x03: // vstem
      case 0x12: // hstemhm
      case 0x17: // vstemhm
         maskbits += (sp / 2);
         break;

      case 0x15: // rmoveto
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: // vmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: // hmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: // rlineto
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
      // starting from a different place.

      case 0x07: // vlineto
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: // hlineto
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: // hvcurveto
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: // vhcurveto
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: // rrcurveto
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: // rcurveline
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: // rlinecurve
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: // vvcurveto
      case 0x1B: // hhcurveto
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: // callsubr
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         // fallthrough
      case 0x1D: // callgsubr
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: // return
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: // endchar
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { // two-byte escape
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         // @TODO These "flex" implementations ignore the flex-depth and resolution,
         // and always draw beziers.
         case 0x22: // hflex
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: // flex
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            //fd is s[12]
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: // hflex1
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: // flex1
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (fabs(dx) > fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254))
            return STBTT__CSERR("reserved operator");

         // push immediate
         if (b0 == 255) {
            f = (float)(i32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(i16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

STBTT_DEF int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   // runs the charstring twice, once to count and once to output (to avoid realloc)
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   u8 *data = info->data + info->kern;
   u32 needle, straw;
   int l, r, m;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); // note: unaligned read
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

STBTT_DEF i32  stbtt__GetCoverageIndex(u8 *coverageTable, int glyph)
{
    u16 coverageFormat = ttUSHORT(coverageTable);
    switch(coverageFormat) {
        case 1: {
            u16 glyphCount = ttUSHORT(coverageTable + 2);

            // Binary search.
            i32 l=0, r=glyphCount-1, m;
            int straw, needle=glyph;
            while (l <= r) {
                u8 *glyphArray = coverageTable + 4;
                u16 glyphID;
                m = (l + r) >> 1;
                glyphID = ttUSHORT(glyphArray + 2 * m);
                straw = glyphID;
                if (needle < straw)
                    r = m - 1;
                else if (needle > straw)
                    l = m + 1;
                else {
                     return m;
                }
            }
        } break;

        case 2: {
            u16 rangeCount = ttUSHORT(coverageTable + 2);
            u8 *rangeArray = coverageTable + 4;

            // Binary search.
            i32 l=0, r=rangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                u8 *rangeRecord;
                m = (l + r) >> 1;
                rangeRecord = rangeArray + 6 * m;
                strawStart = ttUSHORT(rangeRecord);
                strawEnd = ttUSHORT(rangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else {
                    u16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
                    return startCoverageIndex + glyph - strawStart;
                }
            }
        } break;

        default: {
            // There are no other cases.
            assert(0);
        } break;
    }

    return -1;
}

STBTT_DEF i32  stbtt__GetGlyphClass(u8 *classDefTable, int glyph)
{
    u16 classDefFormat = ttUSHORT(classDefTable);
    switch(classDefFormat)
    {
        case 1: {
            u16 startGlyphID = ttUSHORT(classDefTable + 2);
            u16 glyphCount = ttUSHORT(classDefTable + 4);
            u8 *classDef1ValueArray = classDefTable + 6;

            if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
                return (i32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));

            classDefTable = classDef1ValueArray + 2 * glyphCount;
        } break;

        case 2: {
            u16 classRangeCount = ttUSHORT(classDefTable + 2);
            u8 *classRangeRecords = classDefTable + 4;

            // Binary search.
            i32 l=0, r=classRangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                u8 *classRangeRecord;
                m = (l + r) >> 1;
                classRangeRecord = classRangeRecords + 6 * m;
                strawStart = ttUSHORT(classRangeRecord);
                strawEnd = ttUSHORT(classRangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else
                    return (i32)ttUSHORT(classRangeRecord + 4);
            }

            classDefTable = classRangeRecords + 6 * classRangeCount;
        } break;

        default: {
            // There are no other cases.
            assert(0);
        } break;
    }

    return -1;
}

// Define to assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x) assert(x)

STBTT_DEF i32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
    u16 lookupListOffset;
    u8 *lookupList;
    u16 lookupCount;
    u8 *data;
    i32 i;

    if (!info->gpos) return 0;

    data = info->data + info->gpos;

    if (ttUSHORT(data+0) != 1) return 0; // Major version 1
    if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

    lookupListOffset = ttUSHORT(data+8);
    lookupList = data + lookupListOffset;
    lookupCount = ttUSHORT(lookupList);

    for (i=0; i<lookupCount; ++i) {
        u16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
        u8 *lookupTable = lookupList + lookupOffset;

        u16 lookupType = ttUSHORT(lookupTable);
        u16 subTableCount = ttUSHORT(lookupTable + 4);
        u8 *subTableOffsets = lookupTable + 6;
        switch(lookupType) {
            case 2: { // Pair Adjustment Positioning Subtable
                i32 sti;
                for (sti=0; sti<subTableCount; sti++) {
                    u16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
                    u8 *table = lookupTable + subtableOffset;
                    u16 posFormat = ttUSHORT(table);
                    u16 coverageOffset = ttUSHORT(table + 2);
                    i32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
                    if (coverageIndex == -1) continue;

                    switch (posFormat) {
                        case 1: {
                            i32 l, r, m;
                            int straw, needle;
                            u16 valueFormat1 = ttUSHORT(table + 4);
                            u16 valueFormat2 = ttUSHORT(table + 6);
                            i32 valueRecordPairSizeInBytes = 2;
                            u16 pairSetCount = ttUSHORT(table + 8);
                            u16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                            u8 *pairValueTable = table + pairPosOffset;
                            u16 pairValueCount = ttUSHORT(pairValueTable);
                            u8 *pairValueArray = pairValueTable + 2;
                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            assert(coverageIndex < pairSetCount);
                            STBTT__NOTUSED(pairSetCount);

                            needle=glyph2;
                            r=pairValueCount-1;
                            l=0;

                            // Binary search.
                            while (l <= r) {
                                u16 secondGlyph;
                                u8 *pairValue;
                                m = (l + r) >> 1;
                                pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                                secondGlyph = ttUSHORT(pairValue);
                                straw = secondGlyph;
                                if (needle < straw)
                                    r = m - 1;
                                else if (needle > straw)
                                    l = m + 1;
                                else {
                                    i16 xAdvance = ttSHORT(pairValue + 2);
                                    return xAdvance;
                                }
                            }
                        } break;

                        case 2: {
                            u16 valueFormat1 = ttUSHORT(table + 4);
                            u16 valueFormat2 = ttUSHORT(table + 6);

                            u16 classDef1Offset = ttUSHORT(table + 8);
                            u16 classDef2Offset = ttUSHORT(table + 10);
                            int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                            int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                            u16 class1Count = ttUSHORT(table + 12);
                            u16 class2Count = ttUSHORT(table + 14);
                            assert(glyph1class < class1Count);
                            assert(glyph2class < class2Count);

                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {
                                u8 *class1Records = table + 16;
                                u8 *class2Records = class1Records + 2 * (glyph1class * class2Count);
                                i16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                                return xAdvance;
                            }
                        } break;

                        default: {
                            // There are no other cases.
                            assert(0);
                            break;
                        };
                    }
                }
                break;
            };

            default:
                // TODO: Implement other stuff.
                break;
        }
    }

    return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);
   else if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

STBTT_DEF void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

STBTT_DEF void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

STBTT_DEF void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

STBTT_DEF stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   assert(z != NULL);
   if (!z) return z;

   // round dx down to avoid overshooting
   if (dxdy < 0)
      z->dx = -floor(STBTT_FIX * -dxdy);
   else
      z->dx = floor(STBTT_FIX * dxdy);

   z->x = floor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
STBTT_DEF stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   assert(z != NULL);
   //assert(e->y0 <= start_point);
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1

STBTT_DEF void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   // non-zero winding fill
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         // if we're currently at zero, we need to record the edge start point
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         // if we went to zero, we need to draw
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  // x0,x1 are the same pixel, so compute combined coverage
                  scanline[i] = scanline[i] + (u8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) // add antialiasing for x0
                     scanline[i] = scanline[i] + (u8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; // clip

                  if (j < len) // add antialiasing for x1
                     scanline[j] = scanline[j] + (u8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; // clip

                  for (++i; i < j; ++i) // fill pixels between x0 and x1
                     scanline[i] = scanline[i] + (u8) max_weight;
               }
            }
         }
      }

      e = e->next;
   }
}

STBTT_DEF void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  // weight per vertical scanline
   int s; // vertical subsample index
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         // find center of pixel for this scanline
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         // update all active edges;
         // remove all active edges that terminate before the center of this scanline
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; // delete from list
               assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; // advance to position for current scanline
               step = &((*step)->next); // advance through list
            }
         }

         // resort the list if needed
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  // find insertion point
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     // insert at front
                     z->next = active;
                     active = z;
                  } else {
                     // find thing to insert AFTER
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     // at this point, p->next->x is NOT < z->x
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         // now process all active edges in XOR fashion
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

STBTT_DEF void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   assert(y0 < y1);
   assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      assert(x1 <= x+1);
   else if (x0 == x+1)
      assert(x1 >= x);
   else if (x0 <= x)
      assert(x1 <= x);
   else if (x0 >= x+1)
      assert(x1 >= x+1);
   else
      assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
   }
}

STBTT_DEF void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      // brute force every pixel

      // compute intersection points with top & bottom
      assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         assert(e->sy <= y_bottom && e->ey >= y_top);

         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            // from here on, we don't have to range check x values

            if ((int) x_top == (int) x_bottom) {
               float height;
               // simple case, only spans one pixel
               int x = (int) x_top;
               height = sy1 - sy0;
               assert(x >= 0 && x < len);
               scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;
               scanline_fill[x] += e->direction * height; // everything right of this pixel is filled
            } else {
               int x,x1,x2;
               float y_crossing, step, sign, area;
               // covers 2+ pixels
               if (x_top > x_bottom) {
                  // flip scanline vertically; signed area is the same
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
               }

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               // compute intersection with y axis at x1+1
               y_crossing = (x1+1 - x0) * dy + y_top;

               sign = e->direction;
               // area of the rectangle covered from y0..y_crossing
               area = sign * (y_crossing-sy0);
               // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
               scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

               step = sign * dy;
               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2;
                  area += step;
               }
               y_crossing += dy * (x2 - (x1+1));

               assert(fabs(area) <= 1.01f);

               scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            int x;
            for (x=0; x < len; ++x) {

               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  // one segment
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

// directly AA rasterize edges w/o supersampling
STBTT_DEF void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      // find center of pixel for this scanline
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      memset(scanline , 0, result->w*sizeof(scanline[0]));
      memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      // update all active edges;
      // remove all active edges that terminate before the top of this scanline
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; // delete from list
            assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); // advance through list
         }
      }

      // insert all edges that start before the bottom of this scanline
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               if (j == 0 && off_y != 0) {
                  if (z->ey < scan_y_top) {
                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
                     z->ey = scan_y_top;
                  }
               }
               assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
               // insert at front
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      // now process all active edges
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;
            result->pixels[j*result->stride + i] = (unsigned char) m;
         }
      }
      // advance all the edges
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; // advance to position for current scanline
         step = &((*step)->next); // advance through list
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

STBTT_DEF void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

STBTT_DEF void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

STBTT_DEF void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

STBTT_DEF void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity

   // now we have to blow out the windings into explicit edge lists
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         // skip the edge if horizontal
         if (p[j].y == p[k].y)
            continue;
         // add edge from j to k to the list
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   // now sort the edges by their highest point (should snap to integer, and then by x)
   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
   stbtt__sort_edges(e, n);

   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

STBTT_DEF void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; // during first pass, it's unallocated
   points[n].x = x;
   points[n].y = y;
}

// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
STBTT_DEF int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   // midpoint
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   // versus directly drawn line
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) // 65536 segments on one curve better be enough!
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

STBTT_DEF void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (sqrt(dx0*dx0+dy0*dy0)+sqrt(dx1*dx1+dy1*dy1)+sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) // 65536 segments on one curve better be enough!
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

// returns number of contours
STBTT_DEF stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   // count how many "moves" there are to get the contour count
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   // make two passes through the points so we don't need to realloc
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               // start the next contour
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      // e.g. space character
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
      if (ix0) *ix0 = floor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = floor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = ceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = ceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   // now we get the size
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; // in case we error

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}


STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char* const_data, int fontstart)
{
   unsigned char* data = (unsigned char*)const_data;

   u32 cmap, t;
   i32 i,numTables;

   info->data = (unsigned char*)data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
   info->head = stbtt__find_table(data, fontstart, "head"); // required
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      // required for truetype
      if (!info->loca) return 0;
   } else {
      // initialization for CFF / Type2 fonts (OTF)
      stbtt__buf b, topdict, topdictidx;
      u32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      u32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      // @TODO this should use size from table (not 512MB)
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      // read the header
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

      // @TODO the name INDEX could list multiple fonts,
      // but we just use the first one.
      stbtt__cff_get_index(&b);  // name INDEX
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  // string INDEX
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      // we only support Type 2 charstrings
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         // looks like a CID font
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   info->svg = -1;

   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      u32 encoding_record = cmap + 4 + 8 * i;
      // find an encoding we understand:
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  // MS/Unicode
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            // Mac/iOS has these
            // all the encodingIDs are unicode, so we don't bother to check it
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT((unsigned char*)data + info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint) {
   u8 *data = info->data;
   u32 index_map = info->index_map;

   u16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { // apple byte encoding
      i32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      u32 first = ttUSHORT(data + index_map + 6);
      u32 count = ttUSHORT(data + index_map + 8);
      if ((u32) unicode_codepoint >= first && (u32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      return 0;
   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
      u16 segcount = ttUSHORT(data+index_map+6) >> 1;
      u16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      u16 entrySelector = ttUSHORT(data+index_map+10);
      u16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      // do a binary search of the segments
      u32 endCount = index_map + 14;
      u32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      // they lie from endCount .. endCount + segCount
      // but searchRange is the nearest power of two, so...
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      // now decrement to bias correctly to find smallest
      search -= 2;
      while (entrySelector) {
         u16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         u16 offset, start;
         u16 item = (u16) ((search - endCount) >> 1);

         assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));
         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         if (unicode_codepoint < start)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (u16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      u32 ngroups = ttULONG(data+index_map+12);
      i32 low,high;
      low = 0; high = (i32)ngroups;
      // Binary search the right group.
      while (low < high) {
         i32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
         u32 start_char = ttULONG(data+index_map+16+mid*12);
         u32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((u32) unicode_codepoint < start_char)
            high = mid;
         else if ((u32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            u32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else // format == 13
               return start_glyph;
         }
      }
      return 0; // not found
   }
   // @TODO
   assert(0);
   return 0;
}

STBTT_DEF int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; // if length is 0, return -1
}

STBTT_DEF int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
#endif /* n RFONT_EXTERNAL_STB */

/* 
END of stb_truetype defines and source code required by RFont
*/

#endif /* RFONT_IMPLEMENTATION */
/*
* Copyright (C) 2023-24 ColleagueRiley
*
* libpng license
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not
*    claim that you wrote the original software. If you use this software
*    in a product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*
*
*/

/*
	(MAKE SURE RGFW_IMPLEMENTATION is in exactly one header or you use -D RGFW_IMPLEMENTATION)
	#define RGFW_IMPLEMENTATION - makes it so source code is included with header
*/

/*
	#define RGFW_IMPLEMENTATION - (required) makes it so the source code is included
	#define RGFW_PRINT_ERRORS - (optional) makes it so RGFW prints errors when they're found
	#define RGFW_OSMESA - (optional) use OSmesa as backend (instead of system's opengl api + regular opengl)
	#define RGFW_BUFFER - (optional) just draw directly to (RGFW) window pixel buffer that is drawn to screen (the buffer is in the RGBA format)
	#define RGFW_EGL - (optional) use EGL for loading an OpenGL context (instead of the system's opengl api)
	#define RGFW_OPENGL_ES1 - (optional) use EGL to load and use Opengl ES (version 1) for backend rendering (instead of the system's opengl api)
									This version doesn't work for desktops (I'm pretty sure)
	#define RGFW_OPENGL_ES2 - (optional) use OpenGL ES (version 2)
	#define RGFW_OPENGL_ES3 - (optional) use OpenGL ES (version 3)
	#define RGFW_DIRECTX - (optional) use directX for the rendering backend (rather than opengl) (windows only, defaults to opengl for unix)
	#define RGFW_NO_API - (optional) don't use any rendering API (no opengl, no vulkan, no directX)

	#define RGFW_LINK_EGL (optional) (windows only) if EGL is being used, if EGL functions should be defined dymanically (using GetProcAddress)
	#define RGFW_LINK_OSMESA (optional) (windows only) if EGL is being used, if OS Mesa functions should be defined dymanically  (using GetProcAddress)

	#define RGFW_X11 (optional) (unix only) if X11 should be used. This option is turned on by default by unix systems except for MacOS
	#define RGFW_WGL_LOAD (optional) (windows only) if WGL should be loaded dynamically during runtime
	#define RGFW_NO_X11_CURSOR (optional) (unix only) don't use XCursor
	#define RGFW_NO_X11_CURSOR_PRELOAD (optional) (unix only) Use XCursor, but don't link it in code, (you'll have to link it with -lXcursor)

	#define RGFW_NO_DPI - Do not include calculate DPI (no XRM nor libShcore included)

	#define RGFW_ALLOC_DROPFILES (optional) if room should be allocating for drop files (by default it's global data)
	#define RGFW_MALLOC x - choose what function to use to allocate, by default the standard malloc is used
	#define RGFW_CALLOC x - choose what function to use to allocate (calloc), by default the standard calloc is used
	#define RGFW_FREE x - choose what function to use to allocated memory, by default the standard free is used

 	#define RGFW_EXPORT - Use when building RGFW 
    #define RGFW_IMPORT - Use when linking with RGFW (not as a single-header)
	
	#define RGFW_STD_INT - force the use stdint.h (for systems that might not have stdint.h (msvc)) 
*/

/*
	Credits :
		EimaMei/Sacode : Much of the code for creating windows using winapi, Wrote the Silicon library, helped with MacOS Support, siliapp.h -> referencing 

		stb - This project is heavily inspired by the stb single header files

		GLFW:
			certain parts of winapi and X11 are very poorly documented,
			GLFW's source code was referenced and used throughout the project (used code is marked in some way),
			this mainly includes, code for drag and drops, code for setting the icon to a bitmap and the code for managing the clipboard for X11 (as these parts are not documented very well)

			GLFW Copyright, https::/github.com/GLFW/GLFW

			Copyright (c) 2002-2006 Marcus Geelnard
			Copyright (c) 2006-2019 Camilla Lwy

		contributors : (feel free to put yourself here if you contribute)
		krisvers -> code review
		EimaMei (SaCode) -> code review
		Code-Nycticebus -> bug fixes
		Rob Rohan -> X11 bugs and missing features, MacOS/Cocoa fixing memory issues/bugs 
		AICDG (@THISISAGOODNAME) -> vulkan support (example)
		@Easymode -> support, testing/debugging, bug fixes and reviews
*/

#if _MSC_VER
	#pragma comment(lib, "gdi32")
	#pragma comment(lib, "shell32")
	#pragma comment(lib, "opengl32")
	#pragma comment(lib, "winmm")
	#pragma comment(lib, "user32")
#endif

#ifndef RGFW_MALLOC
	#include <stdlib.h>

	#ifndef __USE_POSIX199309
	#define __USE_POSIX199309
	#endif

	#include <time.h>
	#define RGFW_MALLOC malloc
	#define RGFW_CALLOC calloc
	#define RGFW_FREE free
#endif

#if !_MSC_VER
	#ifndef inline
		#ifndef __APPLE__
			#define inline __inline
		#endif
	#endif
#endif

#ifdef RGFW_WIN95 /* for windows 95 testing (not that it really works) */
	#define RGFW_NO_MONITOR
	#define RGFW_NO_PASSTHROUGH
#endif

#if defined(RGFW_EXPORT) ||  defined(RGFW_IMPORT)
	#if defined(_WIN32)
		#if defined(__TINYC__) && (defined(RGFW_EXPORT) ||  defined(RGFW_IMPORT))
			#define __declspec(x) __attribute__((x))
		#endif

		#if defined(RGFW_EXPORT)
			#define RGFWDEF __declspec(dllexport)
		#else 
			#define RGFWDEF __declspec(dllimport)
		#endif
	#else
		#if defined(RGFW_EXPORT)
			#define RGFWDEF __attribute__((visibility("default")))
		#endif
	#endif
#endif 

#ifndef RGFWDEF
	#ifdef __clang__
		#define RGFWDEF static inline
	#else
		#define RGFWDEF inline
	#endif
#endif

#ifndef RGFW_ENUM
	#define RGFW_ENUM(type, name) type name; enum
#endif

#ifndef RGFW_UNUSED
	#define RGFW_UNUSED(x) (void)(x);
#endif

#if defined(__cplusplus) && !defined(__EMSCRIPTEN__)
	extern "C" {
#endif

	/* makes sure the header file part is only defined once by default */
#ifndef RGFW_HEADER

#define RGFW_HEADER

#if !defined(u8)
	#if ((defined(_MSC_VER) || defined(__SYMBIAN32__)) && !defined(RGFW_STD_INT)) /* MSVC might not have stdint.h */
		typedef unsigned char 	u8;
		typedef signed char		i8;
		typedef unsigned short  u16;
		typedef signed short 	i16;
		typedef unsigned int 	u32;
		typedef signed int		i32;
		typedef unsigned long	u64;
		typedef signed long		i64;
	#else /* use stdint standard types instead of c ""standard"" types */
		#include <stdint.h>

		typedef uint8_t     u8;
		typedef int8_t      i8;
		typedef uint16_t   u16;
		typedef int16_t    i16;
		typedef uint32_t   u32;
		typedef int32_t    i32;
		typedef uint64_t   u64;
		typedef int64_t    i64;
	#endif
#endif

#if !defined(b8) /* RGFW bool type */
	typedef u8 b8;
	typedef u32 b32;
#endif

#define RGFW_TRUE 1
#define RGFW_FALSE 0

/* thse OS macros looks better & are standardized */
/* plus it helps with cross-compiling */

#ifdef __EMSCRIPTEN__
	#define RGFW_WEBASM

	#ifndef RGFW_NO_API
		#define RGFW_OPENGL
	#endif

	#ifdef RGFW_EGL
		#undef RGFW_EGL
	#endif

	#include <emscripten/html5.h>
	#include <emscripten/key_codes.h>
#endif

#if defined(RGFW_X11) && defined(__APPLE__)
	#define RGFW_MACOS_X11
	#undef __APPLE__
#endif

#if defined(_WIN32) && !defined(RGFW_X11) && !defined(RGFW_WEBASM) /* (if you're using X11 on windows some how) */
	#define RGFW_WINDOWS

	/* make sure the correct architecture is defined */
	#if defined(_WIN64)
		#define _AMD64_
		#undef _X86_
	#else
		#undef _AMD64_
		#ifndef _X86_
			#define _X86_
		#endif
	#endif

	#ifndef RGFW_NO_XINPUT
		#ifdef __MINGW32__ /* try to find the right header */
			#include <xinput.h>
		#else
			#include <XInput.h>
		#endif
	#endif

	#if defined(RGFW_DIRECTX)
		#include <d3d11.h>
		#include <dxgi.h>
		#include <dxgi.h>
		#include <d3dcompiler.h>

		#ifndef __cplusplus
			#define __uuidof(T) IID_##T
		#endif
	#endif

#elif defined(RGFW_WAYLAND)
    #if !defined(RGFW_NO_API) && (!defined(RGFW_BUFFER) || defined(RGFW_OPENGL))
		#define RGFW_EGL
		#define RGFW_OPENGL
		#include <wayland-egl.h>
	#endif

	#include <wayland-client.h>
#elif (defined(__unix__) || defined(RGFW_MACOS_X11) || defined(RGFW_X11))  && !defined(RGFW_WEBASM)
	#define RGFW_MACOS_X11
	#define RGFW_X11
	#include <X11/Xlib.h>
#elif defined(__APPLE__) && !defined(RGFW_MACOS_X11) && !defined(RGFW_X11)  && !defined(RGFW_WEBASM)
	#define RGFW_MACOS
#endif

#if (defined(RGFW_OPENGL_ES1) || defined(RGFW_OPENGL_ES2) || defined(RGFW_OPENGL_ES3)) && !defined(RGFW_EGL)
	#define RGFW_EGL
#endif

#if !defined(RGFW_OSMESA) && !defined(RGFW_EGL) && !defined(RGFW_OPENGL) && !defined(RGFW_DIRECTX) && !defined(RGFW_BUFFER) && !defined(RGFW_NO_API)
	#define RGFW_OPENGL
#endif

#ifdef RGFW_EGL
	#if defined(__APPLE__)
		#warning  EGL is not supported for Cocoa, switching back to the native opengl api
		#undef RGFW_EGL
	#endif

	#include <EGL/egl.h>
#elif defined(RGFW_OSMESA)
	#ifndef __APPLE__
		#include <GL/osmesa.h>
	#else
		#include <OpenGL/osmesa.h>
	#endif
#endif

#if defined(RGFW_OPENGL) && defined(RGFW_X11)
	#ifndef GLX_MESA_swap_control
		#define  GLX_MESA_swap_control
	#endif
	#include <GL/glx.h> /* GLX defs, xlib.h, gl.h */
#endif

#ifndef RGFW_ALPHA
	#define RGFW_ALPHA 128 /* alpha value for RGFW_TRANSPARENT_WINDOW (WINAPI ONLY, macOS + linux don't need this) */
#endif

/*! Optional arguments for making a windows */
#define RGFW_TRANSPARENT_WINDOW		(1L<<9) /*!< the window is transparent (only properly works on X11 and MacOS, although it's although for windows) */
#define RGFW_NO_BORDER		(1L<<3) /*!< the window doesn't have border */
#define RGFW_NO_RESIZE		(1L<<4) /*!< the window cannot be resized  by the user */
#define RGFW_ALLOW_DND     (1L<<5) /*!< the window supports drag and drop*/
#define RGFW_HIDE_MOUSE (1L<<6) /*! the window should hide the mouse or not (can be toggled later on) using `RGFW_window_mouseShow*/
#define RGFW_FULLSCREEN (1L<<8) /* the window is fullscreen by default or not */
#define RGFW_CENTER (1L<<10) /*! center the window on the screen */
#define RGFW_OPENGL_SOFTWARE (1L<<11) /*! use OpenGL software rendering */
#define RGFW_COCOA_MOVE_TO_RESOURCE_DIR (1L << 12) /* (cocoa only), move to resource folder */
#define RGFW_SCALE_TO_MONITOR (1L << 13) /* scale the window to the screen */
#define RGFW_NO_INIT_API (1L << 2) /* DO not init an API (mostly for bindings, you should use `#define RGFW_NO_API` in C */

#define RGFW_NO_GPU_RENDER (1L<<14) /* don't render (using the GPU based API)*/
#define RGFW_NO_CPU_RENDER (1L<<15) /* don't render (using the CPU based buffer rendering)*/
#define RGFW_WINDOW_HIDE (1L <<  16)/* the window is hidden */

typedef RGFW_ENUM(u8, RGFW_event_types) {
	/*! event codes */
 	RGFW_keyPressed = 1, /* a key has been pressed */
	RGFW_keyReleased, /*!< a key has been released*/
	/*! key event note
		the code of the key pressed is stored in
		RGFW_Event.keyCode
		!!Keycodes defined at the bottom of the RGFW_HEADER part of this file!!

		while a string version is stored in
		RGFW_Event.KeyString

		RGFW_Event.lockState holds the current lockState
		this means if CapsLock, NumLock are active or not
	*/
	RGFW_mouseButtonPressed, /*!< a mouse button has been pressed (left,middle,right)*/
	RGFW_mouseButtonReleased, /*!< a mouse button has been released (left,middle,right)*/
	RGFW_mousePosChanged, /*!< the position of the mouse has been changed*/
	/*! mouse event note
		the x and y of the mouse can be found in the vector, RGFW_Event.point

		RGFW_Event.button holds which mouse button was pressed
	*/
	RGFW_jsButtonPressed, /*!< a joystick button was pressed */
	RGFW_jsButtonReleased, /*!< a joystick button was released */
	RGFW_jsAxisMove, /*!< an axis of a joystick was moved*/
	/*! joystick event note
		RGFW_Event.joystick holds which joystick was altered, if any
		RGFW_Event.button holds which joystick button was pressed

		RGFW_Event.axis holds the data of all the axis
		RGFW_Event.axisCount says how many axis there are
	*/
	RGFW_windowMoved, /*!< the window was moved (by the user) */
	RGFW_windowResized, /*!< the window was resized (by the user), [on webASM this means the browser was resized] */
	RGFW_focusIn, /*!< window is in focus now */
	RGFW_focusOut, /*!< window is out of focus now */
	RGFW_mouseEnter, /* mouse entered the window */
	RGFW_mouseLeave, /* mouse left the window */
	RGFW_windowRefresh, /* The window content needs to be refreshed */

	/* attribs change event note
		The event data is sent straight to the window structure
		with win->r.x, win->r.y, win->r.w and win->r.h
	*/
	RGFW_quit, /*!< the user clicked the quit button*/ 
	RGFW_dnd, /*!< a file has been dropped into the window*/
	RGFW_dnd_init /*!< the start of a dnd event, when the place where the file drop is known */
	/* dnd data note
		The x and y coords of the drop are stored in the vector RGFW_Event.point

		RGFW_Event.droppedFilesCount holds how many files were dropped

		This is also the size of the array which stores all the dropped file string,
		RGFW_Event.droppedFiles
	*/
};

/*! mouse button codes (RGFW_Event.button) */
#define RGFW_mouseLeft  1 /*!< left mouse button is pressed*/
#define RGFW_mouseMiddle  2 /*!< mouse-wheel-button is pressed*/
#define RGFW_mouseRight  3 /*!< right mouse button is pressed*/
#define RGFW_mouseScrollUp  4 /*!< mouse wheel is scrolling up*/
#define RGFW_mouseScrollDown  5 /*!< mouse wheel is scrolling down*/

#ifndef RGFW_MAX_PATH
#define RGFW_MAX_PATH 260 /* max length of a path (for dnd) */
#endif
#ifndef RGFW_MAX_DROPS
#define RGFW_MAX_DROPS 260 /* max items you can drop at once */
#endif


/* for RGFW_Event.lockstate */
#define RGFW_CAPSLOCK (1L << 1)
#define RGFW_NUMLOCK (1L << 2)

/*! joystick button codes (based on xbox/playstation), you may need to change these values per controller */
#ifndef RGFW_joystick_codes
	typedef RGFW_ENUM(u8, RGFW_joystick_codes) {
		RGFW_JS_A = 0, /*!< or PS X button */
		RGFW_JS_B = 1, /*!< or PS circle button */
		RGFW_JS_Y = 2, /*!< or PS triangle button */
		RGFW_JS_X = 3, /*!< or PS square button */
		RGFW_JS_START = 9, /*!< start button */
		RGFW_JS_SELECT = 8, /*!< select button */
		RGFW_JS_HOME = 10, /*!< home button */
		RGFW_JS_UP = 13, /*!< dpad up */
		RGFW_JS_DOWN = 14, /*!< dpad down*/
		RGFW_JS_LEFT = 15, /*!< dpad left */
		RGFW_JS_RIGHT = 16, /*!< dpad right */
		RGFW_JS_L1 = 4, /*!< left bump */
		RGFW_JS_L2 = 5, /*!< left trigger*/
		RGFW_JS_R1 = 6, /*!< right bumper */
		RGFW_JS_R2 = 7, /*!< right trigger */
	};
#endif

/*! basic vector type, if there's not already a point/vector type of choice */
#ifndef RGFW_point
	typedef struct { i32 x, y; } RGFW_point;
#endif

/*! basic rect type, if there's not already a rect type of choice */
#ifndef RGFW_rect
	typedef struct { i32 x, y, w, h; } RGFW_rect;
#endif

/*! basic area type, if there's not already a area type of choice */
#ifndef RGFW_area
	typedef struct { u32 w, h; } RGFW_area;
#endif

#ifndef __cplusplus
#define RGFW_POINT(x, y) (RGFW_point){(i32)(x), (i32)(y)}
#define RGFW_RECT(x, y, w, h) (RGFW_rect){(i32)(x), (i32)(y), (i32)(w), (i32)(h)}
#define RGFW_AREA(w, h) (RGFW_area){(u32)(w), (u32)(h)}
#else
#define RGFW_POINT(x, y) {(i32)(x), (i32)(y)}
#define RGFW_RECT(x, y, w, h) {(i32)(x), (i32)(y), (i32)(w), (i32)(h)}
#define RGFW_AREA(w, h) {(u32)(w), (u32)(h)}
#endif

#ifndef RGFW_NO_MONITOR
	/*! structure for monitor data */
	typedef struct RGFW_monitor {
		char name[128]; /*!< monitor name */
		RGFW_rect rect; /*!< monitor Workarea */
		float scaleX, scaleY; /*!< monitor content scale*/
		float physW, physH; /*!< monitor physical size */
	} RGFW_monitor;

	/*
		NOTE : Monitor functions should be ran only as many times as needed (not in a loop)
	*/

	/*! get an array of all the monitors (max 6) */
	RGFWDEF RGFW_monitor* RGFW_getMonitors(void);
	/*! get the primary monitor */
	RGFWDEF RGFW_monitor RGFW_getPrimaryMonitor(void);
#endif

/* NOTE: some parts of the data can represent different things based on the event (read comments in RGFW_Event struct) */
/*! Event structure for checking/getting events */
typedef struct RGFW_Event {
	char keyName[16]; /*!< key name of event*/

	/*! drag and drop data */
	/* 260 max paths with a max length of 260 */
#ifdef RGFW_ALLOC_DROPFILES
	char** droppedFiles;
#else
	char droppedFiles[RGFW_MAX_DROPS][RGFW_MAX_PATH]; /*!< dropped files*/
#endif
	u32 droppedFilesCount; /*!< house many files were dropped */

	u32 type; /*!< which event has been sent?*/
	RGFW_point point; /*!< mouse x, y of event (or drop point) */
	
	u8 keyCode; /*!< keycode of event 	!!Keycodes defined at the bottom of the RGFW_HEADER part of this file!! */	
	
	b8 repeat; /*!< key press event repeated (the key is being held) */
	b8 inFocus;  /*!< if the window is in focus or not (this is always true for MacOS windows due to the api being weird) */

	u8 lockState;
	
	u8 button; /* !< which mouse button was pressed */
	double scroll; /*!< the raw mouse scroll value */

	u16 joystick; /*! which joystick this event applies to (if applicable to any) */
	u8 axisesCount; /*!< number of axises */
	RGFW_point axis[2]; /*!< x, y of axises (-100 to 100) */

	u64 frameTime, frameTime2; /*!< this is used for counting the fps */
} RGFW_Event;

/*! source data for the window (used by the APIs) */
typedef struct RGFW_window_src {
#ifdef RGFW_WINDOWS
	HWND window; /*!< source window */
	HDC hdc; /*!< source HDC */
	u32 hOffset; /*!< height offset for window */
	#if (defined(RGFW_OPENGL)) && !defined(RGFW_OSMESA) && !defined(RGFW_EGL)
		HGLRC ctx; /*!< source graphics context */
	#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
	#elif defined(RGFW_DIRECTX)
		IDXGISwapChain* swapchain;
		ID3D11RenderTargetView* renderTargetView;
		ID3D11DepthStencilView* pDepthStencilView;
	#elif defined(RGFW_EGL)
		EGLSurface EGL_surface;
		EGLDisplay EGL_display;
		EGLContext EGL_context;
	#endif

	#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
		HDC hdcMem;
		HBITMAP bitmap;
	#endif
	RGFW_area maxSize, minSize; /*!< for setting max/min resize (RGFW_WINDOWS) */
#elif defined(RGFW_X11)
	Display* display; /*!< source display */
	Window window; /*!< source window */
	#if (defined(RGFW_OPENGL)) && !defined(RGFW_OSMESA) && !defined(RGFW_EGL)
		GLXContext ctx; /*!< source graphics context */
	#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
	#elif defined(RGFW_EGL)
		EGLSurface EGL_surface;
		EGLDisplay EGL_display;
		EGLContext EGL_context;
	#endif

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
		XImage* bitmap;
		GC gc;
#endif
#elif defined(RGFW_WAYLAND)
	struct wl_display* display;
	struct wl_surface* surface;
	struct wl_buffer* wl_buffer;
	struct wl_keyboard* keyboard;

	struct xdg_surface* xdg_surface;
	struct xdg_toplevel* xdg_toplevel;
	struct zxdg_toplevel_decoration_v1* decoration;
	RGFW_Event events[20];
		i32 eventLen;
		size_t eventIndex;
	#if defined(RGFW_EGL)
			struct wl_egl_window* window;
			EGLSurface EGL_surface;
			EGLDisplay EGL_display;
			EGLContext EGL_context;
	#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
	#endif
#elif defined(RGFW_MACOS)
	u32 display;
	void* displayLink;
	void* window;
	b8 dndPassed;
#if (defined(RGFW_OPENGL)) && !defined(RGFW_OSMESA) && !defined(RGFW_EGL)
		void* ctx; /*!< source graphics context */
#elif defined(RGFW_OSMESA)
		OSMesaContext ctx;
#elif defined(RGFW_EGL)
		EGLSurface EGL_surface;
		EGLDisplay EGL_display;
		EGLContext EGL_context;
#endif

	void* view; /*apple viewpoint thingy*/

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
		void* bitmap; /*!< API's bitmap for storing or managing */
		void* image;
#endif
#elif defined(RGFW_WEBASM)
	EMSCRIPTEN_WEBGL_CONTEXT_HANDLE ctx;
#endif
} RGFW_window_src;



typedef struct RGFW_window {
	RGFW_window_src src; /*!< src window data */

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER) 
	u8* buffer; /*!< buffer for non-GPU systems (OSMesa, basic software rendering) */
	/* when rendering using RGFW_BUFFER, the buffer is in the RGBA format */
#endif
	void* userPtr; /* ptr for usr data */
	
	RGFW_Event event; /*!< current event */

	RGFW_rect r; /*!< the x, y, w and h of the struct */
	
	RGFW_point _lastMousePoint; /*!< last cusor point (for raw mouse data) */
	
	u32 _winArgs; /*!< windows args (for RGFW to check) */
} RGFW_window; /*!< Window structure for managing the window */

#if defined(RGFW_X11) || defined(RGFW_MACOS)
	typedef u64 RGFW_thread; /*!< thread type unix */
#else
	typedef void* RGFW_thread; /*!< thread type for window */
#endif

/** * @defgroup Window_management
* @{ */ 


/*! 
 * the class name for X11 and WinAPI. apps with the same class will be grouped by the WM
 * by default the class name will == the root window's name
*/
RGFWDEF void RGFW_setClassName(char* name);

/*! this has to be set before createWindow is called, else the fulscreen size is used */
RGFWDEF void RGFW_setBufferSize(RGFW_area size); /*!< the buffer cannot be resized (by RGFW) */

RGFW_window* RGFW_createWindow(
	const char* name, /* name of the window */
	RGFW_rect rect, /* rect of window */
	u16 args /* extra arguments (NULL / (u16)0 means no args used)*/
); /*!< function to create a window struct */

/*! get the size of the screen to an area struct */
RGFWDEF RGFW_area RGFW_getScreenSize(void);

/*!
	this function checks an *individual* event (and updates window structure attributes)
	this means, using this function without a while loop may cause event lag

	ex.

	while (RGFW_window_checkEvent(win) != NULL) [this keeps checking events until it reaches the last one]

	this function is optional if you choose to use event callbacks, 
	although you still need some way to tell RGFW to process events eg. `RGFW_window_checkEvents`
*/

RGFW_Event* RGFW_window_checkEvent(RGFW_window* win); /*!< check current event (returns a pointer to win->event or NULL if there is no event)*/

/*!
	for RGFW_window_eventWait and RGFW_window_checkEvents
	waitMS -> Allows th	e function to keep checking for events even after `RGFW_window_checkEvent == NULL`
			  if waitMS == 0, the loop will not wait for events
			  if waitMS == a positive integer, the loop will wait that many miliseconds after there are no more events until it returns
			  if waitMS == a negative integer, the loop will not return until it gets another event
*/
typedef RGFW_ENUM(i32, RGFW_eventWait) {
	RGFW_NEXT = -1,
	RGFW_NO_WAIT = 0
};

/*! sleep until RGFW gets an event or the timer ends (defined by OS) */
RGFWDEF void RGFW_window_eventWait(RGFW_window* win, i32 waitMS);

/*!
	check all the events until there are none left, 
	this should only be used if you're using callbacks only
*/
RGFWDEF void RGFW_window_checkEvents(RGFW_window* win, i32 waitMS);

/*! 
	Tell RGFW_window_eventWait to stop waiting, to be ran from another thread
*/
RGFWDEF void RGFW_stopCheckEvents(void);

/*! window managment functions*/
RGFWDEF void RGFW_window_close(RGFW_window* win); /*!< close the window and free leftover data */

/*! moves window to a given point */
RGFWDEF void RGFW_window_move(RGFW_window* win,
	RGFW_point v/*!< new pos*/
);

#ifndef RGFW_NO_MONITOR
	/*! move to a specific monitor */
	RGFWDEF void RGFW_window_moveToMonitor(RGFW_window* win, RGFW_monitor m /* monitor */);
#endif

/*! resize window to a current size/area */
RGFWDEF void RGFW_window_resize(RGFW_window* win, /*!< source window */
	RGFW_area a/*!< new size*/
);

/*! set the minimum size a user can shrink a window to a given size/area */
RGFWDEF void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a);
/*! set the minimum size a user can extend a window to a given size/area */
RGFWDEF void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a);

RGFWDEF void RGFW_window_maximize(RGFW_window* win); /*!< maximize the window size */
RGFWDEF void RGFW_window_minimize(RGFW_window* win); /*!< minimize the window (in taskbar (per OS))*/
RGFWDEF void RGFW_window_restore(RGFW_window* win); /*!< restore the window from minimized (per OS)*/

/*! if the window should have a border or not (borderless) based on bool value of `border` */
RGFWDEF void RGFW_window_setBorder(RGFW_window* win, b8 border);

/*! turn on / off dnd (RGFW_ALLOW_DND stil must be passed to the window)*/
RGFWDEF void RGFW_window_setDND(RGFW_window* win, b8 allow);

#ifndef RGFW_NO_PASSTHROUGH
	/*!! turn on / off mouse passthrough */
	RGFWDEF void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough);
#endif 

/*! rename window to a given string */
RGFWDEF void RGFW_window_setName(RGFW_window* win,
	char* name
);

void RGFW_window_setIcon(RGFW_window* win, /*!< source window */
	u8* icon /*!< icon bitmap */,
	RGFW_area a /*!< width and height of the bitmap*/,
	i32 channels /*!< how many channels the bitmap has (rgb : 3, rgba : 4) */
); /*!< image resized by default */

/*!< sets mouse to bitmap (very simular to RGFW_window_setIcon), image NOT resized by default*/
RGFWDEF void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels);

/*!< sets the mouse to a standard API cursor (based on RGFW_MOUSE, as seen at the end of the RGFW_HEADER part of this file) */
RGFWDEF	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse);

RGFWDEF void RGFW_window_setMouseDefault(RGFW_window* win); /*!< sets the mouse to the default mouse icon */
/*
	Locks cursor at the center of the window
	win->event.point become raw mouse movement data 

	this is useful for a 3D camera
*/
RGFWDEF void RGFW_window_mouseHold(RGFW_window* win, RGFW_area area);
/*! stop holding the mouse and let it move freely */
RGFWDEF void RGFW_window_mouseUnhold(RGFW_window* win);

/*! hide the window */
RGFWDEF void RGFW_window_hide(RGFW_window* win);
/*! show the window */
RGFWDEF void RGFW_window_show(RGFW_window* win);

/*
	makes it so `RGFW_window_shouldClose` returns true
	by setting the window event.type to RGFW_quit
*/
RGFWDEF void RGFW_window_setShouldClose(RGFW_window* win);

/*! where the mouse is on the screen */
RGFWDEF RGFW_point RGFW_getGlobalMousePoint(void);

/*! where the mouse is on the window */
RGFWDEF RGFW_point RGFW_window_getMousePoint(RGFW_window* win);

/*! show the mouse or hide the mouse*/
RGFWDEF void RGFW_window_showMouse(RGFW_window* win, i8 show);
/*! move the mouse to a set x, y pos*/
RGFWDEF void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v);

/*! if the window should close (RGFW_close was sent or escape was pressed) */
RGFWDEF b8 RGFW_window_shouldClose(RGFW_window* win);
/*! if window is fullscreen'd */
RGFWDEF b8 RGFW_window_isFullscreen(RGFW_window* win);
/*! if window is hidden */
RGFWDEF b8 RGFW_window_isHidden(RGFW_window* win);
/*! if window is minimized */
RGFWDEF b8 RGFW_window_isMinimized(RGFW_window* win);
/*! if window is maximized */
RGFWDEF b8 RGFW_window_isMaximized(RGFW_window* win);

/** @} */ 

/** * @defgroup Monitor
* @{ */ 

#ifndef RGFW_NO_MONITOR
/*
scale the window to the monitor,
this is run by default if the user uses the arg `RGFW_SCALE_TO_MONITOR` during window creation
*/
RGFWDEF void RGFW_window_scaleToMonitor(RGFW_window* win);
/*! get the struct of the window's monitor  */
RGFWDEF RGFW_monitor RGFW_window_getMonitor(RGFW_window* win);
#endif

/** @} */ 

/** * @defgroup Input
* @{ */ 

/*error handling*/
RGFWDEF b8 RGFW_Error(void); /*!< returns true if an error has occurred (doesn't print errors itself) */

/*! returns true if the key should be shifted */
RGFWDEF b8 RGFW_shouldShift(u32 keycode, u8 lockState);

/*! get char from RGFW keycode (using a LUT), uses shift'd version if shift = true */
RGFWDEF char RGFW_keyCodeToChar(u32 keycode, b8 shift);
/*! get char from RGFW keycode (using a LUT), uses lockState for shouldShift) */
RGFWDEF char RGFW_keyCodeToCharAuto(u32 keycode, u8 lockState);

/*! if window == NULL, it checks if the key is pressed globally. Otherwise, it checks only if the key is pressed while the window in focus.*/
RGFWDEF b8 RGFW_isPressed(RGFW_window* win, u8 key); /*!< if key is pressed (key code)*/

RGFWDEF b8 RGFW_wasPressed(RGFW_window* win, u8 key); /*!< if key was pressed (checks previous state only) (key code)*/

RGFWDEF b8 RGFW_isHeld(RGFW_window* win, u8 key); /*!< if key is held (key code)*/
RGFWDEF b8 RGFW_isReleased(RGFW_window* win, u8 key); /*!< if key is released (key code)*/

/* if a key is pressed and then released, pretty much the same as RGFW_isReleased */
RGFWDEF b8 RGFW_isClicked(RGFW_window* win, u8 key /*!< key code*/);

/*! if a mouse button is pressed */
RGFWDEF b8 RGFW_isMousePressed(RGFW_window* win, u8 button /*!< mouse button code */ );
/*! if a mouse button is held */
RGFWDEF b8 RGFW_isMouseHeld(RGFW_window* win, u8 button /*!< mouse button code */ );
/*! if a mouse button was released */
RGFWDEF b8 RGFW_isMouseReleased(RGFW_window* win, u8 button /*!< mouse button code */ );
/*! if a mouse button was pressed (checks previous state only) */
RGFWDEF b8 RGFW_wasMousePressed(RGFW_window* win, u8 button /*!< mouse button code */ );
/** @} */ 

/** * @defgroup Clipboard
* @{ */ 
RGFWDEF char* RGFW_readClipboard(size_t* size); /*!< read clipboard data */
RGFWDEF void RGFW_clipboardFree(char* str); /*!< the string returned from RGFW_readClipboard must be freed */

RGFWDEF void RGFW_writeClipboard(const char* text, u32 textLen); /*!< write text to the clipboard */
/** @} */ 

/**
	
	
	Event callbacks, 
	these are completely optional, you can use the normal 
	RGFW_checkEvent() method if you prefer that

* @defgroup Callbacks
* @{ 
*/

/*! RGFW_windowMoved, the window and its new rect value  */
typedef void (* RGFW_windowmovefunc)(RGFW_window* win, RGFW_rect r);
/*! RGFW_windowResized, the window and its new rect value  */
typedef void (* RGFW_windowresizefunc)(RGFW_window* win, RGFW_rect r);
/*! RGFW_quit, the window that was closed */
typedef void (* RGFW_windowquitfunc)(RGFW_window* win);
/*! RGFW_focusIn / RGFW_focusOut, the window who's focus has changed and if its inFocus */
typedef void (* RGFW_focusfunc)(RGFW_window* win, b8 inFocus);
/*! RGFW_mouseEnter / RGFW_mouseLeave, the window that changed, the point of the mouse (enter only) and if the mouse has entered */
typedef void (* RGFW_mouseNotifyfunc)(RGFW_window* win, RGFW_point point, b8 status);
/*! RGFW_mousePosChanged, the window that the move happened on and the new point of the mouse  */
typedef void (* RGFW_mouseposfunc)(RGFW_window* win, RGFW_point point);
/*! RGFW_dnd_init, the window, the point of the drop on the windows */
typedef void (* RGFW_dndInitfunc)(RGFW_window* win, RGFW_point point);
/*! RGFW_windowRefresh, the window that needs to be refreshed */
typedef void (* RGFW_windowrefreshfunc)(RGFW_window* win);
/*! RGFW_keyPressed / RGFW_keyReleased, the window that got the event, the keycode, the string version, the state of mod keys, if it was a press (else it's a release) */
typedef void (* RGFW_keyfunc)(RGFW_window* win, u32 keycode, char keyName[16], u8 lockState, b8 pressed);
/*! RGFW_mouseButtonPressed / RGFW_mouseButtonReleased, the window that got the event, the button that was pressed, the scroll value, if it was a press (else it's a release)  */
typedef void (* RGFW_mousebuttonfunc)(RGFW_window* win, u8 button, double scroll, b8 pressed);
/*! RGFW_jsButtonPressed / RGFW_jsButtonReleased, the window that got the event, the button that was pressed, the scroll value, if it was a press (else it's a release) */
typedef void (* RGFW_jsButtonfunc)(RGFW_window* win, u16 joystick, u8 button, b8 pressed);
/*! RGFW_jsAxisMove, the window that got the event, the joystick in question, the axis values and the amount of axises */
typedef void (* RGFW_jsAxisfunc)(RGFW_window* win, u16 joystick, RGFW_point axis[2], u8 axisesCount);


/*!  RGFW_dnd, the window that had the drop, the drop data and the amount files dropped returns previous callback function (if it was set) */
#ifdef RGFW_ALLOC_DROPFILES
	typedef void (* RGFW_dndfunc)(RGFW_window* win, char** droppedFiles, u32 droppedFilesCount);
#else
	typedef void (* RGFW_dndfunc)(RGFW_window* win, char droppedFiles[RGFW_MAX_DROPS][RGFW_MAX_PATH], u32 droppedFilesCount);
#endif
/*! set callback for a window move event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowmovefunc RGFW_setWindowMoveCallback(RGFW_windowmovefunc func);
/*! set callback for a window resize event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowresizefunc RGFW_setWindowResizeCallback(RGFW_windowresizefunc func);
/*! set callback for a window quit event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowquitfunc RGFW_setWindowQuitCallback(RGFW_windowquitfunc func);
/*! set callback for a mouse move event returns previous callback function (if it was set)  */
RGFWDEF RGFW_mouseposfunc RGFW_setMousePosCallback(RGFW_mouseposfunc func);
/*! set callback for a window refresh event returns previous callback function (if it was set)  */
RGFWDEF RGFW_windowrefreshfunc RGFW_setWindowRefreshCallback(RGFW_windowrefreshfunc func);
/*! set callback for a window focus change event returns previous callback function (if it was set)  */
RGFWDEF RGFW_focusfunc RGFW_setFocusCallback(RGFW_focusfunc func);
/*! set callback for a mouse notify event returns previous callback function (if it was set)  */
RGFWDEF RGFW_mouseNotifyfunc RGFW_setMouseNotifyCallBack(RGFW_mouseNotifyfunc func);
/*! set callback for a drop event event returns previous callback function (if it was set)  */
RGFWDEF RGFW_dndfunc RGFW_setDndCallback(RGFW_dndfunc func);
/*! set callback for a start of a drop event returns previous callback function (if it was set)  */
RGFWDEF RGFW_dndInitfunc RGFW_setDndInitCallback(RGFW_dndInitfunc func);
/*! set callback for a key (press / release ) event returns previous callback function (if it was set)  */
RGFWDEF RGFW_keyfunc RGFW_setKeyCallback(RGFW_keyfunc func);
/*! set callback for a mouse button (press / release ) event returns previous callback function (if it was set)  */
RGFWDEF RGFW_mousebuttonfunc RGFW_setMouseButtonCallback(RGFW_mousebuttonfunc func);
/*! set callback for a controller button (press / release ) event returns previous callback function (if it was set)  */
RGFWDEF RGFW_jsButtonfunc RGFW_setjsButtonCallback(RGFW_jsButtonfunc func);
/*! set callback for a joystick axis mov event returns previous callback function (if it was set)  */
RGFWDEF RGFW_jsAxisfunc RGFW_setjsAxisCallback(RGFW_jsAxisfunc func);

/** @} */ 

/** * @defgroup Threads
* @{ */ 

#ifndef RGFW_NO_THREADS
	/*! threading functions*/

	/*! NOTE! (for X11/linux) : if you define a window in a thread, it must be run after the original thread's window is created or else there will be a memory error */
	/*
		I'd suggest you use sili's threading functions instead
		if you're going to use sili
		which is a good idea generally
	*/

	#if defined(__unix__) || defined(__APPLE__) || defined(RGFW_WEBASM) 
		typedef void* (* RGFW_threadFunc_ptr)(void*);
	#else
		typedef DWORD (__stdcall *RGFW_threadFunc_ptr) (LPVOID lpThreadParameter);  
	#endif

	RGFWDEF RGFW_thread RGFW_createThread(RGFW_threadFunc_ptr ptr, void* args); /*!< create a thread*/
	RGFWDEF void RGFW_cancelThread(RGFW_thread thread); /*!< cancels a thread*/
	RGFWDEF void RGFW_joinThread(RGFW_thread thread); /*!< join thread to current thread */
	RGFWDEF void RGFW_setThreadPriority(RGFW_thread thread, u8 priority); /*!< sets the priority priority  */
#endif

/** @} */ 

/** * @defgroup joystick
* @{ */ 

/*! joystick count starts at 0*/
/*!< register joystick to window based on a number (the number is based on when it was connected eg. /dev/js0)*/
RGFWDEF u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber);
RGFWDEF u16 RGFW_registerJoystickF(RGFW_window* win, char* file);

RGFWDEF u32 RGFW_isPressedJS(RGFW_window* win, u16 controller, u8 button);

/** @} */ 

/** * @defgroup graphics_API
* @{ */ 

/*!< make the window the current opengl drawing context

	NOTE:
 	if you want to switch the graphics context's thread, 
	you have to run RGFW_window_makeCurrent(NULL); on the old thread
	then RGFW_window_makeCurrent(valid_window) on the new thread
*/
RGFWDEF void RGFW_window_makeCurrent(RGFW_window* win);

/*< updates fps / sets fps to cap (must by ran manually by the user at the end of a frame), returns current fps */
RGFWDEF u32 RGFW_window_checkFPS(RGFW_window* win, u32 fpsCap);

/* supports openGL, directX, OSMesa, EGL and software rendering */
RGFWDEF void RGFW_window_swapBuffers(RGFW_window* win); /*!< swap the rendering buffer */
RGFWDEF void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval);

RGFWDEF void RGFW_window_setGPURender(RGFW_window* win, i8 set);
RGFWDEF void RGFW_window_setCPURender(RGFW_window* win, i8 set);

/*! native API functions */
#if defined(RGFW_OPENGL) || defined(RGFW_EGL)
	/*! OpenGL init hints */
	RGFWDEF void RGFW_setGLStencil(i32 stencil); /*!< set stencil buffer bit size (8 by default) */
	RGFWDEF void RGFW_setGLSamples(i32 samples); /*!< set number of sampiling buffers (4 by default) */
	RGFWDEF void RGFW_setGLStereo(i32 stereo); /*!< use GL_STEREO (GL_FALSE by default) */
	RGFWDEF void RGFW_setGLAuxBuffers(i32 auxBuffers); /*!< number of aux buffers (0 by default) */

	/*! which profile to use for the opengl verion */
	typedef RGFW_ENUM(u8, RGFW_GL_profile)  { RGFW_GL_CORE = 0,  RGFW_GL_COMPATIBILITY  };
	/*! Set OpenGL version hint (core or compatibility profile)*/
	RGFWDEF void RGFW_setGLVersion(RGFW_GL_profile profile, i32 major, i32 minor);
	RGFWDEF void RGFW_setDoubleBuffer(b8 useDoubleBuffer); 
    RGFWDEF void* RGFW_getProcAddress(const char* procname); /*!< get native opengl proc address */
    RGFWDEF void RGFW_window_makeCurrent_OpenGL(RGFW_window* win); /*!< to be called by RGFW_window_makeCurrent */
#elif defined(RGFW_DIRECTX)
	typedef struct {
		IDXGIFactory* pFactory;
		IDXGIAdapter* pAdapter;
		ID3D11Device* pDevice;
		ID3D11DeviceContext* pDeviceContext;
	} RGFW_directXinfo;

	/*
		RGFW stores a global instance of RGFW_directXinfo,
		you can use this function to get a pointer the instance
	*/
	RGFWDEF RGFW_directXinfo* RGFW_getDirectXInfo(void);
#endif

/** @} */ 

/** * @defgroup Supporting
* @{ */ 
RGFWDEF u64 RGFW_getTime(void); /*!< get time in seconds */
RGFWDEF u64 RGFW_getTimeNS(void); /*!< get time in nanoseconds */
RGFWDEF void RGFW_sleep(u64 milisecond); /*!< sleep for a set time */

/*!
	key codes and mouse icon enums
*/

typedef RGFW_ENUM(u8, RGFW_Key) {
	RGFW_KEY_NULL = 0,
	RGFW_Escape,
	RGFW_F1,
	RGFW_F2,
	RGFW_F3,
	RGFW_F4,
	RGFW_F5,
	RGFW_F6,
	RGFW_F7,
	RGFW_F8,
	RGFW_F9,
	RGFW_F10,
	RGFW_F11,
	RGFW_F12,

	RGFW_Backtick,

	RGFW_0,
	RGFW_1,
	RGFW_2,
	RGFW_3,
	RGFW_4,
	RGFW_5,
	RGFW_6,
	RGFW_7,
	RGFW_8,
	RGFW_9,

	RGFW_Minus,
	RGFW_Equals,
	RGFW_BackSpace,
	RGFW_Tab,
	RGFW_CapsLock,
	RGFW_ShiftL,
	RGFW_ControlL,
	RGFW_AltL,
	RGFW_SuperL,
	RGFW_ShiftR,
	RGFW_ControlR,
	RGFW_AltR,
	RGFW_SuperR,
	RGFW_Space,

	RGFW_a,
	RGFW_b,
	RGFW_c,
	RGFW_d,
	RGFW_e,
	RGFW_f,
	RGFW_g,
	RGFW_h,
	RGFW_i,
	RGFW_j,
	RGFW_k,
	RGFW_l,
	RGFW_m,
	RGFW_n,
	RGFW_o,
	RGFW_p,
	RGFW_q,
	RGFW_r,
	RGFW_s,
	RGFW_t,
	RGFW_u,
	RGFW_v,
	RGFW_w,
	RGFW_x,
	RGFW_y,
	RGFW_z,

	RGFW_Period,
	RGFW_Comma,
	RGFW_Slash,
	RGFW_Bracket,
	RGFW_CloseBracket,
	RGFW_Semicolon,
	RGFW_Return,
	RGFW_Quote,
	RGFW_BackSlash,

	RGFW_Up,
	RGFW_Down,
	RGFW_Left,
	RGFW_Right,

	RGFW_Delete,
	RGFW_Insert,
	RGFW_End,
	RGFW_Home,
	RGFW_PageUp,
	RGFW_PageDown,

	RGFW_Numlock,
	RGFW_KP_Slash,
	RGFW_Multiply,
	RGFW_KP_Minus,
	RGFW_KP_1,
	RGFW_KP_2,
	RGFW_KP_3,
	RGFW_KP_4,
	RGFW_KP_5,
	RGFW_KP_6,
	RGFW_KP_7,
	RGFW_KP_8,
	RGFW_KP_9,
	RGFW_KP_0,
	RGFW_KP_Period,
	RGFW_KP_Return,

	final_key,
};


typedef RGFW_ENUM(u8, RGFW_mouseIcons) {
	RGFW_MOUSE_NORMAL = 0,
	RGFW_MOUSE_ARROW,
	RGFW_MOUSE_IBEAM,
	RGFW_MOUSE_CROSSHAIR,
	RGFW_MOUSE_POINTING_HAND,
	RGFW_MOUSE_RESIZE_EW,
	RGFW_MOUSE_RESIZE_NS,
	RGFW_MOUSE_RESIZE_NWSE,
	RGFW_MOUSE_RESIZE_NESW,
	RGFW_MOUSE_RESIZE_ALL,
	RGFW_MOUSE_NOT_ALLOWED,
};

/** @} */ 

#endif /* RGFW_HEADER */

/*
Example to get you started :

linux : gcc main.c -lX11 -lXcursor -lGL
windows : gcc main.c -lopengl32 -lshell32 -lgdi32
macos : gcc main.c -framework Foundation -framework AppKit -framework OpenGL -framework CoreVideo

#define RGFW_IMPLEMENTATION
#include "RGFW.h"

u8 icon[4 * 3 * 3] = {0xFF, 0x00, 0x00, 0xFF,    0xFF, 0x00, 0x00, 0xFF,     0xFF, 0x00, 0x00, 0xFF,   0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF,     0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF};

int main() {
	RGFW_window* win = RGFW_createWindow("name", RGFW_RECT(500, 500, 500, 500), (u64)0);

	RGFW_window_setIcon(win, icon, RGFW_AREA(3, 3), 4);

	for (;;) {
		RGFW_window_checkEvent(win); // NOTE: checking events outside of a while loop may cause input lag
		if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape))
			break;

		RGFW_window_swapBuffers(win);

		glClearColor(0xFF, 0XFF, 0xFF, 0xFF);
		glClear(GL_COLOR_BUFFER_BIT);
	}

	RGFW_window_close(win);
}

	compiling :

	if you wish to compile the library all you have to do is create a new file with this in it

	rgfw.c
	#define RGFW_IMPLEMENTATION
	#include "RGFW.h"

	then you can use gcc (or whatever compile you wish to use) to compile the library into object file

	ex. gcc -c RGFW.c -fPIC

	after you compile the library into an object file, you can also turn the object file into an static or shared library

	(commands ar and gcc can be replaced with whatever equivalent your system uses)
	static : ar rcs RGFW.a RGFW.o
	shared :
		windows:
			gcc -shared RGFW.o -lopengl32 -lshell32 -lgdi32 -o RGFW.dll
		linux:
			gcc -shared RGFW.o -lX11 -lXcursor -lGL -o RGFW.so
		macos:
			gcc -shared RGFW.o -framework Foundation -framework AppKit -framework OpenGL -framework CoreVideo
*/

#ifdef RGFW_X11
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) l
#elif defined(RGFW_WINDOWS)
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) w
#elif defined(RGFW_MACOS)
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) m
#elif defined(RGFW_WEBASM)
	#define RGFW_OS_BASED_VALUE(l, w, m, h, ww) h
#elif defined(RGFW_WAYLAND)
    #define RGFW_OS_BASED_VALUE(l, w, m, h, ww) ww  
#endif


#ifdef RGFW_IMPLEMENTATION

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <assert.h>

/*
RGFW_IMPLEMENTATION starts with generic RGFW defines

This is the start of keycode data

	Why not use macros instead of the numbers itself?
	Windows -> Not all virtual keys are macros (VK_0 - VK_1, VK_a - VK_z)
	Linux -> Only symcodes are values, (XK_0 - XK_1, XK_a - XK_z) are larger than 0xFF00, I can't find any way to work with them without making the array an unreasonable size
	MacOS -> windows and linux already don't have keycodes as macros, so there's no point
*/



/* 
	the c++ compiler doesn't support setting up an array like, 
	we'll have to do it during runtime using a function & this messy setup
*/
#ifndef __cplusplus
#define RGFW_NEXT ,
#define RGFW_MAP
#else 
#define RGFW_NEXT ;
#define RGFW_MAP RGFW_keycodes
#endif

#ifdef RGFW_WAYLAND
#include <linux/input-event-codes.h>
#endif

u8 RGFW_keycodes [RGFW_OS_BASED_VALUE(136, 337, 128, DOM_VK_WIN_OEM_CLEAR + 1, 130)] = {
#ifdef __cplusplus
	0
};
void RGFW_init_keys(void) {
#endif
	RGFW_MAP [RGFW_OS_BASED_VALUE(49, 192, 50, DOM_VK_BACK_QUOTE, KEY_GRAVE)] = RGFW_Backtick 		RGFW_NEXT

	RGFW_MAP [RGFW_OS_BASED_VALUE(19, 0x30, 29, DOM_VK_0, KEY_0)] = RGFW_0 					RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(10, 0x31, 18, DOM_VK_1, KEY_1)] = RGFW_1						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(11, 0x32, 19, DOM_VK_2, KEY_2)] = RGFW_2						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(12, 0x33, 20, DOM_VK_3, KEY_3)] = RGFW_3						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(13, 0x34, 21, DOM_VK_4, KEY_4)] = RGFW_4						RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(14, 0x35, 23, DOM_VK_5, KEY_5)] = RGFW_5                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(15, 0x36, 22, DOM_VK_6, KEY_6)] = RGFW_6                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(16, 0x37, 26, DOM_VK_7, KEY_7)] = RGFW_7                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(17, 0x38, 28, DOM_VK_8, KEY_8)] = RGFW_8                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(18, 0x39, 25, DOM_VK_9, KEY_9)] = RGFW_9,

	RGFW_MAP [RGFW_OS_BASED_VALUE(65, 0x20, 49, DOM_VK_SPACE, KEY_SPACE)] = RGFW_Space,

	RGFW_MAP [RGFW_OS_BASED_VALUE(38, 0x41, 0, DOM_VK_A, KEY_A)] = RGFW_a                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(56, 0x42, 11, DOM_VK_B, KEY_B)] = RGFW_b                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(54, 0x43, 8, DOM_VK_C, KEY_C)] = RGFW_c                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(40, 0x44, 2, DOM_VK_D, KEY_D)] = RGFW_d                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(26, 0x45, 14, DOM_VK_E, KEY_E)] = RGFW_e                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(41, 0x46, 3, DOM_VK_F, KEY_F)] = RGFW_f                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(42, 0x47, 5, DOM_VK_G, KEY_G)] = RGFW_g                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(43, 0x48, 4, DOM_VK_H, KEY_H)] = RGFW_h                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(31, 0x49, 34, DOM_VK_I, KEY_I)] = RGFW_i                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(44, 0x4A, 38, DOM_VK_J, KEY_J)] = RGFW_j                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(45, 0x4B, 40, DOM_VK_K, KEY_K)] = RGFW_k                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(46, 0x4C, 37, DOM_VK_L, KEY_L)] = RGFW_l                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(58, 0x4D, 46, DOM_VK_M, KEY_M)] = RGFW_m                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(57, 0x4E, 45, DOM_VK_N, KEY_N)] = RGFW_n                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(32, 0x4F, 31, DOM_VK_O, KEY_O)] = RGFW_o                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(33, 0x50, 35, DOM_VK_P, KEY_P)] = RGFW_p                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(24, 0x51, 12, DOM_VK_Q, KEY_Q)] = RGFW_q                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(27, 0x52, 15, DOM_VK_R, KEY_R)] = RGFW_r                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(39, 0x53, 1, DOM_VK_S, KEY_S)] = RGFW_s                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(28, 0x54, 17, DOM_VK_T, KEY_T)] = RGFW_t                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(30, 0x55, 32, DOM_VK_U, KEY_U)] = RGFW_u                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(55, 0x56, 9, DOM_VK_V, KEY_V)] = RGFW_v                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(25, 0x57, 13, DOM_VK_W, KEY_W)] = RGFW_w                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(53, 0x58, 7, DOM_VK_X, KEY_X)] = RGFW_x                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(29, 0x59, 16, DOM_VK_Y, KEY_Y)] = RGFW_y                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(52, 0x5A, 6, DOM_VK_Z, KEY_Z)] = RGFW_z,

	RGFW_MAP [RGFW_OS_BASED_VALUE(60, 190, 47, DOM_VK_PERIOD, KEY_DOT)] = RGFW_Period             			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(59, 188, 43, DOM_VK_COMMA, KEY_COMMA)] = RGFW_Comma               			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(61, 191, 44, DOM_VK_SLASH, KEY_SLASH)] = RGFW_Slash               			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(34, 219, 33, DOM_VK_OPEN_BRACKET, KEY_LEFTBRACE)] = RGFW_Bracket      			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(35, 221, 30, DOM_VK_CLOSE_BRACKET, KEY_RIGHTBRACE)] = RGFW_CloseBracket             RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(47, 186, 41, DOM_VK_SEMICOLON, KEY_SEMICOLON)] = RGFW_Semicolon                 RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(48, 222, 39, DOM_VK_QUOTE, KEY_APOSTROPHE)] = RGFW_Quote                 			RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(51, 322, 42, DOM_VK_BACK_SLASH, KEY_BACKSLASH)] = RGFW_BackSlash,
	
	RGFW_MAP [RGFW_OS_BASED_VALUE(36, 0x0D, 36, DOM_VK_RETURN, KEY_ENTER)] = RGFW_Return              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(119, 0x2E, 118, DOM_VK_DELETE, KEY_DELETE)] = RGFW_Delete                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(77, 0x90, 72, DOM_VK_NUM_LOCK, KEY_NUMLOCK)] = RGFW_Numlock               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(106, 0x6F, 82, DOM_VK_DIVIDE, KEY_KPSLASH)] = RGFW_KP_Slash               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(63, 0x6A, 76, DOM_VK_MULTIPLY, KEY_KPASTERISK)] = RGFW_Multiply              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(82, 0x6D, 67, DOM_VK_SUBTRACT, KEY_KPMINUS)] = RGFW_KP_Minus              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(87, 0x61, 84, DOM_VK_NUMPAD1, KEY_KP1)] = RGFW_KP_1               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(88, 0x62, 85, DOM_VK_NUMPAD2, KEY_KP2)] = RGFW_KP_2               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(89, 0x63, 86, DOM_VK_NUMPAD3, KEY_KP3)] = RGFW_KP_3               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(83, 0x64, 87, DOM_VK_NUMPAD4, KEY_KP4)] = RGFW_KP_4               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(84, 0x65, 88, DOM_VK_NUMPAD5, KEY_KP5)] = RGFW_KP_5               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(85, 0x66, 89, DOM_VK_NUMPAD6, KEY_KP6)] = RGFW_KP_6               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(79, 0x67, 90, DOM_VK_NUMPAD7, KEY_KP7)] = RGFW_KP_7               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(80, 0x68, 92, DOM_VK_NUMPAD8, KEY_KP8)] = RGFW_KP_8               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(81, 0x69, 93, DOM_VK_NUMPAD9, KEY_KP9)] = RGFW_KP_9               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(90, 0x60, 83, DOM_VK_NUMPAD0, KEY_KP0)] = RGFW_KP_0               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(91, 0x6E, 65, DOM_VK_DECIMAL, KEY_KPDOT)] = RGFW_KP_Period              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(104, 0x92, 77, 0, KEY_KPENTER)] = RGFW_KP_Return,
	
	RGFW_MAP [RGFW_OS_BASED_VALUE(20, 189, 27, DOM_VK_HYPHEN_MINUS, KEY_MINUS)] = RGFW_Minus              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(21, 187, 24, DOM_VK_EQUALS, KEY_EQUAL)] = RGFW_Equals               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(22, 8, 51, DOM_VK_BACK_SPACE, KEY_BACKSPACE)] = RGFW_BackSpace              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(23, 0x09, 48, DOM_VK_TAB, KEY_TAB)] = RGFW_Tab                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(66, 20, 57, DOM_VK_CAPS_LOCK, KEY_CAPSLOCK)] = RGFW_CapsLock               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(50, 0x10, 56, DOM_VK_SHIFT, KEY_LEFTSHIFT)] = RGFW_ShiftL               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(37, 0x11, 59, DOM_VK_CONTROL, KEY_LEFTCTRL)] = RGFW_ControlL               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(64,0x12, 58, DOM_VK_ALT, KEY_LEFTALT)] = RGFW_AltL                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(133, 0x5B, 55, DOM_VK_WIN, KEY_LEFTMETA)] = RGFW_SuperL,
	
	#if !defined(RGFW_WINDOWS) && !defined(RGFW_MACOS) && !defined(RGFW_WEBASM)
	RGFW_MAP [RGFW_OS_BASED_VALUE(105, 0x11, 59, 0, KEY_RIGHTCTRL)] = RGFW_ControlR               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(135, 0xA4, 55, 0, KEY_RIGHTMETA)] = RGFW_SuperR,
	RGFW_MAP [RGFW_OS_BASED_VALUE(62, 0x5C, 56, 0, KEY_RIGHTSHIFT)] = RGFW_ShiftR              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(108, 165, 58, 0, KEY_RIGHTALT)] = RGFW_AltR,
	#endif

	RGFW_MAP [RGFW_OS_BASED_VALUE(67, 0x70, 127, DOM_VK_F1, KEY_F1)] = RGFW_F1                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(68, 0x71, 121, DOM_VK_F2, KEY_F2)] = RGFW_F2                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(69, 0x72, 100, DOM_VK_F3, KEY_F3)] = RGFW_F3                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(70, 0x73, 119, DOM_VK_F4, KEY_F4)] = RGFW_F4                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(71, 0x74, 97, DOM_VK_F5, KEY_F5)] = RGFW_F5              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(72, 0x75, 98, DOM_VK_F6, KEY_F6)] = RGFW_F6              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(73, 0x76, 99, DOM_VK_F7, KEY_F7)] = RGFW_F7              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(74, 0x77, 101, DOM_VK_F8, KEY_F8)] = RGFW_F8                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(75, 0x78, 102, DOM_VK_F9, KEY_F9)] = RGFW_F9                 		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(76, 0x79, 110, DOM_VK_F10, KEY_F10)] = RGFW_F10               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(95, 0x7A, 104, DOM_VK_F11, KEY_F11)] = RGFW_F11               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(96, 0x7B, 112, DOM_VK_F12, KEY_F12)] = RGFW_F12               RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(111, 0x26, 126, DOM_VK_UP, KEY_UP)] = RGFW_Up                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(116, 0x28, 125, DOM_VK_DOWN, KEY_DOWN)] = RGFW_Down                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(113, 0x25, 123, DOM_VK_LEFT, KEY_LEFT)] = RGFW_Left                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(114, 0x27, 124, DOM_VK_RIGHT, KEY_RIGHT)] = RGFW_Right              RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(118, 0x2D, 115, DOM_VK_INSERT, KEY_INSERT)] = RGFW_Insert                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(115, 0x23, 120, DOM_VK_END, KEY_END)] = RGFW_End                  		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(112, 336, 117, DOM_VK_PAGE_UP, KEY_PAGEUP)] = RGFW_PageUp                		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(117, 325, 122, DOM_VK_PAGE_DOWN, KEY_PAGEDOWN)] = RGFW_PageDown            RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(9, 0x1B, 53, DOM_VK_ESCAPE, KEY_ESC)] = RGFW_Escape                   		RGFW_NEXT
	RGFW_MAP [RGFW_OS_BASED_VALUE(110, 0x24, 116, DOM_VK_HOME, KEY_HOME)] = RGFW_Home                    		RGFW_NEXT
#ifndef __cplusplus
};
#else 
}
#endif

#undef RGFW_NEXT
#undef RGFW_MAP

typedef struct {
	b8 current  : 1;
	b8 prev  : 1;
} RGFW_keyState;

RGFW_keyState RGFW_keyboard[final_key] = { {0, 0} };

RGFWDEF u32 RGFW_apiKeyCodeToRGFW(u32 keycode);

u32 RGFW_apiKeyCodeToRGFW(u32 keycode) {
	#ifdef __cplusplus
	if (RGFW_OS_BASED_VALUE(49, 192, 50, DOM_VK_BACK_QUOTE, KEY_GRAVE) != RGFW_Backtick) {
		RGFW_init_keys();
	}
	#endif

	/* make sure the key isn't out of bounds */
	if (keycode > sizeof(RGFW_keycodes) / sizeof(u8))
		return 0;
	
	return RGFW_keycodes[keycode];
}

RGFWDEF void RGFW_resetKey(void);
void RGFW_resetKey(void) {
	size_t len = final_key; /*!< last_key == length */
	
	size_t i; /*!< reset each previous state  */
	for (i = 0; i < len; i++)
		RGFW_keyboard[i].prev = 0;
}

b8 RGFW_shouldShift(u32 keycode, u8 lockState) {
    #define RGFW_xor(x, y) (( (x) && (!(y)) ) ||  ((y) && (!(x)) ))
    b8 caps4caps = (lockState & RGFW_CAPSLOCK) && ((keycode >= RGFW_a) && (keycode <= RGFW_z));
    b8 shouldShift = RGFW_xor((RGFW_isPressed(NULL, RGFW_ShiftL) || RGFW_isPressed(NULL, RGFW_ShiftR)), caps4caps);
    #undef RGFW_xor

	return shouldShift;
}	

char RGFW_keyCodeToChar(u32 keycode, b8 shift) {
    static const char map[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '`', '0', '1', '2', '3', '4', '5', '6', '7', '8', 
        '9', '-', '=', 0, '\t',  0, 0, 0, 0, 0, 0, 0, 0, 0, ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
        'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '.', ',', '/', '[', ']',  ';', '\n', '\'', '\\', 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  '/', '*', '-', '1', '2', '3',  '3', '5', '6', '7', '8',  '9', '0', '\n'
    };

    static const char mapCaps[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '~', ')', '!', '@', '#', '$', '%', '^', '&', '*', 
        '(', '_', '+', 0, '0',  0, 0, 0, 0, 0, 0, 0, 0, 0, ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
        'X', 'Y', 'Z', '>', '<', '?', '{', '}',  ':', '\n', '"', '|', 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '?', '*', '-', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    if (shift == RGFW_FALSE)
        return map[keycode]; 
    return mapCaps[keycode];
}

char RGFW_keyCodeToCharAuto(u32 keycode, u8 lockState) { return RGFW_keyCodeToChar(keycode, RGFW_shouldShift(keycode, lockState)); }

/*
	this is the end of keycode data
*/

/* joystick data */
u8 RGFW_jsPressed[4][16]; /*!< if a key is currently pressed or not (per joystick) */

i32 RGFW_joysticks[4]; /*!< limit of 4 joysticks at a time */
u16 RGFW_joystickCount; /*!< the actual amount of joysticks */

/* 
	event callback defines start here
*/


/*
	These exist to avoid the 
	if (func == NULL) check 
	for (allegedly) better performance
*/
void RGFW_windowmovefuncEMPTY(RGFW_window* win, RGFW_rect r) { RGFW_UNUSED(win); RGFW_UNUSED(r); }
void RGFW_windowresizefuncEMPTY(RGFW_window* win, RGFW_rect r) { RGFW_UNUSED(win); RGFW_UNUSED(r); }
void RGFW_windowquitfuncEMPTY(RGFW_window* win) { RGFW_UNUSED(win); }
void RGFW_focusfuncEMPTY(RGFW_window* win, b8 inFocus) {RGFW_UNUSED(win); RGFW_UNUSED(inFocus);}
void RGFW_mouseNotifyfuncEMPTY(RGFW_window* win, RGFW_point point, b8 status) {RGFW_UNUSED(win); RGFW_UNUSED(point); RGFW_UNUSED(status);}
void RGFW_mouseposfuncEMPTY(RGFW_window* win, RGFW_point point) {RGFW_UNUSED(win); RGFW_UNUSED(point);}
void RGFW_dndInitfuncEMPTY(RGFW_window* win, RGFW_point point) {RGFW_UNUSED(win); RGFW_UNUSED(point);}
void RGFW_windowrefreshfuncEMPTY(RGFW_window* win) {RGFW_UNUSED(win); }
void RGFW_keyfuncEMPTY(RGFW_window* win, u32 keycode, char keyName[16], u8 lockState, b8 pressed) {RGFW_UNUSED(win); RGFW_UNUSED(keycode); RGFW_UNUSED(keyName); RGFW_UNUSED(lockState); RGFW_UNUSED(pressed);}
void RGFW_mousebuttonfuncEMPTY(RGFW_window* win, u8 button, double scroll, b8 pressed) {RGFW_UNUSED(win); RGFW_UNUSED(button); RGFW_UNUSED(scroll); RGFW_UNUSED(pressed);}
void RGFW_jsButtonfuncEMPTY(RGFW_window* win, u16 joystick, u8 button, b8 pressed){RGFW_UNUSED(win); RGFW_UNUSED(joystick); RGFW_UNUSED(button); RGFW_UNUSED(pressed); }
void RGFW_jsAxisfuncEMPTY(RGFW_window* win, u16 joystick, RGFW_point axis[2], u8 axisesCount){RGFW_UNUSED(win); RGFW_UNUSED(joystick); RGFW_UNUSED(axis); RGFW_UNUSED(axisesCount); }

#ifdef RGFW_ALLOC_DROPFILES
void RGFW_dndfuncEMPTY(RGFW_window* win, char** droppedFiles, u32 droppedFilesCount) {RGFW_UNUSED(win); RGFW_UNUSED(droppedFiles); RGFW_UNUSED(droppedFilesCount);}
#else
void RGFW_dndfuncEMPTY(RGFW_window* win, char droppedFiles[RGFW_MAX_DROPS][RGFW_MAX_PATH], u32 droppedFilesCount) {RGFW_UNUSED(win); RGFW_UNUSED(droppedFiles); RGFW_UNUSED(droppedFilesCount);}
#endif

RGFW_windowmovefunc RGFW_windowMoveCallback = RGFW_windowmovefuncEMPTY;
RGFW_windowresizefunc RGFW_windowResizeCallback = RGFW_windowresizefuncEMPTY;
RGFW_windowquitfunc RGFW_windowQuitCallback = RGFW_windowquitfuncEMPTY;
RGFW_mouseposfunc RGFW_mousePosCallback = RGFW_mouseposfuncEMPTY;
RGFW_windowrefreshfunc RGFW_windowRefreshCallback = RGFW_windowrefreshfuncEMPTY;
RGFW_focusfunc RGFW_focusCallback = RGFW_focusfuncEMPTY;
RGFW_mouseNotifyfunc RGFW_mouseNotifyCallBack = RGFW_mouseNotifyfuncEMPTY;
RGFW_dndfunc RGFW_dndCallback = RGFW_dndfuncEMPTY;
RGFW_dndInitfunc RGFW_dndInitCallback = RGFW_dndInitfuncEMPTY;
RGFW_keyfunc RGFW_keyCallback = RGFW_keyfuncEMPTY;
RGFW_mousebuttonfunc RGFW_mouseButtonCallback = RGFW_mousebuttonfuncEMPTY;
RGFW_jsButtonfunc RGFW_jsButtonCallback = RGFW_jsButtonfuncEMPTY;
RGFW_jsAxisfunc RGFW_jsAxisCallback = RGFW_jsAxisfuncEMPTY;

void RGFW_window_checkEvents(RGFW_window* win, i32 waitMS) { 
	RGFW_window_eventWait(win, waitMS);

	while (RGFW_window_checkEvent(win) != NULL && RGFW_window_shouldClose(win) == 0) { 
		if (win->event.type == RGFW_quit) return; 
	}
	
	#ifdef RGFW_WEBASM /* webasm needs to run the sleep function for asyncify */
		RGFW_sleep(0);
	#endif
}

RGFW_windowmovefunc RGFW_setWindowMoveCallback(RGFW_windowmovefunc func) { 
	RGFW_windowmovefunc	prev =  (RGFW_windowMoveCallback == RGFW_windowmovefuncEMPTY) ? NULL : RGFW_windowMoveCallback;
	RGFW_windowMoveCallback = func;
	return prev;
}
RGFW_windowresizefunc RGFW_setWindowResizeCallback(RGFW_windowresizefunc func) {
    RGFW_windowresizefunc prev = (RGFW_windowResizeCallback == RGFW_windowresizefuncEMPTY) ? NULL : RGFW_windowResizeCallback;
    RGFW_windowResizeCallback = func;
    return prev;
}
RGFW_windowquitfunc RGFW_setWindowQuitCallback(RGFW_windowquitfunc func) {
    RGFW_windowquitfunc prev = (RGFW_windowQuitCallback == RGFW_windowquitfuncEMPTY) ? NULL : RGFW_windowQuitCallback;
    RGFW_windowQuitCallback = func;
    return prev;
}

RGFW_mouseposfunc RGFW_setMousePosCallback(RGFW_mouseposfunc func) {
    RGFW_mouseposfunc prev = (RGFW_mousePosCallback == RGFW_mouseposfuncEMPTY) ? NULL : RGFW_mousePosCallback;
    RGFW_mousePosCallback = func;
    return prev;
}
RGFW_windowrefreshfunc RGFW_setWindowRefreshCallback(RGFW_windowrefreshfunc func) {
    RGFW_windowrefreshfunc prev = (RGFW_windowRefreshCallback == RGFW_windowrefreshfuncEMPTY) ? NULL : RGFW_windowRefreshCallback;
    RGFW_windowRefreshCallback = func;
    return prev;
}
RGFW_focusfunc RGFW_setFocusCallback(RGFW_focusfunc func) {
    RGFW_focusfunc prev = (RGFW_focusCallback == RGFW_focusfuncEMPTY) ? NULL : RGFW_focusCallback;
    RGFW_focusCallback = func;
    return prev;
}

RGFW_mouseNotifyfunc RGFW_setMouseNotifyCallBack(RGFW_mouseNotifyfunc func) {
    RGFW_mouseNotifyfunc prev = (RGFW_mouseNotifyCallBack == RGFW_mouseNotifyfuncEMPTY) ? NULL : RGFW_mouseNotifyCallBack;
    RGFW_mouseNotifyCallBack = func;
    return prev;
}
RGFW_dndfunc RGFW_setDndCallback(RGFW_dndfunc func) {
    RGFW_dndfunc prev = (RGFW_dndCallback == RGFW_dndfuncEMPTY) ? NULL : RGFW_dndCallback;
    RGFW_dndCallback = func;
    return prev;
}
RGFW_dndInitfunc RGFW_setDndInitCallback(RGFW_dndInitfunc func) {
    RGFW_dndInitfunc prev = (RGFW_dndInitCallback == RGFW_dndInitfuncEMPTY) ? NULL : RGFW_dndInitCallback;
    RGFW_dndInitCallback = func;
    return prev;
}
RGFW_keyfunc RGFW_setKeyCallback(RGFW_keyfunc func) {
    RGFW_keyfunc prev = (RGFW_keyCallback == RGFW_keyfuncEMPTY) ? NULL : RGFW_keyCallback;
    RGFW_keyCallback = func;
    return prev;
}
RGFW_mousebuttonfunc RGFW_setMouseButtonCallback(RGFW_mousebuttonfunc func) {
    RGFW_mousebuttonfunc prev = (RGFW_mouseButtonCallback == RGFW_mousebuttonfuncEMPTY) ? NULL : RGFW_mouseButtonCallback;
    RGFW_mouseButtonCallback = func;
    return prev;
}
RGFW_jsButtonfunc RGFW_setjsButtonCallback(RGFW_jsButtonfunc func) {
    RGFW_jsButtonfunc prev = (RGFW_jsButtonCallback == RGFW_jsButtonfuncEMPTY) ? NULL : RGFW_jsButtonCallback;
    RGFW_jsButtonCallback = func;
    return prev;
}
RGFW_jsAxisfunc RGFW_setjsAxisCallback(RGFW_jsAxisfunc func) {
    RGFW_jsAxisfunc prev = (RGFW_jsAxisCallback == RGFW_jsAxisfuncEMPTY) ? NULL : RGFW_jsAxisCallback;
    RGFW_jsAxisCallback = func;
    return prev;
}
/* 
no more event call back defines
*/

#define RGFW_ASSERT(check, str) {\
	if (!(check)) { \
		printf(str); \
		assert(check); \
	} \
}

b8 RGFW_error = 0;
b8 RGFW_Error(void) { return RGFW_error; }

#define SET_ATTRIB(a, v) { \
    assert(((size_t) index + 1) < sizeof(attribs) / sizeof(attribs[0])); \
    attribs[index++] = a; \
    attribs[index++] = v; \
}
	
RGFW_area RGFW_bufferSize = {0, 0};
void RGFW_setBufferSize(RGFW_area size) {
	RGFW_bufferSize = size;
}


RGFWDEF RGFW_window* RGFW_window_basic_init(RGFW_rect rect, u16 args);

/* do a basic initialization for RGFW_window, this is to standard it for each OS */
RGFW_window* RGFW_window_basic_init(RGFW_rect rect, u16 args) {
	RGFW_window* win = (RGFW_window*) RGFW_MALLOC(sizeof(RGFW_window)); /*!< make a new RGFW struct */

	/* clear out dnd info */
#ifdef RGFW_ALLOC_DROPFILES
	win->event.droppedFiles = (char**) RGFW_MALLOC(sizeof(char*) * RGFW_MAX_DROPS);
	u32 i;
	for (i = 0; i < RGFW_MAX_DROPS; i++)
		win->event.droppedFiles[i] = (char*) RGFW_CALLOC(RGFW_MAX_PATH, sizeof(char));
#endif

	/* X11 requires us to have a display to get the screen size */
	#ifndef RGFW_X11 
	RGFW_area screenR = RGFW_getScreenSize();
	#else
	win->src.display = XOpenDisplay(NULL);
	assert(win->src.display != NULL);

	Screen* scrn = DefaultScreenOfDisplay((Display*)win->src.display);
	RGFW_area screenR = RGFW_AREA((u32)scrn->width, (u32)scrn->height);
	#endif
	
	/* rect based the requested args */
	if (args & RGFW_FULLSCREEN)
		rect = RGFW_RECT(0, 0, screenR.w, screenR.h);

	if (args & RGFW_CENTER)
		rect = RGFW_RECT((screenR.w - rect.w) / 2, (screenR.h - rect.h) / 2, rect.w, rect.h);

	/* set and init the new window's data */
	win->r = rect;
	win->event.inFocus = 1;
	win->event.droppedFilesCount = 0;
	RGFW_joystickCount = 0;
	win->_winArgs = 0;
	win->event.lockState = 0;

	return win;
}

#ifndef RGFW_NO_MONITOR
void RGFW_window_scaleToMonitor(RGFW_window* win) {
	RGFW_monitor monitor = RGFW_window_getMonitor(win);
	
	RGFW_window_resize(win, RGFW_AREA(((u32) monitor.scaleX) * win->r.w, ((u32) monitor.scaleX) * win->r.h));
}
#endif

RGFW_window* RGFW_root = NULL;


#define RGFW_HOLD_MOUSE			(1L<<2) /*!< hold the moues still */
#define RGFW_MOUSE_LEFT 		(1L<<3) /* if mouse left the window */

char* RGFW_className = NULL;
void RGFW_setClassName(char* name) {
	RGFW_className = name;
}

void RGFW_clipboardFree(char* str) { RGFW_FREE(str); }

RGFW_keyState RGFW_mouseButtons[5] = { {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0} };

b8 RGFW_isMousePressed(RGFW_window* win, u8 button) {
	assert(win != NULL);
	return RGFW_mouseButtons[button].current && (win != NULL) && win->event.inFocus; 
}
b8 RGFW_wasMousePressed(RGFW_window* win, u8 button) {
	assert(win != NULL); 
	return RGFW_mouseButtons[button].prev && (win != NULL) && win->event.inFocus; 
}
b8 RGFW_isMouseHeld(RGFW_window* win, u8 button) {
	return (RGFW_isMousePressed(win, button) && RGFW_wasMousePressed(win, button));
}
b8 RGFW_isMouseReleased(RGFW_window* win, u8 button) {
	return (!RGFW_isMousePressed(win, button) && RGFW_wasMousePressed(win, button));	
}

b8 RGFW_isPressed(RGFW_window* win, u8 key) {
	return RGFW_keyboard[key].current && (win == NULL || win->event.inFocus);
}

b8 RGFW_wasPressed(RGFW_window* win, u8 key) {
	return RGFW_keyboard[key].prev && (win == NULL || win->event.inFocus);
}

b8 RGFW_isHeld(RGFW_window* win, u8 key) {
	return (RGFW_isPressed(win, key) && RGFW_wasPressed(win, key));
}

b8 RGFW_isClicked(RGFW_window* win, u8 key) {
	return (RGFW_wasPressed(win, key) && !RGFW_isPressed(win, key));
}

b8 RGFW_isReleased(RGFW_window* win, u8 key) {
	return (!RGFW_isPressed(win, key) && RGFW_wasPressed(win, key));	
}

#if defined(RGFW_WINDOWS)  && defined(RGFW_DIRECTX) /* defines for directX context*/
	RGFW_directXinfo RGFW_dxInfo;
	RGFW_directXinfo* RGFW_getDirectXInfo(void) { return &RGFW_dxInfo; }
#endif

void RGFW_window_makeCurrent(RGFW_window* win) {
#if defined(RGFW_WINDOWS) && defined(RGFW_DIRECTX)
	if (win == NULL)
		RGFW_dxInfo.pDeviceContext->lpVtbl->OMSetRenderTargets(RGFW_dxInfo.pDeviceContext, 1, NULL, NULL);
	else
		RGFW_dxInfo.pDeviceContext->lpVtbl->OMSetRenderTargets(RGFW_dxInfo.pDeviceContext, 1, &win->src.renderTargetView, NULL);
#elif defined(RGFW_OPENGL)
	RGFW_window_makeCurrent_OpenGL(win);
#else
	RGFW_UNUSED(win)
#endif
}

void RGFW_window_setGPURender(RGFW_window* win, i8 set) {
	if (!set && !(win->_winArgs & RGFW_NO_GPU_RENDER))
		win->_winArgs |= RGFW_NO_GPU_RENDER;
		
	else if (set && win->_winArgs & RGFW_NO_GPU_RENDER)
		win->_winArgs ^= RGFW_NO_GPU_RENDER;
}

void RGFW_window_setCPURender(RGFW_window* win, i8 set) {
	if (!set && !(win->_winArgs & RGFW_NO_CPU_RENDER))
		win->_winArgs |= RGFW_NO_CPU_RENDER;

	else if (set && win->_winArgs & RGFW_NO_CPU_RENDER)
		win->_winArgs ^= RGFW_NO_CPU_RENDER;
}

void RGFW_window_maximize(RGFW_window* win) {
	assert(win != NULL);

	RGFW_area screen = RGFW_getScreenSize();

	RGFW_window_move(win, RGFW_POINT(0, 0));
	RGFW_window_resize(win, screen);
}

b8 RGFW_window_shouldClose(RGFW_window* win) {
	assert(win != NULL);
	return (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape));
}

void RGFW_window_setShouldClose(RGFW_window* win) { win->event.type = RGFW_quit; RGFW_windowQuitCallback(win); }

#ifndef RGFW_NO_MONITOR
	void RGFW_window_moveToMonitor(RGFW_window* win, RGFW_monitor m) {
		RGFW_window_move(win, RGFW_POINT(m.rect.x + win->r.x, m.rect.y + win->r.y));
	}
#endif

RGFWDEF void RGFW_captureCursor(RGFW_window* win, RGFW_rect);
RGFWDEF void RGFW_releaseCursor(RGFW_window* win);

void RGFW_window_mouseHold(RGFW_window* win, RGFW_area area) {
	if ((win->_winArgs & RGFW_HOLD_MOUSE))
		return;
	

	if (!area.w && !area.h)
		area = RGFW_AREA(win->r.w / 2, win->r.h / 2);
		
	win->_winArgs |= RGFW_HOLD_MOUSE;
	RGFW_captureCursor(win, win->r);
	RGFW_window_moveMouse(win, RGFW_POINT(win->r.x + (win->r.w / 2), win->r.y + (win->r.h / 2)));
}

void RGFW_window_mouseUnhold(RGFW_window* win) {
	if ((win->_winArgs & RGFW_HOLD_MOUSE)) {
		win->_winArgs ^= RGFW_HOLD_MOUSE;

		RGFW_releaseCursor(win);
	}
}

u32 RGFW_window_checkFPS(RGFW_window* win, u32 fpsCap) {
	u64 deltaTime = RGFW_getTimeNS() - win->event.frameTime;

	u32 output_fps = 0;
	u64 fps = round(1e+9 / deltaTime);
	output_fps= fps;

	if (fpsCap && fps > fpsCap) {
		u64 frameTimeNS = 1e+9 / fpsCap;
		u64 sleepTimeMS = (frameTimeNS - deltaTime) / 1e6;

		if (sleepTimeMS > 0) {
			RGFW_sleep(sleepTimeMS);
			win->event.frameTime = 0;
		}
	}

	win->event.frameTime = RGFW_getTimeNS();
	
	if (fpsCap == 0) 
		return (u32) output_fps;
	
	deltaTime = RGFW_getTimeNS() - win->event.frameTime2;
	output_fps = round(1e+9 / deltaTime);
	win->event.frameTime2 = RGFW_getTimeNS();

	return output_fps;
}

u32 RGFW_isPressedJS(RGFW_window* win, u16 c, u8 button) { 
	RGFW_UNUSED(win);
	return RGFW_jsPressed[c][button]; 
}

#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
	void RGFW_window_showMouse(RGFW_window* win, i8 show) {
		static u8 RGFW_blk[] = { 0, 0, 0, 0 };
		if (show == 0)
			RGFW_window_setMouse(win, RGFW_blk, RGFW_AREA(1, 1), 4);
		else
			RGFW_window_setMouseDefault(win);
	}
#endif

RGFWDEF void RGFW_updateLockState(RGFW_window* win, b8 capital, b8 numlock);	
void RGFW_updateLockState(RGFW_window* win, b8 capital, b8 numlock) {
	if (capital && !(win->event.lockState & RGFW_CAPSLOCK))
		win->event.lockState |= RGFW_CAPSLOCK;
	else if (!capital && (win->event.lockState & RGFW_CAPSLOCK))			
		win->event.lockState ^= RGFW_CAPSLOCK;
	
	if (numlock && !(win->event.lockState & RGFW_NUMLOCK))
		win->event.lockState |= RGFW_NUMLOCK;
	else if (!numlock && (win->event.lockState & RGFW_NUMLOCK))
		win->event.lockState ^= RGFW_NUMLOCK;
}

#if defined(RGFW_X11) || defined(RGFW_MACOS) || defined(RGFW_WEBASM) || defined(RGFW_WAYLAND)
	struct timespec;

	int nanosleep(const struct timespec* duration, struct timespec* rem);
	int clock_gettime(clockid_t clk_id, struct timespec* tp);
	int setenv(const char *name, const char *value, int overwrite);

	void RGFW_window_setDND(RGFW_window* win, b8 allow) {
		if (allow && !(win->_winArgs & RGFW_ALLOW_DND))
			win->_winArgs |= RGFW_ALLOW_DND;

		else if (!allow && (win->_winArgs & RGFW_ALLOW_DND))
			win->_winArgs ^= RGFW_ALLOW_DND;
	}
#endif

/*
	graphics API specific code (end of generic code)
	starts here 
*/


/* 
	OpenGL defines start here   (Normal, EGL, OSMesa)
*/

#if defined(RGFW_OPENGL) || defined(RGFW_EGL) || defined(RGFW_OSMESA)
	#ifdef RGFW_WINDOWS
		#define WIN32_LEAN_AND_MEAN
		#define OEMRESOURCE
		#include <windows.h>
	#endif

	#if !defined(__APPLE__) && !defined(RGFW_NO_GL_HEADER)
		#include <GL/gl.h>
	#elif defined(__APPLE__)
		#ifndef GL_SILENCE_DEPRECATION
			#define GL_SILENCE_DEPRECATION
		#endif
		#include <OpenGL/gl.h>
		#include <OpenGL/OpenGL.h>
	#endif

/* EGL, normal OpenGL only */
#if !defined(RGFW_OSMESA) 
	i32 RGFW_majorVersion = 0, RGFW_minorVersion = 0;
	b8 RGFW_profile = RGFW_GL_CORE;
	
	#ifndef RGFW_EGL
	i32 RGFW_STENCIL = 8, RGFW_SAMPLES = 4, RGFW_STEREO = 0, RGFW_AUX_BUFFERS = 0, RGFW_DOUBLE_BUFFER = 1;
	#else
	i32 RGFW_STENCIL = 0, RGFW_SAMPLES = 0, RGFW_STEREO = 0, RGFW_AUX_BUFFERS = 0, RGFW_DOUBLE_BUFFER = 1;
	#endif


	void RGFW_setGLStencil(i32 stencil) { RGFW_STENCIL = stencil; }
	void RGFW_setGLSamples(i32 samples) { RGFW_SAMPLES = samples; }
	void RGFW_setGLStereo(i32 stereo) { RGFW_STEREO = stereo; }
	void RGFW_setGLAuxBuffers(i32 auxBuffers) { RGFW_AUX_BUFFERS = auxBuffers; }
	void RGFW_setDoubleBuffer(b8 useDoubleBuffer) { RGFW_DOUBLE_BUFFER = useDoubleBuffer; }

	void RGFW_setGLVersion(b8 profile, i32 major, i32 minor) {
        RGFW_profile = profile;
		RGFW_majorVersion = major;
		RGFW_minorVersion = minor;
	}

/* OPENGL normal only (no EGL / OSMesa) */
#ifndef RGFW_EGL

#define RGFW_GL_RENDER_TYPE 		RGFW_OS_BASED_VALUE(GLX_X_VISUAL_TYPE,    	0x2003,		73, 0, 0)
	#define RGFW_GL_ALPHA_SIZE 		RGFW_OS_BASED_VALUE(GLX_ALPHA_SIZE,       	0x201b,		11,     0, 0)
	#define RGFW_GL_DEPTH_SIZE 		RGFW_OS_BASED_VALUE(GLX_DEPTH_SIZE,       	0x2022,		12,     0, 0)
	#define RGFW_GL_DOUBLEBUFFER 		RGFW_OS_BASED_VALUE(GLX_DOUBLEBUFFER,     	0x2011, 	5,  0, 0)   
	#define RGFW_GL_STENCIL_SIZE 		RGFW_OS_BASED_VALUE(GLX_STENCIL_SIZE,	 	0x2023,	13,     0, 0)
	#define RGFW_GL_SAMPLES			RGFW_OS_BASED_VALUE(GLX_SAMPLES, 		 	0x2042,	    55,     0, 0)
	#define RGFW_GL_STEREO 			RGFW_OS_BASED_VALUE(GLX_STEREO,	 		 	0x2012,			6,  0, 0)
	#define RGFW_GL_AUX_BUFFERS		RGFW_OS_BASED_VALUE(GLX_AUX_BUFFERS,	    0x2024,	7, 		    0, 0)

#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
	#define RGFW_GL_DRAW 			RGFW_OS_BASED_VALUE(GLX_X_RENDERABLE,	 	0x2001,					0, 0, 0)
	#define RGFW_GL_DRAW_TYPE 		RGFW_OS_BASED_VALUE(GLX_RENDER_TYPE,     	0x2013,						0, 0, 0)
	#define RGFW_GL_FULL_FORMAT		RGFW_OS_BASED_VALUE(GLX_TRUE_COLOR,   	 	0x2027,						0, 0, 0)
	#define RGFW_GL_RED_SIZE		RGFW_OS_BASED_VALUE(GLX_RED_SIZE,         	0x2015,						0, 0, 0)
	#define RGFW_GL_GREEN_SIZE		RGFW_OS_BASED_VALUE(GLX_GREEN_SIZE,       	0x2017,						0, 0, 0)
	#define RGFW_GL_BLUE_SIZE		RGFW_OS_BASED_VALUE(GLX_BLUE_SIZE, 	 		0x2019,						0, 0, 0)
	#define RGFW_GL_USE_RGBA		RGFW_OS_BASED_VALUE(GLX_RGBA_BIT,   	 	0x202B,						0, 0, 0)
#endif

#ifdef RGFW_WINDOWS
	#define WGL_SUPPORT_OPENGL_ARB                    0x2010
	#define WGL_COLOR_BITS_ARB                        0x2014
	#define WGL_NUMBER_PIXEL_FORMATS_ARB 			0x2000
	#define WGL_CONTEXT_MAJOR_VERSION_ARB             0x2091
	#define WGL_CONTEXT_MINOR_VERSION_ARB             0x2092
	#define WGL_CONTEXT_PROFILE_MASK_ARB              0x9126
	#define WGL_CONTEXT_CORE_PROFILE_BIT_ARB 0x00000001
	#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
	#define WGL_SAMPLE_BUFFERS_ARB               0x2041
	#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB 0x20a9
	#define WGL_PIXEL_TYPE_ARB                        0x2013
	#define WGL_TYPE_RGBA_ARB                         0x202B

	#define WGL_TRANSPARENT_ARB   					  0x200A
#endif
	
/*  The window'ing api needs to know how to render the data we (or opengl) give it 
	MacOS and Windows do this using a structure called a "pixel format" 
	X11 calls it a "Visual"
	This function returns the attributes for the format we want */
	static u32* RGFW_initFormatAttribs(u32 useSoftware) {
		RGFW_UNUSED(useSoftware);
		static u32 attribs[] = {
								#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
								RGFW_GL_RENDER_TYPE,
								RGFW_GL_FULL_FORMAT,
								#endif
								RGFW_GL_ALPHA_SIZE      , 8,
								RGFW_GL_DEPTH_SIZE      , 24,
								#if defined(RGFW_X11) || defined(RGFW_WINDOWS)
								RGFW_GL_DRAW, 1,
								RGFW_GL_RED_SIZE        , 8,
								RGFW_GL_GREEN_SIZE      , 8,
								RGFW_GL_BLUE_SIZE       , 8,
								RGFW_GL_DRAW_TYPE     , RGFW_GL_USE_RGBA,
								#endif 

								#ifdef RGFW_X11
								GLX_DRAWABLE_TYPE   , GLX_WINDOW_BIT,
								#endif	

								#ifdef RGFW_MACOS
								72,
								8, 24,
								#endif

								#ifdef RGFW_WINDOWS
								WGL_SUPPORT_OPENGL_ARB,		1,
								WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
								WGL_COLOR_BITS_ARB,	 32,
								#endif

								0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
		};

		size_t index = (sizeof(attribs) / sizeof(attribs[0])) - 13;

#define RGFW_GL_ADD_ATTRIB(attrib, attVal) \
		if (attVal) { \
			attribs[index] = attrib;\
			attribs[index + 1] = attVal;\
			index += 2;\
		}
         
        RGFW_GL_ADD_ATTRIB(RGFW_GL_DOUBLEBUFFER, 1);
        
        RGFW_GL_ADD_ATTRIB(RGFW_GL_STENCIL_SIZE, RGFW_STENCIL);
		RGFW_GL_ADD_ATTRIB(RGFW_GL_STEREO, RGFW_STEREO);
		RGFW_GL_ADD_ATTRIB(RGFW_GL_AUX_BUFFERS, RGFW_AUX_BUFFERS);

#ifndef RGFW_X11
		RGFW_GL_ADD_ATTRIB(RGFW_GL_SAMPLES, RGFW_SAMPLES);
#endif 

#ifdef RGFW_MACOS
		if (useSoftware) {
			RGFW_GL_ADD_ATTRIB(70, kCGLRendererGenericFloatID);
		} else {
			attribs[index] = RGFW_GL_RENDER_TYPE;
			index += 1;
		}
#endif

#ifdef RGFW_MACOS
		/* macOS has the surface attribs and the opengl attribs connected for some reason
			maybe this is to give macOS more control to limit openGL/the opengl version? */

		attribs[index] = 99;
		attribs[index + 1] = 0x1000;

		if (RGFW_majorVersion >= 4 || RGFW_majorVersion >= 3) {
			attribs[index + 1] = (u32) ((RGFW_majorVersion >= 4) ? 0x4100 : 0x3200);
		}
#endif

		RGFW_GL_ADD_ATTRIB(0, 0);

		return attribs;
	}

/* EGL only (no OSMesa nor normal OPENGL) */
#elif defined(RGFW_EGL)

#include <EGL/egl.h>

#if defined(RGFW_LINK_EGL)
	typedef EGLBoolean(EGLAPIENTRY* PFN_eglInitialize)(EGLDisplay, EGLint*, EGLint*);

	PFNEGLINITIALIZEPROC eglInitializeSource;
	PFNEGLGETCONFIGSPROC eglGetConfigsSource;
	PFNEGLCHOOSECONFIGPROC eglChooseConfigSource;
	PFNEGLCREATEWINDOWSURFACEPROC eglCreateWindowSurfaceSource;
	PFNEGLCREATECONTEXTPROC eglCreateContextSource;
	PFNEGLMAKECURRENTPROC eglMakeCurrentSource;
	PFNEGLGETDISPLAYPROC eglGetDisplaySource;
	PFNEGLSWAPBUFFERSPROC eglSwapBuffersSource;
	PFNEGLSWAPINTERVALPROC eglSwapIntervalSource;
	PFNEGLBINDAPIPROC eglBindAPISource;
	PFNEGLDESTROYCONTEXTPROC eglDestroyContextSource;
	PFNEGLTERMINATEPROC eglTerminateSource;
	PFNEGLDESTROYSURFACEPROC eglDestroySurfaceSource;

#define eglInitialize eglInitializeSource
#define eglGetConfigs eglGetConfigsSource
#define eglChooseConfig eglChooseConfigSource
#define eglCreateWindowSurface eglCreateWindowSurfaceSource
#define eglCreateContext eglCreateContextSource
#define eglMakeCurrent eglMakeCurrentSource
#define eglGetDisplay eglGetDisplaySource
#define eglSwapBuffers eglSwapBuffersSource
#define eglSwapInterval eglSwapIntervalSource
#define eglBindAPI eglBindAPISource
#define eglDestroyContext eglDestroyContextSource
#define eglTerminate eglTerminateSource
#define eglDestroySurface eglDestroySurfaceSource;
#endif


#define EGL_SURFACE_MAJOR_VERSION_KHR 0x3098
#define EGL_SURFACE_MINOR_VERSION_KHR 0x30fb

#ifndef RGFW_GL_ADD_ATTRIB
#define RGFW_GL_ADD_ATTRIB(attrib, attVal) \
	if (attVal) { \
		attribs[index] = attrib;\
		attribs[index + 1] = attVal;\
		index += 2;\
	}
#endif


	void RGFW_createOpenGLContext(RGFW_window* win) {
#if defined(RGFW_LINK_EGL)
		eglInitializeSource = (PFNEGLINITIALIZEPROC) eglGetProcAddress("eglInitialize");
		eglGetConfigsSource = (PFNEGLGETCONFIGSPROC) eglGetProcAddress("eglGetConfigs");
		eglChooseConfigSource = (PFNEGLCHOOSECONFIGPROC) eglGetProcAddress("eglChooseConfig");
		eglCreateWindowSurfaceSource = (PFNEGLCREATEWINDOWSURFACEPROC) eglGetProcAddress("eglCreateWindowSurface");
		eglCreateContextSource = (PFNEGLCREATECONTEXTPROC) eglGetProcAddress("eglCreateContext");
		eglMakeCurrentSource = (PFNEGLMAKECURRENTPROC) eglGetProcAddress("eglMakeCurrent");
		eglGetDisplaySource = (PFNEGLGETDISPLAYPROC) eglGetProcAddress("eglGetDisplay");
		eglSwapBuffersSource = (PFNEGLSWAPBUFFERSPROC) eglGetProcAddress("eglSwapBuffers");
		eglSwapIntervalSource = (PFNEGLSWAPINTERVALPROC) eglGetProcAddress("eglSwapInterval");
		eglBindAPISource = (PFNEGLBINDAPIPROC) eglGetProcAddress("eglBindAPI");
		eglDestroyContextSource = (PFNEGLDESTROYCONTEXTPROC) eglGetProcAddress("eglDestroyContext");
		eglTerminateSource = (PFNEGLTERMINATEPROC) eglGetProcAddress("eglTerminate");
		eglDestroySurfaceSource = (PFNEGLDESTROYSURFACEPROC) eglGetProcAddress("eglDestroySurface");
#endif /* RGFW_LINK_EGL */

		#ifdef RGFW_WINDOWS
		win->src.EGL_display = eglGetDisplay((EGLNativeDisplayType) win->src.hdc);
		#else
		win->src.EGL_display = eglGetDisplay((EGLNativeDisplayType) win->src.display);
		#endif

		EGLint major, minor;

		eglInitialize(win->src.EGL_display, &major, &minor);

		#ifndef EGL_OPENGL_ES1_BIT
		#define EGL_OPENGL_ES1_BIT 0x1
		#endif

		EGLint egl_config[] = {
			EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
			EGL_RENDERABLE_TYPE,
			#ifdef RGFW_OPENGL_ES1
			EGL_OPENGL_ES1_BIT,
			#elif defined(RGFW_OPENGL_ES3)
			EGL_OPENGL_ES3_BIT,
			#elif defined(RGFW_OPENGL_ES2)
			EGL_OPENGL_ES2_BIT,
			#else
			EGL_OPENGL_BIT,
			#endif
			EGL_NONE, EGL_NONE
		};

		EGLConfig config;
		EGLint numConfigs;
		eglChooseConfig(win->src.EGL_display, egl_config, &config, 1, &numConfigs);


		win->src.EGL_surface = eglCreateWindowSurface(win->src.EGL_display, config, (EGLNativeWindowType) win->src.window, NULL);

		EGLint attribs[] = {
			EGL_CONTEXT_CLIENT_VERSION,
			#ifdef RGFW_OPENGL_ES1
			1,
			#else
			2,
			#endif
			EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE, EGL_NONE
		};

		size_t index = 4;
		RGFW_GL_ADD_ATTRIB(EGL_STENCIL_SIZE, RGFW_STENCIL);
		RGFW_GL_ADD_ATTRIB(EGL_SAMPLES, RGFW_SAMPLES);

        if (RGFW_DOUBLE_BUFFER)
            RGFW_GL_ADD_ATTRIB(EGL_RENDER_BUFFER, EGL_BACK_BUFFER);

		if (RGFW_majorVersion) {
			attribs[1] = RGFW_majorVersion;
	
			RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_MAJOR_VERSION, RGFW_majorVersion);
			RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_MINOR_VERSION, RGFW_minorVersion);

			if (RGFW_profile == RGFW_GL_CORE) {
				RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT);
			}
			else {
				RGFW_GL_ADD_ATTRIB(EGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT);
			}

		}

		#if defined(RGFW_OPENGL_ES1) || defined(RGFW_OPENGL_ES2) || defined(RGFW_OPENGL_ES3)
		eglBindAPI(EGL_OPENGL_ES_API);
		#else
		eglBindAPI(EGL_OPENGL_API);		
		#endif
      		
		win->src.EGL_context = eglCreateContext(win->src.EGL_display, config, EGL_NO_CONTEXT, attribs);
		
		if (win->src.EGL_context == NULL)
			fprintf(stderr, "failed to create an EGL opengl context\n");

		eglMakeCurrent(win->src.EGL_display, win->src.EGL_surface, win->src.EGL_surface, win->src.EGL_context);
		eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
	}

	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		eglMakeCurrent(win->src.EGL_display, win->src.EGL_surface, win->src.EGL_surface, win->src.EGL_context);
	}

	#ifdef RGFW_APPLE
	void* RGFWnsglFramework = NULL;
	#elif defined(RGFW_WINDOWS)
	static HMODULE wglinstance = NULL;
	#endif

	void* RGFW_getProcAddress(const char* procname) { 
		#if defined(RGFW_WINDOWS)
			void* proc = (void*) GetProcAddress(wglinstance, procname); 

			if (proc)
				return proc;
		#endif

		return (void*) eglGetProcAddress(procname); 
	}

	void RGFW_closeEGL(RGFW_window* win) {
		eglDestroySurface(win->src.EGL_display, win->src.EGL_surface);
		eglDestroyContext(win->src.EGL_display, win->src.EGL_context);

		eglTerminate(win->src.EGL_display);
	}
	
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);
		
		eglSwapInterval(win->src.EGL_display, swapInterval);

	}
#endif /* RGFW_EGL */

/* 
	end of RGFW_EGL defines
*/

/* OPENGL Normal / EGL defines only (no OS MESA)  Ends here */

#elif defined(RGFW_OSMESA) /* OSmesa only */
RGFWDEF void RGFW_OSMesa_reorganize(void);

/* reorganize buffer for osmesa */
void RGFW_OSMesa_reorganize(void) {
	u8* row = (u8*) RGFW_MALLOC(win->r.w * 3);

	i32 half_height = win->r.h / 2;
	i32 stride = win->r.w * 3;

	i32 y;
	for (y = 0; y < half_height; ++y) {
		i32 top_offset = y * stride;
		i32 bottom_offset = (win->r.h - y - 1) * stride;
		memcpy(row, win->buffer + top_offset, stride);
		memcpy(win->buffer + top_offset, win->buffer + bottom_offset, stride);
		memcpy(win->buffer + bottom_offset, row, stride);
	}

	RGFW_FREE(row);
}
#endif /* RGFW_OSMesa */

#endif /* RGFW_GL (OpenGL, EGL, OSMesa )*/

/*
This is where OS specific stuff starts
*/


#if defined(RGFW_WAYLAND) || defined(RGFW_X11)
	int RGFW_eventWait_forceStop[] = {0, 0, 0}; /* for wait events */

	#ifdef __linux__
		#include <linux/joystick.h>
		#include <fcntl.h>
		#include <unistd.h>
		
		RGFW_Event* RGFW_linux_updateJoystick(RGFW_window* win) {
			static int xAxis = 0, yAxis = 0;
			u8 i;
			for (i = 0; i < RGFW_joystickCount; i++) {
				struct js_event e;


				if (RGFW_joysticks[i] == 0)
					continue;

				i32 flags = fcntl(RGFW_joysticks[i], F_GETFL, 0);
				fcntl(RGFW_joysticks[i], F_SETFL, flags | O_NONBLOCK);

				ssize_t bytes;
				while ((bytes = read(RGFW_joysticks[i], &e, sizeof(e))) > 0) {
					switch (e.type) {
					case JS_EVENT_BUTTON:
						win->event.type = e.value ? RGFW_jsButtonPressed : RGFW_jsButtonReleased;
						win->event.button = e.number;
						RGFW_jsPressed[i][e.number] = e.value;
						RGFW_jsButtonCallback(win, i, e.number, e.value);
						return &win->event;
					case JS_EVENT_AXIS:
						ioctl(RGFW_joysticks[i], JSIOCGAXES, &win->event.axisesCount);

						if ((e.number == 0 || e.number % 2) && e.number != 1)
							xAxis = e.value;
						else
							yAxis = e.value;

						win->event.axis[e.number / 2].x = xAxis;
						win->event.axis[e.number / 2].y = yAxis;
						win->event.type = RGFW_jsAxisMove;
						win->event.joystick = i;
						RGFW_jsAxisCallback(win, i, win->event.axis, win->event.axisesCount);
						return &win->event;

						default: break;
					}
				}
			}

			return NULL;
		}

	#endif
#endif

/*


Start of Linux / Unix defines


*/

#ifdef RGFW_X11
#ifndef RGFW_NO_X11_CURSOR
#include <X11/Xcursor/Xcursor.h>
#endif
#include <dlfcn.h>

#ifndef RGFW_NO_DPI
#include <X11/extensions/Xrandr.h>
#include <X11/Xresource.h>
#endif

#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/keysymdef.h>
#include <unistd.h>

#include <X11/XKBlib.h> /* for converting keycode to string */
#include <X11/cursorfont.h> /* for hiding */
#include <X11/extensions/shapeconst.h>
#include <X11/extensions/shape.h>
#include <X11/extensions/XInput2.h>

#include <limits.h> /* for data limits (mainly used in drag and drop functions) */
#include <poll.h>


#ifdef __linux__
#include <linux/joystick.h>
#endif

	u8 RGFW_mouseIconSrc[] = { XC_arrow, XC_left_ptr, XC_xterm, XC_crosshair, XC_hand2, XC_sb_h_double_arrow, XC_sb_v_double_arrow, XC_bottom_left_corner, XC_bottom_right_corner, XC_fleur, XC_X_cursor};  
	/*atoms needed for drag and drop*/
	Atom XdndAware, XdndTypeList, XdndSelection, XdndEnter, XdndPosition, XdndStatus, XdndLeave, XdndDrop, XdndFinished, XdndActionCopy, XtextPlain, XtextUriList;

	Atom wm_delete_window = 0;

#if !defined(RGFW_NO_X11_CURSOR) && !defined(RGFW_NO_X11_CURSOR_PRELOAD)
	typedef XcursorImage* (*PFN_XcursorImageCreate)(int, int);
	typedef void (*PFN_XcursorImageDestroy)(XcursorImage*);
	typedef Cursor(*PFN_XcursorImageLoadCursor)(Display*, const XcursorImage*);
#endif
#ifdef RGFW_OPENGL
	typedef GLXContext(*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);
#endif

#if !defined(RGFW_NO_X11_XI_PRELOAD)
	typedef int (* PFN_XISelectEvents)(Display*,Window,XIEventMask*,int);
	PFN_XISelectEvents XISelectEventsSrc = NULL;
	#define XISelectEvents XISelectEventsSrc

	void* X11Xihandle = NULL;
#endif

#if !defined(RGFW_NO_X11_CURSOR) && !defined(RGFW_NO_X11_CURSOR_PRELOAD)
	PFN_XcursorImageLoadCursor XcursorImageLoadCursorSrc = NULL;
	PFN_XcursorImageCreate XcursorImageCreateSrc = NULL;
	PFN_XcursorImageDestroy XcursorImageDestroySrc = NULL;

#define XcursorImageLoadCursor XcursorImageLoadCursorSrc
#define XcursorImageCreate XcursorImageCreateSrc
#define XcursorImageDestroy XcursorImageDestroySrc

	void* X11Cursorhandle = NULL;
#endif

	u32 RGFW_windowsOpen = 0;

#ifdef RGFW_OPENGL
	void* RGFW_getProcAddress(const char* procname) { return (void*) glXGetProcAddress((GLubyte*) procname); }
#endif

	RGFWDEF void RGFW_init_buffer(RGFW_window* win, XVisualInfo* vi);
	void RGFW_init_buffer(RGFW_window* win, XVisualInfo* vi) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
		if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
			RGFW_bufferSize = RGFW_getScreenSize();
		
		win->buffer = (u8*)RGFW_MALLOC(RGFW_bufferSize.w * RGFW_bufferSize.h * 4);

		#ifdef RGFW_OSMESA
				win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
				OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
		#endif

		win->src.bitmap = XCreateImage(
			win->src.display, XDefaultVisual(win->src.display, vi->screen),
			vi->depth,
			ZPixmap, 0, NULL, RGFW_bufferSize.w, RGFW_bufferSize.h,
			32, 0
		);

		win->src.gc = XCreateGC(win->src.display, win->src.window, 0, NULL);

		#else
		RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
		RGFW_UNUSED(vi)
		#endif
	}



	void RGFW_window_setBorder(RGFW_window* win, u8 border) {
		static Atom _MOTIF_WM_HINTS = 0;
		if (_MOTIF_WM_HINTS == 0 )
			_MOTIF_WM_HINTS = XInternAtom(win->src.display, "_MOTIF_WM_HINTS", False);
		
		struct __x11WindowHints {
			unsigned long flags, functions, decorations, status;
			long input_mode;
		} hints;
		hints.flags = (1L << 1);
		hints.decorations = border;

		XChangeProperty(
			win->src.display, win->src.window,
			_MOTIF_WM_HINTS, _MOTIF_WM_HINTS,
			32, PropModeReplace, (u8*)&hints, 5
		);
	}
	
	void RGFW_releaseCursor(RGFW_window* win) {
		XUngrabPointer(win->src.display, CurrentTime);

		/* disable raw input */
		unsigned char mask[] = { 0 };
		XIEventMask em;
		em.deviceid = XIAllMasterDevices;
		em.mask_len = sizeof(mask);
		em.mask = mask;

		XISelectEvents(win->src.display, XDefaultRootWindow(win->src.display), &em, 1);
	}
	
	void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) { 
		/* enable raw input */
		unsigned char mask[XIMaskLen(XI_RawMotion)] = { 0 };
		XISetMask(mask, XI_RawMotion);

		XIEventMask em;
		em.deviceid = XIAllMasterDevices;
		em.mask_len = sizeof(mask);
		em.mask = mask;
		
		XISelectEvents(win->src.display, XDefaultRootWindow(win->src.display), &em, 1);

		XGrabPointer(win->src.display, win->src.window, True, PointerMotionMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);

		RGFW_window_moveMouse(win, RGFW_POINT(win->r.x + (i32)(r.w / 2), win->r.y + (i32)(r.h / 2)));
	}

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
#if !defined(RGFW_NO_X11_CURSOR) && !defined(RGFW_NO_X11_CURSOR_PRELOAD)
		if (X11Cursorhandle == NULL) {
#if defined(__CYGWIN__)
			X11Cursorhandle = dlopen("libXcursor-1.so", RTLD_LAZY | RTLD_LOCAL);
#elif defined(__OpenBSD__) || defined(__NetBSD__)
			X11Cursorhandle = dlopen("libXcursor.so", RTLD_LAZY | RTLD_LOCAL);
#else
			X11Cursorhandle = dlopen("libXcursor.so.1", RTLD_LAZY | RTLD_LOCAL);
#endif

			XcursorImageCreateSrc = (PFN_XcursorImageCreate) dlsym(X11Cursorhandle, "XcursorImageCreate");
			XcursorImageDestroySrc = (PFN_XcursorImageDestroy) dlsym(X11Cursorhandle, "XcursorImageDestroy");
			XcursorImageLoadCursorSrc = (PFN_XcursorImageLoadCursor) dlsym(X11Cursorhandle, "XcursorImageLoadCursor");
		}
#endif

#if !defined(RGFW_NO_X11_XI_PRELOAD)
		if (X11Xihandle == NULL) {
#if defined(__CYGWIN__)
			X11Xihandle = dlopen("libXi-6.so", RTLD_LAZY | RTLD_LOCAL);
#elif defined(__OpenBSD__) || defined(__NetBSD__)
			X11Xihandle = dlopen("libXi.so", RTLD_LAZY | RTLD_LOCAL);
#else
			X11Xihandle = dlopen("libXi.so.6", RTLD_LAZY | RTLD_LOCAL);
#endif

			XISelectEventsSrc = (PFN_XISelectEvents) dlsym(X11Xihandle, "XISelectEvents");
		}
#endif

		XInitThreads(); /*!< init X11 threading*/

		if (args & RGFW_OPENGL_SOFTWARE)
			setenv("LIBGL_ALWAYS_SOFTWARE", "1", 1);

		RGFW_window* win = RGFW_window_basic_init(rect, args);

		u64 event_mask = KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask | PointerMotionMask | StructureNotifyMask | FocusChangeMask | LeaveWindowMask | EnterWindowMask | ExposureMask; /*!< X11 events accepted*/

#ifdef RGFW_OPENGL
		u32* visual_attribs = RGFW_initFormatAttribs(args & RGFW_OPENGL_SOFTWARE);
		i32 fbcount;
		GLXFBConfig* fbc = glXChooseFBConfig((Display*) win->src.display, DefaultScreen(win->src.display), (i32*) visual_attribs, &fbcount);

		i32 best_fbc = -1;

		if (fbcount == 0) {
			printf("Failed to find any valid GLX visual configs\n");
			return NULL;
		}

		u32 i;
		for (i = 0; i < (u32)fbcount; i++) {
			XVisualInfo* vi = glXGetVisualFromFBConfig((Display*) win->src.display, fbc[i]);
                        if (vi == NULL)
				continue;
                        
			XFree(vi);

			i32 samp_buf, samples;
			glXGetFBConfigAttrib((Display*) win->src.display, fbc[i], GLX_SAMPLE_BUFFERS, &samp_buf);
			glXGetFBConfigAttrib((Display*) win->src.display, fbc[i], GLX_SAMPLES, &samples);
			
			if ((best_fbc < 0 || samp_buf) && (samples == RGFW_SAMPLES || best_fbc == -1)) {
				best_fbc = i;
			}
		}

		if (best_fbc == -1) {
			printf("Failed to get a valid GLX visual\n");
			return NULL;
		}

		GLXFBConfig bestFbc = fbc[best_fbc];

		/* Get a visual */
		XVisualInfo* vi = glXGetVisualFromFBConfig((Display*) win->src.display, bestFbc);
		
		XFree(fbc);
		
		if (args & RGFW_TRANSPARENT_WINDOW) {
			XMatchVisualInfo((Display*) win->src.display, DefaultScreen((Display*) win->src.display), 32, TrueColor, vi); /*!< for RGBA backgrounds*/
		}
		
#else
		XVisualInfo viNorm;

		viNorm.visual = DefaultVisual((Display*) win->src.display, DefaultScreen((Display*) win->src.display));
		
		viNorm.depth = 0;
		XVisualInfo* vi = &viNorm;
		
		XMatchVisualInfo((Display*) win->src.display, DefaultScreen((Display*) win->src.display), 32, TrueColor, vi); /*!< for RGBA backgrounds*/
#endif
		/* make X window attrubutes*/
		XSetWindowAttributes swa;
		Colormap cmap;

		swa.colormap = cmap = XCreateColormap((Display*) win->src.display,
			DefaultRootWindow(win->src.display),
			vi->visual, AllocNone);

		swa.background_pixmap = None;
		swa.border_pixel = 0;
		swa.event_mask = event_mask;
		
		swa.background_pixel = 0;

		/* create the window*/
		win->src.window = XCreateWindow((Display*) win->src.display, DefaultRootWindow((Display*) win->src.display), win->r.x, win->r.y, win->r.w, win->r.h,
			0, vi->depth, InputOutput, vi->visual,
			CWColormap | CWBorderPixel | CWBackPixel | CWEventMask, &swa);

		XFreeColors((Display*) win->src.display, cmap, NULL, 0, 0);

		#ifdef RGFW_OPENGL
		XFree(vi);
		#endif

		// In your .desktop app, if you set the property
		// StartupWMClass=RGFW that will assoicate the launcher icon
		// with your application - robrohan 
		
		if (RGFW_className == NULL)
			RGFW_className = (char*)name;

		XClassHint *hint = XAllocClassHint();
		assert(hint != NULL);
		hint->res_class = (char*)RGFW_className;
		hint->res_name = (char*)name; // just use the window name as the app name
		XSetClassHint((Display*) win->src.display, win->src.window, hint);
		XFree(hint);

		if ((args & RGFW_NO_INIT_API) == 0) {
#ifdef RGFW_OPENGL /* This is the second part of setting up opengl. This is where we ask OpenGL for a specific version. */ 
		i32 context_attribs[7] = { 0, 0, 0, 0, 0, 0, 0 };
		context_attribs[0] = GLX_CONTEXT_PROFILE_MASK_ARB;
		if (RGFW_profile == RGFW_GL_CORE) 
			context_attribs[1] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB;
		else 
			context_attribs[1] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;
		
		if (RGFW_majorVersion || RGFW_minorVersion) {
			context_attribs[2] = GLX_CONTEXT_MAJOR_VERSION_ARB;
			context_attribs[3] = RGFW_majorVersion;
			context_attribs[4] = GLX_CONTEXT_MINOR_VERSION_ARB;
			context_attribs[5] = RGFW_minorVersion;
		}

		glXCreateContextAttribsARBProc glXCreateContextAttribsARB = 0;
		glXCreateContextAttribsARB = (glXCreateContextAttribsARBProc)
			glXGetProcAddressARB((GLubyte*) "glXCreateContextAttribsARB");

		GLXContext ctx = NULL;

		if (RGFW_root != NULL)
			ctx = RGFW_root->src.ctx;

		win->src.ctx = glXCreateContextAttribsARB((Display*) win->src.display, bestFbc, ctx, True, context_attribs);
#endif
		if (RGFW_root == NULL)
			RGFW_root = win;

		RGFW_init_buffer(win, vi);
		}
		

		#ifndef RGFW_NO_MONITOR
		if (args & RGFW_SCALE_TO_MONITOR)
			RGFW_window_scaleToMonitor(win);
		#endif

		if (args & RGFW_NO_RESIZE) { /* make it so the user can't resize the window*/
			XSizeHints* sh = XAllocSizeHints();
			sh->flags = (1L << 4) | (1L << 5);
			sh->min_width = sh->max_width = win->r.w;
			sh->min_height = sh->max_height = win->r.h;

			XSetWMSizeHints((Display*) win->src.display, (Drawable) win->src.window, sh, XA_WM_NORMAL_HINTS);
			XFree(sh);
		}

		if (args & RGFW_NO_BORDER) {
			RGFW_window_setBorder(win, 0);
		}

		XSelectInput((Display*) win->src.display, (Drawable) win->src.window, event_mask); /*!< tell X11 what events we want*/

		/* make it so the user can't close the window until the program does*/
		if (wm_delete_window == 0)
			wm_delete_window = XInternAtom((Display*) win->src.display, "WM_DELETE_WINDOW", False);

		XSetWMProtocols((Display*) win->src.display, (Drawable) win->src.window, &wm_delete_window, 1);

		/* connect the context to the window*/
#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0)
			glXMakeCurrent((Display*) win->src.display, (Drawable) win->src.window, (GLXContext) win->src.ctx);
#endif

		/* set the background*/
		XStoreName((Display*) win->src.display, (Drawable) win->src.window, name); /*!< set the name*/

		XMapWindow((Display*) win->src.display, (Drawable) win->src.window);						  /* draw the window*/
		XMoveWindow((Display*) win->src.display, (Drawable) win->src.window, win->r.x, win->r.y); /*!< move the window to it's proper cords*/

		if (args & RGFW_ALLOW_DND) { /* init drag and drop atoms and turn on drag and drop for this window */
			win->_winArgs |= RGFW_ALLOW_DND;

			XdndTypeList = XInternAtom((Display*) win->src.display, "XdndTypeList", False);
			XdndSelection = XInternAtom((Display*) win->src.display, "XdndSelection", False);

			/* client messages */
			XdndEnter = XInternAtom((Display*) win->src.display, "XdndEnter", False);
			XdndPosition = XInternAtom((Display*) win->src.display, "XdndPosition", False);
			XdndStatus = XInternAtom((Display*) win->src.display, "XdndStatus", False);
			XdndLeave = XInternAtom((Display*) win->src.display, "XdndLeave", False);
			XdndDrop = XInternAtom((Display*) win->src.display, "XdndDrop", False);
			XdndFinished = XInternAtom((Display*) win->src.display, "XdndFinished", False);

			/* actions */
			XdndActionCopy = XInternAtom((Display*) win->src.display, "XdndActionCopy", False);

			XtextUriList = XInternAtom((Display*) win->src.display, "text/uri-list", False); 
			XtextPlain = XInternAtom((Display*) win->src.display, "text/plain", False);

			XdndAware = XInternAtom((Display*) win->src.display, "XdndAware", False);
			const u8 version = 5;

			XChangeProperty((Display*) win->src.display, (Window) win->src.window,
				XdndAware, 4, 32,
				PropModeReplace, &version, 1); /*!< turns on drag and drop */
		}

		#ifdef RGFW_EGL
			if ((args & RGFW_NO_INIT_API) == 0)
				RGFW_createOpenGLContext(win);
		#endif

		RGFW_window_setMouseDefault(win);

		RGFW_windowsOpen++;

		return win; /*return newly created window*/
	}

	RGFW_area RGFW_getScreenSize(void) {
		assert(RGFW_root != NULL);

		Screen* scrn = DefaultScreenOfDisplay((Display*) RGFW_root->src.display);
		return RGFW_AREA(scrn->width, scrn->height);
	}

	RGFW_point RGFW_getGlobalMousePoint(void) {
		assert(RGFW_root != NULL);

		RGFW_point RGFWMouse;

		i32 x, y;
		u32 z;
		Window window1, window2;
		XQueryPointer((Display*) RGFW_root->src.display, XDefaultRootWindow((Display*) RGFW_root->src.display), &window1, &window2, &RGFWMouse.x, &RGFWMouse.y, &x, &y, &z);
 
		return RGFWMouse;
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		assert(win != NULL);

		RGFW_point RGFWMouse;

		i32 x, y;
		u32 z;
		Window window1, window2;
		XQueryPointer((Display*) win->src.display, win->src.window, &window1, &window2, &x, &y, &RGFWMouse.x, &RGFWMouse.y, &z);

		return RGFWMouse;
	}

	int xAxis = 0, yAxis = 0;

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		assert(win != NULL);

		static struct {
			long source, version;
			i32 format;
		} xdnd;

		if (win->event.type == 0) 
			RGFW_resetKey();

		if (win->event.type == RGFW_quit) {
			return NULL;
		}

		win->event.type = 0;

#ifdef __linux__
	RGFW_Event* event = RGFW_linux_updateJoystick(win);
	if (event != NULL)
		return event;
#endif

		XPending(win->src.display);

		XEvent E; /*!< raw X11 event */

		/* if there is no unread qued events, get a new one */
		if ((QLength(win->src.display) || XEventsQueued((Display*) win->src.display, QueuedAlready) + XEventsQueued((Display*) win->src.display, QueuedAfterReading)) 
			&& win->event.type != RGFW_quit
		)
			XNextEvent((Display*) win->src.display, &E);
		else {
			return NULL;
		}

		u32 i;
		win->event.type = 0;


		switch (E.type) {
		case KeyPress:
		case KeyRelease: {
			win->event.repeat = RGFW_FALSE;
			/* check if it's a real key release */
			if (E.type == KeyRelease && XEventsQueued((Display*) win->src.display, QueuedAfterReading)) { /* get next event if there is one*/
				XEvent NE;
				XPeekEvent((Display*) win->src.display, &NE);

				if (E.xkey.time == NE.xkey.time && E.xkey.keycode == NE.xkey.keycode) /* check if the current and next are both the same*/
					win->event.repeat = RGFW_TRUE;
			}

			/* set event key data */
			KeySym sym = (KeySym)XkbKeycodeToKeysym((Display*) win->src.display, E.xkey.keycode, 0, E.xkey.state & ShiftMask ? 1 : 0);
			win->event.keyCode = RGFW_apiKeyCodeToRGFW(E.xkey.keycode);
			
			char* str = (char*)XKeysymToString(sym);
			if (str != NULL)
				strncpy(win->event.keyName, str, 16);

			win->event.keyName[15] = '\0';		

			RGFW_keyboard[win->event.keyCode].prev = RGFW_isPressed(win, win->event.keyCode);
			
			/* get keystate data */
			win->event.type = (E.type == KeyPress) ? RGFW_keyPressed : RGFW_keyReleased;

			XKeyboardState keystate;
			XGetKeyboardControl((Display*) win->src.display, &keystate);

			RGFW_updateLockState(win, (keystate.led_mask & 1), (keystate.led_mask & 2));
			RGFW_keyboard[win->event.keyCode].current = (E.type == KeyPress);
			RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, (E.type == KeyPress));
			break;
		}
		case ButtonPress:
		case ButtonRelease:
			win->event.type = RGFW_mouseButtonPressed + (E.type == ButtonRelease); // the events match 
			
			switch(win->event.button) {
				case RGFW_mouseScrollUp:
					win->event.scroll = 1;
					break;
				case RGFW_mouseScrollDown:
					win->event.scroll = -1;
					break;
				default: break;
			}

			win->event.button = E.xbutton.button;
			RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;

			if (win->event.repeat == RGFW_FALSE)
				win->event.repeat = RGFW_isPressed(win, win->event.keyCode);

			RGFW_mouseButtons[win->event.button].current = (E.type == ButtonPress);
			RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, (E.type == ButtonPress));
			break;

		case MotionNotify:	
			win->event.point.x = E.xmotion.x;
			win->event.point.y = E.xmotion.y;
			
			if ((win->_winArgs & RGFW_HOLD_MOUSE)) {
				win->event.point.y = E.xmotion.y;

				win->event.point.x = win->_lastMousePoint.x - abs(win->event.point.x);
				win->event.point.y = win->_lastMousePoint.y - abs(win->event.point.y);
			}

			win->_lastMousePoint = RGFW_POINT(E.xmotion.x, E.xmotion.y);

			win->event.type = RGFW_mousePosChanged;
			RGFW_mousePosCallback(win, win->event.point);
			break;

		case GenericEvent: {
			/* MotionNotify is used for mouse events if the mouse isn't held */                
			if (!(win->_winArgs & RGFW_HOLD_MOUSE)) {
            	XFreeEventData(win->src.display, &E.xcookie);
				break;
			}
			
            XGetEventData(win->src.display, &E.xcookie);
            if (E.xcookie.evtype == XI_RawMotion) {
				XIRawEvent *raw = (XIRawEvent *)E.xcookie.data;
				if (raw->valuators.mask_len == 0) {
					XFreeEventData(win->src.display, &E.xcookie);
					break;
				}

                double deltaX = 0.0f; 
				double deltaY = 0.0f;

                /* check if relative motion data exists where we think it does */
				if (XIMaskIsSet(raw->valuators.mask, 0) != 0)
					deltaX += raw->raw_values[0];
				if (XIMaskIsSet(raw->valuators.mask, 1) != 0)
					deltaY += raw->raw_values[1];

				win->event.point = RGFW_POINT((i32)deltaX, (i32)deltaY);
				
				RGFW_window_moveMouse(win, RGFW_POINT(win->r.x + (win->r.w / 2), win->r.y + (win->r.h / 2)));

				win->event.type = RGFW_mousePosChanged;
				RGFW_mousePosCallback(win, win->event.point);
            }

            XFreeEventData(win->src.display, &E.xcookie);
			break;
		}
		
		case Expose:
			win->event.type = RGFW_windowRefresh;
			RGFW_windowRefreshCallback(win);
			break;

		case ClientMessage:
			/* if the client closed the window*/
			if (E.xclient.data.l[0] == (i64) wm_delete_window) {
				win->event.type = RGFW_quit;
				RGFW_windowQuitCallback(win);
				break;
			}
			
			/* reset DND values */
			if (win->event.droppedFilesCount) {
				for (i = 0; i < win->event.droppedFilesCount; i++)
					win->event.droppedFiles[i][0] = '\0';
			}

			win->event.droppedFilesCount = 0;

			if ((win->_winArgs & RGFW_ALLOW_DND) == 0)
				break;

			XEvent reply = { ClientMessage };
			reply.xclient.window = xdnd.source;
			reply.xclient.format = 32;
			reply.xclient.data.l[0] = (long) win->src.window;
			reply.xclient.data.l[1] = 0;
			reply.xclient.data.l[2] = None;

			if (E.xclient.message_type == XdndEnter) {
				unsigned long count;
				Atom* formats;
				Atom real_formats[6];

				Bool list = E.xclient.data.l[1] & 1;

				xdnd.source = E.xclient.data.l[0];
				xdnd.version = E.xclient.data.l[1] >> 24;
				xdnd.format = None;

				if (xdnd.version > 5)
					break;

				if (list) {
					Atom actualType;
					i32 actualFormat;
					unsigned long bytesAfter;

					XGetWindowProperty((Display*) win->src.display,
						xdnd.source,
						XdndTypeList,
						0,
						LONG_MAX,
						False,
						4,
						&actualType,
						&actualFormat,
						&count,
						&bytesAfter,
						(u8**) &formats);
				} else {
					count = 0;

					if (E.xclient.data.l[2] != None)
						real_formats[count++] = E.xclient.data.l[2];
					if (E.xclient.data.l[3] != None)
						real_formats[count++] = E.xclient.data.l[3];
					if (E.xclient.data.l[4] != None)
						real_formats[count++] = E.xclient.data.l[4];
					
					formats = real_formats;
				}

				unsigned long i;
				for (i = 0; i < count; i++) {
				    if (formats[i] == XtextUriList || formats[i] == XtextPlain) {
						xdnd.format = formats[i];
						break;
					}
				}

				if (list) {
					XFree(formats);
				}

				break;
			}
			if (E.xclient.message_type == XdndPosition) {
				const i32 xabs = (E.xclient.data.l[2] >> 16) & 0xffff;
				const i32 yabs = (E.xclient.data.l[2]) & 0xffff;
				Window dummy;
				i32 xpos, ypos;

				if (xdnd.version > 5)
					break;

				XTranslateCoordinates((Display*) win->src.display,
					XDefaultRootWindow((Display*) win->src.display),
					(Window) win->src.window,
					xabs, yabs,
					&xpos, &ypos,
					&dummy);

				win->event.point.x = xpos;
				win->event.point.y = ypos;

				reply.xclient.window = xdnd.source;
				reply.xclient.message_type = XdndStatus;

				if (xdnd.format) {
					reply.xclient.data.l[1] = 1;
					if (xdnd.version >= 2)
						reply.xclient.data.l[4] = XdndActionCopy;
				}

				XSendEvent((Display*) win->src.display, xdnd.source, False, NoEventMask, &reply);
				XFlush((Display*) win->src.display);
				break;
			}

			if (E.xclient.message_type != XdndDrop)
				break;

			if (xdnd.version > 5)
				break;

			win->event.type = RGFW_dnd_init;

			if (xdnd.format) {
				Time time = CurrentTime;

				if (xdnd.version >= 1)
					time = E.xclient.data.l[2];

				XConvertSelection((Display*) win->src.display,
					XdndSelection,
					xdnd.format,
					XdndSelection,
					(Window) win->src.window,
					time);
			} else if (xdnd.version >= 2) {
				XEvent reply = { ClientMessage };

				XSendEvent((Display*) win->src.display, xdnd.source,
					False, NoEventMask, &reply);
				XFlush((Display*) win->src.display);
			}

			RGFW_dndInitCallback(win, win->event.point);
			break;
		case SelectionNotify: {
			/* this is only for checking for xdnd drops */
			if (E.xselection.property != XdndSelection || !(win->_winArgs | RGFW_ALLOW_DND))
				break;

			char* data;
			unsigned long result;

			Atom actualType;
			i32 actualFormat;
			unsigned long bytesAfter;

			XGetWindowProperty((Display*) win->src.display, E.xselection.requestor, E.xselection.property, 0, LONG_MAX, False, E.xselection.target, &actualType, &actualFormat, &result, &bytesAfter, (u8**) &data);

			if (result == 0)
				break;

			/*
			SOURCED FROM GLFW _glfwParseUriList
			Copyright (c) 2002-2006 Marcus Geelnard
			Copyright (c) 2006-2019 Camilla Lwy
			*/

			const char* prefix = (const char*)"file://";

			char* line;

			win->event.droppedFilesCount = 0;

			win->event.type = RGFW_dnd;

			while ((line = strtok(data, "\r\n"))) {
				char path[RGFW_MAX_PATH];

				data = NULL;

				if (line[0] == '#')
					continue;

				char* l;
				for (l = line; 1; l++) {
					if ((l - line) > 7)
						break;
					else if (*l != prefix[(l - line)])
						break;
					else if (*l == '\0' && prefix[(l - line)] == '\0') {
						line += 7;
						while (*line != '/')
							line++;
						break;
					} else if (*l == '\0')
						break;
				}

				win->event.droppedFilesCount++;

				size_t index = 0;
				while (*line) {
					if (line[0] == '%' && line[1] && line[2]) {
						const char digits[3] = { line[1], line[2], '\0' };
						path[index] = (char) strtol(digits, NULL, 16);
						line += 2;
					} else
						path[index] = *line;

					index++;
					line++;
				}
				path[index] = '\0';
				strncpy(win->event.droppedFiles[win->event.droppedFilesCount - 1], path, index + 1);
			}

			if (data)
				XFree(data);

			if (xdnd.version >= 2) {
				reply.xclient.message_type = XdndFinished;
				reply.xclient.data.l[1] = result;
				reply.xclient.data.l[2] = XdndActionCopy;

				XSendEvent((Display*) win->src.display, xdnd.source, False, NoEventMask, &reply);
				XFlush((Display*) win->src.display);
			}

			RGFW_dndCallback(win, win->event.droppedFiles, win->event.droppedFilesCount);
			break;
		}
		case FocusIn:
			win->event.inFocus = 1;
			win->event.type = RGFW_focusIn;
			RGFW_focusCallback(win, 1);
			break;

			break;
		case FocusOut:
			win->event.inFocus = 0;
			win->event.type = RGFW_focusOut;
			RGFW_focusCallback(win, 0);
			break;
		
		case EnterNotify: {
			win->event.type = RGFW_mouseEnter;
			win->event.point.x = E.xcrossing.x;
			win->event.point.y = E.xcrossing.y;
			RGFW_mouseNotifyCallBack(win, win->event.point, 1);
			break;
		}

		case LeaveNotify: {
			win->event.type = RGFW_mouseLeave;
			RGFW_mouseNotifyCallBack(win, win->event.point, 0);
			break;
		}

		case ConfigureNotify: {
				/* detect resize */
      			if (E.xconfigure.width != win->r.w || E.xconfigure.height != win->r.h) {
					win->event.type = RGFW_windowResized;
					win->r = RGFW_RECT(win->r.x, win->r.y, E.xconfigure.width, E.xconfigure.height);
					RGFW_windowResizeCallback(win, win->r);
					break;
      			}  
      
      			/* detect move */
      			if (E.xconfigure.x != win->r.x || E.xconfigure.y != win->r.y) {
					win->event.type = RGFW_windowMoved;
					win->r = RGFW_RECT(E.xconfigure.x, E.xconfigure.y, win->r.w, win->r.h);
					RGFW_windowMoveCallback(win, win->r);
					break;
				} 

				break;
		}
		default: {
			break;
		}
		}

		XFlush((Display*) win->src.display);

		if (win->event.type)
			return &win->event;
		else
			return NULL;
	}

	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);
		win->r.x = v.x;
		win->r.y = v.y;

		XMoveWindow((Display*) win->src.display, (Window) win->src.window, v.x, v.y);
	}


	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);
		win->r.w = a.w;
		win->r.h = a.h;

		XResizeWindow((Display*) win->src.display, (Window) win->src.window, a.w, a.h);
	}

	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		if (a.w == 0 && a.h == 0)
			return;

		XSizeHints hints;
		long flags;

		XGetWMNormalHints(win->src.display, (Window) win->src.window, &hints, &flags);

		hints.flags |= PMinSize;
		
		hints.min_width = a.w;
		hints.min_height = a.h;

		XSetWMNormalHints(win->src.display, (Window) win->src.window, &hints);
	}

	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		if (a.w == 0 && a.h == 0)
			return;

		XSizeHints hints;
		long flags;

		XGetWMNormalHints(win->src.display, (Window) win->src.window, &hints, &flags);

		hints.flags |= PMaxSize;

		hints.max_width = a.w;
		hints.max_height = a.h;

		XSetWMNormalHints(win->src.display, (Window) win->src.window, &hints);
	}


	void RGFW_window_minimize(RGFW_window* win) {
		assert(win != NULL);

		XIconifyWindow(win->src.display, (Window) win->src.window, DefaultScreen(win->src.display));
		XFlush(win->src.display);
	}

	void RGFW_window_restore(RGFW_window* win) {
		assert(win != NULL);

		XMapWindow(win->src.display, (Window) win->src.window);
		XFlush(win->src.display);
	}	

	void RGFW_window_setName(RGFW_window* win, char* name) {
		assert(win != NULL);

		XStoreName((Display*) win->src.display, (Window) win->src.window, name);
	}
	
	void* RGFW_libxshape = NULL;

	#ifndef RGFW_NO_PASSTHROUGH
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		assert(win != NULL);
		
		#if defined(__CYGWIN__)
			RGFW_libxshape = dlopen("libXext-6.so", RTLD_LAZY | RTLD_LOCAL);
		#elif defined(__OpenBSD__) || defined(__NetBSD__)
			RGFW_libxshape = dlopen("libXext.so", RTLD_LAZY | RTLD_LOCAL);
		#else
    		RGFW_libxshape = dlopen("libXext.so.6", RTLD_LAZY | RTLD_LOCAL);
		#endif
		
		typedef void (* PFN_XShapeCombineMask)(Display*,Window,int,int,int,Pixmap,int);
		static PFN_XShapeCombineMask XShapeCombineMask;
		
		typedef void (* PFN_XShapeCombineRegion)(Display*,Window,int,int,int,Region,int);
		static PFN_XShapeCombineRegion XShapeCombineRegion;
		
		if (XShapeCombineMask != NULL)
			XShapeCombineMask = (PFN_XShapeCombineMask) dlsym(RGFW_libxshape, "XShapeCombineMask");

		if (XShapeCombineRegion != NULL)
			XShapeCombineRegion = (PFN_XShapeCombineRegion) dlsym(RGFW_libxshape, "XShapeCombineMask");

		if (passthrough) {
			Region region = XCreateRegion();
			XShapeCombineRegion(win->src.display, win->src.window, ShapeInput, 0, 0, region, ShapeSet);
			XDestroyRegion(region);

			return;
		}

		XShapeCombineMask(win->src.display, win->src.window, ShapeInput, 0, 0, None, ShapeSet);
	}
	#endif

	/*
		the majority function is sourced from GLFW
	*/

	void RGFW_window_setIcon(RGFW_window* win, u8* icon, RGFW_area a, i32 channels) {
		assert(win != NULL);

		i32 longCount = 2 + a.w * a.h;

		u64* X11Icon = (u64*) RGFW_MALLOC(longCount * sizeof(u64));
		u64* target = X11Icon;

		*target++ = a.w;
		*target++ = a.h;

		u32 i;

		for (i = 0; i < a.w * a.h; i++) {
			if (channels == 3)
				*target++ = ((icon[i * 3 + 0]) << 16) |
				((icon[i * 3 + 1]) << 8) |
				((icon[i * 3 + 2]) << 0) |
				(0xFF << 24);

			else if (channels == 4)
				*target++ = ((icon[i * 4 + 0]) << 16) |
				((icon[i * 4 + 1]) << 8) |
				((icon[i * 4 + 2]) << 0) |
				((icon[i * 4 + 3]) << 24);
		}

		static Atom NET_WM_ICON = 0;
		if (NET_WM_ICON == 0)
			NET_WM_ICON = XInternAtom((Display*) win->src.display, "_NET_WM_ICON", False);

		XChangeProperty((Display*) win->src.display, (Window) win->src.window,
			NET_WM_ICON,
			6, 32,
			PropModeReplace,
			(u8*) X11Icon,
			longCount);

		RGFW_FREE(X11Icon);

		XFlush((Display*) win->src.display);
	}

	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		assert(win != NULL);

#ifndef RGFW_NO_X11_CURSOR
		XcursorImage* native = XcursorImageCreate(a.w, a.h);
		native->xhot = 0;
		native->yhot = 0;

		u8* source = (u8*) image;
		XcursorPixel* target = native->pixels;

		u32 i;
		for (i = 0; i < a.w * a.h; i++, target++, source += 4) {
			u8 alpha = 0xFF;
			if (channels == 4)
				alpha = source[3];

			*target = (alpha << 24) | (((source[0] * alpha) / 255) << 16) | (((source[1] * alpha) / 255) << 8) | (((source[2] * alpha) / 255) << 0);
		}

		Cursor cursor = XcursorImageLoadCursor((Display*) win->src.display, native);
		XDefineCursor((Display*) win->src.display, (Window) win->src.window, (Cursor) cursor);

		XFreeCursor((Display*) win->src.display, (Cursor) cursor);
		XcursorImageDestroy(native);
#else
	RGFW_UNUSED(image) RGFW_UNUSED(a.w) RGFW_UNUSED(channels)
#endif
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);

		XEvent event;
		XQueryPointer(win->src.display, DefaultRootWindow(win->src.display),
			&event.xbutton.root, &event.xbutton.window,
			&event.xbutton.x_root, &event.xbutton.y_root,
			&event.xbutton.x, &event.xbutton.y,
			&event.xbutton.state);

		if (event.xbutton.x == v.x && event.xbutton.y == v.y)
			return;

		XWarpPointer(win->src.display, None, win->src.window, 0, 0, 0, 0, (int) v.x - win->r.x, (int) v.y - win->r.y);
	}

	RGFWDEF void RGFW_window_disableMouse(RGFW_window* win) {
		RGFW_UNUSED(win);
	}

	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_ARROW);
	}

	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
		assert(win != NULL);
		 
		if (mouse > (sizeof(RGFW_mouseIconSrc) / sizeof(u8)))
			return;
		
		mouse = RGFW_mouseIconSrc[mouse];

		Cursor cursor = XCreateFontCursor((Display*) win->src.display, mouse);
		XDefineCursor((Display*) win->src.display, (Window) win->src.window, (Cursor) cursor);

		XFreeCursor((Display*) win->src.display, (Cursor) cursor);
	}

	void RGFW_window_hide(RGFW_window* win) {
		XMapWindow(win->src.display, win->src.window);
	}

	void RGFW_window_show(RGFW_window* win) {
		XUnmapWindow(win->src.display, win->src.window);
	}

	/*
		the majority function is sourced from GLFW
	*/
	char* RGFW_readClipboard(size_t* size) {
		static Atom UTF8 = 0;
		if (UTF8 == 0)
			UTF8 = XInternAtom(RGFW_root->src.display, "UTF8_STRING", True);

		XEvent event;
		int format;
		unsigned long N, sizeN;
		char* data, * s = NULL;
		Atom target;
		Atom CLIPBOARD = 0, XSEL_DATA = 0;

		if (CLIPBOARD == 0) {
			CLIPBOARD = XInternAtom(RGFW_root->src.display, "CLIPBOARD", 0);
			XSEL_DATA = XInternAtom(RGFW_root->src.display, "XSEL_DATA", 0);
		}

		XConvertSelection(RGFW_root->src.display, CLIPBOARD, UTF8, XSEL_DATA, RGFW_root->src.window, CurrentTime);
		XSync(RGFW_root->src.display, 0);
		XNextEvent(RGFW_root->src.display, &event);

		if (event.type != SelectionNotify || event.xselection.selection != CLIPBOARD || event.xselection.property == 0)
			return NULL;

		XGetWindowProperty(event.xselection.display, event.xselection.requestor,
			event.xselection.property, 0L, (~0L), 0, AnyPropertyType, &target,
			&format, &sizeN, &N, (unsigned char**) &data);

		if (target == UTF8 || target == XA_STRING) {
			s = (char*)RGFW_MALLOC(sizeof(char) * sizeN);
			strncpy(s, data, sizeN);
			s[sizeN] = '\0';
			XFree(data);
		}

		XDeleteProperty(event.xselection.display, event.xselection.requestor, event.xselection.property);

		if (s != NULL && size != NULL)
			*size = sizeN;

		return s;
	}

	/*
		almost all of this function is sourced from GLFW
	*/
	void RGFW_writeClipboard(const char* text, u32 textLen) {
		static Atom CLIPBOARD = 0,
			UTF8_STRING = 0,
			SAVE_TARGETS = 0,
			TARGETS = 0,
			MULTIPLE = 0,
			ATOM_PAIR = 0,
			CLIPBOARD_MANAGER = 0;

		if (CLIPBOARD == 0) {
			CLIPBOARD = XInternAtom((Display*) RGFW_root->src.display, "CLIPBOARD", False);
			UTF8_STRING = XInternAtom((Display*) RGFW_root->src.display, "UTF8_STRING", False);
			SAVE_TARGETS = XInternAtom((Display*) RGFW_root->src.display, "SAVE_TARGETS", False);
			TARGETS = XInternAtom((Display*) RGFW_root->src.display, "TARGETS", False);
			MULTIPLE = XInternAtom((Display*) RGFW_root->src.display, "MULTIPLE", False);
			ATOM_PAIR = XInternAtom((Display*) RGFW_root->src.display, "ATOM_PAIR", False);
			CLIPBOARD_MANAGER = XInternAtom((Display*) RGFW_root->src.display, "CLIPBOARD_MANAGER", False);
		}
		
		XSetSelectionOwner((Display*) RGFW_root->src.display, CLIPBOARD, (Window) RGFW_root->src.window, CurrentTime);

		XConvertSelection((Display*) RGFW_root->src.display, CLIPBOARD_MANAGER, SAVE_TARGETS, None, (Window) RGFW_root->src.window, CurrentTime);
		for (;;) {
			XEvent event;

			XNextEvent((Display*) RGFW_root->src.display, &event);
			if (event.type != SelectionRequest) {
				break;
			}

			const XSelectionRequestEvent* request = &event.xselectionrequest;

			XEvent reply = { SelectionNotify };
			reply.xselection.property = 0;

			if (request->target == TARGETS) {
				const Atom targets[] = { TARGETS,
										MULTIPLE,
										UTF8_STRING,
										XA_STRING };

				XChangeProperty((Display*) RGFW_root->src.display,
					request->requestor,
					request->property,
					4,
					32,
					PropModeReplace,
					(u8*) targets,
					sizeof(targets) / sizeof(targets[0]));

				reply.xselection.property = request->property;
			}

			if (request->target == MULTIPLE) {
				Atom* targets = NULL;

				Atom actualType = 0;
				int actualFormat = 0;
				unsigned long count = 0, bytesAfter = 0;

				XGetWindowProperty((Display*) RGFW_root->src.display, request->requestor, request->property, 0, LONG_MAX, False, ATOM_PAIR, &actualType, &actualFormat, &count, &bytesAfter, (u8**) &targets);

				unsigned long i;
				for (i = 0; i < (u32)count; i += 2) {
					if (targets[i] == UTF8_STRING || targets[i] == XA_STRING) {
						XChangeProperty((Display*) RGFW_root->src.display,
							request->requestor,
							targets[i + 1],
							targets[i],
							8,
							PropModeReplace,
							(u8*) text,
							textLen);
						XFlush(RGFW_root->src.display);
					} else {
						targets[i + 1] = None;
					}
				}

				XChangeProperty((Display*) RGFW_root->src.display,
					request->requestor,
					request->property,
					ATOM_PAIR,
					32,
					PropModeReplace,
					(u8*) targets,
					count);

				XFlush(RGFW_root->src.display);
				XFree(targets);

				reply.xselection.property = request->property;
			}

			reply.xselection.display = request->display;
			reply.xselection.requestor = request->requestor;
			reply.xselection.selection = request->selection;
			reply.xselection.target = request->target;
			reply.xselection.time = request->time;

			XSendEvent((Display*) RGFW_root->src.display, request->requestor, False, 0, &reply);
			XFlush(RGFW_root->src.display);
		}
	}

	u8 RGFW_window_isFullscreen(RGFW_window* win) {
		assert(win != NULL);

		XWindowAttributes windowAttributes;
		XGetWindowAttributes(win->src.display, (Window) win->src.window, &windowAttributes);

		/* check if the window is visable */
		if (windowAttributes.map_state != IsViewable)
			return 0;

		/* check if the window covers the full screen */
		return (windowAttributes.x == 0 && windowAttributes.y == 0 &&
			windowAttributes.width == XDisplayWidth(win->src.display, DefaultScreen(win->src.display)) &&
			windowAttributes.height == XDisplayHeight(win->src.display, DefaultScreen(win->src.display)));
	}

	u8 RGFW_window_isHidden(RGFW_window* win) {
		assert(win != NULL);

		XWindowAttributes windowAttributes;
		XGetWindowAttributes(win->src.display, (Window) win->src.window, &windowAttributes);

		return (windowAttributes.map_state == IsUnmapped && !RGFW_window_isMinimized(win));
	}

	u8 RGFW_window_isMinimized(RGFW_window* win) {
		assert(win != NULL);

		static Atom prop = 0;
		if (prop == 0)
			prop = XInternAtom(win->src.display, "WM_STATE", False);

		Atom actual_type;
		i32 actual_format;
		unsigned long nitems, bytes_after;
		unsigned char* prop_data;

		i16 status = XGetWindowProperty(win->src.display, (Window) win->src.window, prop, 0, 2, False,
			AnyPropertyType, &actual_type, &actual_format,
			&nitems, &bytes_after, &prop_data);

		if (status == Success && nitems >= 1 && *((int*) prop_data) == IconicState) {
			XFree(prop_data);
			return 1;
		}

		if (prop_data != NULL)
			XFree(prop_data);

		return 0;
	}

	u8 RGFW_window_isMaximized(RGFW_window* win) {
		assert(win != NULL);

		static Atom net_wm_state = 0;
		static Atom net_wm_state_maximized_horz = 0;
		static Atom net_wm_state_maximized_vert = 0;

		if (net_wm_state == 0) {
			net_wm_state = XInternAtom(win->src.display, "_NET_WM_STATE", False);
			net_wm_state_maximized_vert = XInternAtom(win->src.display, "_NET_WM_STATE_MAXIMIZED_VERT", False);
			net_wm_state_maximized_horz = XInternAtom(win->src.display, "_NET_WM_STATE_MAXIMIZED_HORZ", False);
		}

		Atom actual_type;
		i32 actual_format;
		unsigned long nitems, bytes_after;
		unsigned char* prop_data;

		i16 status = XGetWindowProperty(win->src.display, (Window) win->src.window, net_wm_state, 0, 1024, False,
			XA_ATOM, &actual_type, &actual_format,
			&nitems, &bytes_after, &prop_data);

		if (status != Success) {
			if (prop_data != NULL)
				XFree(prop_data);

			return 0;
		}

		Atom* atoms = (Atom*) prop_data;
		u64 i;
		for (i = 0; i < nitems; ++i) {
			if (atoms[i] == net_wm_state_maximized_horz ||
				atoms[i] == net_wm_state_maximized_vert) {
				XFree(prop_data);
				return 1;
			}
		}

		return 0;
	}

	static void XGetSystemContentScale(Display* display, float* xscale, float* yscale) {
		float xdpi = 96.f, ydpi = 96.f;

#ifndef RGFW_NO_DPI
		char* rms = XResourceManagerString(display);
		XrmDatabase db = NULL;

		if (rms && db)
			db = XrmGetStringDatabase(rms);

		if (db == 0) {
			*xscale = xdpi / 96.f;
			*yscale = ydpi / 96.f;
			return;
		}

		XrmValue value;
		char* type = NULL;

		if (XrmGetResource(db, "Xft.dpi", "Xft.Dpi", &type, &value) && type && strncmp(type, "String", 7) == 0)
			xdpi = ydpi = atof(value.addr);
		XrmDestroyDatabase(db);
#endif

		* xscale = xdpi / 96.f;
		*yscale = ydpi / 96.f;
	}

	RGFW_monitor RGFW_XCreateMonitor(i32 screen) {
		RGFW_monitor monitor;

		Display* display = XOpenDisplay(NULL);

		monitor.rect = RGFW_RECT(0, 0, DisplayWidth(display, screen), DisplayHeight(display, screen));
		monitor.physW = (monitor.rect.w * 25.4f / 96.f);
		monitor.physH = (monitor.rect.h * 25.4f / 96.f);

		strncpy(monitor.name, DisplayString(display), 128);

		XGetSystemContentScale(display, &monitor.scaleX, &monitor.scaleY);

		XRRScreenResources* sr = XRRGetScreenResourcesCurrent(display, RootWindow(display, screen));

		XRRCrtcInfo* ci = NULL;
		int crtc = 0;

		if (sr->ncrtc > crtc) {
			ci = XRRGetCrtcInfo(display, sr, sr->crtcs[crtc]);
		}

		if (ci == NULL) {
			XRRFreeScreenResources(sr);
			XCloseDisplay(display);
			return monitor;
		}

		monitor.rect.x = ci->x;
		monitor.rect.y = ci->y;

		XRRFreeCrtcInfo(ci);
		XRRFreeScreenResources(sr);

		XCloseDisplay(display);

		return monitor;
	}

	RGFW_monitor RGFW_monitors[6];
	RGFW_monitor* RGFW_getMonitors(void) {
		size_t i;
		for (i = 0; i < (size_t)ScreenCount(RGFW_root->src.display) && i < 6; i++)
			RGFW_monitors[i] = RGFW_XCreateMonitor(i);

		return RGFW_monitors;
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
		assert(RGFW_root != NULL);

		i32 primary = -1;
		Window root = DefaultRootWindow(RGFW_root->src.display);
		XRRScreenResources* res = XRRGetScreenResources(RGFW_root->src.display, root);

		for (int i = 0; i < res->noutput; i++) {
			XRROutputInfo* output_info = XRRGetOutputInfo(RGFW_root->src.display, res, res->outputs[i]);
			if (output_info->connection == RR_Connected && output_info->crtc) {
				XRRCrtcInfo* crtc_info = XRRGetCrtcInfo(RGFW_root->src.display, res, output_info->crtc);
				if (crtc_info->mode != None && crtc_info->x == 0 && crtc_info->y == 0) {
					primary = i;
					XRRFreeCrtcInfo(crtc_info);
					XRRFreeOutputInfo(output_info);
					break;
				}
				XRRFreeCrtcInfo(crtc_info);
			}
			XRRFreeOutputInfo(output_info);
		}

		XRRFreeScreenResources(res);

		return RGFW_XCreateMonitor(primary);
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		return RGFW_XCreateMonitor(DefaultScreen(win->src.display));
	}

	#ifdef RGFW_OPENGL
	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		if (win == NULL)
			glXMakeCurrent((Display*) NULL, (Drawable)NULL, (GLXContext) NULL);
		else
			glXMakeCurrent((Display*) win->src.display, (Drawable) win->src.window, (GLXContext) win->src.ctx);
	}
	#endif


	void RGFW_window_swapBuffers(RGFW_window* win) {
		assert(win != NULL);

		/* clear the window*/
		if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			#ifdef RGFW_OSMESA
			RGFW_OSMesa_reorganize();
			#endif
			RGFW_area area = RGFW_bufferSize;

#ifndef RGFW_X11_DONT_CONVERT_BGR
			win->src.bitmap->data = (char*) win->buffer;
			u32 x, y;
			for (y = 0; y < (u32)win->r.h; y++) {
				for (x = 0; x < (u32)win->r.w; x++) {
					u32 index = (y * 4 * area.w) + x * 4;

					u8 red = win->src.bitmap->data[index];
					win->src.bitmap->data[index] = win->buffer[index + 2];
					win->src.bitmap->data[index + 2] = red;

				}
			}
#endif	
			XPutImage(win->src.display, (Window) win->src.window, win->src.gc, win->src.bitmap, 0, 0, 0, 0, RGFW_bufferSize.w, RGFW_bufferSize.h);
#endif
		}

		if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) {
			#ifdef RGFW_EGL
					eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
			#elif defined(RGFW_OPENGL)
					glXSwapBuffers((Display*) win->src.display, (Window) win->src.window);
			#endif
		}
	}

	#if !defined(RGFW_EGL)	
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);

		#if defined(RGFW_OPENGL)	
		((PFNGLXSWAPINTERVALEXTPROC) glXGetProcAddress((GLubyte*) "glXSwapIntervalEXT"))((Display*) win->src.display, (Window) win->src.window, swapInterval);
		#else
		RGFW_UNUSED(swapInterval);
		#endif
	}
	#endif


	void RGFW_window_close(RGFW_window* win) {
		/* ungrab pointer if it was grabbed */
		if (win->_winArgs & RGFW_HOLD_MOUSE) 
			XUngrabPointer(win->src.display, CurrentTime);
			
		assert(win != NULL);
#ifdef RGFW_EGL
		RGFW_closeEGL(win);
#endif

#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
		if (win->buffer != NULL) {
			XDestroyImage((XImage*) win->src.bitmap);
			XFreeGC(win->src.display, win->src.gc);
		}
#endif

		if ((Display*) win->src.display) {
#ifdef RGFW_OPENGL
			glXDestroyContext((Display*) win->src.display, win->src.ctx);
#endif

			if (win == RGFW_root)
				RGFW_root = NULL;

			if ((Drawable) win->src.window)
				XDestroyWindow((Display*) win->src.display, (Drawable) win->src.window); /*!< close the window*/
			
			XCloseDisplay((Display*) win->src.display); /*!< kill the display*/
		}

#ifdef RGFW_ALLOC_DROPFILES
		{
			u32 i;
			for (i = 0; i < RGFW_MAX_DROPS; i++)
				RGFW_FREE(win->event.droppedFiles[i]);


			RGFW_FREE(win->event.droppedFiles);
		}
#endif

		RGFW_windowsOpen--;
#if !defined(RGFW_NO_X11_CURSOR_PRELOAD) && !defined(RGFW_NO_X11_CURSOR)
		if (X11Cursorhandle != NULL && RGFW_windowsOpen <= 0) {
			dlclose(X11Cursorhandle);

			X11Cursorhandle = NULL;
		}
#endif
#if !defined(RGFW_NO_X11_XI_PRELOAD)
		if (X11Xihandle != NULL && RGFW_windowsOpen <= 0) {
			dlclose(X11Xihandle);

			X11Xihandle = NULL;
		}
#endif

		if (RGFW_libxshape != NULL && RGFW_windowsOpen <= 0) {
			dlclose(RGFW_libxshape);
			RGFW_libxshape = NULL;
		}

		if (RGFW_windowsOpen <= 0) {
			if (RGFW_eventWait_forceStop[0] || RGFW_eventWait_forceStop[1]){
				close(RGFW_eventWait_forceStop[0]);
				close(RGFW_eventWait_forceStop[1]);
			}

			u8 i;
			for (i = 0; i < RGFW_joystickCount; i++)
				close(RGFW_joysticks[i]);
		}

		/* set cleared display / window to NULL for error checking */
		win->src.display = (Display*) 0;
		win->src.window = (Window) 0;

		RGFW_FREE(win); /*!< free collected window data */
	}
	

/* 
	End of X11 linux / unix defines
*/

#endif /* RGFW_X11 */


/* wayland or X11 defines*/
#if defined(RGFW_WAYLAND) || defined(RGFW_X11)
#include <fcntl.h>
#include <poll.h>
#include <unistd.h>
	u16 RGFW_registerJoystickF(RGFW_window* win, char* file) {
		assert(win != NULL);

#ifdef __linux__

		i32 js = open(file, O_RDONLY);

		if (js && RGFW_joystickCount < 4) {
			RGFW_joystickCount++;

			RGFW_joysticks[RGFW_joystickCount - 1] = open(file, O_RDONLY);

			u8 i;
			for (i = 0; i < 16; i++)
				RGFW_jsPressed[RGFW_joystickCount - 1][i] = 0;

		}

		else {
#ifdef RGFW_PRINT_ERRORS
			RGFW_error = 1;
			fprintf(stderr, "Error RGFW_registerJoystickF : Cannot open file %s\n", file);
#endif
		}

		return RGFW_joystickCount - 1;
#endif
	}
	
	u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber) {
		assert(win != NULL);

#ifdef __linux__
		char file[15];
		sprintf(file, "/dev/input/js%i", jsNumber);

		return RGFW_registerJoystickF(win, file);
#endif
	}
	
	void RGFW_stopCheckEvents(void) { 
		RGFW_eventWait_forceStop[2] = 1;
		while (1) {
			const char byte = 0;
			const ssize_t result = write(RGFW_eventWait_forceStop[1], &byte, 1);
			if (result == 1 || result == -1)
				break;
		}
	}

	void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
		if (waitMS == 0)
			return;
		
		u8 i;

		if (RGFW_eventWait_forceStop[0] == 0 || RGFW_eventWait_forceStop[1] == 0) {
			if (pipe(RGFW_eventWait_forceStop) != -1) {
				fcntl(RGFW_eventWait_forceStop[0], F_GETFL, 0);
				fcntl(RGFW_eventWait_forceStop[0], F_GETFD, 0);
				fcntl(RGFW_eventWait_forceStop[1], F_GETFL, 0);
				fcntl(RGFW_eventWait_forceStop[1], F_GETFD, 0);
			}
		}

		struct pollfd fds[] = {
			#ifdef RGFW_WAYLAND
			{ wl_display_get_fd(win->src.display), POLLIN, 0 },
			#else
			{ ConnectionNumber(win->src.display), POLLIN, 0 },
			#endif
			{ RGFW_eventWait_forceStop[0], POLLIN, 0 },
			#ifdef __linux__ /* blank space for 4 joystick files*/
			{ -1, POLLIN, 0 }, {-1, POLLIN, 0 }, {-1, POLLIN, 0 },  {-1, POLLIN, 0} 
			#endif
		};

		u8 index = 2;
		
		#if defined(__linux__)
			for (i = 0; i < RGFW_joystickCount; i++) {
				if (RGFW_joysticks[i] == 0)
					continue;

				fds[index].fd = RGFW_joysticks[i];
				index++;
			}
		#endif


		u64 start = RGFW_getTimeNS();

		#ifdef RGFW_WAYLAND
		while (wl_display_dispatch(win->src.display) <= 0 && waitMS >= -1) {
		#else
		while (XPending(win->src.display) == 0 && waitMS >= -1) {
		#endif
			if (poll(fds, index, waitMS) <= 0)
				break;

			if (waitMS > 0) {
				waitMS -= (RGFW_getTimeNS() - start) / 1e+6;
			}
		}

		/* drain any data in the stop request */
		if (RGFW_eventWait_forceStop[2]) {	
			char data[64];
			(void)!read(RGFW_eventWait_forceStop[0], data, sizeof(data));
			
			RGFW_eventWait_forceStop[2] = 0;
		}
	}

	u64 RGFW_getTimeNS(void) { 
		struct timespec ts = { 0 };
		clock_gettime(1, &ts);
		unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;

		return nanoSeconds;
	}

	u64 RGFW_getTime(void) {
		struct timespec ts = { 0 };
		clock_gettime(1, &ts);
		unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;

		return (double)(nanoSeconds) * 1e-9;
	}
#endif /* end of wayland or X11 time defines*/


/*

	Start of Wayland defines


*/

#ifdef RGFW_WAYLAND
/*
Wayland TODO:
- fix RGFW_keyPressed lock state

	RGFW_windowMoved, 		the window was moved (by the user)
	RGFW_windowResized  	the window was resized (by the user), [on webASM this means the browser was resized]
	RGFW_windowRefresh	 	The window content needs to be refreshed

	RGFW_dnd 				a file has been dropped into the window
	RGFW_dnd_init

- window args:
	#define RGFW_NO_RESIZE	 			the window cannot be resized  by the user
	#define RGFW_ALLOW_DND     			the window supports drag and drop
	#define RGFW_SCALE_TO_MONITOR 			scale the window to the screen 

- other missing functions functions ("TODO wayland") (~30 functions)
- fix buffer rendering weird behavior
*/
	#include <errno.h>
	#include <unistd.h>
	#include <sys/mman.h>
	#include <xkbcommon/xkbcommon.h>
	#include <xkbcommon/xkbcommon-keysyms.h>
	#include <dirent.h>
	#include <linux/kd.h> 
	#include <wayland-cursor.h>

RGFW_window* RGFW_key_win = NULL;

void RGFW_eventPipe_push(RGFW_window* win, RGFW_Event event) {
	if (win == NULL) {
		win = RGFW_key_win;

		if (win == NULL) return;
	}
	
	if (win->src.eventLen >= (i32)(sizeof(win->src.events) / sizeof(win->src.events[0])))
		return;

	win->src.events[win->src.eventLen] = event;
	win->src.eventLen += 1;
}

RGFW_Event RGFW_eventPipe_pop(RGFW_window* win) {
	RGFW_Event ev;
	ev.type = 0;
	
	if (win->src.eventLen > -1)
		win->src.eventLen -= 1;
	
	if (win->src.eventLen >= 0)  
		ev = win->src.events[win->src.eventLen];
	else {
		printf("H2\n");
	}

	return ev;	
}

/* wayland global garbage (wayland bad, X11 is fine (ish) (not really)) */
#include "xdg-shell.h"
#include "xdg-decoration-unstable-v1.h"

struct xdg_wm_base *xdg_wm_base;
struct wl_compositor* RGFW_compositor = NULL;
struct wl_shm* shm = NULL;
struct wl_shell* RGFW_shell = NULL;
static struct wl_seat *seat = NULL;
static struct xkb_context *xkb_context;
static struct xkb_keymap *keymap = NULL;
static struct xkb_state *xkb_state = NULL;
enum zxdg_toplevel_decoration_v1_mode client_preferred_mode, RGFW_current_mode;
static struct zxdg_decoration_manager_v1 *decoration_manager = NULL;

struct wl_cursor_theme* RGFW_wl_cursor_theme = NULL;
struct wl_surface* RGFW_cursor_surface = NULL;
struct wl_cursor_image* RGFW_cursor_image = NULL;

static void xdg_wm_base_ping_handler(void *data,
        struct xdg_wm_base *wm_base, uint32_t serial)
{
	RGFW_UNUSED(data);
    xdg_wm_base_pong(wm_base, serial);
}

static const struct xdg_wm_base_listener xdg_wm_base_listener = {
    .ping = xdg_wm_base_ping_handler,
};

b8 RGFW_wl_configured = 0;

static void xdg_surface_configure_handler(void *data,
        struct xdg_surface *xdg_surface, uint32_t serial)
{	
	RGFW_UNUSED(data);
    xdg_surface_ack_configure(xdg_surface, serial);
	#ifdef RGFW_DEBUG
	printf("Surface configured\n");
	#endif
	RGFW_wl_configured = 1;
}

static const struct xdg_surface_listener xdg_surface_listener = {
    .configure = xdg_surface_configure_handler,
};

static void xdg_toplevel_configure_handler(void *data,
        struct xdg_toplevel *toplevel, int32_t width, int32_t height,
        struct wl_array *states)
{
	RGFW_UNUSED(data); RGFW_UNUSED(toplevel); RGFW_UNUSED(states)
    fprintf(stderr, "XDG toplevel configure: %dx%d\n", width, height);
}

static void xdg_toplevel_close_handler(void *data,
        struct xdg_toplevel *toplevel)
{
	RGFW_UNUSED(data);
	RGFW_window* win = (RGFW_window*)xdg_toplevel_get_user_data(toplevel);
	if (win == NULL)
		win = RGFW_key_win;
	
	RGFW_Event ev;
	ev.type = RGFW_quit;

	RGFW_eventPipe_push(win, ev); 	

	RGFW_windowQuitCallback(win);
}

static void shm_format_handler(void *data,
        struct wl_shm *shm, uint32_t format)
{
	RGFW_UNUSED(data); RGFW_UNUSED(shm);
    fprintf(stderr, "Format %d\n", format);
}

static const struct wl_shm_listener shm_listener = {
    .format = shm_format_handler,
};

static const struct xdg_toplevel_listener xdg_toplevel_listener = {
    .configure = xdg_toplevel_configure_handler,
    .close = xdg_toplevel_close_handler,
};

RGFW_window* RGFW_mouse_win = NULL;

static void pointer_enter(void *data, struct wl_pointer *pointer, uint32_t serial, struct wl_surface *surface, wl_fixed_t surface_x, wl_fixed_t surface_y) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(serial); RGFW_UNUSED(surface_x); RGFW_UNUSED(surface_y);
	RGFW_window* win = (RGFW_window*)wl_surface_get_user_data(surface);
	RGFW_mouse_win = win;

	RGFW_Event ev;
	ev.type = RGFW_mouseEnter;
	ev.point = win->event.point;

	RGFW_eventPipe_push(win, ev); 	

	RGFW_mouseNotifyCallBack(win, win->event.point, RGFW_TRUE);
}
static void pointer_leave(void *data, struct wl_pointer *pointer, uint32_t serial, struct wl_surface *surface) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(serial); RGFW_UNUSED(surface);
	RGFW_window* win = (RGFW_window*)wl_surface_get_user_data(surface);
	if (RGFW_mouse_win == win)
		RGFW_mouse_win = NULL;
	
	RGFW_Event ev;
	ev.type = RGFW_mouseLeave;
	ev.point = win->event.point;
	RGFW_eventPipe_push(win, ev);

	RGFW_mouseNotifyCallBack(win,  win->event.point, RGFW_FALSE);
}
static void pointer_motion(void *data, struct wl_pointer *pointer, uint32_t time, wl_fixed_t x, wl_fixed_t y) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(time); RGFW_UNUSED(x); RGFW_UNUSED(y);

	assert(RGFW_mouse_win != NULL);
	
	RGFW_Event ev;
	ev.type = RGFW_mousePosChanged;
	ev.point = RGFW_POINT(wl_fixed_to_double(x), wl_fixed_to_double(y));
	RGFW_eventPipe_push(RGFW_mouse_win, ev);
	
	RGFW_mousePosCallback(RGFW_mouse_win, RGFW_POINT(wl_fixed_to_double(x), wl_fixed_to_double(y)));
}
static void pointer_button(void *data, struct wl_pointer *pointer, uint32_t serial, uint32_t time, uint32_t button, uint32_t state) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(time); RGFW_UNUSED(serial);
	assert(RGFW_mouse_win != NULL);

	u32 b = (button - 0x110) + 1;

	/* flip right and middle button codes */
	if (b == 2) b = 3;
	else if (b == 3) b = 2;
	
	RGFW_mouseButtons[b].prev = RGFW_mouseButtons[b].current;
	RGFW_mouseButtons[b].current = state;

	RGFW_Event ev;
	ev.type = RGFW_mouseButtonPressed + state;
	ev.button = b;
	RGFW_eventPipe_push(RGFW_mouse_win, ev);

	RGFW_mouseButtonCallback(RGFW_mouse_win, b, 0, state);
}
static void pointer_axis(void *data, struct wl_pointer *pointer, uint32_t time, uint32_t axis, wl_fixed_t value) {
	RGFW_UNUSED(data); RGFW_UNUSED(pointer); RGFW_UNUSED(time);  RGFW_UNUSED(axis);
	assert(RGFW_mouse_win != NULL); 

	double scroll = wl_fixed_to_double(value);

	RGFW_Event ev;
	ev.type = RGFW_mouseButtonPressed;
	ev.button = RGFW_mouseScrollUp + (scroll < 0);
	RGFW_eventPipe_push(RGFW_mouse_win, ev);

	RGFW_mouseButtonCallback(RGFW_mouse_win, RGFW_mouseScrollUp + (scroll < 0), scroll, 1);
}

void RGFW_doNothing(void) { }
static struct wl_pointer_listener pointer_listener = (struct wl_pointer_listener){&pointer_enter, &pointer_leave, &pointer_motion, &pointer_button, &pointer_axis, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing, (void*)&RGFW_doNothing};

static void keyboard_keymap (void *data, struct wl_keyboard *keyboard, uint32_t format, int32_t fd, uint32_t size) {
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(format);

	char *keymap_string = mmap (NULL, size, PROT_READ, MAP_SHARED, fd, 0);
	xkb_keymap_unref (keymap);
	keymap = xkb_keymap_new_from_string (xkb_context, keymap_string, XKB_KEYMAP_FORMAT_TEXT_V1, XKB_KEYMAP_COMPILE_NO_FLAGS);
	
	munmap (keymap_string, size);
	close (fd);
	xkb_state_unref (xkb_state);
	xkb_state = xkb_state_new (keymap);
}
static void keyboard_enter (void *data, struct wl_keyboard *keyboard, uint32_t serial, struct wl_surface *surface, struct wl_array *keys) { 
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial); RGFW_UNUSED(keys);

	RGFW_key_win = (RGFW_window*)wl_surface_get_user_data(surface);

	RGFW_Event ev;
	ev.type = RGFW_focusIn;
	ev.inFocus = RGFW_TRUE;
	RGFW_key_win->event.inFocus = RGFW_TRUE;

	RGFW_eventPipe_push((RGFW_window*)RGFW_mouse_win, ev);

	RGFW_focusCallback(RGFW_key_win, RGFW_TRUE);
}
static void keyboard_leave (void *data, struct wl_keyboard *keyboard, uint32_t serial, struct wl_surface *surface) { 
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial);

	RGFW_window* win = (RGFW_window*)wl_surface_get_user_data(surface);
	if (RGFW_key_win == win)
		RGFW_key_win = NULL;	

	RGFW_Event ev;
	ev.type = RGFW_focusOut;
	ev.inFocus = RGFW_FALSE;
	win->event.inFocus = RGFW_FALSE;
	RGFW_eventPipe_push(win, ev);

	RGFW_focusCallback(win, RGFW_FALSE);
}
static void keyboard_key (void *data, struct wl_keyboard *keyboard, uint32_t serial, uint32_t time, uint32_t key, uint32_t state) {
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial); RGFW_UNUSED(time); 

	assert(RGFW_key_win != NULL);

	xkb_keysym_t keysym = xkb_state_key_get_one_sym (xkb_state, key+8);
	char name[16];
	xkb_keysym_get_name(keysym, name, 16);

	u32 RGFW_key = RGFW_apiKeyCodeToRGFW(key);
	RGFW_keyboard[RGFW_key].prev = RGFW_keyboard[RGFW_key].current;
	RGFW_keyboard[RGFW_key].current = state;
	RGFW_Event ev;
	ev.type = RGFW_keyPressed + state;
	ev.keyCode = RGFW_key;
	strcpy(ev.keyName, name);
	ev.repeat = RGFW_isHeld(RGFW_key_win, RGFW_key);
	RGFW_eventPipe_push(RGFW_key_win, ev);
	
	RGFW_updateLockState(RGFW_key_win, xkb_keymap_mod_get_index(keymap, "Lock"), xkb_keymap_mod_get_index(keymap, "Mod2"));

	RGFW_keyCallback(RGFW_key_win, RGFW_key, name, RGFW_key_win->event.lockState, state);
}
static void keyboard_modifiers (void *data, struct wl_keyboard *keyboard, uint32_t serial, uint32_t mods_depressed, uint32_t mods_latched, uint32_t mods_locked, uint32_t group) {
	RGFW_UNUSED(data); RGFW_UNUSED(keyboard); RGFW_UNUSED(serial); RGFW_UNUSED(time); 
	xkb_state_update_mask (xkb_state, mods_depressed, mods_latched, mods_locked, 0, 0, group);
}
static struct wl_keyboard_listener keyboard_listener = {&keyboard_keymap, &keyboard_enter, &keyboard_leave, &keyboard_key, &keyboard_modifiers, (void*)&RGFW_doNothing};

static void seat_capabilities (void *data, struct wl_seat *seat, uint32_t capabilities) {
	RGFW_UNUSED(data);

	if (capabilities & WL_SEAT_CAPABILITY_POINTER) {
		struct wl_pointer *pointer = wl_seat_get_pointer (seat);
		wl_pointer_add_listener (pointer, &pointer_listener, NULL);
	}
	if (capabilities & WL_SEAT_CAPABILITY_KEYBOARD) {
		struct wl_keyboard *keyboard = wl_seat_get_keyboard (seat);
		wl_keyboard_add_listener (keyboard, &keyboard_listener, NULL);
	}
}
static struct wl_seat_listener seat_listener = {&seat_capabilities, (void*)&RGFW_doNothing};

static void wl_global_registry_handler(void *data,
		struct wl_registry *registry, uint32_t id, const char *interface,
		uint32_t version)
{
	RGFW_UNUSED(data); RGFW_UNUSED(version);

    if (strcmp(interface, "wl_compositor") == 0) {
		RGFW_compositor = wl_registry_bind(registry,
			id, &wl_compositor_interface, 4);
	} else if (strcmp(interface, "xdg_wm_base") == 0) {
	xdg_wm_base = wl_registry_bind(registry,
		id, &xdg_wm_base_interface, 1);
	} else if (strcmp(interface, zxdg_decoration_manager_v1_interface.name) == 0) {
		decoration_manager = wl_registry_bind(registry, id, &zxdg_decoration_manager_v1_interface, 1);
    } else if (strcmp(interface, "wl_shm") == 0) {
        shm = wl_registry_bind(registry,
            id, &wl_shm_interface, 1);
        wl_shm_add_listener(shm, &shm_listener, NULL);
	} else if (strcmp(interface,"wl_seat") == 0) {
		seat = wl_registry_bind(registry, id, &wl_seat_interface, 1);
		wl_seat_add_listener(seat, &seat_listener, NULL);
	}

	else {
		#ifdef RGFW_DEBUG
		printf("did not register %s\n", interface);
		return;
		#endif
	}

		#ifdef RGFW_DEBUG
		printf("registered %s\n", interface);
		#endif
}

static void wl_global_registry_remove(void *data, struct wl_registry *registry, uint32_t name) { RGFW_UNUSED(data); RGFW_UNUSED(registry); RGFW_UNUSED(name); }
static const struct wl_registry_listener registry_listener = {
	.global = wl_global_registry_handler,
	.global_remove = wl_global_registry_remove,
};

static const char *get_mode_name(enum zxdg_toplevel_decoration_v1_mode mode) {
	switch (mode) {
	case ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE:
		return "client-side decorations";
	case ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE:
		return "server-side decorations";
	}
	abort();
}


static void decoration_handle_configure(void *data,
		struct zxdg_toplevel_decoration_v1 *decoration,
		enum zxdg_toplevel_decoration_v1_mode mode) {
	RGFW_UNUSED(data); RGFW_UNUSED(decoration);
	printf("Using %s\n", get_mode_name(mode));
	RGFW_current_mode = mode;
}

static const struct zxdg_toplevel_decoration_v1_listener decoration_listener = {
	.configure = decoration_handle_configure,
};

static void randname(char *buf) {
	struct timespec ts;
	clock_gettime(CLOCK_REALTIME, &ts);
	long r = ts.tv_nsec;
	for (int i = 0; i < 6; ++i) {
		buf[i] = 'A'+(r&15)+(r&16)*2;
		r >>= 5;
	}
}

static int anonymous_shm_open(void) {
	char name[] = "/RGFW-wayland-XXXXXX";
	int retries = 100;

	do {
		randname(name + strlen(name) - 6);

		--retries;
		// shm_open guarantees that O_CLOEXEC is set
		int fd = shm_open(name, O_RDWR | O_CREAT | O_EXCL, 0600);
		if (fd >= 0) {
			shm_unlink(name);
			return fd;
		}
	} while (retries > 0 && errno == EEXIST);

	return -1;
}

int create_shm_file(off_t size) {
	int fd = anonymous_shm_open();
	if (fd < 0) {
		return fd;
	}

	if (ftruncate(fd, size) < 0) {
		close(fd);
		return -1;
	}

	return fd;
}

static void wl_surface_frame_done(void *data, struct wl_callback *cb, uint32_t time) {
	#ifdef RGFW_BUFFER
		RGFW_window* win = (RGFW_window*)data;
		if ((win->_winArgs & RGFW_NO_CPU_RENDER))
			return;	
		
		#ifndef RGFW_X11_DONT_CONVERT_BGR
			u32 x, y;
			for (y = 0; y < (u32)win->r.h; y++) {
				for (x = 0; x < (u32)win->r.w; x++) {
					u32 index = (y * 4 * win->r.w) + x * 4;

					u8 red = win->buffer[index];
					win->buffer[index] = win->buffer[index + 2];
					win->buffer[index + 2] = red;

				}
			}
		#endif	
	
		wl_surface_attach(win->src.surface, win->src.wl_buffer, 0, 0);
		wl_surface_damage_buffer(win->src.surface, 0, 0, win->r.w, win->r.h);
		wl_surface_commit(win->src.surface);
	#endif
}

static const struct wl_callback_listener wl_surface_frame_listener = {
	.done = wl_surface_frame_done,
};


	/* normal wayland RGFW stuff */
	
	RGFW_area RGFW_getScreenSize(void) {
		RGFW_area area = {};

		if (RGFW_root != NULL)
			/* this isn't right but it's here for buffers */
			area = RGFW_AREA(RGFW_root->r.w, RGFW_root->r.h);
		
		/* TODO wayland */
		return area;
	}
	
	void RGFW_releaseCursor(RGFW_window* win) {
		RGFW_UNUSED(win);
	}

	void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) {
		RGFW_UNUSED(win); RGFW_UNUSED(r);

		/* TODO wayland */
	}


	RGFWDEF void RGFW_init_buffer(RGFW_window* win);
	void RGFW_init_buffer(RGFW_window* win) {
		#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)	
			size_t size = win->r.w * win->r.h * 4;
			int fd = create_shm_file(size);
			if (fd < 0) {
				fprintf(stderr, "Failed to create a buffer. size: %ld\n", size);
				exit(1);
			}

			win->buffer = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
			if (win->buffer == MAP_FAILED) {
				fprintf(stderr, "mmap failed!\n");
				close(fd);
				exit(1);
			}

			struct wl_shm_pool* pool = wl_shm_create_pool(shm, fd, size);
			win->src.wl_buffer = wl_shm_pool_create_buffer(pool, 0, win->r.w, win->r.h, win->r.w * 4,
				WL_SHM_FORMAT_ARGB8888);
			wl_shm_pool_destroy(pool);

			close(fd);
			
			wl_surface_attach(win->src.surface, win->src.wl_buffer, 0, 0);
			wl_surface_commit(win->src.surface);

			u8 color[] = {0x00, 0x00, 0x00, 0xFF};

			size_t i;
			for (i = 0; i < size; i += 4) {
				memcpy(&win->buffer[i], color, 4);
			}
	
			#if defined(RGFW_OSMESA)
					win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
					OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
			#endif
		#else
		RGFW_UNUSED(win);
		#endif
	}
   

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
		RGFW_window* win = RGFW_window_basic_init(rect, args);
		
		fprintf(stderr, "Warning: RGFW Wayland support is experimental\n");
		
		win->src.display = wl_display_connect(NULL);
		if (win->src.display == NULL) {
			#ifdef RGFW_DEBUG
				fprintf(stderr, "Failed to load Wayland display\n");
			#endif
			return NULL;
		}
		
		struct wl_registry *registry = wl_display_get_registry(win->src.display);
		wl_registry_add_listener(registry, &registry_listener, NULL);
			
		wl_display_dispatch(win->src.display);
		wl_display_roundtrip(win->src.display);

		if (RGFW_compositor == NULL) {
			#ifdef RGFW_DEBUG
				fprintf(stderr, "Can't find compositor.\n");
			#endif
			
			return NULL;
		}
		
		if (RGFW_wl_cursor_theme == NULL) {
			RGFW_wl_cursor_theme = wl_cursor_theme_load(NULL, 24, shm);
			RGFW_cursor_surface = wl_compositor_create_surface(RGFW_compositor); 
			
			struct wl_cursor* cursor = wl_cursor_theme_get_cursor(RGFW_wl_cursor_theme, "left_ptr");
			RGFW_cursor_image = cursor->images[0];
			struct wl_buffer* cursor_buffer	= wl_cursor_image_get_buffer(RGFW_cursor_image);

			wl_surface_attach(RGFW_cursor_surface, cursor_buffer, 0, 0);
			wl_surface_commit(RGFW_cursor_surface); 
		}

		if (RGFW_root == NULL)
			xdg_wm_base_add_listener(xdg_wm_base, &xdg_wm_base_listener, NULL);
		
		xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);

		win->src.surface = wl_compositor_create_surface(RGFW_compositor);
		wl_surface_set_user_data(win->src.surface, win);

		win->src.xdg_surface = xdg_wm_base_get_xdg_surface(xdg_wm_base, win->src.surface);
		xdg_surface_add_listener(win->src.xdg_surface, &xdg_surface_listener, NULL);
	
		xdg_wm_base_set_user_data(xdg_wm_base, win);

		win->src.xdg_toplevel = xdg_surface_get_toplevel(win->src.xdg_surface);
		xdg_toplevel_set_user_data(win->src.xdg_toplevel, win);
		xdg_toplevel_set_title(win->src.xdg_toplevel, name);
		xdg_toplevel_add_listener(win->src.xdg_toplevel, &xdg_toplevel_listener, NULL);

		xdg_surface_set_window_geometry(win->src.xdg_surface, 0, 0, win->r.w, win->r.h);
		
		if (!(args & RGFW_NO_BORDER)) {
			win->src.decoration = zxdg_decoration_manager_v1_get_toplevel_decoration(
						decoration_manager, win->src.xdg_toplevel);
		}


		if (args & RGFW_OPENGL_SOFTWARE)
			setenv("LIBGL_ALWAYS_SOFTWARE", "1", 1);

		wl_display_roundtrip(win->src.display);

		wl_surface_commit(win->src.surface);
		
		/* wait for the surface to be configured */
		while (wl_display_dispatch(win->src.display) != -1 && !RGFW_wl_configured) { }
		
		
		#ifdef RGFW_OPENGL
			if ((args & RGFW_NO_INIT_API) == 0) {
				win->src.window = wl_egl_window_create(win->src.surface, win->r.w, win->r.h);
				RGFW_createOpenGLContext(win);
			}
		#endif	

		RGFW_init_buffer(win);

		struct wl_callback* callback = wl_surface_frame(win->src.surface);
   		wl_callback_add_listener(callback, &wl_surface_frame_listener, win);	
		wl_surface_commit(win->src.surface);

		if (args & RGFW_HIDE_MOUSE) {
			RGFW_window_showMouse(win, 0);
		}
		
		if (RGFW_root == NULL) {
			RGFW_root = win;
		}
		
		win->src.eventIndex = 0;
		win->src.eventLen = 0;
		
		return win;
	}

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		if (win->_winArgs & RGFW_WINDOW_HIDE)
			return NULL;

		if (win->src.eventIndex == 0) {
			if (wl_display_roundtrip(win->src.display) == -1) {
				return NULL;
			}
			RGFW_resetKey();
		}

		#ifdef __linux__
			RGFW_Event* event = RGFW_linux_updateJoystick(win);
			if (event != NULL)
				return event;
		#endif
		
		if (win->src.eventLen == 0) {
				return NULL;
		}

		RGFW_Event ev = RGFW_eventPipe_pop(win);
		
		if (ev.type ==  0 || win->event.type == RGFW_quit) {
			return NULL;
		}
        
		ev.frameTime = win->event.frameTime;
        ev.frameTime2 = win->event.frameTime2;
        ev.inFocus = win->event.inFocus;
        win->event = ev;
		
		return &win->event;
	}


	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		RGFW_UNUSED(win); RGFW_UNUSED(a);

		/* TODO wayland */
	}

	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		RGFW_UNUSED(win); RGFW_UNUSED(v);

		/* TODO wayland */
	}

	void RGFW_window_setIcon(RGFW_window* win, u8* src, RGFW_area a, i32 channels) {
		RGFW_UNUSED(win); RGFW_UNUSED(src); RGFW_UNUSED(a); RGFW_UNUSED(channels)
		/* TODO wayland */
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) {
		RGFW_UNUSED(win); RGFW_UNUSED(v);

		/* TODO wayland */
	}

	void RGFW_window_showMouse(RGFW_window* win, i8 show) {
		RGFW_UNUSED(win);

		if (show) {

		}
		else {
			
		}

		/* TODO wayland */
	}

	b8 RGFW_window_isMaximized(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	b8 RGFW_window_isMinimized(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	b8 RGFW_window_isHidden(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	b8 RGFW_window_isFullscreen(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return 0;
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		RGFW_UNUSED(win);
		/* TODO wayland */
		return RGFW_POINT(0, 0);
	}
			
	RGFW_point RGFW_getGlobalMousePoint(void) {
		/* TODO wayland */
		return RGFW_POINT(0, 0);
	}
			
	void RGFW_window_show(RGFW_window* win) {
		//wl_surface_attach(win->src.surface, win->rc., 0, 0);
        wl_surface_commit(win->src.surface);
		
		if (win->_winArgs & RGFW_WINDOW_HIDE)
			win->_winArgs ^= RGFW_WINDOW_HIDE;
	}
		
	void RGFW_window_hide(RGFW_window* win) {
		wl_surface_attach(win->src.surface, NULL, 0, 0);
        wl_surface_commit(win->src.surface);
		win->_winArgs |= RGFW_WINDOW_HIDE;
	}
		
	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_UNUSED(win);
	
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_NORMAL);
	}
		
	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
		RGFW_UNUSED(win);
		
		static const char* iconStrings[] = { "left_ptr", "left_ptr", "text", "cross", "pointer", "e-resize", "n-resize", "nw-resize", "ne-resize", "all-resize", "not-allowed" };

		struct wl_cursor* cursor = wl_cursor_theme_get_cursor(RGFW_wl_cursor_theme, iconStrings[mouse]);
		RGFW_cursor_image = cursor->images[0];
		struct wl_buffer* cursor_buffer	= wl_cursor_image_get_buffer(RGFW_cursor_image);

		wl_surface_attach(RGFW_cursor_surface, cursor_buffer, 0, 0);
		wl_surface_commit(RGFW_cursor_surface); 
	}
		
	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		RGFW_UNUSED(win); RGFW_UNUSED(image); RGFW_UNUSED(a); RGFW_UNUSED(channels)
		//struct wl_cursor* cursor = wl_cursor_theme_get_cursor(RGFW_wl_cursor_theme, iconStrings[mouse]);
		//RGFW_cursor_image = image;
		struct wl_buffer* cursor_buffer	= wl_cursor_image_get_buffer(RGFW_cursor_image);

		wl_surface_attach(RGFW_cursor_surface, cursor_buffer, 0, 0);
		wl_surface_commit(RGFW_cursor_surface); 
	}
		
	void RGFW_window_setName(RGFW_window* win, char* name) {
		xdg_toplevel_set_title(win->src.xdg_toplevel, name);
	}
		
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		RGFW_UNUSED(win); RGFW_UNUSED(passthrough);

	/* TODO wayland */
	}
		
	void RGFW_window_setBorder(RGFW_window* win, b8 border) {
		RGFW_UNUSED(win); RGFW_UNUSED(border);

	/* TODO wayland */
	}
		
	void RGFW_window_restore(RGFW_window* win) {
		RGFW_UNUSED(win);

	/* TODO wayland */
	}
		
	void RGFW_window_minimize(RGFW_window* win) {
		RGFW_UNUSED(win);

	/* TODO wayland */
	}
		
	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		RGFW_UNUSED(win); RGFW_UNUSED(a);

	/* TODO wayland */
	}
		
	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		RGFW_UNUSED(win); RGFW_UNUSED(a);

	/* TODO wayland */
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		RGFW_monitor m = {};
		RGFW_UNUSED(win);
		RGFW_UNUSED(m);
		/* TODO wayland */

		return m;
	}


	#ifndef RGFW_EGL
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) { RGFW_UNUSED(win); RGFW_UNUSED(swapInterval); }
	#endif

	void RGFW_window_swapBuffers(RGFW_window* win) {
		assert(win != NULL);

		/* clear the window*/
		#ifdef RGFW_BUFFER	
			wl_surface_frame_done(win, NULL, 0);
			if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) 
		#endif
		{
		#ifdef RGFW_OPENGL
			eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
		#endif
		}
		
		wl_display_flush(win->src.display);
	}

	void RGFW_window_close(RGFW_window* win) {
		#ifdef RGFW_EGL
			RGFW_closeEGL(win);
		#endif

		if (RGFW_root == win) {
			RGFW_root = NULL;
		}

		xdg_toplevel_destroy(win->src.xdg_toplevel);
		xdg_surface_destroy(win->src.xdg_surface);
		wl_surface_destroy(win->src.surface);

		#ifdef RGFW_BUFFER
		wl_buffer_destroy(win->src.wl_buffer);
		#endif
		
		wl_display_disconnect(win->src.display);
		RGFW_FREE(win);
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
		/* TODO wayland */

		return (RGFW_monitor){};
	}
						
	RGFW_monitor* RGFW_getMonitors(void) {
		/* TODO wayland */

		return NULL;
	}

	void RGFW_writeClipboard(const char* text, u32 textLen) {
		RGFW_UNUSED(text); RGFW_UNUSED(textLen);

		/* TODO wayland */
	}

	char* RGFW_readClipboard(size_t* size) {
		RGFW_UNUSED(size);

		/* TODO wayland */

		return NULL;
	}
#endif /* RGFW_WAYLAND */

/* 
	End of Wayland defines
*/


/*

	Start of Windows defines


*/

#ifdef RGFW_WINDOWS
	#define WIN32_LEAN_AND_MEAN
	#define OEMRESOURCE
	#include <windows.h>
	
	#include <processthreadsapi.h>
	#include <wchar.h>
	#include <locale.h>
	#include <windowsx.h>
	#include <shellapi.h>
	#include <shellscalingapi.h>

	#include <winuser.h>

	__declspec(dllimport) int __stdcall WideCharToMultiByte( UINT CodePage, DWORD dwFlags, const WCHAR* lpWideCharStr, int cchWideChar,  LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
	
	#ifndef RGFW_NO_XINPUT
	typedef DWORD (WINAPI * PFN_XInputGetState)(DWORD,XINPUT_STATE*);
	PFN_XInputGetState XInputGetStateSRC = NULL;
	#define XInputGetState XInputGetStateSRC

	typedef DWORD (WINAPI * PFN_XInputGetKeystroke)(DWORD, DWORD, PXINPUT_KEYSTROKE);
	PFN_XInputGetKeystroke XInputGetKeystrokeSRC = NULL;
	#define XInputGetKeystroke XInputGetKeystrokeSRC

	static HMODULE RGFW_XInput_dll = NULL;
	#endif

	u32 RGFW_mouseIconSrc[] = {OCR_NORMAL, OCR_NORMAL, OCR_IBEAM, OCR_CROSS, OCR_HAND, OCR_SIZEWE, OCR_SIZENS, OCR_SIZENWSE, OCR_SIZENESW, OCR_SIZEALL, OCR_NO};

	char* createUTF8FromWideStringWin32(const WCHAR* source);

#define GL_FRONT				0x0404
#define GL_BACK					0x0405
#define GL_LEFT					0x0406
#define GL_RIGHT				0x0407

#if defined(RGFW_OSMESA) && defined(RGFW_LINK_OSMESA)

	typedef void (GLAPIENTRY* PFN_OSMesaDestroyContext)(OSMesaContext);
	typedef i32(GLAPIENTRY* PFN_OSMesaMakeCurrent)(OSMesaContext, void*, int, int, int);
	typedef OSMesaContext(GLAPIENTRY* PFN_OSMesaCreateContext)(GLenum, OSMesaContext);

	PFN_OSMesaMakeCurrent OSMesaMakeCurrentSource;
	PFN_OSMesaCreateContext OSMesaCreateContextSource;
	PFN_OSMesaDestroyContext OSMesaDestroyContextSource;

#define OSMesaCreateContext OSMesaCreateContextSource
#define OSMesaMakeCurrent OSMesaMakeCurrentSource
#define OSMesaDestroyContext OSMesaDestroyContextSource
#endif

	typedef int (*PFN_wglGetSwapIntervalEXT)(void);
	PFN_wglGetSwapIntervalEXT wglGetSwapIntervalEXTSrc = NULL;
#define wglGetSwapIntervalEXT wglGetSwapIntervalEXTSrc


	void* RGFWjoystickApi = NULL;

	/* these two wgl functions need to be preloaded */
	typedef HGLRC (WINAPI *PFNWGLCREATECONTEXTATTRIBSARBPROC)(HDC hdc, HGLRC hglrc, const int *attribList);
	PFNWGLCREATECONTEXTATTRIBSARBPROC wglCreateContextAttribsARB = NULL;

	/* defines for creating ARB attributes */
#define WGL_NUMBER_PIXEL_FORMATS_ARB 0x2000
#define WGL_CONTEXT_MAJOR_VERSION_ARB             0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB             0x2092
#define WGL_DRAW_TO_WINDOW_ARB                    0x2001
#define WGL_ACCELERATION_ARB                      0x2003
#define WGL_NO_ACCELERATION_ARB 0x2025
#define WGL_DOUBLE_BUFFER_ARB                     0x2011
#define WGL_COLOR_BITS_ARB                        0x2014
#define WGL_RED_BITS_ARB 0x2015
#define WGL_RED_SHIFT_ARB 0x2016
#define WGL_GREEN_BITS_ARB 0x2017
#define WGL_GREEN_SHIFT_ARB 0x2018
#define WGL_BLUE_BITS_ARB 0x2019
#define WGL_BLUE_SHIFT_ARB 0x201a
#define WGL_ALPHA_BITS_ARB 0x201b
#define WGL_ALPHA_SHIFT_ARB 0x201c
#define WGL_ACCUM_BITS_ARB 0x201d
#define WGL_ACCUM_RED_BITS_ARB 0x201e
#define WGL_ACCUM_GREEN_BITS_ARB 0x201f
#define WGL_ACCUM_BLUE_BITS_ARB 0x2020
#define WGL_ACCUM_ALPHA_BITS_ARB 0x2021
#define WGL_DEPTH_BITS_ARB 0x2022
#define WGL_AUX_BUFFERS_ARB 0x2024
#define WGL_STEREO_ARB 0x2012
#define WGL_DEPTH_BITS_ARB                        0x2022
#define WGL_STENCIL_BITS_ARB 					  0x2023
#define WGL_FULL_ACCELERATION_ARB                 0x2027
#define WGL_CONTEXT_FLAGS_ARB                     0x2094
#define WGL_CONTEXT_PROFILE_MASK_ARB              0x9126
#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
#define WGL_SAMPLE_BUFFERS_ARB               0x2041
#define WGL_SAMPLES_ARB 0x2042
#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB 0x20a9

#ifndef RGFW_EGL
static HMODULE wglinstance = NULL;
#endif

#ifdef RGFW_WGL_LOAD
	typedef HGLRC(WINAPI* PFN_wglCreateContext)(HDC);
	typedef BOOL(WINAPI* PFN_wglDeleteContext)(HGLRC);
	typedef PROC(WINAPI* PFN_wglGetProcAddress)(LPCSTR);
	typedef BOOL(WINAPI* PFN_wglMakeCurrent)(HDC, HGLRC);
	typedef HDC(WINAPI* PFN_wglGetCurrentDC)();
	typedef HGLRC(WINAPI* PFN_wglGetCurrentContext)();

	PFN_wglCreateContext wglCreateContextSRC;
	PFN_wglDeleteContext wglDeleteContextSRC;
	PFN_wglGetProcAddress wglGetProcAddressSRC;
	PFN_wglMakeCurrent wglMakeCurrentSRC;
	PFN_wglGetCurrentDC wglGetCurrentDCSRC;
	PFN_wglGetCurrentContext wglGetCurrentContextSRC;

	#define wglCreateContext wglCreateContextSRC
	#define wglDeleteContext wglDeleteContextSRC
	#define wglGetProcAddress wglGetProcAddressSRC
	#define wglMakeCurrent wglMakeCurrentSRC

	#define wglGetCurrentDC wglGetCurrentDCSRC
	#define wglGetCurrentContext wglGetCurrentContextSRC
#endif

#ifdef RGFW_OPENGL
	void* RGFW_getProcAddress(const char* procname) { 
		void* proc = (void*) wglGetProcAddress(procname);
		if (proc)
			return proc;

		return (void*) GetProcAddress(wglinstance, procname); 
	}

	typedef HRESULT (APIENTRY* PFNWGLCHOOSEPIXELFORMATARBPROC)(HDC hdc, const int* piAttribIList, const FLOAT* pfAttribFList, UINT nMaxFormats, int* piFormats, UINT* nNumFormats);
	static PFNWGLCHOOSEPIXELFORMATARBPROC wglChoosePixelFormatARB = NULL;
#endif

	RGFW_window RGFW_eventWindow;

	LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
		switch (message) {
		case WM_MOVE:
			RGFW_eventWindow.r.x = LOWORD(lParam);
			RGFW_eventWindow.r.y = HIWORD(lParam);
			RGFW_eventWindow.src.window = hWnd;
			return DefWindowProcA(hWnd, message, wParam, lParam);
		case WM_SIZE:
			RGFW_eventWindow.r.w = LOWORD(lParam);
			RGFW_eventWindow.r.h = HIWORD(lParam);
			RGFW_eventWindow.src.window = hWnd;
			return DefWindowProcA(hWnd, message, wParam, lParam); // Call DefWindowProc after handling
		default:
			return DefWindowProcA(hWnd, message, wParam, lParam);
		}
	}
	
	#ifndef RGFW_NO_DPI
	static HMODULE RGFW_Shcore_dll = NULL;
	typedef HRESULT (WINAPI * PFN_GetDpiForMonitor)(HMONITOR,MONITOR_DPI_TYPE,UINT*,UINT*);
	PFN_GetDpiForMonitor GetDpiForMonitorSRC = NULL;
	#define GetDpiForMonitor GetDpiForMonitorSRC
	#endif

	__declspec(dllimport) u32 __stdcall timeBeginPeriod(u32 uPeriod);
	
	#ifndef RGFW_NO_XINPUT
	void RGFW_loadXInput(void) {
		u32 i;
		static const char* names[] = { 
			"xinput1_4.dll",
			"xinput1_3.dll",
			"xinput9_1_0.dll",
			"xinput1_2.dll",
			"xinput1_1.dll"
		};

		for (i = 0; i < sizeof(names) / sizeof(const char*);  i++) {
			RGFW_XInput_dll = LoadLibraryA(names[i]);

			if (RGFW_XInput_dll) {
				XInputGetStateSRC = (PFN_XInputGetState)(void*)GetProcAddress(RGFW_XInput_dll, "XInputGetState");
			
				if (XInputGetStateSRC == NULL)
					printf("Failed to load XInputGetState");
			}
		}
	}
	#endif

	RGFWDEF void RGFW_init_buffer(RGFW_window* win);
	void RGFW_init_buffer(RGFW_window* win) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
	if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
		RGFW_bufferSize = RGFW_getScreenSize();
	
	BITMAPV5HEADER bi = { 0 };
	ZeroMemory(&bi, sizeof(bi));
	bi.bV5Size = sizeof(bi);
	bi.bV5Width = RGFW_bufferSize.w;
	bi.bV5Height = -((LONG) RGFW_bufferSize.h);
	bi.bV5Planes = 1;
	bi.bV5BitCount = 32;
	bi.bV5Compression = BI_BITFIELDS;
	bi.bV5BlueMask = 0x00ff0000;
	bi.bV5GreenMask = 0x0000ff00;
	bi.bV5RedMask = 0x000000ff;
	bi.bV5AlphaMask = 0xff000000;

	win->src.bitmap = CreateDIBSection(win->src.hdc,
		(BITMAPINFO*) &bi,
		DIB_RGB_COLORS,
		(void**) &win->buffer,
		NULL,
		(DWORD) 0);
	
	win->src.hdcMem = CreateCompatibleDC(win->src.hdc);

	#if defined(RGFW_OSMESA)
	win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
	OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
	#endif
#else
RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
#endif
	}

	void RGFW_window_setDND(RGFW_window* win, b8 allow) {
		DragAcceptFiles(win->src.window, allow);
	}

	void RGFW_releaseCursor(RGFW_window* win) {
		RGFW_UNUSED(win);
		ClipCursor(NULL);
    	const RAWINPUTDEVICE id = { 0x01, 0x02, RIDEV_REMOVE, NULL };
    	RegisterRawInputDevices(&id, 1, sizeof(id));	
	}

	void RGFW_captureCursor(RGFW_window* win, RGFW_rect rect) {
		RGFW_UNUSED(win)
		
		RECT clipRect;
		GetClientRect(win->src.window, &clipRect);
		ClientToScreen(win->src.window, (POINT*) &clipRect.left);
		ClientToScreen(win->src.window, (POINT*) &clipRect.right);
		ClipCursor(&clipRect);

	    const RAWINPUTDEVICE id = { 0x01, 0x02, 0, win->src.window };
		RegisterRawInputDevices(&id, 1, sizeof(id));
	}

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
		#ifndef RGFW_NO_XINPUT
		if (RGFW_XInput_dll == NULL)
			RGFW_loadXInput();
		#endif

		#ifndef RGFW_NO_DPI
		if (RGFW_Shcore_dll == NULL) {
			RGFW_Shcore_dll = LoadLibraryA("shcore.dll");
			GetDpiForMonitorSRC = (PFN_GetDpiForMonitor)(void*)GetProcAddress(RGFW_Shcore_dll, "GetDpiForMonitor");
		}
		#endif

		if (wglinstance == NULL) {
			wglinstance = LoadLibraryA("opengl32.dll");
#ifdef RGFW_WGL_LOAD
			wglCreateContextSRC = (PFN_wglCreateContext) GetProcAddress(wglinstance, "wglCreateContext");
			wglDeleteContextSRC = (PFN_wglDeleteContext) GetProcAddress(wglinstance, "wglDeleteContext");
			wglGetProcAddressSRC = (PFN_wglGetProcAddress) GetProcAddress(wglinstance, "wglGetProcAddress");
			wglMakeCurrentSRC = (PFN_wglMakeCurrent) GetProcAddress(wglinstance, "wglMakeCurrent");
			wglGetCurrentDCSRC = (PFN_wglGetCurrentDC) GetProcAddress(wglinstance, "wglGetCurrentDC");
			wglGetCurrentContextSRC = (PFN_wglGetCurrentContext) GetProcAddress(wglinstance, "wglGetCurrentContext");
#endif
		}
	
		if (name[0] == 0) name = (char*) " ";

		RGFW_eventWindow.r = RGFW_RECT(-1, -1, -1, -1);
		RGFW_eventWindow.src.window = NULL;

		RGFW_window* win = RGFW_window_basic_init(rect, args);

		win->src.maxSize = RGFW_AREA(0, 0);
		win->src.minSize = RGFW_AREA(0, 0);


		HINSTANCE inh = GetModuleHandleA(NULL);

		#ifndef __cplusplus
		WNDCLASSA Class = { 0 }; /*!< Setup the Window class. */
		#else
		WNDCLASSA Class = { };
		#endif

		if (RGFW_className == NULL)
			RGFW_className = (char*)name;

		Class.lpszClassName = RGFW_className;
		Class.hInstance = inh;
		Class.hCursor = LoadCursor(NULL, IDC_ARROW);
		Class.lpfnWndProc = WndProc;

		RegisterClassA(&Class);

		DWORD window_style = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;

		RECT windowRect, clientRect;

		if (!(args & RGFW_NO_BORDER)) {
			window_style |= WS_CAPTION | WS_SYSMENU | WS_BORDER | WS_MINIMIZEBOX;

			if (!(args & RGFW_NO_RESIZE))
				window_style |= WS_SIZEBOX | WS_MAXIMIZEBOX | WS_THICKFRAME;
		} else
			window_style |= WS_POPUP | WS_VISIBLE | WS_SYSMENU | WS_MINIMIZEBOX;

		HWND dummyWin = CreateWindowA(Class.lpszClassName, name, window_style, win->r.x, win->r.y, win->r.w, win->r.h, 0, 0, inh, 0);

		GetWindowRect(dummyWin, &windowRect);
		GetClientRect(dummyWin, &clientRect);

		win->src.hOffset = (windowRect.bottom - windowRect.top) - (clientRect.bottom - clientRect.top);
		win->src.window = CreateWindowA(Class.lpszClassName, name, window_style, win->r.x, win->r.y, win->r.w, win->r.h + win->src.hOffset, 0, 0, inh, 0);

		if (args & RGFW_ALLOW_DND) {
			win->_winArgs |= RGFW_ALLOW_DND;
			RGFW_window_setDND(win, 1);
		}
		win->src.hdc = GetDC(win->src.window);

		if ((args & RGFW_NO_INIT_API) == 0) {
#ifdef RGFW_DIRECTX
		assert(FAILED(CreateDXGIFactory(&__uuidof(IDXGIFactory), (void**) &RGFW_dxInfo.pFactory)) == 0);

		if (FAILED(RGFW_dxInfo.pFactory->lpVtbl->EnumAdapters(RGFW_dxInfo.pFactory, 0, &RGFW_dxInfo.pAdapter))) {
			fprintf(stderr, "Failed to enumerate DXGI adapters\n");
			RGFW_dxInfo.pFactory->lpVtbl->Release(RGFW_dxInfo.pFactory);
			return NULL;
		}

		D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_11_0 };

		if (FAILED(D3D11CreateDevice(RGFW_dxInfo.pAdapter, D3D_DRIVER_TYPE_UNKNOWN, NULL, 0, featureLevels, 1, D3D11_SDK_VERSION, &RGFW_dxInfo.pDevice, NULL, &RGFW_dxInfo.pDeviceContext))) {
			fprintf(stderr, "Failed to create Direct3D device\n");
			RGFW_dxInfo.pAdapter->lpVtbl->Release(RGFW_dxInfo.pAdapter);
			RGFW_dxInfo.pFactory->lpVtbl->Release(RGFW_dxInfo.pFactory);
			return NULL;
		}

		DXGI_SWAP_CHAIN_DESC swapChainDesc = { 0 };
		swapChainDesc.BufferCount = 1;
		swapChainDesc.BufferDesc.Width = win->r.w;
		swapChainDesc.BufferDesc.Height = win->r.h;
		swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		swapChainDesc.OutputWindow = win->src.window;
		swapChainDesc.SampleDesc.Count = 1;
		swapChainDesc.SampleDesc.Quality = 0;
		swapChainDesc.Windowed = TRUE;
		RGFW_dxInfo.pFactory->lpVtbl->CreateSwapChain(RGFW_dxInfo.pFactory, (IUnknown*) RGFW_dxInfo.pDevice, &swapChainDesc, &win->src.swapchain);

		ID3D11Texture2D* pBackBuffer;
		win->src.swapchain->lpVtbl->GetBuffer(win->src.swapchain, 0, &__uuidof(ID3D11Texture2D), (LPVOID*) &pBackBuffer);
		RGFW_dxInfo.pDevice->lpVtbl->CreateRenderTargetView(RGFW_dxInfo.pDevice, (ID3D11Resource*) pBackBuffer, NULL, &win->src.renderTargetView);
		pBackBuffer->lpVtbl->Release(pBackBuffer);

		D3D11_TEXTURE2D_DESC depthStencilDesc = { 0 };
		depthStencilDesc.Width = win->r.w;
		depthStencilDesc.Height = win->r.h;
		depthStencilDesc.MipLevels = 1;
		depthStencilDesc.ArraySize = 1;
		depthStencilDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
		depthStencilDesc.SampleDesc.Count = 1;
		depthStencilDesc.SampleDesc.Quality = 0;
		depthStencilDesc.Usage = D3D11_USAGE_DEFAULT;
		depthStencilDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;

		ID3D11Texture2D* pDepthStencilTexture = NULL;
		RGFW_dxInfo.pDevice->lpVtbl->CreateTexture2D(RGFW_dxInfo.pDevice, &depthStencilDesc, NULL, &pDepthStencilTexture);

		D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc = { 0 };
		depthStencilViewDesc.Format = depthStencilDesc.Format;
		depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
		depthStencilViewDesc.Texture2D.MipSlice = 0;

		RGFW_dxInfo.pDevice->lpVtbl->CreateDepthStencilView(RGFW_dxInfo.pDevice, (ID3D11Resource*) pDepthStencilTexture, &depthStencilViewDesc, &win->src.pDepthStencilView);

		pDepthStencilTexture->lpVtbl->Release(pDepthStencilTexture);

		RGFW_dxInfo.pDeviceContext->lpVtbl->OMSetRenderTargets(RGFW_dxInfo.pDeviceContext, 1, &win->src.renderTargetView, win->src.pDepthStencilView);
#endif

#ifdef RGFW_OPENGL 
		HDC dummy_dc = GetDC(dummyWin);
        
        u32 pfd_flags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL; 
        
        //if (RGFW_DOUBLE_BUFFER)    
             pfd_flags |= PFD_DOUBLEBUFFER;
		
        PIXELFORMATDESCRIPTOR pfd = {
			sizeof(pfd),
			1, /* version */
			pfd_flags,
		    PFD_TYPE_RGBA, /* ipixel type */
			24, /* color bits */
			0, 0, 0, 0, 0, 0,
			8, /* alpha bits */
			0, 0, 0, 0, 0, 0,
			32, /* depth bits */
			8, /* stencil bits */ 
			0,
			PFD_MAIN_PLANE, /* Layer type */
			0, 0, 0, 0
		};

		int pixel_format = ChoosePixelFormat(dummy_dc, &pfd);
		SetPixelFormat(dummy_dc, pixel_format, &pfd);

		HGLRC dummy_context = wglCreateContext(dummy_dc);
		wglMakeCurrent(dummy_dc, dummy_context);

		if (wglChoosePixelFormatARB == NULL) {
			wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC) (void*) wglGetProcAddress("wglCreateContextAttribsARB");
			wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC) (void*)wglGetProcAddress("wglChoosePixelFormatARB");
		}

		wglMakeCurrent(dummy_dc, 0);
		wglDeleteContext(dummy_context);
		ReleaseDC(dummyWin, dummy_dc);
		
		/* try to create the pixel format we want for opengl and then try to create an opengl context for the specified version */ 
		if (wglCreateContextAttribsARB != NULL) {
			PIXELFORMATDESCRIPTOR pfd = {sizeof(pfd), 1, pfd_flags, PFD_TYPE_RGBA, 32, 8, PFD_MAIN_PLANE, 24, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

			if (args & RGFW_OPENGL_SOFTWARE)
				pfd.dwFlags |= PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED;

			if (wglChoosePixelFormatARB != NULL) {
				i32* pixel_format_attribs = (i32*)RGFW_initFormatAttribs(args & RGFW_OPENGL_SOFTWARE);

				int pixel_format;
				UINT num_formats;
				wglChoosePixelFormatARB(win->src.hdc, pixel_format_attribs, 0, 1, &pixel_format, &num_formats);
				if (!num_formats) {
					printf("Failed to create a pixel format for WGL.\n");
				}

				DescribePixelFormat(win->src.hdc, pixel_format, sizeof(pfd), &pfd);
				if (!SetPixelFormat(win->src.hdc, pixel_format, &pfd)) {
					printf("Failed to set the WGL pixel format.\n");
				}
			}
			
			/* create opengl/WGL context for the specified version */ 
			u32 index = 0;
			i32 attribs[40];

			if (RGFW_profile == RGFW_GL_CORE) {
				SET_ATTRIB(WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB);
			}
			else {
				SET_ATTRIB(WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB);
			}
			
			if (RGFW_majorVersion || RGFW_minorVersion) {
				SET_ATTRIB(WGL_CONTEXT_MAJOR_VERSION_ARB, RGFW_majorVersion);
				SET_ATTRIB(WGL_CONTEXT_MINOR_VERSION_ARB, RGFW_minorVersion);
			}

			SET_ATTRIB(0, 0);

			win->src.ctx = (HGLRC)wglCreateContextAttribsARB(win->src.hdc, NULL, attribs);
		} else { /* fall back to a default context (probably opengl 2 or something) */
			fprintf(stderr, "Failed to create an accelerated OpenGL Context\n");

			int pixel_format = ChoosePixelFormat(win->src.hdc, &pfd);
			SetPixelFormat(win->src.hdc, pixel_format, &pfd);

			win->src.ctx = wglCreateContext(win->src.hdc);
		}
		
		wglMakeCurrent(win->src.hdc, win->src.ctx);
#endif
	}

#ifdef RGFW_OSMESA
#ifdef RGFW_LINK_OSM ESA
		OSMesaMakeCurrentSource = (PFN_OSMesaMakeCurrent) GetProcAddress(win->src.hdc, "OSMesaMakeCurrent");
		OSMesaCreateContextSource = (PFN_OSMesaCreateContext) GetProcAddress(win->src.hdc, "OSMesaCreateContext");
		OSMesaDestroyContextSource = (PFN_OSMesaDestroyContext) GetProcAddress(win->src.hdc, "OSMesaDestroyContext");
#endif
#endif

#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0) {
			ReleaseDC(win->src.window, win->src.hdc);
			win->src.hdc = GetDC(win->src.window);
			wglMakeCurrent(win->src.hdc, win->src.ctx);
		}
#endif

		DestroyWindow(dummyWin);
		RGFW_init_buffer(win);


		#ifndef RGFW_NO_MONITOR
		if (args & RGFW_SCALE_TO_MONITOR)
			RGFW_window_scaleToMonitor(win);
		#endif

#ifdef RGFW_EGL
		if ((args & RGFW_NO_INIT_API) == 0)
			RGFW_createOpenGLContext(win);
#endif

		if (args & RGFW_HIDE_MOUSE)
			RGFW_window_showMouse(win, 0);

		if (args & RGFW_TRANSPARENT_WINDOW) {
			SetWindowLong(win->src.window, GWL_EXSTYLE, GetWindowLong(win->src.window, GWL_EXSTYLE) | WS_EX_LAYERED);
			SetLayeredWindowAttributes(win->src.window, RGB(255, 255, 255), RGFW_ALPHA, LWA_ALPHA);
		}

		ShowWindow(win->src.window, SW_SHOWNORMAL);
		
		if (RGFW_root == NULL)
			RGFW_root = win;
		
		#ifdef RGFW_OPENGL
		else 
			wglShareLists(RGFW_root->src.ctx, win->src.ctx);
		#endif

		return win;
	}

	void RGFW_window_setBorder(RGFW_window* win, u8 border) {
		DWORD style = GetWindowLong(win->src.window, GWL_STYLE);

		if (border == 0) {
			SetWindowLong(win->src.window, GWL_STYLE, style & ~WS_OVERLAPPEDWINDOW);
			SetWindowPos(
				win->src.window, HWND_TOP, 0, 0, 0, 0,
				SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE
			);
		}
		else {
			SetWindowLong(win->src.window, GWL_STYLE, style | WS_OVERLAPPEDWINDOW);
			SetWindowPos(
				win->src.window, HWND_TOP, 0, 0, 0, 0,
				SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE
			);
		}
	}


	RGFW_area RGFW_getScreenSize(void) {
		return RGFW_AREA(GetDeviceCaps(GetDC(NULL), HORZRES), GetDeviceCaps(GetDC(NULL), VERTRES));
	}

	RGFW_point RGFW_getGlobalMousePoint(void) {
		POINT p;
		GetCursorPos(&p);

		return RGFW_POINT(p.x, p.y);
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		POINT p;
		GetCursorPos(&p);
		ScreenToClient(win->src.window, &p);

		return RGFW_POINT(p.x, p.y);
	}

	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);
		win->src.minSize = a;
	}

	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);
		win->src.maxSize = a;
	}


	void RGFW_window_minimize(RGFW_window* win) {
		assert(win != NULL);

		ShowWindow(win->src.window, SW_MINIMIZE);
	}

	void RGFW_window_restore(RGFW_window* win) {
		assert(win != NULL);

		ShowWindow(win->src.window, SW_RESTORE);
	}


	u8 RGFW_xinput2RGFW[] = {
		RGFW_JS_A, /* or PS X button */
		RGFW_JS_B, /* or PS circle button */
		RGFW_JS_X, /* or PS square button */
		RGFW_JS_Y, /* or PS triangle button */
		RGFW_JS_R1, /* right bumper */
		RGFW_JS_L1, /* left bump */
		RGFW_JS_L2, /* left trigger*/
		RGFW_JS_R2, /* right trigger */
		0, 0, 0, 0, 0, 0, 0, 0,
		RGFW_JS_UP, /* dpad up */
		RGFW_JS_DOWN, /* dpad down*/
		RGFW_JS_LEFT, /* dpad left */
		RGFW_JS_RIGHT, /* dpad right */
		RGFW_JS_START, /* start button */
		RGFW_JS_SELECT/* select button */
	};

	static i32 RGFW_checkXInput(RGFW_window* win, RGFW_Event* e) {
		RGFW_UNUSED(win)
		
		size_t i;
		for (i = 0; i < 4; i++) {
			XINPUT_KEYSTROKE keystroke;

			if (XInputGetKeystroke == NULL)
				return 0;

			DWORD result = XInputGetKeystroke((DWORD)i, 0, &keystroke);

			if ((keystroke.Flags & XINPUT_KEYSTROKE_REPEAT) == 0 && result != ERROR_EMPTY) {
				if (result != ERROR_SUCCESS)
					return 0;

				if (keystroke.VirtualKey > VK_PAD_BACK)
					continue;

				// RGFW_jsButtonPressed + 1 = RGFW_jsButtonReleased
				e->type = RGFW_jsButtonPressed + !(keystroke.Flags & XINPUT_KEYSTROKE_KEYDOWN);
				e->button = RGFW_xinput2RGFW[keystroke.VirtualKey - 0x5800];
				RGFW_jsPressed[i][e->button] = !(keystroke.Flags & XINPUT_KEYSTROKE_KEYDOWN);

				return 1;
			}

			XINPUT_STATE state;
			if (XInputGetState == NULL ||
				XInputGetState((DWORD) i, &state) == ERROR_DEVICE_NOT_CONNECTED
			)
				return 0;
#define INPUT_DEADZONE  ( 0.24f * (float)(0x7FFF) )  // Default to 24% of the +/- 32767 range.   This is a reasonable default value but can be altered if needed.

			if ((state.Gamepad.sThumbLX < INPUT_DEADZONE &&
				state.Gamepad.sThumbLX > -INPUT_DEADZONE) &&
				(state.Gamepad.sThumbLY < INPUT_DEADZONE &&
					state.Gamepad.sThumbLY > -INPUT_DEADZONE))
			{
				state.Gamepad.sThumbLX = 0;
				state.Gamepad.sThumbLY = 0;
			}

			if ((state.Gamepad.sThumbRX < INPUT_DEADZONE &&
				state.Gamepad.sThumbRX > -INPUT_DEADZONE) &&
				(state.Gamepad.sThumbRY < INPUT_DEADZONE &&
					state.Gamepad.sThumbRY > -INPUT_DEADZONE))
			{
				state.Gamepad.sThumbRX = 0;
				state.Gamepad.sThumbRY = 0;
			}

			e->axisesCount = 2;
			RGFW_point axis1 = RGFW_POINT(state.Gamepad.sThumbLX, state.Gamepad.sThumbLY);
			RGFW_point axis2 = RGFW_POINT(state.Gamepad.sThumbRX, state.Gamepad.sThumbRY);

			if (axis1.x != e->axis[0].x || axis1.y != e->axis[0].y || axis2.x != e->axis[1].x || axis2.y != e->axis[1].y) {
				e->type = RGFW_jsAxisMove;

				e->axis[0] = axis1;
				e->axis[1] = axis2;

				return 1;
			}

			e->axis[0] = axis1;
			e->axis[1] = axis2;
		}

		return 0;
	}

	void RGFW_stopCheckEvents(void) { 
		PostMessageW(RGFW_root->src.window, WM_NULL, 0, 0);
	}

	void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
		RGFW_UNUSED(win);

		MsgWaitForMultipleObjects(0, NULL, FALSE, (DWORD) (waitMS * 1e3), QS_ALLINPUT);
	}

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		assert(win != NULL);

		if (win->event.type == RGFW_quit) {
			return NULL;
		}

		MSG msg;

		if (RGFW_eventWindow.src.window == win->src.window) {
			if (RGFW_eventWindow.r.x != -1) {
				win->r.x = RGFW_eventWindow.r.x;
				win->r.y = RGFW_eventWindow.r.y;
				win->event.type = RGFW_windowMoved;
				RGFW_windowMoveCallback(win, win->r);
			}

			if (RGFW_eventWindow.r.w != -1) {
				win->r.w = RGFW_eventWindow.r.w;
				win->r.h = RGFW_eventWindow.r.h;
				win->event.type = RGFW_windowResized;
				RGFW_windowResizeCallback(win, win->r);
			}

			RGFW_eventWindow.src.window = NULL;
			RGFW_eventWindow.r = RGFW_RECT(-1, -1, -1, -1);

			return &win->event;
		}


		static HDROP drop;
		
		if (win->event.type == RGFW_dnd_init) {
			if (win->event.droppedFilesCount) {
				u32 i;
				for (i = 0; i < win->event.droppedFilesCount; i++)
					win->event.droppedFiles[i][0] = '\0';
			}

			win->event.droppedFilesCount = 0;
			win->event.droppedFilesCount = DragQueryFileW(drop, 0xffffffff, NULL, 0);
			//win->event.droppedFiles = (char**)RGFW_CALLOC(win->event.droppedFilesCount, sizeof(char*));

			u32 i;
			for (i = 0; i < win->event.droppedFilesCount; i++) {
				const UINT length = DragQueryFileW(drop, i, NULL, 0);
				WCHAR* buffer = (WCHAR*) RGFW_CALLOC((size_t) length + 1, sizeof(WCHAR));

				DragQueryFileW(drop, i, buffer, length + 1);
				strncpy(win->event.droppedFiles[i], createUTF8FromWideStringWin32(buffer), RGFW_MAX_PATH);
				win->event.droppedFiles[i][RGFW_MAX_PATH - 1] = '\0';
				RGFW_FREE(buffer);
			}

			DragFinish(drop);
			RGFW_dndCallback(win, win->event.droppedFiles, win->event.droppedFilesCount);
			
			win->event.type = RGFW_dnd;
			return &win->event;
		}

		win->event.inFocus = (GetForegroundWindow() == win->src.window);

		if (RGFW_checkXInput(win, &win->event))
			return &win->event;

		static BYTE keyboardState[256];

		if (PeekMessageA(&msg, win->src.window, 0u, 0u, PM_REMOVE)) {
			switch (msg.message) {
			case WM_CLOSE:
			case WM_QUIT:
				RGFW_windowQuitCallback(win);
				win->event.type = RGFW_quit;
				break;

			case WM_ACTIVATE:
				win->event.inFocus = (LOWORD(msg.wParam) == WA_INACTIVE);

				if (win->event.inFocus) {
					win->event.type = RGFW_focusIn;
					RGFW_focusCallback(win, 1);
				}
				else {
					win->event.type = RGFW_focusOut;
					RGFW_focusCallback(win, 0);
				}

				break;
			
			case WM_PAINT:
				win->event.type = RGFW_windowRefresh;
				RGFW_windowRefreshCallback(win);
				break;
			
			case WM_MOUSELEAVE:
				win->event.type = RGFW_mouseLeave;
				win->_winArgs |= RGFW_MOUSE_LEFT;
				RGFW_mouseNotifyCallBack(win, win->event.point, 0);
				break;
			
			case WM_KEYUP: {
				win->event.keyCode = RGFW_apiKeyCodeToRGFW((u32) msg.wParam);
								
				RGFW_keyboard[win->event.keyCode].prev = RGFW_isPressed(win, win->event.keyCode);

				static char keyName[16];
				
				{
					GetKeyNameTextA((LONG) msg.lParam, keyName, 16);

					if ((!(GetKeyState(VK_CAPITAL) & 0x0001) && !(GetKeyState(VK_SHIFT) & 0x8000)) ||
						((GetKeyState(VK_CAPITAL) & 0x0001) && (GetKeyState(VK_SHIFT) & 0x8000))) {
						CharLowerBuffA(keyName, 16);
					}
				}

				RGFW_updateLockState(win, (GetKeyState(VK_CAPITAL) & 0x0001), (GetKeyState(VK_NUMLOCK) & 0x0001));

				strncpy(win->event.keyName, keyName, 16);

				if (RGFW_isPressed(win, RGFW_ShiftL)) {
					ToAscii((UINT) msg.wParam, MapVirtualKey((UINT) msg.wParam, MAPVK_VK_TO_CHAR),
						keyboardState, (LPWORD) win->event.keyName, 0);
				}

				win->event.type = RGFW_keyReleased;
				RGFW_keyboard[win->event.keyCode].current = 0;
				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 0);
				break;
			}
			case WM_KEYDOWN: {
				win->event.keyCode = RGFW_apiKeyCodeToRGFW((u32) msg.wParam);

				RGFW_keyboard[win->event.keyCode].prev = RGFW_isPressed(win, win->event.keyCode);

				static char keyName[16];
				
				{
					GetKeyNameTextA((LONG) msg.lParam, keyName, 16);

					if ((!(GetKeyState(VK_CAPITAL) & 0x0001) && !(GetKeyState(VK_SHIFT) & 0x8000)) ||
						((GetKeyState(VK_CAPITAL) & 0x0001) && (GetKeyState(VK_SHIFT) & 0x8000))) {
						CharLowerBuffA(keyName, 16);
					}
				}
				
				RGFW_updateLockState(win, (GetKeyState(VK_CAPITAL) & 0x0001), (GetKeyState(VK_NUMLOCK) & 0x0001));

				strncpy(win->event.keyName, keyName, 16);

				if (RGFW_isPressed(win, RGFW_ShiftL) & 0x8000) {
					ToAscii((UINT) msg.wParam, MapVirtualKey((UINT) msg.wParam, MAPVK_VK_TO_CHAR),
						keyboardState, (LPWORD) win->event.keyName, 0);
				}

				win->event.type = RGFW_keyPressed;
				win->event.repeat = RGFW_isPressed(win, win->event.keyCode);
				RGFW_keyboard[win->event.keyCode].current = 1;
				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 1);
				break;
			}

			case WM_MOUSEMOVE:
				if ((win->_winArgs & RGFW_HOLD_MOUSE))
					break;

				win->event.type = RGFW_mousePosChanged;

				win->event.point.x = GET_X_LPARAM(msg.lParam);
				win->event.point.y = GET_Y_LPARAM(msg.lParam);
				
				RGFW_mousePosCallback(win, win->event.point);

				if (win->_winArgs & RGFW_MOUSE_LEFT) {
					win->_winArgs ^= RGFW_MOUSE_LEFT;
					win->event.type = RGFW_mouseEnter;
					RGFW_mouseNotifyCallBack(win, win->event.point, 1);
				}

				break;

			case WM_INPUT: {
				if (!(win->_winArgs & RGFW_HOLD_MOUSE))
					break;
				
				unsigned size = sizeof(RAWINPUT);
				static RAWINPUT raw[sizeof(RAWINPUT)];
				GetRawInputData((HRAWINPUT)msg.lParam, RID_INPUT, raw, &size, sizeof(RAWINPUTHEADER));

				if (raw->header.dwType != RIM_TYPEMOUSE || (raw->data.mouse.lLastX == 0 && raw->data.mouse.lLastY == 0) )
					break;
				
				win->event.type = RGFW_mousePosChanged;
				win->event.point.x = raw->data.mouse.lLastX;
				win->event.point.y = raw->data.mouse.lLastY;
				break;
			}

			case WM_LBUTTONDOWN:
				win->event.button = RGFW_mouseLeft;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;
			case WM_RBUTTONDOWN:
				win->event.button = RGFW_mouseRight;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;
			case WM_MBUTTONDOWN:
				win->event.button = RGFW_mouseMiddle;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case WM_MOUSEWHEEL:
				if (msg.wParam > 0)
					win->event.button = RGFW_mouseScrollUp;
				else
					win->event.button = RGFW_mouseScrollDown;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;

				win->event.scroll = (SHORT) HIWORD(msg.wParam) / (double) WHEEL_DELTA;

				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case WM_LBUTTONUP:
			
				win->event.button = RGFW_mouseLeft;
				win->event.type = RGFW_mouseButtonReleased;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;
			case WM_RBUTTONUP:
				win->event.button = RGFW_mouseRight;
				win->event.type = RGFW_mouseButtonReleased;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;
			case WM_MBUTTONUP:
				win->event.button = RGFW_mouseMiddle;
				win->event.type = RGFW_mouseButtonReleased;

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

				/*
					much of this event is source from glfw
				*/
			case WM_DROPFILES: {				
				win->event.type = RGFW_dnd_init;

				drop = (HDROP) msg.wParam;
				POINT pt;

				/* Move the mouse to the position of the drop */
				DragQueryPoint(drop, &pt);

				win->event.point.x = pt.x;
				win->event.point.y = pt.y;

				RGFW_dndInitCallback(win, win->event.point);
			}
				break;
			case WM_GETMINMAXINFO:
			{
				if (win->src.maxSize.w == 0 && win->src.maxSize.h == 0)
					break;

				MINMAXINFO* mmi = (MINMAXINFO*) msg.lParam;
				mmi->ptMinTrackSize.x = win->src.minSize.w;
				mmi->ptMinTrackSize.y = win->src.minSize.h;
				mmi->ptMaxTrackSize.x = win->src.maxSize.w;
				mmi->ptMaxTrackSize.y = win->src.maxSize.h;
				return 0;
			}
			default:
				win->event.type = 0;
				break;
			}

			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}

		else
			win->event.type = 0;

		if (!IsWindow(win->src.window)) {
			win->event.type = RGFW_quit;
			RGFW_windowQuitCallback(win);
		}

		if (win->event.type)
			return &win->event;
		else
			return NULL;
	}

	u8 RGFW_window_isFullscreen(RGFW_window* win) {
		assert(win != NULL);

		#ifndef __cplusplus
		WINDOWPLACEMENT placement = { 0 };
		#else
		WINDOWPLACEMENT placement = {  };
		#endif
		GetWindowPlacement(win->src.window, &placement);
		return placement.showCmd == SW_SHOWMAXIMIZED;
	}

	u8 RGFW_window_isHidden(RGFW_window* win) {
		assert(win != NULL);

		return IsWindowVisible(win->src.window) == 0 && !RGFW_window_isMinimized(win);
	}

	u8 RGFW_window_isMinimized(RGFW_window* win) {
		assert(win != NULL);

		#ifndef __cplusplus
		WINDOWPLACEMENT placement = { 0 };
		#else
		WINDOWPLACEMENT placement = {  };
		#endif
		GetWindowPlacement(win->src.window, &placement);
		return placement.showCmd == SW_SHOWMINIMIZED;
	}

	u8 RGFW_window_isMaximized(RGFW_window* win) {
		assert(win != NULL);

		#ifndef __cplusplus
		WINDOWPLACEMENT placement = { 0 };
		#else
		WINDOWPLACEMENT placement = {  };
		#endif
		GetWindowPlacement(win->src.window, &placement);
		return placement.showCmd == SW_SHOWMAXIMIZED;
	}

	typedef struct { int iIndex; HMONITOR hMonitor; } RGFW_mInfo;
	BOOL CALLBACK GetMonitorByHandle(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {
		RGFW_UNUSED(hdcMonitor)
		RGFW_UNUSED(lprcMonitor)

		RGFW_mInfo* info = (RGFW_mInfo*) dwData;
		if (info->hMonitor == hMonitor)
			return FALSE;

		info->iIndex++;
		return TRUE;
	}
	
	#ifndef RGFW_NO_MONITOR
	RGFW_monitor win32CreateMonitor(HMONITOR src) {
		RGFW_monitor monitor;
		MONITORINFO monitorInfo;

		monitorInfo.cbSize = sizeof(MONITORINFO);
		GetMonitorInfoA(src, &monitorInfo);

		RGFW_mInfo info;
		info.iIndex = 0;
		info.hMonitor = src;

		/* get the monitor's index */
		if (EnumDisplayMonitors(NULL, NULL, GetMonitorByHandle, (LPARAM) &info)) {
			DISPLAY_DEVICEA dd;
			dd.cb = sizeof(dd);

			/* loop through the devices until you find a device with the monitor's index */
			size_t deviceIndex;
			for (deviceIndex = 0; EnumDisplayDevicesA(0, (DWORD) deviceIndex, &dd, 0); deviceIndex++) {
				char* deviceName = dd.DeviceName;
				if (EnumDisplayDevicesA(deviceName, info.iIndex, &dd, 0)) {
					strncpy(monitor.name, dd.DeviceString, 128); /*!< copy the monitor's name */
					break;
				}
			}
		}

		monitor.rect.x = monitorInfo.rcWork.left;
		monitor.rect.y = monitorInfo.rcWork.top;
		monitor.rect.w = monitorInfo.rcWork.right - monitorInfo.rcWork.left;
		monitor.rect.h = monitorInfo.rcWork.bottom - monitorInfo.rcWork.top;

#ifndef RGFW_NO_DPI
		#ifndef USER_DEFAULT_SCREEN_DPI
		#define USER_DEFAULT_SCREEN_DPI 96
		#endif

		if (GetDpiForMonitor != NULL) {
			u32 x, y;
			GetDpiForMonitor(src, MDT_ANGULAR_DPI, &x, &y);
			monitor.scaleX = (float) (x) / (float) USER_DEFAULT_SCREEN_DPI;
			monitor.scaleY = (float) (y) / (float) USER_DEFAULT_SCREEN_DPI;
		}
#endif

		HDC hdc = GetDC(NULL);
		/* get pixels per inch */
		i32 ppiX = GetDeviceCaps(hdc, LOGPIXELSX);
		i32 ppiY = GetDeviceCaps(hdc, LOGPIXELSY);
		ReleaseDC(NULL, hdc);

		/* Calculate physical height in inches */
		monitor.physW = GetSystemMetrics(SM_CYSCREEN) / (float) ppiX;
		monitor.physH = GetSystemMetrics(SM_CXSCREEN) / (float) ppiY;

		return monitor;
	}
	#endif /* RGFW_NO_MONITOR */
	

	#ifndef RGFW_NO_MONITOR
	RGFW_monitor RGFW_monitors[6];
	BOOL CALLBACK GetMonitorHandle(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {
		RGFW_UNUSED(hdcMonitor)
		RGFW_UNUSED(lprcMonitor)

		RGFW_mInfo* info = (RGFW_mInfo*) dwData;

		if (info->iIndex >= 6)
			return FALSE;

		RGFW_monitors[info->iIndex] = win32CreateMonitor(hMonitor);
		info->iIndex++;

		return TRUE;
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
        #ifdef __cplusplus
        return win32CreateMonitor(MonitorFromPoint({ 0, 0 }, MONITOR_DEFAULTTOPRIMARY));
        #else
		return win32CreateMonitor(MonitorFromPoint((POINT) { 0, 0 }, MONITOR_DEFAULTTOPRIMARY));
	    #endif
    }

	RGFW_monitor* RGFW_getMonitors(void) {
		RGFW_mInfo info;
		info.iIndex = 0;
		while (EnumDisplayMonitors(NULL, NULL, GetMonitorHandle, (LPARAM) &info));

		return RGFW_monitors;
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		HMONITOR src = MonitorFromWindow(win->src.window, MONITOR_DEFAULTTOPRIMARY);
		return win32CreateMonitor(src);
	}
	#endif

	HICON RGFW_loadHandleImage(RGFW_window* win, u8* src, RGFW_area a, BOOL icon) {
		assert(win != NULL);

		u32 i;
		HDC dc;
		HICON handle;
		HBITMAP color, mask;
		BITMAPV5HEADER bi;
		ICONINFO ii;
		u8* target = NULL;
		u8* source = src;

		ZeroMemory(&bi, sizeof(bi));
		bi.bV5Size = sizeof(bi);
		bi.bV5Width = a.w;
		bi.bV5Height = -((LONG) a.h);
		bi.bV5Planes = 1;
		bi.bV5BitCount = 32;
		bi.bV5Compression = BI_BITFIELDS;
		bi.bV5RedMask = 0x00ff0000;
		bi.bV5GreenMask = 0x0000ff00;
		bi.bV5BlueMask = 0x000000ff;
		bi.bV5AlphaMask = 0xff000000;

		dc = GetDC(NULL);
		color = CreateDIBSection(dc,
			(BITMAPINFO*) &bi,
			DIB_RGB_COLORS,
			(void**) &target,
			NULL,
			(DWORD) 0);
		ReleaseDC(NULL, dc);

		mask = CreateBitmap(a.w, a.h, 1, 1, NULL);

		for (i = 0; i < a.w * a.h; i++) {
			target[0] = source[2];
			target[1] = source[1];
			target[2] = source[0];
			target[3] = source[3];
			target += 4;
			source += 4;
		}

		ZeroMemory(&ii, sizeof(ii));
		ii.fIcon = icon;
		ii.xHotspot = 0;
		ii.yHotspot = 0;
		ii.hbmMask = mask;
		ii.hbmColor = color;

		handle = CreateIconIndirect(&ii);

		DeleteObject(color);
		DeleteObject(mask);

		return handle;
	}

	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		assert(win != NULL);
		RGFW_UNUSED(channels)

		HCURSOR cursor = (HCURSOR) RGFW_loadHandleImage(win, image, a, FALSE);
		SetClassLongPtrA(win->src.window, GCLP_HCURSOR, (LPARAM) cursor);
		SetCursor(cursor);
		DestroyCursor(cursor);
	}

	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_ARROW);
	}

	void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
		assert(win != NULL);

		if (mouse > (sizeof(RGFW_mouseIconSrc) / sizeof(u32)))
			return;

		char* icon = MAKEINTRESOURCEA(RGFW_mouseIconSrc[mouse]);

		SetClassLongPtrA(win->src.window, GCLP_HCURSOR, (LPARAM) LoadCursorA(NULL, icon));
		SetCursor(LoadCursorA(NULL, icon));
	}

	void RGFW_window_hide(RGFW_window* win) {
		ShowWindow(win->src.window, SW_HIDE);
	}

	void RGFW_window_show(RGFW_window* win) {
		ShowWindow(win->src.window, SW_RESTORE);
	}

	void RGFW_window_close(RGFW_window* win) {
		assert(win != NULL);

#ifdef RGFW_EGL
		RGFW_closeEGL(win);
#endif

		if (win == RGFW_root) {
#ifdef RGFW_DIRECTX
			RGFW_dxInfo.pDeviceContext->lpVtbl->Release(RGFW_dxInfo.pDeviceContext);
			RGFW_dxInfo.pDevice->lpVtbl->Release(RGFW_dxInfo.pDevice);
			RGFW_dxInfo.pAdapter->lpVtbl->Release(RGFW_dxInfo.pAdapter);
			RGFW_dxInfo.pFactory->lpVtbl->Release(RGFW_dxInfo.pFactory);
#endif
		
			if (RGFW_XInput_dll != NULL) {
				FreeLibrary(RGFW_XInput_dll);
				RGFW_XInput_dll = NULL;
			}

			#ifndef RGFW_NO_DPI
			if (RGFW_Shcore_dll != NULL) {
				FreeLibrary(RGFW_Shcore_dll);
				RGFW_Shcore_dll = NULL;
			}
			#endif

			if (wglinstance != NULL) {
				FreeLibrary(wglinstance);
				wglinstance = NULL;
			}

			RGFW_root = NULL;
		}

#ifdef RGFW_DIRECTX
		win->src.swapchain->lpVtbl->Release(win->src.swapchain);
		win->src.renderTargetView->lpVtbl->Release(win->src.renderTargetView);
		win->src.pDepthStencilView->lpVtbl->Release(win->src.pDepthStencilView);
#endif

#ifdef RGFW_BUFFER
		DeleteDC(win->src.hdcMem);
		DeleteObject(win->src.bitmap);
#endif

#ifdef RGFW_OPENGL
		wglDeleteContext((HGLRC) win->src.ctx); /*!< delete opengl context */
#endif
		DeleteDC(win->src.hdc); /*!< delete device context */
		DestroyWindow(win->src.window); /*!< delete window */

#if defined(RGFW_OSMESA)
		if (win->buffer != NULL)
			RGFW_FREE(win->buffer);
#endif

#ifdef RGFW_ALLOC_DROPFILES
		{
			u32 i;
			for (i = 0; i < RGFW_MAX_DROPS; i++)
				RGFW_FREE(win->event.droppedFiles[i]);


			RGFW_FREE(win->event.droppedFiles);
		}
#endif

		RGFW_FREE(win);
	}

	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);

		win->r.x = v.x;
		win->r.y = v.y;
		SetWindowPos(win->src.window, HWND_TOP, win->r.x, win->r.y, 0, 0, SWP_NOSIZE);
	}

	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		win->r.w = a.w;
		win->r.h = a.h;
		SetWindowPos(win->src.window, HWND_TOP, 0, 0, win->r.w, win->r.h + win->src.hOffset, SWP_NOMOVE);
	}


	void RGFW_window_setName(RGFW_window* win, char* name) {
		assert(win != NULL);

		SetWindowTextA(win->src.window, name);
	}

	/* sourced from GLFW */
	#ifndef RGFW_NO_PASSTHROUGH
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		assert(win != NULL);
		
		COLORREF key = 0;
		BYTE alpha = 0;
		DWORD flags = 0;
		DWORD exStyle = GetWindowLongW(win->src.window, GWL_EXSTYLE);
		
		if (exStyle & WS_EX_LAYERED)
			GetLayeredWindowAttributes(win->src.window, &key, &alpha, &flags);

		if (passthrough)
			exStyle |= (WS_EX_TRANSPARENT | WS_EX_LAYERED);
		else
		{
			exStyle &= ~WS_EX_TRANSPARENT;
			// NOTE: Window opacity also needs the layered window style so do not
			//       remove it if the window is alpha blended
			if (exStyle & WS_EX_LAYERED)
			{
				if (!(flags & LWA_ALPHA))
					exStyle &= ~WS_EX_LAYERED;
			}
		}

		SetWindowLongW(win->src.window, GWL_EXSTYLE, exStyle);

		if (passthrough) {
			SetLayeredWindowAttributes(win->src.window, key, alpha, flags);
		}
	}
	#endif

	/* much of this function is sourced from GLFW */
	void RGFW_window_setIcon(RGFW_window* win, u8* src, RGFW_area a, i32 channels) {
		assert(win != NULL);
		#ifndef RGFW_WIN95
		RGFW_UNUSED(channels)

		HICON handle = RGFW_loadHandleImage(win, src, a, TRUE);

		SetClassLongPtrA(win->src.window, GCLP_HICON, (LPARAM) handle);

		DestroyIcon(handle);
		#else
		RGFW_UNUSED(src)
		RGFW_UNUSED(a)
		RGFW_UNUSED(channels)
		#endif
	}

	char* RGFW_readClipboard(size_t* size) {
		/* Open the clipboard */
		if (OpenClipboard(NULL) == 0)
			return (char*) "";

		/* Get the clipboard data as a Unicode string */
		HANDLE hData = GetClipboardData(CF_UNICODETEXT);
		if (hData == NULL) {
			CloseClipboard();
			return (char*) "";
		}

		wchar_t* wstr = (wchar_t*) GlobalLock(hData);

		char* text;

		{
			setlocale(LC_ALL, "en_US.UTF-8");

			size_t textLen = wcstombs(NULL, wstr, 0);
			if (textLen == 0)
				return (char*) "";

			text = (char*) RGFW_MALLOC((textLen * sizeof(char)) + 1);

			wcstombs(text, wstr, (textLen) +1);

			if (size != NULL)
				*size = textLen + 1;

			text[textLen] = '\0';
		}

		/* Release the clipboard data */
		GlobalUnlock(hData);
		CloseClipboard();

		return text;
	}

	void RGFW_writeClipboard(const char* text, u32 textLen) {
		HANDLE object;
		WCHAR* buffer;

		object = GlobalAlloc(GMEM_MOVEABLE, (1 + textLen) * sizeof(WCHAR));
		if (!object)
			return;

		buffer = (WCHAR*) GlobalLock(object);
		if (!buffer) {
			GlobalFree(object);
			return;
		}

		MultiByteToWideChar(CP_UTF8, 0, text, -1, buffer, textLen);
		GlobalUnlock(object);

		if (!OpenClipboard(RGFW_root->src.window)) {
			GlobalFree(object);
			return;
		}

		EmptyClipboard();
		SetClipboardData(CF_UNICODETEXT, object);
		CloseClipboard();
	}

	u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber) {
		assert(win != NULL);

		RGFW_UNUSED(jsNumber)

		return RGFW_registerJoystickF(win, (char*) "");
	}

	u16 RGFW_registerJoystickF(RGFW_window* win, char* file) {
		assert(win != NULL);
		RGFW_UNUSED(file)

		return RGFW_joystickCount - 1;
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point p) {
		assert(win != NULL);

		SetCursorPos(p.x, p.y);
	}

	#ifdef RGFW_OPENGL
	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		if (win == NULL)
			wglMakeCurrent(NULL, NULL);
		else
			wglMakeCurrent(win->src.hdc, (HGLRC) win->src.ctx);
	}
	#endif

	#ifndef RGFW_EGL
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);
		
		#if defined(RGFW_OPENGL)
		typedef BOOL(APIENTRY* PFNWGLSWAPINTERVALEXTPROC)(int interval);
		static PFNWGLSWAPINTERVALEXTPROC wglSwapIntervalEXT = NULL;
		static void* loadSwapFunc = (void*) 1;

		if (loadSwapFunc == NULL) {
			fprintf(stderr, "wglSwapIntervalEXT not supported\n");
			return;
		}

		if (wglSwapIntervalEXT == NULL) {
			loadSwapFunc = (void*) wglGetProcAddress("wglSwapIntervalEXT");
			wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC) loadSwapFunc;
		}

		if (wglSwapIntervalEXT(swapInterval) == FALSE)
			fprintf(stderr, "Failed to set swap interval\n");
		#else
        RGFW_UNUSED(swapInterval);
        #endif

	}
	#endif

	void RGFW_window_swapBuffers(RGFW_window* win) {
		//assert(win != NULL);
		/* clear the window*/

		if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			#ifdef RGFW_OSMESA
			RGFW_OSMesa_reorganize();
			#endif

			HGDIOBJ oldbmp = SelectObject(win->src.hdcMem, win->src.bitmap);
			BitBlt(win->src.hdc, 0, 0, win->r.w, win->r.h, win->src.hdcMem, 0, 0, SRCCOPY);
			SelectObject(win->src.hdcMem, oldbmp);
#endif
		}

		if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) {
			#ifdef RGFW_EGL
					eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
			#elif defined(RGFW_OPENGL)
					SwapBuffers(win->src.hdc);
			#endif

			#if defined(RGFW_WINDOWS) && defined(RGFW_DIRECTX)
					win->src.swapchain->lpVtbl->Present(win->src.swapchain, 0, 0);
			#endif
		}
	}

	char* createUTF8FromWideStringWin32(const WCHAR* source) {
		char* target;
		i32 size;

		size = WideCharToMultiByte(CP_UTF8, 0, source, -1, NULL, 0, NULL, NULL);
		if (!size) {
			return NULL;
		}

		target = (char*) RGFW_CALLOC(size, 1);

		if (!WideCharToMultiByte(CP_UTF8, 0, source, -1, target, size, NULL, NULL)) {
			RGFW_FREE(target);
			return NULL;
		}

		return target;
	}
	
    static inline LARGE_INTEGER RGFW_win32_initTimer(void) {
		static LARGE_INTEGER frequency = {{0, 0}};
		if (frequency.QuadPart == 0) {
			timeBeginPeriod(1);
			QueryPerformanceFrequency(&frequency);
		}

		return frequency;
	}

	u64 RGFW_getTimeNS(void) {
		LARGE_INTEGER frequency = RGFW_win32_initTimer();

		LARGE_INTEGER counter;
		QueryPerformanceCounter(&counter);

		return (u64) ((counter.QuadPart * 1e9) / frequency.QuadPart);
	}

	u64 RGFW_getTime(void) {
		LARGE_INTEGER frequency = RGFW_win32_initTimer();

		LARGE_INTEGER counter;
		QueryPerformanceCounter(&counter);
		return (u64) (counter.QuadPart / (double) frequency.QuadPart);
	}
	
	void RGFW_sleep(u64 ms) {
		Sleep(ms);
	}

#ifndef RGFW_NO_THREADS
	RGFW_thread RGFW_createThread(RGFW_threadFunc_ptr ptr, void* args) { return CreateThread(NULL, 0, ptr, args, 0, NULL); }
	void RGFW_cancelThread(RGFW_thread thread) { CloseHandle((HANDLE) thread); }
	void RGFW_joinThread(RGFW_thread thread) { WaitForSingleObject((HANDLE) thread, INFINITE); }
	void RGFW_setThreadPriority(RGFW_thread thread, u8 priority) { SetThreadPriority((HANDLE) thread, priority); }
#endif
#endif /* RGFW_WINDOWS */

/*
	End of Windows defines
*/



/* 

	Start of MacOS defines


*/

#if defined(RGFW_MACOS)
	/*
		based on silicon.h
		start of cocoa wrapper
	*/

#include <CoreVideo/CVDisplayLink.h>
#include <ApplicationServices/ApplicationServices.h>
#include <objc/runtime.h>
#include <objc/message.h>
#include <mach/mach_time.h>

	typedef CGRect NSRect;
	typedef CGPoint NSPoint;
	typedef CGSize NSSize;

	typedef void NSBitmapImageRep;
	typedef void NSCursor;
	typedef void NSDraggingInfo;
	typedef void NSWindow;
	typedef void NSApplication;
	typedef void NSScreen;
	typedef void NSEvent;
	typedef void NSString;
	typedef void NSOpenGLContext;
	typedef void NSPasteboard;
	typedef void NSColor;
	typedef void NSArray;
	typedef void NSImageRep;
	typedef void NSImage;
	typedef void NSOpenGLView;


	typedef const char* NSPasteboardType;
	typedef unsigned long NSUInteger;
	typedef long NSInteger;
	typedef NSInteger NSModalResponse;

#ifdef __arm64__
	/* ARM just uses objc_msgSend */
#define abi_objc_msgSend_stret objc_msgSend
#define abi_objc_msgSend_fpret objc_msgSend
#else /* __i386__ */ 
	/* x86 just uses abi_objc_msgSend_fpret and (NSColor *)objc_msgSend_id respectively */
#define abi_objc_msgSend_stret objc_msgSend_stret
#define abi_objc_msgSend_fpret objc_msgSend_fpret
#endif

#define NSAlloc(nsclass) objc_msgSend_id((id)nsclass, sel_registerName("alloc"))
#define objc_msgSend_bool			((BOOL (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void			((void (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void_id		((void (*)(id, SEL, id))objc_msgSend)
#define objc_msgSend_uint			((NSUInteger (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void_bool		((void (*)(id, SEL, BOOL))objc_msgSend)
#define objc_msgSend_bool_void		((BOOL (*)(id, SEL))objc_msgSend)
#define objc_msgSend_void_SEL		((void (*)(id, SEL, SEL))objc_msgSend)
#define objc_msgSend_id				((id (*)(id, SEL))objc_msgSend)
#define objc_msgSend_id_id				((id (*)(id, SEL, id))objc_msgSend)
#define objc_msgSend_id_bool			((BOOL (*)(id, SEL, id))objc_msgSend)
#define objc_msgSend_int ((id (*)(id, SEL, int))objc_msgSend)
#define objc_msgSend_arr ((id (*)(id, SEL, int))objc_msgSend)
#define objc_msgSend_ptr ((id (*)(id, SEL, void*))objc_msgSend)
#define objc_msgSend_class ((id (*)(Class, SEL))objc_msgSend)
#define objc_msgSend_class_char ((id (*)(Class, SEL, char*))objc_msgSend)

	NSApplication* NSApp = NULL;

	void NSRelease(id obj) {
		objc_msgSend_void(obj, sel_registerName("release"));
	}

	#define release NSRelease

	NSString* NSString_stringWithUTF8String(const char* str) {	
		return ((id(*)(id, SEL, const char*))objc_msgSend)
			((id)objc_getClass("NSString"), sel_registerName("stringWithUTF8String:"), str);
	}

	const char* NSString_to_char(NSString* str) {
		return ((const char* (*)(id, SEL)) objc_msgSend) (str, sel_registerName("UTF8String"));
	}

	void si_impl_func_to_SEL_with_name(const char* class_name, const char* register_name, void* function) {
		Class selected_class;

		if (strcmp(class_name, "NSView") == 0) {
			selected_class = objc_getClass("ViewClass");
		} else if (strcmp(class_name, "NSWindow") == 0) {
			selected_class = objc_getClass("WindowClass");
		} else {
			selected_class = objc_getClass(class_name);
		}

		class_addMethod(selected_class, sel_registerName(register_name), (IMP) function, 0);
	}

	/* Header for the array. */
	typedef struct siArrayHeader {
		size_t count;
		/* TODO(EimaMei): Add a `type_width` later on. */
	} siArrayHeader;

	/* Gets the header of the siArray. */
#define SI_ARRAY_HEADER(s) ((siArrayHeader*)s - 1)

	void* si_array_init_reserve(size_t sizeof_element, size_t count) {
		siArrayHeader* ptr = malloc(sizeof(siArrayHeader) + (sizeof_element * count));
		void* array = ptr + sizeof(siArrayHeader);

		siArrayHeader* header = SI_ARRAY_HEADER(array);
		header->count = count;

		return array;
	}

#define si_array_len(array) (SI_ARRAY_HEADER(array)->count)
#define si_func_to_SEL(class_name, function) si_impl_func_to_SEL_with_name(class_name, #function":", function)
	/* Creates an Objective-C method (SEL) from a regular C function with the option to set the register name.*/
#define si_func_to_SEL_with_name(class_name, register_name, function) si_impl_func_to_SEL_with_name(class_name, register_name":", function)
	
	unsigned char* NSBitmapImageRep_bitmapData(NSBitmapImageRep* imageRep) {
		return ((unsigned char* (*)(id, SEL))objc_msgSend)
			(imageRep, sel_registerName("bitmapData"));
	}

#define NS_ENUM(type, name) type name; enum

	typedef NS_ENUM(NSUInteger, NSBitmapFormat) {
		NSBitmapFormatAlphaFirst = 1 << 0,       // 0 means is alpha last (RGBA, CMYKA, etc.)
			NSBitmapFormatAlphaNonpremultiplied = 1 << 1,       // 0 means is premultiplied
			NSBitmapFormatFloatingPointSamples = 1 << 2,  // 0 is integer

			NSBitmapFormatSixteenBitLittleEndian API_AVAILABLE(macos(10.10)) = (1 << 8),
			NSBitmapFormatThirtyTwoBitLittleEndian API_AVAILABLE(macos(10.10)) = (1 << 9),
			NSBitmapFormatSixteenBitBigEndian API_AVAILABLE(macos(10.10)) = (1 << 10),
			NSBitmapFormatThirtyTwoBitBigEndian API_AVAILABLE(macos(10.10)) = (1 << 11)
	};

	NSBitmapImageRep* NSBitmapImageRep_initWithBitmapData(unsigned char** planes, NSInteger width, NSInteger height, NSInteger bps, NSInteger spp, bool alpha, bool isPlanar, const char* colorSpaceName, NSBitmapFormat bitmapFormat, NSInteger rowBytes, NSInteger pixelBits) {
		void* func = sel_registerName("initWithBitmapDataPlanes:pixelsWide:pixelsHigh:bitsPerSample:samplesPerPixel:hasAlpha:isPlanar:colorSpaceName:bitmapFormat:bytesPerRow:bitsPerPixel:");

		return (NSBitmapImageRep*) ((id(*)(id, SEL, unsigned char**, NSInteger, NSInteger, NSInteger, NSInteger, bool, bool, const char*, NSBitmapFormat, NSInteger, NSInteger))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSBitmapImageRep")), func, planes, width, height, bps, spp, alpha, isPlanar, NSString_stringWithUTF8String(colorSpaceName), bitmapFormat, rowBytes, pixelBits);
	}

	NSColor* NSColor_colorWithSRGB(CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha) {
		void* nsclass = objc_getClass("NSColor");
		void* func = sel_registerName("colorWithSRGBRed:green:blue:alpha:");
		return ((id(*)(id, SEL, CGFloat, CGFloat, CGFloat, CGFloat))objc_msgSend)
			(nsclass, func, red, green, blue, alpha);
	}

	NSCursor* NSCursor_initWithImage(NSImage* newImage, NSPoint aPoint) {
		void* func = sel_registerName("initWithImage:hotSpot:");
		void* nsclass = objc_getClass("NSCursor");

		return (NSCursor*) ((id(*)(id, SEL, id, NSPoint))objc_msgSend)
			(NSAlloc(nsclass), func, newImage, aPoint);
	}

	void NSImage_addRepresentation(NSImage* image, NSImageRep* imageRep) {
		void* func = sel_registerName("addRepresentation:");
		objc_msgSend_void_id(image, func, imageRep);
	}

	NSImage* NSImage_initWithSize(NSSize size) {
		void* func = sel_registerName("initWithSize:");
		return ((id(*)(id, SEL, NSSize))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSImage")), func, size);
	}
#define NS_OPENGL_ENUM_DEPRECATED(minVers, maxVers) API_AVAILABLE(macos(minVers))
	typedef NS_ENUM(NSInteger, NSOpenGLContextParameter) {
		NSOpenGLContextParameterSwapInterval           NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 222, /* 1 param.  0 -> Don't sync, 1 -> Sync to vertical retrace     */
			NSOpenGLContextParametectxaceOrder           NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 235, /* 1 param.  1 -> Above Window (default), -1 -> Below Window    */
			NSOpenGLContextParametectxaceOpacity         NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 236, /* 1 param.  1-> Surface is opaque (default), 0 -> non-opaque   */
			NSOpenGLContextParametectxaceBackingSize     NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 304, /* 2 params.  Width/height of surface backing size              */
			NSOpenGLContextParameterReclaimResources       NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 308, /* 0 params.                                                    */
			NSOpenGLContextParameterCurrentRendererID      NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 309, /* 1 param.   Retrieves the current renderer ID                 */
			NSOpenGLContextParameterGPUVertexProcessing    NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 310, /* 1 param.   Currently processing vertices with GPU (get)      */
			NSOpenGLContextParameterGPUFragmentProcessing  NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 311, /* 1 param.   Currently processing fragments with GPU (get)     */
			NSOpenGLContextParameterHasDrawable            NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 314, /* 1 param.   Boolean returned if drawable is attached          */
			NSOpenGLContextParameterMPSwapsInFlight        NS_OPENGL_ENUM_DEPRECATED(10.0, 10.14) = 315, /* 1 param.   Max number of swaps queued by the MP GL engine    */

			NSOpenGLContextParameterSwapRectangle API_DEPRECATED("", macos(10.0, 10.14)) = 200, /* 4 params.  Set or get the swap rectangle {x, y, w, h} */
			NSOpenGLContextParameterSwapRectangleEnable API_DEPRECATED("", macos(10.0, 10.14)) = 201, /* Enable or disable the swap rectangle */
			NSOpenGLContextParameterRasterizationEnable API_DEPRECATED("", macos(10.0, 10.14)) = 221, /* Enable or disable all rasterization */
			NSOpenGLContextParameterStateValidation API_DEPRECATED("", macos(10.0, 10.14)) = 301, /* Validate state for multi-screen functionality */
			NSOpenGLContextParametectxaceSurfaceVolatile API_DEPRECATED("", macos(10.0, 10.14)) = 306, /* 1 param.   Surface volatile state */
	};


	void NSOpenGLContext_setValues(NSOpenGLContext* context, const int* vals, NSOpenGLContextParameter param) {
		void* func = sel_registerName("setValues:forParameter:");
		((void (*)(id, SEL, const int*, NSOpenGLContextParameter))objc_msgSend)
			(context, func, vals, param);
	}

	void* NSOpenGLPixelFormat_initWithAttributes(const uint32_t* attribs) {
		void* func = sel_registerName("initWithAttributes:");
		return (void*) ((id(*)(id, SEL, const uint32_t*))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSOpenGLPixelFormat")), func, attribs);
	}

	NSOpenGLView* NSOpenGLView_initWithFrame(NSRect frameRect, uint32_t* format) {
		void* func = sel_registerName("initWithFrame:pixelFormat:");
		return (NSOpenGLView*) ((id(*)(id, SEL, NSRect, uint32_t*))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSOpenGLView")), func, frameRect, format);
	}

	void NSCursor_performSelector(NSCursor* cursor, void* selector) {
		void* func = sel_registerName("performSelector:");
		objc_msgSend_void_SEL(cursor, func, selector);
	}

	NSPasteboard* NSPasteboard_generalPasteboard(void) {
		return (NSPasteboard*) objc_msgSend_id((id)objc_getClass("NSPasteboard"), sel_registerName("generalPasteboard"));
	}

	NSString** cstrToNSStringArray(char** strs, size_t len) {
		static NSString* nstrs[6];
		size_t i;
		for (i = 0; i < len; i++)
			nstrs[i] = NSString_stringWithUTF8String(strs[i]);

		return nstrs;
	}

	const char* NSPasteboard_stringForType(NSPasteboard* pasteboard, NSPasteboardType dataType) {
		void* func = sel_registerName("stringForType:");
		return (const char*) NSString_to_char(((id(*)(id, SEL, const char*))objc_msgSend)(pasteboard, func, NSString_stringWithUTF8String(dataType)));
	}

	NSArray* c_array_to_NSArray(void* array, size_t len) {
		SEL func = sel_registerName("initWithObjects:count:");
		void* nsclass = objc_getClass("NSArray");
		return ((id (*)(id, SEL, void*, NSUInteger))objc_msgSend)
					(NSAlloc(nsclass), func, array, len);
	}
 
	void NSregisterForDraggedTypes(void* view, NSPasteboardType* newTypes, size_t len) {
		NSString** ntypes = cstrToNSStringArray((char**)newTypes, len);

		NSArray* array = c_array_to_NSArray(ntypes, len);
		objc_msgSend_void_id(view, sel_registerName("registerForDraggedTypes:"), array);
		NSRelease(array);
	}

	NSInteger NSPasteBoard_declareTypes(NSPasteboard* pasteboard, NSPasteboardType* newTypes, size_t len, void* owner) {
		NSString** ntypes = cstrToNSStringArray((char**)newTypes, len);

		void* func = sel_registerName("declareTypes:owner:");

		NSArray* array = c_array_to_NSArray(ntypes, len);

		NSInteger output = ((NSInteger(*)(id, SEL, id, void*))objc_msgSend)
			(pasteboard, func, array, owner);
		NSRelease(array);

		return output;
	}

	bool NSPasteBoard_setString(NSPasteboard* pasteboard, const char* stringToWrite, NSPasteboardType dataType) {
		void* func = sel_registerName("setString:forType:");
		return ((bool (*)(id, SEL, id, NSPasteboardType))objc_msgSend)
			(pasteboard, func, NSString_stringWithUTF8String(stringToWrite), NSString_stringWithUTF8String(dataType));
	}

	void NSRetain(id obj) { objc_msgSend_void(obj, sel_registerName("retain")); }

	typedef enum NSApplicationActivationPolicy {
		NSApplicationActivationPolicyRegular,
		NSApplicationActivationPolicyAccessory,
		NSApplicationActivationPolicyProhibited
	} NSApplicationActivationPolicy;

	typedef NS_ENUM(u32, NSBackingStoreType) {
		NSBackingStoreRetained = 0,
			NSBackingStoreNonretained = 1,
			NSBackingStoreBuffered = 2
	};

	typedef NS_ENUM(u32, NSWindowStyleMask) {
		NSWindowStyleMaskBorderless = 0,
			NSWindowStyleMaskTitled = 1 << 0,
			NSWindowStyleMaskClosable = 1 << 1,
			NSWindowStyleMaskMiniaturizable = 1 << 2,
			NSWindowStyleMaskResizable = 1 << 3,
			NSWindowStyleMaskTexturedBackground = 1 << 8, /* deprecated */
			NSWindowStyleMaskUnifiedTitleAndToolbar = 1 << 12,
			NSWindowStyleMaskFullScreen = 1 << 14,
			NSWindowStyleMaskFullSizeContentView = 1 << 15,
			NSWindowStyleMaskUtilityWindow = 1 << 4,
			NSWindowStyleMaskDocModalWindow = 1 << 6,
			NSWindowStyleMaskNonactivatingPanel = 1 << 7,
			NSWindowStyleMaskHUDWindow = 1 << 13
	};

	NSPasteboardType const NSPasteboardTypeString = "public.utf8-plain-text"; // Replaces NSStringPboardType


	typedef NS_ENUM(i32, NSDragOperation) {
		NSDragOperationNone = 0,
			NSDragOperationCopy = 1,
			NSDragOperationLink = 2,
			NSDragOperationGeneric = 4,
			NSDragOperationPrivate = 8,
			NSDragOperationMove = 16,
			NSDragOperationDelete = 32,
			NSDragOperationEvery = ULONG_MAX,

			//NSDragOperationAll_Obsolete	API_DEPRECATED("", macos(10.0,10.10)) = 15, // Use NSDragOperationEvery
			//NSDragOperationAll API_DEPRECATED("", macos(10.0,10.10)) = NSDragOperationAll_Obsolete, // Use NSDragOperationEvery
	};

	void* NSArray_objectAtIndex(NSArray* array, NSUInteger index) {
		void* func = sel_registerName("objectAtIndex:");
		return ((id(*)(id, SEL, NSUInteger))objc_msgSend)(array, func, index);
	}

	const char** NSPasteboard_readObjectsForClasses(NSPasteboard* pasteboard, Class* classArray, size_t len, void* options) {
		void* func = sel_registerName("readObjectsForClasses:options:");

		NSArray* array = c_array_to_NSArray(classArray, len);

		NSArray* output = (NSArray*) ((id(*)(id, SEL, id, void*))objc_msgSend)
			(pasteboard, func, array, options);

		NSRelease(array);
		NSUInteger count = ((NSUInteger(*)(id, SEL))objc_msgSend)(output, sel_registerName("count"));

		const char** res = si_array_init_reserve(sizeof(const char*), count);

		void* path_func = sel_registerName("path");

		for (NSUInteger i = 0; i < count; i++) {
			void* url = NSArray_objectAtIndex(output, i);
			NSString* url_str = ((id(*)(id, SEL))objc_msgSend)(url, path_func);
			res[i] = NSString_to_char(url_str);
		}

		return res;
	}

	void* NSWindow_contentView(NSWindow* window) {
		void* func = sel_registerName("contentView");
		return objc_msgSend_id(window, func);
	}

	/*
		End of cocoa wrapper
	*/

	char* RGFW_mouseIconSrc[] = {"arrowCursor", "arrowCursor", "IBeamCursor", "crosshairCursor", "pointingHandCursor", "resizeLeftRightCursor", "resizeUpDownCursor", "_windowResizeNorthWestSouthEastCursor", "_windowResizeNorthEastSouthWestCursor", "closedHandCursor", "operationNotAllowedCursor"};

	void* RGFWnsglFramework = NULL;

#ifdef RGFW_OPENGL
	void* RGFW_getProcAddress(const char* procname) {
		if (RGFWnsglFramework == NULL)
			RGFWnsglFramework = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.opengl"));

		CFStringRef symbolName = CFStringCreateWithCString(kCFAllocatorDefault, procname, kCFStringEncodingASCII);

		void* symbol = CFBundleGetFunctionPointerForName(RGFWnsglFramework, symbolName);

		CFRelease(symbolName);

		return symbol;
	}
#endif

	CVReturn displayCallback(CVDisplayLinkRef displayLink, const CVTimeStamp* inNow, const CVTimeStamp* inOutputTime, CVOptionFlags flagsIn, CVOptionFlags* flagsOut, void* displayLinkContext) { 
		RGFW_UNUSED(displayLink) RGFW_UNUSED(inNow) RGFW_UNUSED(inOutputTime) RGFW_UNUSED(flagsIn) RGFW_UNUSED(flagsOut) RGFW_UNUSED(displayLinkContext)
		return kCVReturnSuccess; 
	}

	id NSWindow_delegate(RGFW_window* win) {
		return (id) objc_msgSend_id(win->src.window, sel_registerName("delegate"));
	}

	u32 RGFW_OnClose(void* self) {
		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return true;

		win->event.type = RGFW_quit;
		RGFW_windowQuitCallback(win);

		return true;
	}

	/* NOTE(EimaMei): Fixes the constant clicking when the app is running under a terminal. */
	bool acceptsFirstResponder(void) { return true; }
	bool performKeyEquivalent(NSEvent* event) { RGFW_UNUSED(event); return true; }

	NSDragOperation draggingEntered(id self, SEL sel, id sender) { 
		RGFW_UNUSED(sender); RGFW_UNUSED(self); RGFW_UNUSED(sel);  

		return NSDragOperationCopy; 
	}
	NSDragOperation draggingUpdated(id self, SEL sel, id sender) { 
		RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return 0;
		
		if (!(win->_winArgs & RGFW_ALLOW_DND)) {
			return 0;
		}

		win->event.type = RGFW_dnd_init;
		win->src.dndPassed = 0;

		NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(sender, sel_registerName("draggingLocation"));

		win->event.point = RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));
		RGFW_dndInitCallback(win, win->event.point);

		return NSDragOperationCopy; 
	}
	bool prepareForDragOperation(id self) {
		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return true;
		
		if (!(win->_winArgs & RGFW_ALLOW_DND)) {
			return false;
		}

		return true;
	}

	void RGFW__osxDraggingEnded(id self, SEL sel, id sender) { RGFW_UNUSED(sender); RGFW_UNUSED(self); RGFW_UNUSED(sel);  return; }

	/* NOTE(EimaMei): Usually, you never need 'id self, SEL cmd' for C -> Obj-C methods. This isn't the case. */
	bool performDragOperation(id self, SEL sel, id sender) {
		RGFW_UNUSED(sender); RGFW_UNUSED(self); RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);

        if (win == NULL)
			return false;

		// NSPasteboard* pasteBoard = objc_msgSend_id(sender, sel_registerName("draggingPasteboard"));

        /////////////////////////////
        id pasteBoard = objc_msgSend_id(sender, sel_registerName("draggingPasteboard"));

        // Get the types of data available on the pasteboard
        id types = objc_msgSend_id(pasteBoard, sel_registerName("types"));

        // Get the string type for file URLs
        id fileURLsType = objc_msgSend_class_char(objc_getClass("NSString"), sel_registerName("stringWithUTF8String:"), "NSFilenamesPboardType");

        // Check if the pasteboard contains file URLs
        if (objc_msgSend_id_bool(types, sel_registerName("containsObject:"), fileURLsType) == 0) {
		    #ifdef RGFW_DEBUG
            printf("No files found on the pasteboard.\n");
			#endif

			return 0;
		}

		id fileURLs = objc_msgSend_id_id(pasteBoard, sel_registerName("propertyListForType:"), fileURLsType);
		int count = ((int (*)(id, SEL))objc_msgSend)(fileURLs, sel_registerName("count"));

		if (count == 0)
			return 0;

		for (int i = 0; i < count; i++) {
			id fileURL = objc_msgSend_arr(fileURLs, sel_registerName("objectAtIndex:"), i);
			const char *filePath = ((const char* (*)(id, SEL))objc_msgSend)(fileURL, sel_registerName("UTF8String"));
			// printf("File: %s\n", filePath);
			strncpy(win->event.droppedFiles[i], filePath, RGFW_MAX_PATH);
			win->event.droppedFiles[i][RGFW_MAX_PATH - 1] = '\0';
		}
		win->event.droppedFilesCount = count;

		win->event.type = RGFW_dnd;
		win->src.dndPassed = 0;
		
		NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(sender, sel_registerName("draggingLocation"));
		win->event.point = RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));
		
		RGFW_dndCallback(win, win->event.droppedFiles, win->event.droppedFilesCount);
	
    	return false;
	}

	static void NSMoveToResourceDir(void) {
		/* sourced from glfw */
		char resourcesPath[255];

		CFBundleRef bundle = CFBundleGetMainBundle();
		if (!bundle)
			return;

		CFURLRef resourcesURL = CFBundleCopyResourcesDirectoryURL(bundle);
		CFStringRef last = CFURLCopyLastPathComponent(resourcesURL);

		if (
			CFStringCompare(CFSTR("Resources"), last, 0) != kCFCompareEqualTo ||
			CFURLGetFileSystemRepresentation(resourcesURL, true, (u8*) resourcesPath, 255) == 0
			) {
			CFRelease(last);
			CFRelease(resourcesURL);
			return;
		}

		CFRelease(last);
		CFRelease(resourcesURL);

		chdir(resourcesPath);
	}


	NSSize RGFW__osxWindowResize(void* self, SEL sel, NSSize frameSize) {
		RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return frameSize;
		
		win->r.w = frameSize.width;
		win->r.h = frameSize.height;
		win->event.type = RGFW_windowResized;
		RGFW_windowResizeCallback(win, win->r);
		return frameSize;
	}

	void RGFW__osxWindowMove(void* self, SEL sel) {
		RGFW_UNUSED(sel); 

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return;
		
		NSRect frame = ((NSRect(*)(id, SEL))abi_objc_msgSend_stret)(win->src.window, sel_registerName("frame"));
		win->r.x = (i32) frame.origin.x;
		win->r.y = (i32) frame.origin.y;

		win->event.type = RGFW_windowMoved;
		RGFW_windowMoveCallback(win, win->r);
	}

	void RGFW__osxUpdateLayer(void* self, SEL sel) {
		RGFW_UNUSED(sel);

		RGFW_window* win = NULL;
		object_getInstanceVariable(self, "RGFW_window", (void*)&win);
		if (win == NULL)
			return;
		
		win->event.type = RGFW_windowRefresh;
		RGFW_windowRefreshCallback(win);
	}

	RGFWDEF void RGFW_init_buffer(RGFW_window* win);
	void RGFW_init_buffer(RGFW_window* win) {
		#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
				RGFW_bufferSize = RGFW_getScreenSize();
				
			win->buffer = RGFW_MALLOC(RGFW_bufferSize.w * RGFW_bufferSize.h * 4);

		#ifdef RGFW_OSMESA
				win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
				OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
		#endif
		#else
		RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
		#endif
	}

	NSPasteboardType const NSPasteboardTypeURL = "public.url";
	NSPasteboardType const NSPasteboardTypeFileURL  = "public.file-url";

	RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
		static u8 RGFW_loaded = 0;

		/* NOTE(EimaMei): Why does Apple hate good code? Like wtf, who thought of methods being a great idea???
		Imagine a universe, where MacOS had a proper system API (we would probably have like 20% better performance).
		*/
		si_func_to_SEL_with_name("NSObject", "windowShouldClose", RGFW_OnClose);

		/* NOTE(EimaMei): Fixes the 'Boop' sfx from constantly playing each time you click a key. Only a problem when running in the terminal. */
		si_func_to_SEL("NSWindow", acceptsFirstResponder);
		si_func_to_SEL("NSWindow", performKeyEquivalent);

		// RR Create an autorelease pool
		id pool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
		pool = objc_msgSend_id(pool, sel_registerName("init"));

		if (NSApp == NULL) {
			NSApp = objc_msgSend_id((id)objc_getClass("NSApplication"), sel_registerName("sharedApplication"));

			((void (*)(id, SEL, NSUInteger))objc_msgSend)
				(NSApp, sel_registerName("setActivationPolicy:"), NSApplicationActivationPolicyRegular);
		}

		RGFW_window* win = RGFW_window_basic_init(rect, args);
		
		RGFW_window_setMouseDefault(win);

		NSRect windowRect;
		windowRect.origin.x = win->r.x;
		windowRect.origin.y = win->r.y;
		windowRect.size.width = win->r.w;
		windowRect.size.height = win->r.h;

		NSBackingStoreType macArgs = NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable | NSBackingStoreBuffered | NSWindowStyleMaskTitled;

		if (!(args & RGFW_NO_RESIZE))
			macArgs |= NSWindowStyleMaskResizable;
		if (!(args & RGFW_NO_BORDER))
			macArgs |= NSWindowStyleMaskTitled;
		else
			macArgs = NSWindowStyleMaskBorderless;
		{
			void* nsclass = objc_getClass("NSWindow");
			void* func = sel_registerName("initWithContentRect:styleMask:backing:defer:");

			win->src.window = ((id(*)(id, SEL, NSRect, NSWindowStyleMask, NSBackingStoreType, bool))objc_msgSend)
				(NSAlloc(nsclass), func, windowRect, macArgs, macArgs, false);
		}

		NSString* str = NSString_stringWithUTF8String(name);
		objc_msgSend_void_id(win->src.window, sel_registerName("setTitle:"), str);

#ifdef RGFW_OPENGL
	if ((args & RGFW_NO_INIT_API) == 0) {
		void* attrs = RGFW_initFormatAttribs(args & RGFW_OPENGL_SOFTWARE);
		void* format = NSOpenGLPixelFormat_initWithAttributes(attrs);

		if (format == NULL) {
			printf("Failed to load pixel format for OpenGL\n");

			void* attrs = RGFW_initFormatAttribs(1);
			format = NSOpenGLPixelFormat_initWithAttributes(attrs);
			if (format == NULL)
				printf("and loading software rendering OpenGL failed\n");
			else
				printf("Switching to software rendering\n");
		}
		
		/* the pixel format can be passed directly to opengl context creation to create a context 
			this is because the format also includes information about the opengl version (which may be a bad thing) */
		win->src.view = NSOpenGLView_initWithFrame((NSRect){{0, 0}, {win->r.w, win->r.h}}, format);
		objc_msgSend_void(win->src.view, sel_registerName("prepareOpenGL"));
		win->src.ctx = objc_msgSend_id(win->src.view, sel_registerName("openGLContext"));
	} else
#endif
	{
		NSRect contentRect = (NSRect){{0, 0}, {win->r.w, win->r.h}};
		win->src.view = ((id(*)(id, SEL, NSRect))objc_msgSend)
			(NSAlloc((id)objc_getClass("NSView")), sel_registerName("initWithFrame:"),
				contentRect);
	}

		void* contentView = NSWindow_contentView(win->src.window);
		objc_msgSend_void_bool(contentView, sel_registerName("setWantsLayer:"), true);

		objc_msgSend_void_id(win->src.window, sel_registerName("setContentView:"), win->src.view);

#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0)
			objc_msgSend_void(win->src.ctx, sel_registerName("makeCurrentContext"));
#endif
		if (args & RGFW_TRANSPARENT_WINDOW) {
#ifdef RGFW_OPENGL
		if ((args & RGFW_NO_INIT_API) == 0) {
			i32 opacity = 0;
			#define NSOpenGLCPSurfaceOpacity 236
			NSOpenGLContext_setValues(win->src.ctx, &opacity, NSOpenGLCPSurfaceOpacity);
		}
#endif

			objc_msgSend_void_bool(win->src.window, sel_registerName("setOpaque:"), false);

			objc_msgSend_void_id(win->src.window, sel_registerName("setBackgroundColor:"),
				NSColor_colorWithSRGB(0, 0, 0, 0));
		}

		win->src.display = CGMainDisplayID();
		CVDisplayLinkCreateWithCGDisplay(win->src.display, (CVDisplayLinkRef*)&win->src.displayLink);
		CVDisplayLinkSetOutputCallback(win->src.displayLink, displayCallback, win);
		CVDisplayLinkStart(win->src.displayLink);

		RGFW_init_buffer(win);

		#ifndef RGFW_NO_MONITOR
		if (args & RGFW_SCALE_TO_MONITOR)
			RGFW_window_scaleToMonitor(win);
		#endif

		if (args & RGFW_HIDE_MOUSE)
			RGFW_window_showMouse(win, 0);

		if (args & RGFW_COCOA_MOVE_TO_RESOURCE_DIR)
			NSMoveToResourceDir();

		Class delegateClass = objc_allocateClassPair(objc_getClass("NSObject"), "WindowDelegate", 0);

		class_addIvar(
			delegateClass, "RGFW_window",
			sizeof(RGFW_window*), rint(log2(sizeof(RGFW_window*))),
			"L"
		);

		class_addMethod(delegateClass, sel_registerName("windowWillResize:toSize:"), (IMP) RGFW__osxWindowResize, "{NSSize=ff}@:{NSSize=ff}");
		class_addMethod(delegateClass, sel_registerName("updateLayer:"), (IMP) RGFW__osxUpdateLayer, "");
		class_addMethod(delegateClass, sel_registerName("windowWillMove:"), (IMP) RGFW__osxWindowMove, "");
		class_addMethod(delegateClass, sel_registerName("windowDidMove:"), (IMP) RGFW__osxWindowMove, "");
		class_addMethod(delegateClass, sel_registerName("draggingEntered:"), (IMP)draggingEntered, "l@:@");
		class_addMethod(delegateClass, sel_registerName("draggingUpdated:"), (IMP)draggingUpdated, "l@:@");
		class_addMethod(delegateClass, sel_registerName("draggingExited:"), (IMP)RGFW__osxDraggingEnded, "v@:@");
		class_addMethod(delegateClass, sel_registerName("draggingEnded:"), (IMP)RGFW__osxDraggingEnded, "v@:@");
		class_addMethod(delegateClass, sel_registerName("prepareForDragOperation:"), (IMP)prepareForDragOperation, "B@:@");
		class_addMethod(delegateClass, sel_registerName("performDragOperation:"), (IMP)performDragOperation, "B@:@");

		id delegate = objc_msgSend_id(NSAlloc(delegateClass), sel_registerName("init"));

		object_setInstanceVariable(delegate, "RGFW_window", win);

		objc_msgSend_void_id(win->src.window, sel_registerName("setDelegate:"), delegate);

		if (args & RGFW_ALLOW_DND) {
			win->_winArgs |= RGFW_ALLOW_DND;

			NSPasteboardType types[] = {NSPasteboardTypeURL, NSPasteboardTypeFileURL, NSPasteboardTypeString};
			NSregisterForDraggedTypes(win->src.window, types, 3);
		}

		// Show the window
		objc_msgSend_void_bool(NSApp, sel_registerName("activateIgnoringOtherApps:"), true);
		((id(*)(id, SEL, SEL))objc_msgSend)(win->src.window, sel_registerName("makeKeyAndOrderFront:"), NULL);
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIsVisible:"), true);

		if (!RGFW_loaded) {
			objc_msgSend_void(win->src.window, sel_registerName("makeMainWindow"));

			RGFW_loaded = 1;
		}

		objc_msgSend_void(win->src.window, sel_registerName("makeKeyWindow"));

		objc_msgSend_void(NSApp, sel_registerName("finishLaunching"));

		if (RGFW_root == NULL)
			RGFW_root = win;

		NSRetain(win->src.window);
		NSRetain(NSApp);

		return win;
	}

	void RGFW_window_setBorder(RGFW_window* win, u8 border) {
		NSBackingStoreType storeType = NSWindowStyleMaskBorderless;
		if (!border) {
			storeType = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable;
		}
		if (!(win->_winArgs & RGFW_NO_RESIZE)) {
			storeType |= NSWindowStyleMaskResizable;
		}
		
		((void (*)(id, SEL, NSBackingStoreType))objc_msgSend)(win->src.window, sel_registerName("setStyleMask:"), storeType);

		objc_msgSend_void_bool(win->src.window, sel_registerName("setHasShadow:"), border);
	}

	RGFW_area RGFW_getScreenSize(void) {
		static CGDirectDisplayID display = 0;

		if (display == 0)
			display = CGMainDisplayID();

		return RGFW_AREA(CGDisplayPixelsWide(display), CGDisplayPixelsHigh(display));
	}

	RGFW_point RGFW_getGlobalMousePoint(void) {
		assert(RGFW_root != NULL);

		CGEventRef e = CGEventCreate(NULL);
		CGPoint point = CGEventGetLocation(e);
		CFRelease(e);

		return RGFW_POINT((u32) point.x, (u32) point.y); /*!< the point is loaded during event checks */
	}

	RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
		NSPoint p =  ((NSPoint(*)(id, SEL)) objc_msgSend)(win->src.window, sel_registerName("mouseLocationOutsideOfEventStream"));

		return RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));
	}

	u32 RGFW_keysPressed[10]; /*10 keys at a time*/
	typedef NS_ENUM(u32, NSEventType) {        /* various types of events */
		NSEventTypeLeftMouseDown = 1,
			NSEventTypeLeftMouseUp = 2,
			NSEventTypeRightMouseDown = 3,
			NSEventTypeRightMouseUp = 4,
			NSEventTypeMouseMoved = 5,
			NSEventTypeLeftMouseDragged = 6,
			NSEventTypeRightMouseDragged = 7,
			NSEventTypeMouseEntered = 8,
			NSEventTypeMouseExited = 9,
			NSEventTypeKeyDown = 10,
			NSEventTypeKeyUp = 11,
			NSEventTypeFlagsChanged = 12,
			NSEventTypeAppKitDefined = 13,
			NSEventTypeSystemDefined = 14,
			NSEventTypeApplicationDefined = 15,
			NSEventTypePeriodic = 16,
			NSEventTypeCursorUpdate = 17,
			NSEventTypeScrollWheel = 22,
			NSEventTypeTabletPoint = 23,
			NSEventTypeTabletProximity = 24,
			NSEventTypeOtherMouseDown = 25,
			NSEventTypeOtherMouseUp = 26,
			NSEventTypeOtherMouseDragged = 27,
			/* The following event types are available on some hardware on 10.5.2 and later */
			NSEventTypeGesture API_AVAILABLE(macos(10.5)) = 29,
			NSEventTypeMagnify API_AVAILABLE(macos(10.5)) = 30,
			NSEventTypeSwipe   API_AVAILABLE(macos(10.5)) = 31,
			NSEventTypeRotate  API_AVAILABLE(macos(10.5)) = 18,
			NSEventTypeBeginGesture API_AVAILABLE(macos(10.5)) = 19,
			NSEventTypeEndGesture API_AVAILABLE(macos(10.5)) = 20,

			NSEventTypeSmartMagnify API_AVAILABLE(macos(10.8)) = 32,
			NSEventTypeQuickLook API_AVAILABLE(macos(10.8)) = 33,

			NSEventTypePressure API_AVAILABLE(macos(10.10.3)) = 34,
			NSEventTypeDirectTouch API_AVAILABLE(macos(10.10)) = 37,

			NSEventTypeChangeMode API_AVAILABLE(macos(10.15)) = 38,
	};

	typedef NS_ENUM(unsigned long long, NSEventMask) { /* masks for the types of events */
		NSEventMaskLeftMouseDown = 1ULL << NSEventTypeLeftMouseDown,
			NSEventMaskLeftMouseUp = 1ULL << NSEventTypeLeftMouseUp,
			NSEventMaskRightMouseDown = 1ULL << NSEventTypeRightMouseDown,
			NSEventMaskRightMouseUp = 1ULL << NSEventTypeRightMouseUp,
			NSEventMaskMouseMoved = 1ULL << NSEventTypeMouseMoved,
			NSEventMaskLeftMouseDragged = 1ULL << NSEventTypeLeftMouseDragged,
			NSEventMaskRightMouseDragged = 1ULL << NSEventTypeRightMouseDragged,
			NSEventMaskMouseEntered = 1ULL << NSEventTypeMouseEntered,
			NSEventMaskMouseExited = 1ULL << NSEventTypeMouseExited,
			NSEventMaskKeyDown = 1ULL << NSEventTypeKeyDown,
			NSEventMaskKeyUp = 1ULL << NSEventTypeKeyUp,
			NSEventMaskFlagsChanged = 1ULL << NSEventTypeFlagsChanged,
			NSEventMaskAppKitDefined = 1ULL << NSEventTypeAppKitDefined,
			NSEventMaskSystemDefined = 1ULL << NSEventTypeSystemDefined,
			NSEventMaskApplicationDefined = 1ULL << NSEventTypeApplicationDefined,
			NSEventMaskPeriodic = 1ULL << NSEventTypePeriodic,
			NSEventMaskCursorUpdate = 1ULL << NSEventTypeCursorUpdate,
			NSEventMaskScrollWheel = 1ULL << NSEventTypeScrollWheel,
			NSEventMaskTabletPoint = 1ULL << NSEventTypeTabletPoint,
			NSEventMaskTabletProximity = 1ULL << NSEventTypeTabletProximity,
			NSEventMaskOtherMouseDown = 1ULL << NSEventTypeOtherMouseDown,
			NSEventMaskOtherMouseUp = 1ULL << NSEventTypeOtherMouseUp,
			NSEventMaskOtherMouseDragged = 1ULL << NSEventTypeOtherMouseDragged,
			/* The following event masks are available on some hardware on 10.5.2 and later */
			NSEventMaskGesture API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeGesture,
			NSEventMaskMagnify API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeMagnify,
			NSEventMaskSwipe API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeSwipe,
			NSEventMaskRotate API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeRotate,
			NSEventMaskBeginGesture API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeBeginGesture,
			NSEventMaskEndGesture API_AVAILABLE(macos(10.5)) = 1ULL << NSEventTypeEndGesture,

			/* Note: You can only use these event masks on 64 bit. In other words, you cannot setup a local, nor global, event monitor for these event types on 32 bit. Also, you cannot search the event queue for them (nextEventMatchingMask:...) on 32 bit.
			 */
			NSEventMaskSmartMagnify API_AVAILABLE(macos(10.8)) = 1ULL << NSEventTypeSmartMagnify,
			NSEventMaskPressure API_AVAILABLE(macos(10.10.3)) = 1ULL << NSEventTypePressure,
			NSEventMaskDirectTouch API_AVAILABLE(macos(10.12.2)) = 1ULL << NSEventTypeDirectTouch,

			NSEventMaskChangeMode API_AVAILABLE(macos(10.15)) = 1ULL << NSEventTypeChangeMode,

			NSEventMaskAny = ULONG_MAX,

	};

	typedef enum NSEventModifierFlags {
		NSEventModifierFlagCapsLock = 1 << 16,
		NSEventModifierFlagShift = 1 << 17,
		NSEventModifierFlagControl = 1 << 18,
		NSEventModifierFlagOption = 1 << 19,
		NSEventModifierFlagCommand = 1 << 20,
		NSEventModifierFlagNumericPad = 1 << 21
	} NSEventModifierFlags;

	void RGFW_stopCheckEvents(void) { 
		id eventPool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
        eventPool = objc_msgSend_id(eventPool, sel_registerName("init"));

		NSEvent* e = (NSEvent*) ((id(*)(id, SEL, NSEventType, NSPoint, NSEventModifierFlags, void*, NSInteger, void**, short, NSInteger, NSInteger))objc_msgSend)
			(NSApp, sel_registerName("otherEventWithType:location:modifierFlags:timestamp:windowNumber:context:subtype:data1:data2:"), 
				NSEventTypeApplicationDefined, (NSPoint){0, 0}, 0, 0, 0, NULL, 0, 0, 0);

		((void (*)(id, SEL, id, bool))objc_msgSend)
			(NSApp, sel_registerName("postEvent:atStart:"), e, 1);

		objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
	}

	void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
		RGFW_UNUSED(win);
		
		id eventPool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
        eventPool = objc_msgSend_id(eventPool, sel_registerName("init"));

		void* date = (void*) ((id(*)(Class, SEL, double))objc_msgSend)
					(objc_getClass("NSDate"), sel_registerName("dateWithTimeIntervalSinceNow:"), waitMS);

		NSEvent* e = (NSEvent*) ((id(*)(id, SEL, NSEventMask, void*, NSString*, bool))objc_msgSend)
			(NSApp, sel_registerName("nextEventMatchingMask:untilDate:inMode:dequeue:"), 
				ULONG_MAX, date, NSString_stringWithUTF8String("kCFRunLoopDefaultMode"), true);


		if (e) {
			objc_msgSend_void_id(NSApp, sel_registerName("sendEvent:"), e);
		}

		objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
	}

	RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
		assert(win != NULL);
		
		if (win->event.type == RGFW_quit)
			return NULL;
		
		if ((win->event.type == RGFW_dnd || win->event.type == RGFW_dnd_init) && win->src.dndPassed == 0) {
			win->src.dndPassed = 1;
			return &win->event;
		}

		id eventPool = objc_msgSend_class(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc"));
        eventPool = objc_msgSend_id(eventPool, sel_registerName("init"));

		static void* eventFunc = NULL;
		if (eventFunc == NULL) 
			eventFunc = sel_registerName("nextEventMatchingMask:untilDate:inMode:dequeue:");

		if ((win->event.type == RGFW_windowMoved || win->event.type == RGFW_windowResized || win->event.type == RGFW_windowRefresh) && win->event.keyCode != 120) {
			win->event.keyCode = 120;
			objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
			return &win->event;
		}

		void* date = NULL;

		NSEvent* e = (NSEvent*) ((id(*)(id, SEL, NSEventMask, void*, NSString*, bool))objc_msgSend)
			(NSApp, eventFunc, ULONG_MAX, date, NSString_stringWithUTF8String("kCFRunLoopDefaultMode"), true);

		if (e == NULL) {
			objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
			return NULL;
		}
		
		if (objc_msgSend_id(e, sel_registerName("window")) != win->src.window) {
			((void (*)(id, SEL, id, bool))objc_msgSend)
				(NSApp, sel_registerName("postEvent:atStart:"), e, 0);
						
			objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
			return NULL;
		}

		if (win->event.droppedFilesCount) {
			u32 i;
			for (i = 0; i < win->event.droppedFilesCount; i++)
				win->event.droppedFiles[i][0] = '\0';
		}

		win->event.droppedFilesCount = 0;
		win->event.type = 0;
		
		switch (objc_msgSend_uint(e, sel_registerName("type"))) {
			case NSEventTypeMouseEntered: {
				win->event.type = RGFW_mouseEnter;
				NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(e, sel_registerName("locationInWindow"));

				win->event.point = RGFW_POINT((i32) p.x, (i32) (win->r.h - p.y));
				RGFW_mouseNotifyCallBack(win, win->event.point, 1);
				break;
			}
			
			case NSEventTypeMouseExited:
				win->event.type = RGFW_mouseLeave;
				RGFW_mouseNotifyCallBack(win, win->event.point, 0);
				break;

			case NSEventTypeKeyDown: {
				u32 key = (u16) objc_msgSend_uint(e, sel_registerName("keyCode"));
				win->event.keyCode = RGFW_apiKeyCodeToRGFW(key);
				RGFW_keyboard[win->event.keyCode].prev = RGFW_keyboard[win->event.keyCode].current;

				win->event.type = RGFW_keyPressed;
				char* str = (char*)(const char*) NSString_to_char(objc_msgSend_id(e, sel_registerName("characters")));
				strncpy(win->event.keyName, str, 16);
				win->event.repeat = RGFW_isPressed(win, win->event.keyCode);
				RGFW_keyboard[win->event.keyCode].current = 1;

				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 1);
				break;
			}

			case NSEventTypeKeyUp: {
				u32 key = (u16) objc_msgSend_uint(e, sel_registerName("keyCode"));
				win->event.keyCode = RGFW_apiKeyCodeToRGFW(key);;

				RGFW_keyboard[win->event.keyCode].prev = RGFW_keyboard[win->event.keyCode].current;

				win->event.type = RGFW_keyReleased;
				char* str = (char*)(const char*) NSString_to_char(objc_msgSend_id(e, sel_registerName("characters")));
				strncpy(win->event.keyName, str, 16);

				RGFW_keyboard[win->event.keyCode].current = 0;
				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, 0);
				break;
			}

			case NSEventTypeFlagsChanged: {
				u32 flags = objc_msgSend_uint(e, sel_registerName("modifierFlags"));
				RGFW_updateLockState(win, ((u32)(flags & NSEventModifierFlagCapsLock) % 255), ((flags & NSEventModifierFlagNumericPad) % 255));
				
				u8 i;
				for (i = 0; i < 9; i++)
					RGFW_keyboard[i + RGFW_CapsLock].prev = 0;
				
				for (i = 0; i < 5; i++) {
					u32 shift = (1 << (i + 16));
					u32 key = i + RGFW_CapsLock;

					if ((flags & shift) && !RGFW_wasPressed(win, key)) {
						RGFW_keyboard[key].current = 1;

						if (key != RGFW_CapsLock)
							RGFW_keyboard[key+ 4].current = 1;
						
						win->event.type = RGFW_keyPressed;
						win->event.keyCode = key;
						break;
					} 
					
					if (!(flags & shift) && RGFW_wasPressed(win, key)) {
						RGFW_keyboard[key].current = 0;
						
						if (key != RGFW_CapsLock)
							RGFW_keyboard[key + 4].current = 0;

						win->event.type = RGFW_keyReleased;
						win->event.keyCode = key;
						break;
					}
				}

				RGFW_keyCallback(win, win->event.keyCode, win->event.keyName, win->event.lockState, win->event.type == RGFW_keyPressed);

				break;
			}
			case NSEventTypeLeftMouseDragged:
			case NSEventTypeOtherMouseDragged:
			case NSEventTypeRightMouseDragged:
			case NSEventTypeMouseMoved:
				win->event.type = RGFW_mousePosChanged;
				NSPoint p = ((NSPoint(*)(id, SEL)) objc_msgSend)(e, sel_registerName("locationInWindow"));
				win->event.point = RGFW_POINT((u32) p.x, (u32) (win->r.h - p.y));

				if ((win->_winArgs & RGFW_HOLD_MOUSE)) {
					p.x = ((CGFloat(*)(id, SEL))abi_objc_msgSend_fpret)(e, sel_registerName("deltaX"));
					p.y = ((CGFloat(*)(id, SEL))abi_objc_msgSend_fpret)(e, sel_registerName("deltaY"));
					
					win->event.point = RGFW_POINT((i32)p.x, (i32)p.y);
				}

				RGFW_mousePosCallback(win, win->event.point);
				break;

			case NSEventTypeLeftMouseDown:
				win->event.button = RGFW_mouseLeft;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case NSEventTypeOtherMouseDown:
				win->event.button = RGFW_mouseMiddle;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case NSEventTypeRightMouseDown:
				win->event.button = RGFW_mouseRight;
				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;

			case NSEventTypeLeftMouseUp:
				win->event.button = RGFW_mouseLeft;
				win->event.type = RGFW_mouseButtonReleased;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

			case NSEventTypeOtherMouseUp:
				win->event.button = RGFW_mouseMiddle;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				win->event.type = RGFW_mouseButtonReleased;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

			case NSEventTypeRightMouseUp:
				win->event.button = RGFW_mouseRight;
				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 0;
				win->event.type = RGFW_mouseButtonReleased;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 0);
				break;

			case NSEventTypeScrollWheel: {
				double deltaY = ((CGFloat(*)(id, SEL))abi_objc_msgSend_fpret)(e, sel_registerName("deltaY"));

				if (deltaY > 0) {
					win->event.button = RGFW_mouseScrollUp;
				}
				else if (deltaY < 0) {
					win->event.button = RGFW_mouseScrollDown;
				}

				RGFW_mouseButtons[win->event.button].prev = RGFW_mouseButtons[win->event.button].current;
				RGFW_mouseButtons[win->event.button].current = 1;

				win->event.scroll = deltaY;

				win->event.type = RGFW_mouseButtonPressed;
				RGFW_mouseButtonCallback(win, win->event.button, win->event.scroll, 1);
				break;
			}

			default:
				break;
		}

		objc_msgSend_void_id(NSApp, sel_registerName("sendEvent:"), e);
		((void(*)(id, SEL))objc_msgSend)(NSApp, sel_registerName("updateWindows"));
				
		objc_msgSend_bool_void(eventPool, sel_registerName("drain"));
		return &win->event;
	}


	void RGFW_window_move(RGFW_window* win, RGFW_point v) {
		assert(win != NULL);

		win->r.x = v.x;
		win->r.y = v.y;
		((void(*)(id, SEL, NSRect, bool, bool))objc_msgSend)
			(win->src.window, sel_registerName("setFrame:display:animate:"), (NSRect){{win->r.x, win->r.y}, {win->r.w, win->r.h}}, true, true);
	}

	void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
		assert(win != NULL);

		win->r.w = a.w;
		win->r.h = a.h;
		((void(*)(id, SEL, NSRect, bool, bool))objc_msgSend)
			(win->src.window, sel_registerName("setFrame:display:animate:"), (NSRect){{win->r.x, win->r.y}, {win->r.w, win->r.h}}, true, true);
	}

	void RGFW_window_minimize(RGFW_window* win) {
		assert(win != NULL);

		objc_msgSend_void_SEL(win->src.window, sel_registerName("performMiniaturize:"), NULL);
	}

	void RGFW_window_restore(RGFW_window* win) {
		assert(win != NULL);

		objc_msgSend_void_SEL(win->src.window, sel_registerName("deminiaturize:"), NULL);
	}

	void RGFW_window_setName(RGFW_window* win, char* name) {
		assert(win != NULL);

		NSString* str = NSString_stringWithUTF8String(name);
		objc_msgSend_void_id(win->src.window, sel_registerName("setTitle:"), str);
	}

	#ifndef RGFW_NO_PASSTHROUGH
	void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIgnoresMouseEvents:"), passthrough);
	}
	#endif

	void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) {
		if (a.w == 0 && a.h == 0)
			return;

		((void (*)(id, SEL, NSSize))objc_msgSend)
			(win->src.window, sel_registerName("setMinSize:"), (NSSize){a.w, a.h});
	}

	void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) {
		if (a.w == 0 && a.h == 0)
			return;

		((void (*)(id, SEL, NSSize))objc_msgSend)
			(win->src.window, sel_registerName("setMaxSize:"), (NSSize){a.w, a.h});
	}

	void RGFW_window_setIcon(RGFW_window* win, u8* data, RGFW_area area, i32 channels) {
		assert(win != NULL);

		/* code by EimaMei  */
		// Make a bitmap representation, then copy the loaded image into it.
		void* representation = NSBitmapImageRep_initWithBitmapData(NULL, area.w, area.h, 8, channels, (channels == 4), false, "NSCalibratedRGBColorSpace", 1 << 1, area.w * channels, 8 * channels);
		memcpy(NSBitmapImageRep_bitmapData(representation), data, area.w * area.h * channels);

		// Add ze representation.
		void* dock_image = NSImage_initWithSize((NSSize){area.w, area.h});
		NSImage_addRepresentation(dock_image, (void*) representation);

		// Finally, set the dock image to it.
		objc_msgSend_void_id(NSApp, sel_registerName("setApplicationIconImage:"), dock_image);
		// Free the garbage.
		release(dock_image);
		release(representation);
	}

	NSCursor* NSCursor_arrowStr(char* str) {
		void* nclass = objc_getClass("NSCursor");
		void* func = sel_registerName(str);
		return (NSCursor*) objc_msgSend_id(nclass, func);
	}

	void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) {
		assert(win != NULL);

		if (image == NULL) {
			objc_msgSend_void(NSCursor_arrowStr("arrowCursor"), sel_registerName("set"));
			return;
		}

		/* NOTE(EimaMei): Code by yours truly. */
		// Make a bitmap representation, then copy the loaded image into it.
		void* representation = NSBitmapImageRep_initWithBitmapData(NULL, a.w, a.h, 8, channels, (channels == 4), false, "NSCalibratedRGBColorSpace", 1 << 1, a.w * channels, 8 * channels);
		memcpy(NSBitmapImageRep_bitmapData(representation), image, a.w * a.h * channels);

		// Add ze representation.
		void* cursor_image = NSImage_initWithSize((NSSize){a.w, a.h});
		NSImage_addRepresentation(cursor_image, representation);

		// Finally, set the cursor image.
		void* cursor = NSCursor_initWithImage(cursor_image, (NSPoint){0.0, 0.0});

		objc_msgSend_void(cursor, sel_registerName("set"));

		// Free the garbage.
		release(cursor_image);
		release(representation);
	}

	void RGFW_window_setMouseDefault(RGFW_window* win) {
		RGFW_window_setMouseStandard(win, RGFW_MOUSE_ARROW);
	}

	void RGFW_window_showMouse(RGFW_window* win, i8 show) {
		RGFW_UNUSED(win);

		if (show) {
			CGDisplayShowCursor(kCGDirectMainDisplay);
		}
		else {
			CGDisplayHideCursor(kCGDirectMainDisplay);
		}
	}

	void RGFW_window_setMouseStandard(RGFW_window* win, u8 stdMouses) {
		if (stdMouses > ((sizeof(RGFW_mouseIconSrc)) / (sizeof(char*))))
			return;
		
		char* mouseStr = RGFW_mouseIconSrc[stdMouses];
		void* mouse = NSCursor_arrowStr(mouseStr);

		if (mouse == NULL)
			return;

		RGFW_UNUSED(win);
		CGDisplayShowCursor(kCGDirectMainDisplay);
		objc_msgSend_void(mouse, sel_registerName("set"));
	}
	
	void RGFW_releaseCursor(RGFW_window* win) {
		RGFW_UNUSED(win);
		CGAssociateMouseAndMouseCursorPosition(1);	
	}

	void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) { 
		RGFW_UNUSED(win)

		CGWarpMouseCursorPosition(CGPointMake(r.x + (r.w / 2), r.y + (r.h / 2)));
		CGAssociateMouseAndMouseCursorPosition(0);
	}

	void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) {
		RGFW_UNUSED(win);
		
		CGWarpMouseCursorPosition(CGPointMake(v.x, v.y));		
	}


	void RGFW_window_hide(RGFW_window* win) {
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIsVisible:"), false);
	}

	void RGFW_window_show(RGFW_window* win) {
		((id(*)(id, SEL, SEL))objc_msgSend)(win->src.window, sel_registerName("makeKeyAndOrderFront:"), NULL);
		objc_msgSend_void_bool(win->src.window, sel_registerName("setIsVisible:"), true);
	}

	u8 RGFW_window_isFullscreen(RGFW_window* win) {
		assert(win != NULL);

		NSWindowStyleMask mask = (NSWindowStyleMask) objc_msgSend_uint(win->src.window, sel_registerName("styleMask"));
		return (mask & NSWindowStyleMaskFullScreen) == NSWindowStyleMaskFullScreen;
	}

	u8 RGFW_window_isHidden(RGFW_window* win) {
		assert(win != NULL);

		bool visible = objc_msgSend_bool(win->src.window, sel_registerName("isVisible"));
		return visible == NO && !RGFW_window_isMinimized(win);
	}

	u8 RGFW_window_isMinimized(RGFW_window* win) {
		assert(win != NULL);

		return objc_msgSend_bool(win->src.window, sel_registerName("isMiniaturized")) == YES;
	}

	u8 RGFW_window_isMaximized(RGFW_window* win) {
		assert(win != NULL);

		return objc_msgSend_bool(win->src.window, sel_registerName("isZoomed"));
	}

	static RGFW_monitor RGFW_NSCreateMonitor(CGDirectDisplayID display) {
		RGFW_monitor monitor;

		CGRect bounds = CGDisplayBounds(display);
		monitor.rect = RGFW_RECT((int) bounds.origin.x, (int) bounds.origin.y, (int) bounds.size.width, (int) bounds.size.height);

		CGSize screenSizeMM = CGDisplayScreenSize(display);
		monitor.physW = screenSizeMM.width / 25.4;
		monitor.physH = screenSizeMM.height / 25.4;

		monitor.scaleX = (monitor.rect.w / (screenSizeMM.width)) / 2.6;
		monitor.scaleY = (monitor.rect.h / (screenSizeMM.height)) / 2.6;

		snprintf(monitor.name, 128, "%i %i %i", CGDisplayModelNumber(display), CGDisplayVendorNumber(display), CGDisplaySerialNumber(display));

		return monitor;
	}


	static RGFW_monitor RGFW_monitors[7];

	RGFW_monitor* RGFW_getMonitors(void) {
		static CGDirectDisplayID displays[7];
		u32 count;

		if (CGGetActiveDisplayList(6, displays, &count) != kCGErrorSuccess)
			return NULL;

		for (u32 i = 0; i < count; i++)
			RGFW_monitors[i] = RGFW_NSCreateMonitor(displays[i]);

		return RGFW_monitors;
	}

	RGFW_monitor RGFW_getPrimaryMonitor(void) {
		CGDirectDisplayID primary = CGMainDisplayID();
		return RGFW_NSCreateMonitor(primary);
	}

	RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) {
		return RGFW_NSCreateMonitor(win->src.display);
	}

	char* RGFW_readClipboard(size_t* size) {
		char* clip = (char*)NSPasteboard_stringForType(NSPasteboard_generalPasteboard(), NSPasteboardTypeString);
		
		size_t clip_len = 1;

		if (clip != NULL) {
			clip_len = strlen(clip) + 1; 
		}

		char* str = (char*)RGFW_MALLOC(sizeof(char) * clip_len);
		
		if (clip != NULL) {
			strncpy(str, clip, clip_len);
		}

		str[clip_len] = '\0';
		
		if (size != NULL)
			*size = clip_len;
		return str;
	}

	void RGFW_writeClipboard(const char* text, u32 textLen) {
		RGFW_UNUSED(textLen);

		NSPasteboardType array[] = { NSPasteboardTypeString, NULL };
		NSPasteBoard_declareTypes(NSPasteboard_generalPasteboard(), array, 1, NULL);

		NSPasteBoard_setString(NSPasteboard_generalPasteboard(), text, NSPasteboardTypeString);
	}

	u16 RGFW_registerJoystick(RGFW_window* win, i32 jsNumber) {
		RGFW_UNUSED(jsNumber);

		assert(win != NULL);

		return RGFW_registerJoystickF(win, (char*) "");
	}

	u16 RGFW_registerJoystickF(RGFW_window* win, char* file) {
		RGFW_UNUSED(file);

		assert(win != NULL);

		return RGFW_joystickCount - 1;
	}

	#ifdef RGFW_OPENGL
	void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
		assert(win != NULL);
		objc_msgSend_void(win->src.ctx, sel_registerName("makeCurrentContext"));
	}
	#endif

	#if !defined(RGFW_EGL)
	void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) {
		assert(win != NULL);
		#if defined(RGFW_OPENGL)
		
		NSOpenGLContext_setValues(win->src.ctx, &swapInterval, 222);
		#else
		RGFW_UNUSED(swapInterval);
		#endif
	}
	#endif
	
	// Function to create a CGImageRef from an array of bytes
	CGImageRef createImageFromBytes(unsigned char *buffer, int width, int height)
	{
		// Define color space
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        // Create bitmap context
        CGContextRef context = CGBitmapContextCreate(
        		buffer, 
        		width, height,
        		8,
        		RGFW_bufferSize.w * 4, 
        		colorSpace,
        		kCGImageAlphaPremultipliedLast);
        // Create image from bitmap context
        CGImageRef image = CGBitmapContextCreateImage(context);
        // Release the color space and context
        CGColorSpaceRelease(colorSpace);
        CGContextRelease(context);
                         
        return image;
    }

	void RGFW_window_swapBuffers(RGFW_window* win) {
		assert(win != NULL);
		/* clear the window*/

		if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {
#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
			#ifdef RGFW_OSMESA
			RGFW_OSMesa_reorganize();
			#endif

			void* view = NSWindow_contentView(win->src.window);
			void* layer = objc_msgSend_id(view, sel_registerName("layer"));

			((void(*)(id, SEL, NSRect))objc_msgSend)(layer,
				sel_registerName("setFrame:"),
				(NSRect){{0, 0}, {win->r.w, win->r.h}});

            CGImageRef image = createImageFromBytes(win->buffer, win->r.w, win->r.h);
            // Get the current graphics context
            id graphicsContext = objc_msgSend_class(objc_getClass("NSGraphicsContext"), sel_registerName("currentContext"));
            // Get the CGContext from the current NSGraphicsContext
            id cgContext = objc_msgSend_id(graphicsContext, sel_registerName("graphicsPort"));
			// Draw the image in the context
			NSRect bounds = (NSRect){{0,0}, {win->r.w, win->r.h}};
		    CGContextDrawImage((void*)cgContext, *(CGRect*)&bounds, image);
          	// Flush the graphics context to ensure the drawing is displayed
            objc_msgSend_id(graphicsContext, sel_registerName("flushGraphics"));
            
            objc_msgSend_void_id(layer, sel_registerName("setContents:"), (id)image);
            objc_msgSend_id(layer, sel_registerName("setNeedsDisplay"));
            
            CGImageRelease(image);
#endif
		}

		if (!(win->_winArgs & RGFW_NO_GPU_RENDER)) {
			#ifdef RGFW_EGL
					eglSwapBuffers(win->src.EGL_display, win->src.EGL_surface);
			#elif defined(RGFW_OPENGL)
					objc_msgSend_void(win->src.ctx, sel_registerName("flushBuffer"));
			#endif
		}
	}

	void RGFW_window_close(RGFW_window* win) {
		assert(win != NULL);
		release(win->src.view);

#ifdef RGFW_ALLOC_DROPFILES
		{
			u32 i;
			for (i = 0; i < RGFW_MAX_DROPS; i++)
				RGFW_FREE(win->event.droppedFiles[i]);


			RGFW_FREE(win->event.droppedFiles);
		}
#endif
	
#ifdef RGFW_BUFFER
		release(win->src.bitmap);
		release(win->src.image);
#endif

		CVDisplayLinkStop(win->src.displayLink);
		CVDisplayLinkRelease(win->src.displayLink);

		RGFW_FREE(win);
	}

	u64 RGFW_getTimeNS(void) {
		static mach_timebase_info_data_t timebase_info;
		if (timebase_info.denom == 0) {
			mach_timebase_info(&timebase_info);
		}
		return mach_absolute_time() * timebase_info.numer / timebase_info.denom;
	}

	u64 RGFW_getTime(void) {
		static mach_timebase_info_data_t timebase_info;
		if (timebase_info.denom == 0) {
			mach_timebase_info(&timebase_info);
		}
		return (double) mach_absolute_time() * (double) timebase_info.numer / ((double) timebase_info.denom * 1e9);
	}
#endif /* RGFW_MACOS */

/*
	End of MaOS defines
*/

/*
	WEBASM defines
*/

#ifdef RGFW_WEBASM
RGFW_Event RGFW_events[20];
size_t RGFW_eventLen = 0;

EM_BOOL Emscripten_on_keydown(int eventType, const EmscriptenKeyboardEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);
	
	RGFW_events[RGFW_eventLen].type = RGFW_keyPressed;
	memcpy(RGFW_events[RGFW_eventLen].keyName, e->key, 16);
	RGFW_events[RGFW_eventLen].keyCode = RGFW_apiKeyCodeToRGFW(e->keyCode);
	RGFW_events[RGFW_eventLen].lockState = 0;
	RGFW_eventLen++;

	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].prev = RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current;
	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current = 1;
	RGFW_keyCallback(RGFW_root, RGFW_apiKeyCodeToRGFW(e->keyCode), RGFW_events[RGFW_eventLen].keyName, 0, 1);
	
    return EM_TRUE;
}

EM_BOOL Emscripten_on_keyup(int eventType, const EmscriptenKeyboardEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_keyReleased;
	memcpy(RGFW_events[RGFW_eventLen].keyName, e->key, 16);
	RGFW_events[RGFW_eventLen].keyCode = RGFW_apiKeyCodeToRGFW(e->keyCode);
	RGFW_events[RGFW_eventLen].lockState = 0;
	RGFW_eventLen++;

	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].prev = RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current;
	RGFW_keyboard[RGFW_apiKeyCodeToRGFW(e->keyCode)].current = 0;

	RGFW_keyCallback(RGFW_root, RGFW_apiKeyCodeToRGFW(e->keyCode), RGFW_events[RGFW_eventLen].keyName, 0, 0);

    return EM_TRUE;
}

EM_BOOL Emscripten_on_resize(int eventType, const EmscriptenUiEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_windowResized;
	RGFW_eventLen++;

	RGFW_windowResizeCallback(RGFW_root, RGFW_RECT(0, 0, e->windowInnerWidth, e->windowInnerHeight));
    return EM_TRUE;
}

EM_BOOL Emscripten_on_fullscreenchange(int eventType, const EmscriptenFullscreenChangeEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_windowResized;
	RGFW_eventLen++;

	RGFW_root->r = RGFW_RECT(0, 0, e->elementWidth, e->elementHeight);
	RGFW_windowResizeCallback(RGFW_root, RGFW_root->r);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_focusin(int eventType, const EmscriptenFocusEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData); RGFW_UNUSED(e);

	RGFW_events[RGFW_eventLen].type = RGFW_focusIn;
	RGFW_eventLen++;

	RGFW_root->event.inFocus = 1;
	RGFW_focusCallback(RGFW_root, 1);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_focusout(int eventType, const EmscriptenFocusEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData); RGFW_UNUSED(e);

	RGFW_events[RGFW_eventLen].type = RGFW_focusOut;
	RGFW_eventLen++;

	RGFW_root->event.inFocus = 0;
	RGFW_focusCallback(RGFW_root, 0);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_mousemove(int eventType, const EmscriptenMouseEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mousePosChanged;

	if ((RGFW_root->_winArgs & RGFW_HOLD_MOUSE)) {
		RGFW_point p = RGFW_POINT(e->movementX, e->movementY);
		RGFW_events[RGFW_eventLen].point = p;
	}
	else
		RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->targetX, e->targetY);
	RGFW_eventLen++;
	
	RGFW_mousePosCallback(RGFW_root, RGFW_events[RGFW_eventLen].point);
    return EM_TRUE;
}

EM_BOOL Emscripten_on_mousedown(int eventType, const EmscriptenMouseEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonPressed;
	RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->targetX, e->targetY);
	RGFW_events[RGFW_eventLen].button = e->button + 1; 
	RGFW_events[RGFW_eventLen].scroll = 0;

	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 1;

	RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 1);
	RGFW_eventLen++;
	
    return EM_TRUE;
}

EM_BOOL Emscripten_on_mouseup(int eventType, const EmscriptenMouseEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonReleased;
	RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->targetX, e->targetY);
	RGFW_events[RGFW_eventLen].button = e->button + 1; 
	RGFW_events[RGFW_eventLen].scroll = 0;

	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 0;

	RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 0);
	RGFW_eventLen++;
    return EM_TRUE;
}

EM_BOOL Emscripten_on_wheel(int eventType, const EmscriptenWheelEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonPressed;
	RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->mouse.targetX, e->mouse.targetY);
	RGFW_events[RGFW_eventLen].button = RGFW_mouseScrollUp + (e->deltaY < 0); 
	RGFW_events[RGFW_eventLen].scroll = e->deltaY;

	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 1;

	RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 1);
	RGFW_eventLen++;

    return EM_TRUE;
}

EM_BOOL Emscripten_on_touchstart(int eventType, const EmscriptenTouchEvent* e, void* userData) { 
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

    size_t i; 
    for (i = 0; i < (size_t)e->numTouches; i++) { 
	    RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonPressed;
	    RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->touches[i].targetX, e->touches[i].targetY);
	    RGFW_events[RGFW_eventLen].button = 1; 
	    RGFW_events[RGFW_eventLen].scroll = 0;


	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 1;

        RGFW_mousePosCallback(RGFW_root, RGFW_events[RGFW_eventLen].point);

	    RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 1);
    	RGFW_eventLen++;
    }

	return EM_TRUE;
}
EM_BOOL Emscripten_on_touchmove(int eventType, const EmscriptenTouchEvent* e, void* userData) { 
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);
    
    size_t i; 
    for (i = 0; i < (size_t)e->numTouches; i++) { 
   	    RGFW_events[RGFW_eventLen].type = RGFW_mousePosChanged;
	    RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->touches[i].targetX, e->touches[i].targetY);

        RGFW_mousePosCallback(RGFW_root, RGFW_events[RGFW_eventLen].point);
	    RGFW_eventLen++;
    }
    return EM_TRUE;
}

EM_BOOL Emscripten_on_touchend(int eventType, const EmscriptenTouchEvent* e, void* userData) {
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);
	
    size_t i; 
    for (i = 0; i < (size_t)e->numTouches; i++) { 
	    RGFW_events[RGFW_eventLen].type = RGFW_mouseButtonReleased;
	    RGFW_events[RGFW_eventLen].point = RGFW_POINT(e->touches[i].targetX, e->touches[i].targetY);
	    RGFW_events[RGFW_eventLen].button = 1; 
	    RGFW_events[RGFW_eventLen].scroll = 0;

	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].prev = RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current;	
	    RGFW_mouseButtons[RGFW_events[RGFW_eventLen].button].current = 0;
        
	    RGFW_mouseButtonCallback(RGFW_root, RGFW_events[RGFW_eventLen].button, RGFW_events[RGFW_eventLen].scroll, 0);
	    RGFW_eventLen++;
    }
	return EM_TRUE;
}

EM_BOOL Emscripten_on_touchcancel(int eventType, const EmscriptenTouchEvent* e, void* userData) { RGFW_UNUSED(eventType); RGFW_UNUSED(userData); RGFW_UNUSED(e); return EM_TRUE; }

EM_BOOL Emscripten_on_gamepad(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData) {	
	RGFW_UNUSED(eventType); RGFW_UNUSED(userData);

	if (gamepadEvent->index >= 4)
		return 0;

	RGFW_joysticks[gamepadEvent->index] = gamepadEvent->connected;

    return 1; // The event was consumed by the callback handler
}

void EMSCRIPTEN_KEEPALIVE Emscripten_onDrop(size_t count) {
	if (!(RGFW_root->_winArgs & RGFW_ALLOW_DND))
		return;

	RGFW_events[RGFW_eventLen].droppedFilesCount = count;	
	RGFW_dndCallback(RGFW_root, RGFW_events[RGFW_eventLen].droppedFiles, count);
	RGFW_eventLen++;
}

b8 RGFW_stopCheckEvents_bool = RGFW_FALSE;
void RGFW_stopCheckEvents(void) { 
	RGFW_stopCheckEvents_bool = RGFW_TRUE;
}

void RGFW_window_eventWait(RGFW_window* win, i32 waitMS) {
	RGFW_UNUSED(win);

	if (waitMS == 0)
		return;
	
	u32 start = (u32)(((u64)RGFW_getTimeNS()) / 1e+6);

	while ((RGFW_eventLen == 0) && RGFW_stopCheckEvents_bool == RGFW_FALSE && 
		(waitMS < 0 || (RGFW_getTimeNS() / 1e+6) - start < waitMS)
	) {
		emscripten_sleep(0);
	}
	
	RGFW_stopCheckEvents_bool = RGFW_FALSE;
}

RGFWDEF void RGFW_init_buffer(RGFW_window* win);
void RGFW_init_buffer(RGFW_window* win) {
	#if defined(RGFW_OSMESA) || defined(RGFW_BUFFER)
		if (RGFW_bufferSize.w == 0 && RGFW_bufferSize.h == 0)
			RGFW_bufferSize = RGFW_getScreenSize();
		
		win->buffer = RGFW_MALLOC(RGFW_bufferSize.w * RGFW_bufferSize.h * 4);
	#ifdef RGFW_OSMESA
			win->src.ctx = OSMesaCreateContext(OSMESA_RGBA, NULL);
			OSMesaMakeCurrent(win->src.ctx, win->buffer, GL_UNSIGNED_BYTE, win->r.w, win->r.h);
	#endif
	#else
	RGFW_UNUSED(win); /*!< if buffer rendering is not being used */
	#endif
}

void EMSCRIPTEN_KEEPALIVE RGFW_makeSetValue(size_t index, char* file) { 
	/* This seems like a terrible idea, don't replicate this unless you hate yourself or the OS */
	/* TODO: find a better way to do this, 
		strcpy doesn't seem to work, maybe because of asyncio
	*/

	RGFW_events[RGFW_eventLen].type = RGFW_dnd;
	char** arr = (char**)&RGFW_events[RGFW_eventLen].droppedFiles[index];
	*arr = file;
}

#include <sys/stat.h>
#include <sys/types.h>
#include <errno.h>

void EMSCRIPTEN_KEEPALIVE RGFW_mkdir(char* name) { mkdir(name, 0755); }

void EMSCRIPTEN_KEEPALIVE RGFW_writeFile(const char *path, const char *data, size_t len) {
    FILE* file = fopen(path, "w+");
	if (file == NULL)
		return;

    fwrite(data, sizeof(char), len, file);
    fclose(file);
}

RGFW_window* RGFW_createWindow(const char* name, RGFW_rect rect, u16 args) {
	RGFW_UNUSED(name) 

	RGFW_UNUSED(RGFW_initFormatAttribs);
	
    RGFW_window* win = RGFW_window_basic_init(rect, args);

    EmscriptenWebGLContextAttributes attrs;
    attrs.alpha = EM_TRUE;
    attrs.depth = EM_TRUE;
	attrs.alpha = EM_TRUE;
    attrs.stencil = RGFW_STENCIL;
    attrs.antialias = RGFW_SAMPLES;
    attrs.premultipliedAlpha = EM_TRUE;
    attrs.preserveDrawingBuffer = EM_FALSE;
	
    if (RGFW_DOUBLE_BUFFER == 0)
        attrs.renderViaOffscreenBackBuffer = 0;
    else
        attrs.renderViaOffscreenBackBuffer = RGFW_AUX_BUFFERS;
    
    attrs.failIfMajorPerformanceCaveat = EM_FALSE;
	attrs.majorVersion = (RGFW_majorVersion == 0) ? 1 : RGFW_majorVersion;
	attrs.minorVersion = RGFW_minorVersion;
	
    attrs.enableExtensionsByDefault = EM_TRUE;
    attrs.explicitSwapControl = EM_TRUE;

    emscripten_webgl_init_context_attributes(&attrs);
    win->src.ctx = emscripten_webgl_create_context("#canvas", &attrs);
    emscripten_webgl_make_context_current(win->src.ctx);

	#ifdef LEGACY_GL_EMULATION
	EM_ASM("Module.useWebGL = true; GLImmediate.init();");	
	#endif

	emscripten_set_canvas_element_size("#canvas", rect.w, rect.h);
	emscripten_set_window_title(name);

	/* load callbacks */
    emscripten_set_keydown_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_keydown);
    emscripten_set_keyup_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_keyup);
    emscripten_set_resize_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_resize);
    emscripten_set_fullscreenchange_callback(EMSCRIPTEN_EVENT_TARGET_DOCUMENT, NULL, EM_FALSE, Emscripten_on_fullscreenchange);
    emscripten_set_mousemove_callback("#canvas", NULL, EM_FALSE, Emscripten_on_mousemove);
    emscripten_set_touchstart_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchstart);
    emscripten_set_touchend_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchend);
    emscripten_set_touchmove_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchmove);
    emscripten_set_touchcancel_callback("#canvas", NULL, EM_FALSE, Emscripten_on_touchcancel);
    emscripten_set_mousedown_callback("#canvas", NULL, EM_FALSE, Emscripten_on_mousedown);
    emscripten_set_mouseup_callback("#canvas", NULL, EM_FALSE, Emscripten_on_mouseup);
    emscripten_set_wheel_callback("#canvas", NULL, EM_FALSE, Emscripten_on_wheel);
    emscripten_set_focusin_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_focusin);
    emscripten_set_focusout_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, EM_FALSE, Emscripten_on_focusout);
	emscripten_set_gamepadconnected_callback(NULL, 1, Emscripten_on_gamepad);
	emscripten_set_gamepaddisconnected_callback(NULL, 1, Emscripten_on_gamepad);
	
	if (args & RGFW_ALLOW_DND)  {
		win->_winArgs |= RGFW_ALLOW_DND;
	}

    EM_ASM({
		var canvas = document.getElementById('canvas');
        canvas.addEventListener('drop', function(e) {
            e.preventDefault();
            if (e.dataTransfer.file < 0)
				return;

			var filenamesArray = [];
			var count = e.dataTransfer.files.length;

			/* Read and save the files to emscripten's files */
			var drop_dir = '.rgfw_dropped_files';
			Module._RGFW_mkdir(drop_dir);

			for (var i = 0; i < count; i++) {
				var file = e.dataTransfer.files[i];

				var path = '/' + drop_dir + '/' + file.name.replace("//", '_');
				var reader = new FileReader();
				
				reader.onloadend = (e) => {
					if (reader.readyState != 2) {
						out('failed to read dropped file: '+file.name+': '+reader.error);
					}
					else {
						var data = e.target.result;
						
						_RGFW_writeFile(path, new Uint8Array(data), file.size);
					}
				};

				reader.readAsArrayBuffer(file);		
				// This works weird on modern opengl
				var filename = stringToNewUTF8(path);

				filenamesArray.push(filename);
				
				Module._RGFW_makeSetValue(i, filename);
			}
			
			Module._Emscripten_onDrop(count);
			
			for (var i = 0; i < count; ++i) {
				_free(filenamesArray[i]);
			}
        }, true);

        canvas.addEventListener('dragover', function(e) { e.preventDefault(); return false; }, true);
    });

	RGFW_init_buffer(win);
	glViewport(0, 0, rect.w, rect.h);
	
	RGFW_root = win; 

	if (args & RGFW_HIDE_MOUSE) {
		RGFW_window_showMouse(win, 0);
	}

	if (args & RGFW_FULLSCREEN) {
		RGFW_window_resize(win, RGFW_getScreenSize());
	}

    return win;
}

RGFW_Event* RGFW_window_checkEvent(RGFW_window* win) {
	static u8 index = 0;
	
	if (index == 0) 
		RGFW_resetKey();

	/* check gamepads */
    for (int i = 0; (i < emscripten_get_num_gamepads()) && (i < 4); i++) {
		if (RGFW_joysticks[i] == 0)
			continue;;
		
        EmscriptenGamepadEvent gamepadState;

        if (emscripten_get_gamepad_status(i, &gamepadState) != EMSCRIPTEN_RESULT_SUCCESS)
			break;

		// Register buttons data for every connected gamepad
		for (int j = 0; (j < gamepadState.numButtons) && (j < 16); j++) {
			u32 map[] = {
				RGFW_JS_A, RGFW_JS_X, RGFW_JS_B, RGFW_JS_Y,
				RGFW_JS_L1, RGFW_JS_R1, RGFW_JS_L2, RGFW_JS_R2,
				RGFW_JS_SELECT, RGFW_JS_START,
				0, 0,
				RGFW_JS_UP, RGFW_JS_DOWN, RGFW_JS_LEFT, RGFW_JS_RIGHT
			};

			u32 button = map[j]; 
			if (RGFW_jsPressed[i][button] != gamepadState.digitalButton[j]) {
				win->event.type = RGFW_jsButtonPressed;
				win->event.joystick = i;
				win->event.button = map[j];
				return &win->event;
			}

			RGFW_jsPressed[i][button] = gamepadState.digitalButton[j];
		}

		for (int j = 0; (j < gamepadState.numAxes) && (j < 4); j += 2) {
			win->event.axisesCount = gamepadState.numAxes;
			if (win->event.axis[j].x != gamepadState.axis[j] || 
				win->event.axis[j].y != gamepadState.axis[j + 1]
			) {
				win->event.axis[j].x = gamepadState.axis[j];
				win->event.axis[j].y = gamepadState.axis[j + 1];
				win->event.type = RGFW_jsAxisMove;
				win->event.joystick = i;
				return &win->event;
			}
		}
    }

	/* check queued events */
	if (RGFW_eventLen == 0)
		return NULL;
	
	RGFW_events[index].frameTime = win->event.frameTime;
	RGFW_events[index].frameTime2 = win->event.frameTime2;
	RGFW_events[index].inFocus = win->event.inFocus;

	win->event = RGFW_events[index];

	RGFW_eventLen--;

	if (RGFW_eventLen)
		index++;
	else
		index = 0;

	return &win->event;
}

void RGFW_window_resize(RGFW_window* win, RGFW_area a) {
	RGFW_UNUSED(win)
	emscripten_set_canvas_element_size("#canvas", a.w, a.h);
}

/* NOTE: I don't know if this is possible */
void RGFW_window_moveMouse(RGFW_window* win, RGFW_point v) { RGFW_UNUSED(win); RGFW_UNUSED(v); }
/* this one might be possible but it looks iffy */
void RGFW_window_setMouse(RGFW_window* win, u8* image, RGFW_area a, i32 channels) { RGFW_UNUSED(win); RGFW_UNUSED(channels) RGFW_UNUSED(a) RGFW_UNUSED(image) }

const char RGFW_CURSORS[11][12] = {
    "default",
    "default",
    "text",
    "crosshair",
    "pointer",
    "ew-resize",
    "ns-resize",
    "nwse-resize",
    "nesw-resize",
    "move",
    "not-allowed"
};

void RGFW_window_setMouseStandard(RGFW_window* win, u8 mouse) {
	RGFW_UNUSED(win)
	EM_ASM( { document.getElementById("canvas").style.cursor = UTF8ToString($0); }, RGFW_CURSORS[mouse]);
}

void RGFW_window_setMouseDefault(RGFW_window* win) {
	RGFW_window_setMouseStandard(win, RGFW_MOUSE_NORMAL);
}

void RGFW_window_showMouse(RGFW_window* win, i8 show) {
	if (show)
		RGFW_window_setMouseDefault(win);
	else
		EM_ASM(document.getElementById('canvas').style.cursor = 'none';);
}

RGFW_point RGFW_getGlobalMousePoint(void) {
    RGFW_point point;
    point.x = EM_ASM_INT({
        return window.mouseX || 0;
    });
    point.y = EM_ASM_INT({
        return window.mouseY || 0;
    });
    return point;
}

RGFW_point RGFW_window_getMousePoint(RGFW_window* win) {
	RGFW_UNUSED(win);
	
	EmscriptenMouseEvent mouseEvent;
    emscripten_get_mouse_status(&mouseEvent);
	return RGFW_POINT( mouseEvent.targetX,  mouseEvent.targetY);
}

void RGFW_window_setMousePassthrough(RGFW_window* win, b8 passthrough) {
	RGFW_UNUSED(win);

    EM_ASM_({
        var canvas = document.getElementById('canvas');
        if ($0) {
            canvas.style.pointerEvents = 'none';
        } else {
            canvas.style.pointerEvents = 'auto';
        }
    }, passthrough);
}

void RGFW_writeClipboard(const char* text, u32 textLen) {
	RGFW_UNUSED(textLen)
	EM_ASM({ navigator.clipboard.writeText(UTF8ToString($0)); }, text);
}


char* RGFW_readClipboard(size_t* size) {
	/*
		placeholder code for later
		I'm not sure if this is possible do the the async stuff
	*/
	
	if (size != NULL)
		*size = 0;
	
	char* str = (char*)malloc(1);
	str[0] = '\0';

	return str;
}

void RGFW_window_swapBuffers(RGFW_window* win) {
	RGFW_UNUSED(win);
	
	#ifdef RGFW_BUFFER
	if (!(win->_winArgs & RGFW_NO_CPU_RENDER)) {		
		glEnable(GL_TEXTURE_2D);

		GLuint texture;
		glGenTextures(1,&texture);

		glBindTexture(GL_TEXTURE_2D,texture);
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, RGFW_bufferSize.w, RGFW_bufferSize.h, 0, GL_RGBA, GL_UNSIGNED_BYTE, win->buffer);
		
		float ratioX = ((float)win->r.w / (float)RGFW_bufferSize.w);
		float ratioY = ((float)win->r.h / (float)RGFW_bufferSize.h);

		// Set up the viewport
		glClear(GL_COLOR_BUFFER_BIT);

		glBegin(GL_TRIANGLES);
			glTexCoord2f(0, ratioY); glColor3f(1, 1, 1); glVertex2f(-1, -1);
			glTexCoord2f(0, 0); glColor3f(1, 1, 1); glVertex2f(-1, 1);
			glTexCoord2f(ratioX, ratioY); glColor3f(1, 1, 1); glVertex2f(1, -1);

			glTexCoord2f(ratioX, 0); glColor3f(1, 1, 1); glVertex2f(1, 1);
			glTexCoord2f(ratioX, ratioY); glColor3f(1, 1, 1); glVertex2f(1, -1);
			glTexCoord2f(0, 0); glColor3f(1, 1, 1); glVertex2f(-1, 1);
		glEnd();

		glDeleteTextures(1, &texture);
	}
	#endif

	emscripten_webgl_commit_frame();
	emscripten_sleep(0);
}


void RGFW_window_makeCurrent_OpenGL(RGFW_window* win) {
	if (win == NULL)
	    emscripten_webgl_make_context_current(0);
	else
	    emscripten_webgl_make_context_current(win->src.ctx);
}

#ifndef RGFW_EGL
void RGFW_window_swapInterval(RGFW_window* win, i32 swapInterval) { RGFW_UNUSED(win); RGFW_UNUSED(swapInterval); }
#endif

void RGFW_window_close(RGFW_window* win) {
    emscripten_webgl_destroy_context(win->src.ctx);

    free(win);
}

int RGFW_innerWidth(void) {   return EM_ASM_INT({ return window.innerWidth; });  }
int RGFW_innerHeight(void) {  return EM_ASM_INT({ return window.innerHeight; });  }

RGFW_area RGFW_getScreenSize(void) {
	return RGFW_AREA(RGFW_innerWidth(), RGFW_innerHeight());
}

void* RGFW_getProcAddress(const char* procname) { 
	return emscripten_webgl_get_proc_address(procname);
}

void RGFW_sleep(u64 milisecond) {
	emscripten_sleep(milisecond);
}

u64 RGFW_getTimeNS(void) {
	return emscripten_get_now() * 1e+6;
}

u64 RGFW_getTime(void) {
	return emscripten_get_now() * 1000;
}

void RGFW_releaseCursor(RGFW_window* win) {
	RGFW_UNUSED(win);
	emscripten_exit_pointerlock();
}

void RGFW_captureCursor(RGFW_window* win, RGFW_rect r) { 
	RGFW_UNUSED(win); RGFW_UNUSED(r);

	emscripten_request_pointerlock("#canvas", 1);
}


void RGFW_window_setName(RGFW_window* win, char* name) {
	RGFW_UNUSED(win);
	emscripten_set_window_title(name);
}

/* unsupported functions */
RGFW_monitor* RGFW_getMonitors(void) { return NULL; }
RGFW_monitor RGFW_getPrimaryMonitor(void) { return (RGFW_monitor){}; }
void RGFW_window_move(RGFW_window* win, RGFW_point v) { RGFW_UNUSED(win) RGFW_UNUSED(v) }
void RGFW_window_setMinSize(RGFW_window* win, RGFW_area a) { RGFW_UNUSED(win) RGFW_UNUSED(a)  }
void RGFW_window_setMaxSize(RGFW_window* win, RGFW_area a) { RGFW_UNUSED(win) RGFW_UNUSED(a)  }
void RGFW_window_minimize(RGFW_window* win) { RGFW_UNUSED(win)}
void RGFW_window_restore(RGFW_window* win) { RGFW_UNUSED(win) }
void RGFW_window_setBorder(RGFW_window* win, b8 border) { RGFW_UNUSED(win) RGFW_UNUSED(border)  }
void RGFW_window_setIcon(RGFW_window* win, u8* icon, RGFW_area a, i32 channels) { RGFW_UNUSED(win) RGFW_UNUSED(icon) RGFW_UNUSED(a) RGFW_UNUSED(channels)  }
void RGFW_window_hide(RGFW_window* win) { RGFW_UNUSED(win) }
void RGFW_window_show(RGFW_window* win) {RGFW_UNUSED(win) }
b8 RGFW_window_isHidden(RGFW_window* win) { RGFW_UNUSED(win) return 0; }
b8 RGFW_window_isMinimized(RGFW_window* win) { RGFW_UNUSED(win) return 0; }
b8 RGFW_window_isMaximized(RGFW_window* win) { RGFW_UNUSED(win) return 0; }
RGFW_monitor RGFW_window_getMonitor(RGFW_window* win) { RGFW_UNUSED(win) return (RGFW_monitor){}; }

#endif

/* end of web asm defines */

/* unix (macOS, linux, web asm) only stuff */
#if defined(RGFW_X11) || defined(RGFW_MACOS) || defined(RGFW_WEBASM)  || defined(RGFW_WAYLAND)
/* unix threading */
#ifndef RGFW_NO_THREADS
#include <pthread.h>

	RGFW_thread RGFW_createThread(RGFW_threadFunc_ptr ptr, void* args) {
		RGFW_UNUSED(args);
		
		RGFW_thread t;
		pthread_create((pthread_t*) &t, NULL, *ptr, NULL);
		return t;
	}
	void RGFW_cancelThread(RGFW_thread thread) { pthread_cancel((pthread_t) thread); }
	void RGFW_joinThread(RGFW_thread thread) { pthread_join((pthread_t) thread, NULL); }
#ifdef __linux__
	void RGFW_setThreadPriority(RGFW_thread thread, u8 priority) { pthread_setschedprio((pthread_t)thread, priority); }
#endif
#endif

#ifndef RGFW_WEBASM
/* unix sleep */
	void RGFW_sleep(u64 ms) {
		struct timespec time;
		time.tv_sec = 0;
		time.tv_nsec = ms * 1e+6;

		nanosleep(&time, NULL);
	}
#endif

#endif /* end of unix / mac stuff*/
#endif /*RGFW_IMPLEMENTATION*/

#if defined(__cplusplus) && !defined(__EMSCRIPTEN__)
}
#endif
#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_vector rotateAroundCenter(RSoft_vector v, RSoft_vector center, RSoft_vector player, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_simpleRotateMatrix(m, angle);
	m = RSoft_translateMatrix(m, center);
	m = RSoft_translateMatrix(m, RSOFT_VECTOR3D(-player.x, -player.y, -player.z));
	return RSoft_applyMatrix(m, v);
}

void drawLine(RGFW_window* win, RSoft_vector center, RSoft_vector player, float angle, RSoft_vector v1, RSoft_vector v2) {
	v1 = rotateAroundCenter(v1, center, player, angle);
	v2 = rotateAroundCenter(v2, center, player, angle);

	RSoft_setMatrix(RSoft_initMatrix());

	if (RGFW_isPressed(win, RGFW_Tab)) {
		RSoft_drawLineF(win->buffer, v1, v2, (u8[4]){255, 225, 225, 255});
	} else {
		v1.x = (-(v1.x * 200)) / (v1.y - (center.y));
		v1.y = (v1.z * 200) / (v1.y - (center.y)) + center.y;	

		v2.x = (-(v2.x * 200)) / (v2.y - (center.y));	
		v2.y = (v2.z * 200) / (v2.y - (center.y)) + center.y;	
		
		if (v1.x >= 0 && v1.y >= 0 && v2.x >= 0 && v2.y >= 0) 
			RSoft_drawLineF(win->buffer, v1, v2, (u8[4]){255, 225, 225, 255});
	}
}

u8* buffer = NULL;
int w, h, c;

void drawWall(RGFW_window* win, RSoft_vector center, RSoft_vector player, float angle, RSoft_rectF rect) {
	for (float i = 0; i < rect.h; i += 0.1) {
		RSoft_setTexture(buffer, RSOFT_RECT(0, i, w, h), RSOFT_AREA(w, h));
		drawLine(win, center, player, angle, RSOFT_VECTOR3D(rect.x, rect.y, i), RSOFT_VECTOR3D(rect.x + rect.w, rect.y, i));
	}
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Doom-Like example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));

	buffer = stbi_load("wall2.jpg", &w, &h, &c, 4);

	float angle = 0;
	float fov = 120;

	RSoft_vector center = RSOFT_VECTOR2D(win->r.w / 2, win->r.h / 2);

	RSoft_vector player = RSOFT_VECTOR3D(0, 0, 10);

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        } 
			
		if (RGFW_isPressed(win, RGFW_w)) {
			RSoft_vector next = RSOFT_VECTOR3D(player.x - RSoft_cos(angle + 90), 
											   player.y - RSoft_sin(angle + 90),
											   player.z);

			player = next;
		}
		if (RGFW_isPressed(win, RGFW_s)){
			RSoft_vector next = RSOFT_VECTOR3D(player.x + RSoft_cos(angle + 90), 
											   player.y + RSoft_sin(angle + 90),
											   player.z);
			player = next;
		}

		if (RGFW_isPressed(win, RGFW_a)) {
			RSoft_vector next = RSOFT_VECTOR3D(player.x + RSoft_cos(angle), 
											   player.y + RSoft_sin(angle),
											   player.z);

			player = next;
		}

		if (RGFW_isPressed(win, RGFW_d)) {
			RSoft_vector next = RSOFT_VECTOR3D(player.x - RSoft_cos(angle), 
											   player.y - RSoft_sin(angle),
											   player.z);
			
			player = next;
		}

		if (RGFW_isPressed(win, RGFW_Left))
			angle += 0.5;	
		if (RGFW_isPressed(win, RGFW_Right))
			angle -= 0.5;

		if (RGFW_isPressed(win, RGFW_Up))
			player.z -= 5;	
		if (RGFW_isPressed(win, RGFW_Down))
			player.z += 5;

		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 255});
		RSoft_setMatrix(RSoft_initMatrix());
		
		if (RGFW_isPressed(win, RGFW_Tab)) {
			RSoft_matrix m = RSoft_initMatrix();
			m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
			m = RSoft_simpleRotateMatrix(m, angle - 90);
			m = RSoft_translateMatrix(m, center);
			RSoft_setMatrix(m);
			
			RSoft_drawPolygon(win->buffer, RSOFT_RECT(center.x - 10, center.y - 5, 20, 10), 3, (u8[4]){255, 0, 0, 255});
		}

		drawWall(win, center, player, angle, RSOFT_RECTF(200, 200, 200, 20));

		RGFW_window_swapBuffers(win);
    }
	
	free(buffer);
    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/doom-like.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="doom-like.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_matrix rotateAroundCenter(RSoft_vector center, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_rotateMatrix(m, angle, 1, 1, 1);
	m = RSoft_translateMatrix(m, center);
	return m;
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Raycaster example", RGFW_RECT(0, 0, 1100, 800), RGFW_CENTER);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));

	int w, h, c;
	u8* buffer = stbi_load("wall.jpg", &w, &h, &c, 4);

	const u32 map_width = 20;
	const u32 map_height = 20;
	
	u8 map[] = {
		1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
		1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
		1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1,
		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	};

	float angle = 0;
	float fov = 120;
	float precision = 64; 

	RSoft_vector player = RSOFT_VECTOR2D(5, 7);

	RGFW_window_mouseHold(win, RGFW_AREA(0, 0));
	RGFW_window_showMouse(win, 0);

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_mousePosChanged) {
				angle += (win->event.point.x / 15);	
				if (angle >= 360)
					angle -= 360;
				if (angle < 0)
					angle += 360;

			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        }
		
		if (RGFW_isPressed(win, RGFW_w)) {
			RSoft_vector next = RSOFT_VECTOR2D(player.x + RSoft_cos(angle) / 20, 
											   player.y + RSoft_sin(angle) / 20);

			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}
		if (RGFW_isPressed(win, RGFW_s)){
			RSoft_vector next = RSOFT_VECTOR2D(player.x - RSoft_cos(angle) / 20, 
											   player.y - RSoft_sin(angle) / 20);
			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}

		if (RGFW_isPressed(win, RGFW_a)) {
			RSoft_vector next = RSOFT_VECTOR2D(player.x - RSoft_cos(angle + 90) / 20, 
											   player.y - RSoft_sin(angle + 90) / 20);

			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}

		if (RGFW_isPressed(win, RGFW_d)) {
			RSoft_vector next = RSOFT_VECTOR2D(player.x + RSoft_cos(angle + 90) / 20, 
											   player.y + RSoft_sin(angle + 90) / 20);

			if (map[(size_t)((size_t)next.y * map_width) + (size_t)next.x] == 0)
				player = next;
		}

		if (RGFW_isPressed(win, RGFW_Left)) {
			angle -= 5;
;
			if (angle < 0)
				angle += 360;
		}
		if (RGFW_isPressed(win, RGFW_Right)) {
			angle += 5;
			if (angle >= 360)
				angle -= 360;
		}
	

		RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 1, 1), RSOFT_AREA(w, h));
		RSoft_clear(win->buffer, (u8[4]){30, 130, 180, 255});
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(0, win->r.h / 3, win->r.w, win->r.h), (u8[4]){10, 100, 10, 255});	

		float rayAngle = angle - (fov / 2);
		for (size_t i = 0; i < win->r.w; i++) {
			RSoft_vector ray = player;
			rayAngle += (fov / win->r.w);
			
			while (map[(size_t)((size_t)ray.y * map_width) + (size_t)ray.x] == 0) {
				ray.x += cos(rayAngle * DEG2RAD) / precision;
				ray.y += sin(rayAngle * DEG2RAD) / precision;
			}


			if (RGFW_isPressed(win, RGFW_Tab)) {
				RSoft_drawLineF(win->buffer, RSOFT_VECTOR2D(player.x * 50, player.y * 50), RSOFT_VECTOR2D(ray.x * 50, ray.y * 50),  (u8[4]){200, 100, 20, 255});
				continue;
			}

			float dist = (sqrt(pow(player.x - ray.x, 2) + pow(player.y - ray.y, 2)));
			dist *= cos((rayAngle - angle) * DEG2RAD);
			dist += 1;
			
			float height = (win->r.h / 1) / dist;	
			
			if ((rayAngle >= -(fov / 2) && rayAngle <= (fov / 2)) || (rayAngle >= 300))
				RSoft_setTexture(buffer, RSOFT_RECT(sin(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));
			
			if (rayAngle >= 180 - (fov / 2) && rayAngle <= 180 + (fov / 2))
				RSoft_setTexture(buffer, RSOFT_RECT(-sin(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));

			if (rayAngle >= 90 - (fov / 2) && rayAngle <= 90 + (fov / 2))
				RSoft_setTexture(buffer, RSOFT_RECT(-cos(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));

			if (rayAngle >= 220 && rayAngle <= 300)
				RSoft_setTexture(buffer, RSOFT_RECT(cos(rayAngle * DEG2RAD) * w, 100, 1, h), RSOFT_AREA(w, h));

			RSoft_drawRectF(win->buffer, RSOFT_RECTF(i, win->r.h / 3.5, 1, height), (u8[4]){255, 255, 255, 255});	
		}
			

		if (RGFW_isPressed(win, RGFW_Tab)) {
			for (size_t y = 0; y < map_height; y++) {
				for (size_t x = 0; x < map_width; x++) {
					if (map[(y * map_width) + x]) {
						RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 50, 50), RSOFT_AREA(w, h));
						RSoft_drawRect(win->buffer, RSOFT_RECT(x * 50, y * 50, 50, 50), (u8[4]){255, 255, 255, 255});	
					}
				}
			}

			RSoft_drawRect(win->buffer, RSOFT_RECT((player.x * 50) - 10, (player.y * 50) - 10, 20, 20), (u8[4]){255, 0, 0, 255});	
		}

		RGFW_window_swapBuffers(win);
    }
	
	free(buffer);
    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/raycaster.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="raycaster.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_matrix rotateAroundCenter(RSoft_vector center, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_rotateMatrix(m, angle, 1, 1, 1);
	m = RSoft_translateMatrix(m, center);
	return m;
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Shapes example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
	
	float angle = 0;

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        } 
		
		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 15});
		RSoft_vector v1 = RSOFT_VECTOR2D(700, 100);	
		RSoft_vector v2 = RSOFT_VECTOR2D(500, 100);	
		RSoft_vector v3 = RSOFT_VECTOR2D(600, 200);

		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 150), angle));
		RSoft_drawTriangleF(win->buffer, (RSoft_vector[3]){v1, v2, v3}, (u8[4]){0, 255, 0, 255});
	
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(250, 250), angle));
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(150, 150, 200, 200), (u8[4]){0, 255, 0, 255}); 
		
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(200, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(200, 600, 100, 100), 6, (u8[4]){0, 255, 0, 255});
	
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(500, 600, 100, 100), 36, (u8[4]){0, 255, 0, 255});

		angle++;
		RGFW_window_swapBuffers(win);
    }

    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/shapes.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="shapes.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
/* stb_image - v2.27 - public domain image loader - http://nothings.org/stb
                                  no warranty implied; use at your own risk

   Do this:
      #define STB_IMAGE_IMPLEMENTATION
   before you include this file in *one* C or C++ file to create the implementation.

   // i.e. it should look like this:
   #include ...
   #include ...
   #include ...
   #define STB_IMAGE_IMPLEMENTATION
   #include "stb_image.h"

   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free


   QUICK NOTES:
      Primarily of interest to game developers and other people who can
          avoid problematic images and only need the trivial interface

      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
      PNG 1/2/4/8/16-bit-per-channel

      TGA (not sure what subset, if a subset)
      BMP non-1bpp, non-RLE
      PSD (composited view only, no extra channels, 8/16 bit-per-channel)

      GIF (*comp always reports as 4-channel)
      HDR (radiance rgbE format)
      PIC (Softimage PIC)
      PNM (PPM and PGM binary only)

      Animated GIF still needs a proper API, but here's one way to do it:
          http://gist.github.com/urraka/685d9a6340b26b830d49

      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
      - decode from arbitrary I/O callbacks
      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)

   Full documentation under "DOCUMENTATION" below.


LICENSE

  See end of file for license information.

RECENT REVISION HISTORY:

      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes
      2.26  (2020-07-13) many minor fixes
      2.25  (2020-02-02) fix warnings
      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
      2.23  (2019-08-11) fix clang static analysis warning
      2.22  (2019-03-04) gif fixes, fix warnings
      2.21  (2019-02-25) fix typo in comment
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
                         RGB-format JPEG; remove white matting in PSD;
                         allocate large structures on the stack;
                         correct channel count for PNG & BMP
      2.10  (2016-01-22) avoid warning introduced in 2.09
      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED

   See end of file for full revision history.


 ============================    Contributors    =========================

 Image formats                          Extensions, features
    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
    Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
    Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
    github:urraka (animated gif)           Junggon Kim (PNM comments)
    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
                                           socks-the-fox (16-bit PNG)
                                           Jeremy Sawicki (handle all ImageNet JPGs)
 Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)
    John-Mark Allen
    Carmelo J Fdez-Aguera

 Bug & warning fixes
    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko
    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski
    Phil Jordan                                Dave Moore           Roy Eltham
    Hayaki Saito            Nathan Reed        Won Chun
    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community
    Thomas Ruf              Ronny Chevalier                         github:rlyeh
    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou
    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk
    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar
    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex
    Cass Everitt            Ryamond Barbiero                        github:grim210
    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw
    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus
    Josh Tobin                                 Matthew Gregan       github:poppolopoppo
    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji
    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007
                            Brad Weinberger    Matvey Cherevko      github:mosra
    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]
    Ryan C. Gordon          [reserved]                              [reserved]
                     DO NOT ADD YOUR NAME HERE

                     Jacko Dirks

  To add your name to the credits, pick a random blank space in the middle and fill it.
  80% of merge conflicts on stb PRs are due to people adding their name at the end
  of the credits.
*/

#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x                 -- outputs image width in pixels
//    int *y                 -- outputs image height in pixels
//    int *channels_in_file  -- outputs # of image components in image file
//    int desired_channels   -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'desired_channels' if desired_channels is non-zero, or
// *channels_in_file otherwise. If desired_channels is non-zero,
// *channels_in_file has the number of components that _would_ have been
// output otherwise. E.g. if you set desired_channels to 4, you will always
// get RGBA output, but you can check *channels_in_file to see if it's trivially
// opaque because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *channels_in_file will be unchanged. The function
// stbi_failure_reason() can be queried for an extremely brief, end-user
// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// To query the width, height and component count of an image without having to
// decode the full file, you can use the stbi_info family of functions:
//
//   int x,y,n,ok;
//   ok = stbi_info(filename, &x, &y, &n);
//   // returns ok=1 and sets x, y, n if image is a supported format,
//   // 0 otherwise.
//
// Note that stb_image pervasively uses ints in its public API for sizes,
// including sizes of memory buffers. This is now part of the API and thus
// hard to change without causing breakage. As a result, the various image
// loaders all have certain limits on image size; these differ somewhat
// by format but generally boil down to either just under 2GB or just under
// 1GB. When the decoded image would be larger than this, stb_image decoding
// will fail.
//
// Additionally, stb_image will reject image files that have any of their
// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,
// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,
// the only way to have an image with such dimensions load correctly
// is for it to have a rather extreme aspect ratio. Either way, the
// assumption here is that such larger images are likely to be malformed
// or malicious. If you do need to load an image with individual dimensions
// larger than that, and it still fits in the overall size limit, you can
// #define STBI_MAX_DIMENSIONS on your own to be something larger.
//
// ===========================================================================
//
// UNICODE:
//
//   If compiling for Windows and you wish to use Unicode filenames, compile
//   with
//       #define STBI_WINDOWS_UTF8
//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
//   Windows wchar_t filenames to utf8.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy-to-use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// provide more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small source code footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image supports loading HDR images in general, and currently the Radiance
// .HDR file format specifically. You can still load any file through the existing
// interface; if you attempt to load an HDR file, it will be automatically remapped
// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// We optionally support converting iPhone-formatted PNGs (which store
// premultiplied BGRA) back to RGB, even though they're internally encoded
// differently. To enable this conversion, call
// stbi_convert_iphone_png_to_rgb(1).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// ADDITIONAL CONFIGURATION
//
//  - You can suppress implementation of any of the decoders to reduce
//    your code footprint by #defining one or more of the following
//    symbols before creating the implementation.
//
//        STBI_NO_JPEG
//        STBI_NO_PNG
//        STBI_NO_BMP
//        STBI_NO_PSD
//        STBI_NO_TGA
//        STBI_NO_GIF
//        STBI_NO_HDR
//        STBI_NO_PIC
//        STBI_NO_PNM   (.ppm and .pgm)
//
//  - You can request *only* certain decoders and suppress all other ones
//    (this will be more forward-compatible, as addition of new decoders
//    doesn't require you to disable them explicitly):
//
//        STBI_ONLY_JPEG
//        STBI_ONLY_PNG
//        STBI_ONLY_BMP
//        STBI_ONLY_PSD
//        STBI_ONLY_TGA
//        STBI_ONLY_GIF
//        STBI_ONLY_HDR
//        STBI_ONLY_PIC
//        STBI_ONLY_PNM   (.ppm and .pgm)
//
//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
//
//  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater
//    than that size (in either width or height) without further processing.
//    This is to let programs in the wild set an upper bound to prevent
//    denial-of-service attacks on untrusted data, as one could generate a
//    valid image of gigantic dimensions and force stb_image to allocate a
//    huge block of memory and spend disproportionate time decoding it. By
//    default this is set to (1 << 24), which is 16777216, but that's still
//    very big.

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
   STBI_default = 0, // only used for desired_channels

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4
};

#include <stdlib.h>
typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;

#ifdef __cplusplus
extern "C" {
#endif

#ifndef STBIDEF
#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif
#endif

//////////////////////////////////////////////////////////////////////////////
//
// PRIMARY API - works on images of any type
//

//
// load image by filename, open file, or memory buffer
//

typedef struct
{
   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
} stbi_io_callbacks;

////////////////////////////////////
//
// 8-bits-per-channel interface
//

STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
#endif

#ifdef STBI_WINDOWS_UTF8
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
#endif

////////////////////////////////////
//
// 16-bits-per-channel interface
//

STBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
#endif

////////////////////////////////////
//
// float-per-channel interface
//
#ifndef STBI_NO_LINEAR
   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);

   #ifndef STBI_NO_STDIO
   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
   #endif
#endif

#ifndef STBI_NO_HDR
   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
#endif // STBI_NO_HDR

#ifndef STBI_NO_LINEAR
   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_LINEAR

// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename);
STBIDEF int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO


// get a VERY brief reason for failure
// on most compilers (and ALL modern mainstream compilers) this is threadsafe
STBIDEF const char *stbi_failure_reason  (void);

// free the loaded image -- this is just free()
STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);

// get image dimensions & components without fully decoding
STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit          (char const *filename);
STBIDEF int      stbi_is_16_bit_from_file(FILE *f);
#endif



// for image formats that explicitly notate that they have premultiplied alpha,
// we just return the colors as stored in the file. set this flag to force
// unpremultiplication. results are undefined if the unpremultiply overflow.
STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

// indicate whether we should process iphone images back to canonical format,
// or just pass them through "as-is"
STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

// flip the image vertically, so the first pixel in the output array is the bottom left
STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);

// as above, but only applies to images loaded on the thread that calls the function
// this function is only available if your compiler supports thread-local variables;
// calling it will fail to link if your compiler doesn't
STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);
STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);
STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);

// ZLIB client - used by PNG, available for other purposes

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);


#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifdef STB_IMAGE_IMPLEMENTATION

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
   #ifndef STBI_ONLY_JPEG
   #define STBI_NO_JPEG
   #endif
   #ifndef STBI_ONLY_PNG
   #define STBI_NO_PNG
   #endif
   #ifndef STBI_ONLY_BMP
   #define STBI_NO_BMP
   #endif
   #ifndef STBI_ONLY_PSD
   #define STBI_NO_PSD
   #endif
   #ifndef STBI_ONLY_TGA
   #define STBI_NO_TGA
   #endif
   #ifndef STBI_ONLY_GIF
   #define STBI_NO_GIF
   #endif
   #ifndef STBI_ONLY_HDR
   #define STBI_NO_HDR
   #endif
   #ifndef STBI_ONLY_PIC
   #define STBI_NO_PIC
   #endif
   #ifndef STBI_ONLY_PNM
   #define STBI_NO_PNM
   #endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif


#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#ifndef WIN32
#include <math.h>  // ldexp, pow
#endif
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif

#ifdef __cplusplus
#define STBI_EXTERN extern "C"
#else
#define STBI_EXTERN extern
#endif


#ifndef _MSC_VER
   #ifdef __cplusplus
   #define stbi_inline inline
   #else
   #define stbi_inline
   #endif
#else
   #define stbi_inline __forceinline
#endif

#ifndef STBI_NO_THREAD_LOCALS
   #if defined(__cplusplus) &&  __cplusplus >= 201103L
      #define STBI_THREAD_LOCAL       thread_local
   #elif defined(__GNUC__) && __GNUC__ < 5
      #define STBI_THREAD_LOCAL       __thread
   #elif defined(_MSC_VER)
      #define STBI_THREAD_LOCAL       __declspec(thread)
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)
      #define STBI_THREAD_LOCAL       _Thread_local
   #endif

   #ifndef STBI_THREAD_LOCAL
      #if defined(__GNUC__)
        #define STBI_THREAD_LOCAL       __thread
      #endif
   #endif
#endif

#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
   #define stbi_lrot(x,y)  _lrotl(x,y)
#else
   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)           malloc(sz)
#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
#define STBI_FREE(p)              free(p)
#endif

#ifndef STBI_REALLOC_SIZED
#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
#endif

// x86/x64 detection
#if defined(__x86_64__) || defined(_M_X64)
#define STBI__X64_TARGET
#elif defined(__i386) || defined(_M_IX86)
#define STBI__X86_TARGET
#endif

#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
// but previous attempts to provide the SSE2 functions with runtime
// detection caused numerous issues. The way architecture extensions are
// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
// New behavior: if compiled with -msse2, we use SSE2 without any
// detection; if not, we don't use it at all.
#define STBI_NO_SIMD
#endif

#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
//
// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
// simultaneously enabling "-mstackrealign".
//
// See https://github.com/nothings/stb/issues/81 for more information.
//
// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
#define STBI_NO_SIMD
#endif

#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
   int info[4];
   __cpuid(info,1);
   return info[3];
}
#else
static int stbi__cpuid3(void)
{
   int res;
   __asm {
      mov  eax,1
      cpuid
      mov  res,edx
   }
   return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   int info3 = stbi__cpuid3();
   return ((info3 >> 26) & 1) != 0;
}
#endif

#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}
#endif

#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
#ifdef _MSC_VER
#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
#else
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

#ifndef STBI_MAX_DIMENSIONS
#define STBI_MAX_DIMENSIONS (1 << 24)
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
   stbi__uint32 img_x, img_y;
   int img_n, img_out_n;

   stbi_io_callbacks io;
   void *io_user_data;

   int read_from_callbacks;
   int buflen;
   stbi_uc buffer_start[128];
   int callback_already_read;

   stbi_uc *img_buffer, *img_buffer_end;
   stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context *s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}

static void stbi__stdio_skip(void *user, int n)
{
   int ch;
   fseek((FILE*) user, n, SEEK_CUR);
   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
   if (ch != EOF) {
      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
   }
}

static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user) || ferror((FILE *) user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
   STBI_ORDER_RGB,
   STBI_ORDER_BGR
};

typedef struct
{
   int bits_per_channel;
   int num_channels;
   int channel_order;
} stbi__result_info;

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context *s);
static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context *s);
static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__png_is16(stbi__context *s);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context *s);
static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context *s);
static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context *s);
static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__psd_is16(stbi__context *s);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context *s);
static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context *s);
static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context *s);
static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__pnm_is16(stbi__context *s);
#endif

static
#ifdef STBI_THREAD_LOCAL
STBI_THREAD_LOCAL
#endif
const char *stbi__g_failure_reason;

STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}

#ifndef STBI_NO_FAILURE_STRINGS
static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}
#endif

static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}

// stb_image uses ints pervasively, including for offset calculations.
// therefore the largest decoded image size we can support with the
// current code, even on 64-bit targets, is INT_MAX. this is not a
// significant limitation for the intended use case.
//
// we do, however, need to make sure our size calculations don't
// overflow. hence a few helper functions for size calculations that
// multiply integers together, making sure that they're non-negative
// and no overflow occurs.

// return 1 if the sum is valid, 0 on overflow.
// negative terms are considered invalid.
static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And "a + b <= INT_MAX" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}

// returns 1 if the product is valid, 0 on overflow.
// negative factors are considered invalid.
static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}
#endif

// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}

// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}
#endif

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// mallocs with size overflow checking
static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}
#endif

static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}
#endif

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
   #define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
   #define stbi__err(x,y)  stbi__err(y)
#else
   #define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static int stbi__vertically_flip_on_load_global = 0;

STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
#else
static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;

STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}

#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
                                         ? stbi__vertically_flip_on_load_local  \
                                         : stbi__vertically_flip_on_load_global)
#endif // STBI_THREAD_LOCAL

static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   // test the formats with a very explicit header first (at least a FOURCC
   // or distinctive magic number first)
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif

   // then the formats that can end up attempting to load with just 1 or 2
   // bytes matching expectations; these are prone to false positives, so
   // try them later
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}

static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}

static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}

#ifndef STBI_NO_GIF
static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}
#endif

static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 8) {
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}

static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 16) {
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}

#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}
#endif

#ifndef STBI_NO_STDIO

#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
#endif

#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
{
	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
}
#endif

static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
      return 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}


STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   unsigned char *result;
   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}


#endif //!STBI_NO_STDIO

STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
   }

   return result;
}
#endif

#ifndef STBI_NO_LINEAR
static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, "rb");
   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, "rb");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}

STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, SEEK_SET);
   return res;
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}

#ifndef STBI_NO_LINEAR
static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;

STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
   STBI__SCAN_load=0,
   STBI__SCAN_type,
   STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
   if (n == 0) {
      // at end of file, treat same as if from memory, but need to handle case
      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}

stbi_inline static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}

#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
stbi_inline static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      // if feof() is true, check if buffer = end
      // special case: we've only got the special 0 character at the end
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
// nothing
#else
static void stbi__skip(stbi__context *s, int n)
{
   if (n == 0) return;  // already there!
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
// nothing
#else
static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}
#endif

#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
// nothing
#else
static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}
#endif

#ifndef STBI_NO_BMP
static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   z += (stbi__uint32)stbi__get16le(s) << 16;
   return z;
}
#endif

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
      STBI_FREE(data);
      return stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
      STBI_FREE(data);
      return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
   }
   if (n < comp) {
      for (i=0; i < x*y; ++i) {
         output[i*comp + n] = data[i*comp + n]/255.0f;
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
   stbi_uc  fast[1 << FAST_BITS];
   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
   stbi__uint16 code[256];
   stbi_uc  values[256];
   stbi_uc  size[257];
   unsigned int maxcode[18];
   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
   stbi__context *s;
   stbi__huffman huff_dc[4];
   stbi__huffman huff_ac[4];
   stbi__uint16 dequant[4][64];
   stbi__int16 fast_ac[4][1 << FAST_BITS];

// sizes for components, interleaved MCUs
   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;

// definition of jpeg image component
   struct
   {
      int id;
      int h,v;
      int tq;
      int hd,ha;
      int dc_pred;

      int x,y,w2,h2;
      stbi_uc *data;
      void *raw_data, *raw_coeff;
      stbi_uc *linebuf;
      short   *coeff;   // progressive only
      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
   } img_comp[4];

   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
   int            code_bits;   // number of valid bits
   unsigned char  marker;      // marker seen while filling entropy buffer
   int            nomore;      // flag if we saw a marker so must stop

   int            progressive;
   int            spec_start;
   int            spec_end;
   int            succ_high;
   int            succ_low;
   int            eob_run;
   int            jfif;
   int            app14_color_transform; // Adobe APP14 tag
   int            rgb;

   int scan_n, order[4];
   int restart_interval, todo;

// kernels
   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i)
      for (j=0; j < count[i]; ++j)
         h->size[k++] = (stbi_uc) (i+1);
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= FAST_BITS) {
            // magnitude code followed by receive_extend code
            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            // if the result is small enough, we can fit it in fast_ac table
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}

// (1 << n) - 1
static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}

// bias[n] = (-1<<n) + 1
static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & (sgn - 1));
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static const stbi_uc stbi__jpeg_dezigzag[64+15] =
{
    0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
      r = fac[c];
      if (r) { // fast-AC path
         k += (r >> 4) & 15; // run
         s = r & 15; // combined length
         j->code_buffer <<= s;
         j->code_bits -= s;
         // decode into unzigzag'd location
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; // end block
            k += 16;
         } else {
            k += r;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      // first scan for DC coefficient, must be first
      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
      t = stbi__jpeg_huff_decode(j, hdc);
      if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
      diff = t ? stbi__extend_receive(j, t) : 0;

      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      data[0] = (short) (dc * (1 << j->succ_low));
   } else {
      // refinement scan for DC coefficient
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
         r = fac[c];
         if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) * (1 << shift));
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
            }
         }
      } while (k <= j->spec_end);
   } else {
      // refinement scan for these AC coefficients

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; // force end of block
               } else {
                  // r=15 s=0 should write 16 0s, so we just do
                  // a run of 15 0s and then write s (which is 0),
                  // so we don't have to do anything special here
               }
            } else {
               if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
               // sign bit
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            // advance by r
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) * 4096)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      // so we want to round that, which means adding 0.5 * 1<<17,
      // aka 65536. Also, we'll end up with -128 to 127 that we want
      // to encode as 0..255 by adding 128, so we'll add that before the shift
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      // tried computing the shifts into temps, or'ing the temps to see
      // if any were out of range, but that was slower
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by "s" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
      // 16bit 8x8 transpose pass 1
      dct_interleave16(row0, row4);
      dct_interleave16(row1, row5);
      dct_interleave16(row2, row6);
      dct_interleave16(row3, row7);

      // transpose pass 2
      dct_interleave16(row0, row2);
      dct_interleave16(row1, row3);
      dct_interleave16(row4, row6);
      dct_interleave16(row5, row7);

      // transpose pass 3
      dct_interleave16(row0, row1);
      dct_interleave16(row2, row3);
      dct_interleave16(row4, row5);
      dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
      // pack
      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      // 8bit 8x8 transpose pass 1
      dct_interleave8(p0, p2); // a0e0a1e1...
      dct_interleave8(p1, p3); // c0g0c1g1...

      // transpose pass 2
      dct_interleave8(p0, p1); // a0c0e0g0...
      dct_interleave8(p2, p3); // b0d0f0h0...

      // transpose pass 3
      dct_interleave8(p0, p2); // a0b0c0d0...
      dct_interleave8(p1, p3); // a4b4c4d4...

      // store
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

// wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
   { \
      dct_wadd(sum, a, b); \
      dct_wsub(dif, a, b); \
      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
   }

#define dct_pass(shiftop, shift) \
   { \
      /* even part */ \
      int16x8_t sum26 = vaddq_s16(row2, row6); \
      dct_long_mul(p1e, sum26, rot0_0); \
      dct_long_mac(t2e, p1e, row6, rot0_1); \
      dct_long_mac(t3e, p1e, row2, rot0_2); \
      int16x8_t sum04 = vaddq_s16(row0, row4); \
      int16x8_t dif04 = vsubq_s16(row0, row4); \
      dct_widen(t0e, sum04); \
      dct_widen(t1e, dif04); \
      dct_wadd(x0, t0e, t3e); \
      dct_wsub(x3, t0e, t3e); \
      dct_wadd(x1, t1e, t2e); \
      dct_wsub(x2, t1e, t2e); \
      /* odd part */ \
      int16x8_t sum15 = vaddq_s16(row1, row5); \
      int16x8_t sum17 = vaddq_s16(row1, row7); \
      int16x8_t sum35 = vaddq_s16(row3, row5); \
      int16x8_t sum37 = vaddq_s16(row3, row7); \
      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
      dct_long_mul(p5o, sumodd, rot1_0); \
      dct_long_mac(p1o, p5o, sum17, rot1_1); \
      dct_long_mac(p2o, p5o, sum35, rot1_2); \
      dct_long_mul(p3o, sum37, rot2_0); \
      dct_long_mul(p4o, sum15, rot2_1); \
      dct_wadd(sump13o, p1o, p3o); \
      dct_wadd(sump24o, p2o, p4o); \
      dct_wadd(sump23o, p2o, p3o); \
      dct_wadd(sump14o, p1o, p4o); \
      dct_long_mac(x4, sump13o, row7, rot3_0); \
      dct_long_mac(x5, sump24o, row5, rot3_1); \
      dct_long_mac(x6, sump23o, row3, rot3_2); \
      dct_long_mac(x7, sump14o, row1, rot3_3); \
      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
   }

   // load
   row0 = vld1q_s16(data + 0*8);
   row1 = vld1q_s16(data + 1*8);
   row2 = vld1q_s16(data + 2*8);
   row3 = vld1q_s16(data + 3*8);
   row4 = vld1q_s16(data + 4*8);
   row5 = vld1q_s16(data + 5*8);
   row6 = vld1q_s16(data + 6*8);
   row7 = vld1q_s16(data + 7*8);

   // add DC bias
   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

   // column pass
   dct_pass(vrshrn_n_s32, 10);

   // 16bit 8x8 transpose
   {
// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
// whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

      // pass 1
      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
      dct_trn16(row2, row3);
      dct_trn16(row4, row5);
      dct_trn16(row6, row7);

      // pass 2
      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
      dct_trn32(row1, row3);
      dct_trn32(row4, row6);
      dct_trn32(row5, row7);

      // pass 3
      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
      dct_trn64(row1, row5);
      dct_trn64(row2, row6);
      dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
   }

   // row pass
   // vrshrn_n_s32 only supports shifts up to 16, we need
   // 17. so do a non-rounding shift of 16 first then follow
   // up with a rounding shift by 1.
   dct_pass(vshrn_n_s32, 16);

   {
      // pack and round
      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

      // again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

      // sadly can't use interleaved stores here since we only write
      // 8 bytes to each scan line!

      // 8x8 8-bit transpose pass 1
      dct_trn8_8(p0, p1);
      dct_trn8_8(p2, p3);
      dct_trn8_8(p4, p5);
      dct_trn8_8(p6, p7);

      // pass 2
      dct_trn8_16(p0, p2);
      dct_trn8_16(p1, p3);
      dct_trn8_16(p4, p6);
      dct_trn8_16(p5, p7);

      // pass 3
      dct_trn8_32(p0, p4);
      dct_trn8_32(p1, p5);
      dct_trn8_32(p2, p6);
      dct_trn8_32(p3, p7);

      // store
      vst1_u8(out, p0); out += out_stride;
      vst1_u8(out, p1); out += out_stride;
      vst1_u8(out, p2); out += out_stride;
      vst1_u8(out, p3); out += out_stride;
      vst1_u8(out, p4); out += out_stride;
      vst1_u8(out, p5); out += out_stride;
      vst1_u8(out, p6); out += out_stride;
      vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
   }

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         STBI_SIMD_ALIGN(short, data[64]);
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  // if it's NOT a restart, then just bail, so we get corrupt data
                  // rather than no data
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         STBI_SIMD_ALIGN(short, data[64]);
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}

static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      // dequantize and idct the data
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case STBI__MARKER_none: // no marker found
         return stbi__err("expected marker","Corrupt JPEG");

      case 0xDD: // DRI - specify restart interval
         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
            if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err("bad COM len","Corrupt JPEG");
         else
            return stbi__err("bad APP len","Corrupt JPEG");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); // version
            stbi__get16be(z->s); // flags0
            stbi__get16be(z->s); // flags1
            z->app14_color_transform = stbi__get8(z->s); // color transform
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err("unknown marker","Corrupt JPEG");
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; // no match
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err("bad SOS", "Corrupt JPEG");
      } else {
         if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
         z->spec_end = 63;
      }
   }

   return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         STBI_FREE(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = NULL;
         z->img_comp[i].data = NULL;
      }
      if (z->img_comp[i].raw_coeff) {
         STBI_FREE(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         STBI_FREE(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = NULL;
      }
   }
   return why;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
   // and I've never seen a non-corrupted JPEG file actually use them
   for (i=0; i < s->img_n; ++i) {
      if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
      if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == STBI__MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = NULL;
      j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
      if (stbi__SOS(m)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == STBI__MARKER_none ) {
            // handle 0s at the end of image data from IP Kamera 9060
            while (!stbi__at_eof(j->s)) {
               int x = stbi__get8(j->s);
               if (x == 255) {
                  j->marker = stbi__get8(j->s);
                  break;
               }
            }
            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
         }
      } else if (stbi__DNL(m)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
         if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
      } else {
         if (!stbi__process_marker(j, m)) return 0;
      }
      m = stbi__get_marker(j);
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
                                    int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = stbi__div4(n+input[i-1]);
      out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      // interleave even and odd pixels, then undo scaling.
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      // pack and write output
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      uint8x8_t farb  = vld1_u8(in_far + i);
      uint8x8_t nearb = vld1_u8(in_near + i);
      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
      int16x8_t curr  = vaddq_s16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      int16x8_t prv0 = vextq_s16(curr, curr, 7);
      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      int16x8_t curs = vshlq_n_s16(curr, 2);
      int16x8_t prvd = vsubq_s16(prev, curr);
      int16x8_t nxtd = vsubq_s16(next, curr);
      int16x8_t even = vaddq_s16(curs, prvd);
      int16x8_t odd  = vaddq_s16(curs, nxtd);

      // undo scaling and round, then store with even/odd phases interleaved
      uint8x8x2_t o;
      o.val[0] = vqrshrun_n_s16(even, 4);
      o.val[1] = vqrshrun_n_s16(odd,  4);
      vst2_u8(out + i*2, o);
#endif

      // "previous" value for next iter
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}
#endif

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}

// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); // alpha channel

      for (; i+7 < count; i += 8) {
         // load
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

         // unpack to short (and left-shift cr, cb by 8)
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         // color transform
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         // descale
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         // back to byte, set up for transpose
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         // transpose to interleave channels
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         // store
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      uint8x8_t signflip = vdup_n_u8(0x80);
      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

      for (; i+7 < count; i += 8) {
         // load
         uint8x8_t y_bytes  = vld1_u8(y + i);
         uint8x8_t cr_bytes = vld1_u8(pcr + i);
         uint8x8_t cb_bytes = vld1_u8(pcb + i);
         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

         // expand to s16
         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
         int16x8_t crw = vshll_n_s8(cr_biased, 7);
         int16x8_t cbw = vshll_n_s8(cb_biased, 7);

         // color transform
         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
         int16x8_t rws = vaddq_s16(yws, cr0);
         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
         int16x8_t bws = vaddq_s16(yws, cb1);

         // undo scaling, round, convert to byte
         uint8x8x4_t o;
         o.val[0] = vqrshrun_n_s16(rws, 4);
         o.val[1] = vqrshrun_n_s16(gws, 4);
         o.val[2] = vqrshrun_n_s16(bws, 4);
         o.val[3] = vdup_n_u8(255);

         // store, interleaving r/g/b/a
         vst4_u8(out, o);
         out += 8*4;
      }
   }
#endif

   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* stbi__float2fixed(1.40200f);
      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
   resample_row_func resample;
   stbi_uc *line0,*line1;
   int hs,vs;   // expansion factor in each axis
   int w_lores; // horizontal pixels pre-expansion
   int ystep;   // how far through vertical expansion we are
   int ypos;    // which pre-expansion row we're on
} stbi__resample;

// fast 0..255 * 0..255 => 0..255 rounded multiplication
static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   // nothing to do if no components requested; check this now to avoid
   // accessing uninitialized coutput[0] later
   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

   // resample and color-convert
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

      // now go ahead and resample
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { // CMYK
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { // YCCK
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { // YCbCr + alpha?  Ignore the fourth channel for now
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
      return output;
   }
}

static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__errpuc("outofmem", "Out of memory");
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__err("outofmem", "Out of memory");
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   if (!j) return stbi__err("outofmem", "Out of memory");
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
   stbi__uint16 firstcode[16];
   int maxcode[17];
   stbi__uint16 firstsymbol[16];
   stbi_uc  size[STBI__ZNSYMS];
   stbi__uint16 value[STBI__ZNSYMS];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err("bad sizes", "Corrupt PNG");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= STBI__ZFAST_BITS) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << STBI__ZFAST_BITS)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
   stbi_uc *zbuffer, *zbuffer_end;
   int num_bits;
   stbi__uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int   z_expandable;

   stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static int stbi__zeof(stbi__zbuf *z)
{
   return (z->zbuffer >= z->zbuffer_end);
}

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   return stbi__zeof(z) ? 0 : *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      if (z->code_buffer >= (1U << z->num_bits)) {
        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
        return;
      }
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s >= 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) {
      if (stbi__zeof(a)) {
         return -1;   /* report error for unexpected end of data. */
      }
      stbi__fill_bits(a);
   }
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   unsigned int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
   cur   = (unsigned int) (z->zout - z->zout_start);
   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
   if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
   while (cur + n > limit) {
      if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
      limit *= 2;
   }
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err("outofmem", "Out of memory");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}

static const int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static const int stbi__zlength_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static const int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            return 1;
         }
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
         if (zout + len > a->zout_end) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { // run of one byte; common in images.
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
            fill = lencodes[n-1];
         } else if (c == 17) {
            c = stbi__zreceive(a,3)+3;
         } else if (c == 18) {
            c = stbi__zreceive(a,7)+11;
         } else {
            return stbi__err("bad codelengths", "Corrupt PNG");
         }
         if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
   // now fill header the normal way
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}

static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};
/*
Init algorithm:
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;

   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
}
*/

static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}

STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
   stbi__uint32 length;
   stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}

static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
   return 1;
}

typedef struct
{
   stbi__context *s;
   stbi_uc *idata, *expanded, *out;
   int depth;
} stbi__png;


enum {
   STBI__F_none=0,
   STBI__F_sub=1,
   STBI__F_up=2,
   STBI__F_avg=3,
   STBI__F_paeth=4,
   // synthetic filters used for first scanline to avoid needing a dummy row of 0s
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err("outofmem", "Out of memory");

   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   img_len = (img_width_bytes + 1) * y;

   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
   // so just check for raw_len < img_len always.
   if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

   for (j=0; j < y; ++j) {
      stbi_uc *cur = a->out + stride*j;
      stbi_uc *prior;
      int filter = *raw++;

      if (filter > 4)
         return stbi__err("invalid filter","Corrupt PNG");

      if (depth < 8) {
         if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
         filter_bytes = 1;
         width = img_width_bytes;
      }
      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];

      // handle first byte explicitly
      for (k=0; k < filter_bytes; ++k) {
         switch (filter) {
            case STBI__F_none       : cur[k] = raw[k]; break;
            case STBI__F_sub        : cur[k] = raw[k]; break;
            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
            case STBI__F_avg_first  : cur[k] = raw[k]; break;
            case STBI__F_paeth_first: cur[k] = raw[k]; break;
         }
      }

      if (depth == 8) {
         if (img_n != out_n)
            cur[img_n] = 255; // first pixel
         raw += img_n;
         cur += out_n;
         prior += out_n;
      } else if (depth == 16) {
         if (img_n != out_n) {
            cur[filter_bytes]   = 255; // first pixel top byte
            cur[filter_bytes+1] = 255; // first pixel bottom byte
         }
         raw += filter_bytes;
         cur += output_bytes;
         prior += output_bytes;
      } else {
         raw += 1;
         cur += 1;
         prior += 1;
      }

      // this is a little gross, so that we don't switch per-pixel or per-component
      if (depth < 8 || img_n == out_n) {
         int nk = (width - 1)*filter_bytes;
         #define STBI__CASE(f) \
             case f:     \
                for (k=0; k < nk; ++k)
         switch (filter) {
            // "none" filter turns into a memcpy here; make that explicit.
            case STBI__F_none:         memcpy(cur, raw, nk); break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
         }
         #undef STBI__CASE
         raw += nk;
      } else {
         STBI_ASSERT(img_n+1 == out_n);
         #define STBI__CASE(f) \
             case f:     \
                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
                   for (k=0; k < filter_bytes; ++k)
         switch (filter) {
            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
         }
         #undef STBI__CASE

         // the loop above sets the high byte of the pixels' alpha, but for
         // 16 bit png files we also need the low byte set. we'll do that here.
         if (depth == 16) {
            cur = a->out + stride*j; // start at the beginning of the row again
            for (i=0; i < x; ++i,cur+=output_bytes) {
               cur[filter_bytes+1] = 255;
            }
         }
      }
   }

   // we make a separate pass to expand bits to pixels; for performance,
   // this could run two scanlines behind the above code, so it won't
   // intefere with filtering but will still be in the cache.
   if (depth < 8) {
      for (j=0; j < y; ++j) {
         stbi_uc *cur = a->out + stride*j;
         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

         // note that the final byte might overshoot and write more data than desired.
         // we can allocate enough data that this never writes out of memory, but it
         // could also overwrite the next scanline. can it overwrite non-empty data
         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
         // so we need to explicitly clamp the final ones

         if (depth == 4) {
            for (k=x*img_n; k >= 2; k-=2, ++in) {
               *cur++ = scale * ((*in >> 4)       );
               *cur++ = scale * ((*in     ) & 0x0f);
            }
            if (k > 0) *cur++ = scale * ((*in >> 4)       );
         } else if (depth == 2) {
            for (k=x*img_n; k >= 4; k-=4, ++in) {
               *cur++ = scale * ((*in >> 6)       );
               *cur++ = scale * ((*in >> 4) & 0x03);
               *cur++ = scale * ((*in >> 2) & 0x03);
               *cur++ = scale * ((*in     ) & 0x03);
            }
            if (k > 0) *cur++ = scale * ((*in >> 6)       );
            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
         } else if (depth == 1) {
            for (k=x*img_n; k >= 8; k-=8, ++in) {
               *cur++ = scale * ((*in >> 7)       );
               *cur++ = scale * ((*in >> 6) & 0x01);
               *cur++ = scale * ((*in >> 5) & 0x01);
               *cur++ = scale * ((*in >> 4) & 0x01);
               *cur++ = scale * ((*in >> 3) & 0x01);
               *cur++ = scale * ((*in >> 2) & 0x01);
               *cur++ = scale * ((*in >> 1) & 0x01);
               *cur++ = scale * ((*in     ) & 0x01);
            }
            if (k > 0) *cur++ = scale * ((*in >> 7)       );
            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
         }
         if (img_n != out_n) {
            int q;
            // insert alpha = 255
            cur = a->out + stride*j;
            if (img_n == 1) {
               for (q=x-1; q >= 0; --q) {
                  cur[q*2+1] = 255;
                  cur[q*2+0] = cur[q];
               }
            } else {
               STBI_ASSERT(img_n == 3);
               for (q=x-1; q >= 0; --q) {
                  cur[q*4+3] = 255;
                  cur[q*4+2] = cur[q*3+2];
                  cur[q*4+1] = cur[q*3+1];
                  cur[q*4+0] = cur[q*3+0];
               }
            }
         }
      }
   } else if (depth == 16) {
      // force the image data from big-endian to platform-native.
      // this is done in a separate pass due to the decoding relying
      // on the data being untouched, but could probably be done
      // per-line during decode if care is taken.
      stbi_uc *cur = a->out;
      stbi__uint16 *cur16 = (stbi__uint16*)cur;

      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
         *cur16 = (cur[0] << 8) | cur[1];
      }
   }

   return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   if (!final) return stbi__err("outofmem", "Out of memory");
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            STBI_FREE(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         STBI_FREE(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err("outofmem", "Out of memory");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}

static int stbi__unpremultiply_on_load_global = 0;
static int stbi__de_iphone_flag_global = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_global = flag_true_if_should_convert;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
#define stbi__de_iphone_flag  stbi__de_iphone_flag_global
#else
static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;

STBIDEF void stbi__unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
   stbi__unpremultiply_on_load_set = 1;
}

STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_local = flag_true_if_should_convert;
   stbi__de_iphone_flag_set = 1;
}

#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
                                       ? stbi__unpremultiply_on_load_local      \
                                       : stbi__unpremultiply_on_load_global)
#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
                                ? stbi__de_iphone_flag_local                    \
                                : stbi__de_iphone_flag_global)
#endif // STBI_THREAD_LOCAL

static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      STBI_ASSERT(s->img_out_n == 4);
      if (stbi__unpremultiply_on_load) {
         // convert bgr to rgb and unpremultiply
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         // convert bgr to rgb
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}

#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))

static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3]={0};
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case STBI__PNG_TYPE('C','g','B','I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case STBI__PNG_TYPE('I','H','D','R'): {
            int comp,filter;
            if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
            first = 0;
            if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
            s->img_x = stbi__get32be(s);
            s->img_y = stbi__get32be(s);
            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
               if (scan == STBI__SCAN_header) return 1;
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
               // if SCAN_header, have to scan to see if we have a tRNS
            }
            break;
         }

         case STBI__PNG_TYPE('P','L','T','E'):  {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case STBI__PNG_TYPE('t','R','N','S'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
               if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
               has_trans = 1;
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
               } else {
                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
               }
            }
            break;
         }

         case STBI__PNG_TYPE('I','D','A','T'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               STBI_NOTUSED(idata_limit_old);
               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
            ioff += c.length;
            break;
         }

         case STBI__PNG_TYPE('I','E','N','D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               // non-paletted image with tRNS -> source image has (constant) alpha
               ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
         }

         default:
            // if critical, fail
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = "XXXX PNG chunk not known";
               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
               #endif
               return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
            }
            stbi__skip(s, c.length);
            break;
      }
      // end of PNG chunk, read and skip CRC
      stbi__get32be(s);
   }
}

static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth <= 8)
         ri->bits_per_channel = 8;
      else if (p->depth == 16)
         ri->bits_per_channel = 16;
      else
         return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}

static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}

static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}

static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
	   return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}

static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}


// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) { n += 16; z >>= 16; }
   if (z >= 0x00100) { n +=  8; z >>=  8; }
   if (z >= 0x00010) { n +=  4; z >>=  4; }
   if (z >= 0x00004) { n +=  2; z >>=  2; }
   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
   return n;
}

static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}

// extract an arbitrarily-aligned N-bit value (N=bits)
// from v, and then make it 8-bits long and fractionally
// extend it to full full range.
static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   STBI_ASSERT(v < 256);
   v >>= (8-bits);
   STBI_ASSERT(bits >= 0 && bits <= 8);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}

typedef struct
{
   int bpp, offset, hsz;
   unsigned int mr,mg,mb,ma, all_a;
   int extra_read;
} stbi__bmp_data;

static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
{
   // BI_BITFIELDS specifies masks explicitly, don't override
   if (compress == 3)
      return 1;

   if (compress == 0) {
      if (info->bpp == 16) {
         info->mr = 31u << 10;
         info->mg = 31u <<  5;
         info->mb = 31u <<  0;
      } else if (info->bpp == 32) {
         info->mr = 0xffu << 16;
         info->mg = 0xffu <<  8;
         info->mb = 0xffu <<  0;
         info->ma = 0xffu << 24;
         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
      } else {
         // otherwise, use defaults, which is all-0
         info->mr = info->mg = info->mb = info->ma = 0;
      }
      return 1;
   }
   return 0; // error
}

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;
   info->extra_read = 14;

   if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
      if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
      stbi__get32le(s); // discard sizeof
      stbi__get32le(s); // discard hres
      stbi__get32le(s); // discard vres
      stbi__get32le(s); // discard colorsused
      stbi__get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               stbi__bmp_set_mask_defaults(info, compress);
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               info->extra_read += 12;
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return stbi__errpuc("bad BMP", "bad BMP");
               }
            } else
               return stbi__errpuc("bad BMP", "bad BMP");
         }
      } else {
         // V4/V5 header
         int i;
         if (hsz != 108 && hsz != 124)
            return stbi__errpuc("bad BMP", "bad BMP");
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
            stbi__bmp_set_mask_defaults(info, compress);
         stbi__get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            stbi__get32le(s); // discard color space parameters
         if (hsz == 124) {
            stbi__get32le(s); // discard rendering intent
            stbi__get32le(s); // discard offset of profile data
            stbi__get32le(s); // discard size of profile data
            stbi__get32le(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}


static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
      return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - info.extra_read - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - info.extra_read - info.hsz) >> 2;
   }
   if (psize == 0) {
      if (info.offset != s->callback_already_read + (s->img_buffer - s->img_buffer_original)) {
        return stbi__errpuc("bad offset", "Corrupt BMP");
      }
   }

   if (info.bpp == 24 && ma == 0xff000000)
      s->img_n = 3;
   else
      s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return stbi__errpuc("too large", "Corrupt BMP");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - info.extra_read - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
         // right shift amt to put high bit in position #7
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = STBI__BYTECAST(a);
            }
         }
         stbi__skip(s, pad);
      }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
// returns STBI_rgb or whatever, 0 on error
static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
               // fallthrough
      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24: // fallthrough
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s,9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
      sz = stbi__get8(s);    //   check bits per palette color entry
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       // skip image x and y origin
   } else { // "normal" image w/o colormap
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
      stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}

// read 16bit value and convert to 24bit RGB
static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the "image descriptor byte")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}

static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);
   STBI_NOTUSED(tga_x_origin); // @TODO
   STBI_NOTUSED(tga_y_origin); // @TODO

   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
      return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return stbi__errpuc("too large", "Corrupt TGA");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      //   do I need to load a palette?
      if ( tga_indexed)
      {
         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
            STBI_FREE(tga_data);
            return stbi__errpuc("bad palette", "Corrupt TGA");
         }

         //   any data to skip? (offset usually = 0)
         stbi__skip(s, tga_palette_start );
         //   load the palette
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            STBI_FREE(tga_data);
            return stbi__errpuc("outofmem", "Out of memory");
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            STBI_ASSERT(tga_comp == STBI_rgb);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               STBI_FREE(tga_data);
               STBI_FREE(tga_palette);
               return stbi__errpuc("bad palette", "Corrupt TGA");
         }
      }
      //   load the data
      for (i=0; i < tga_width * tga_height; ++i)
      {
         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               //   yep, get the next byte as a RLE command
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         //   OK, if I need to read a pixel, do it now
         if ( read_next_pixel )
         {
            //   load however much data we did have
            if ( tga_indexed )
            {
               // read in index, then perform the lookup
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  // invalid index
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               STBI_ASSERT(tga_comp == STBI_rgb);
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               //   read in the data raw
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            //   clear the reading flag for the next pixel
            read_next_pixel = 0;
         } // end of reading a pixel

         // copy data
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         //   in case we're in RLE mode, keep counting down
         --RLE_count;
      }
      //   do I need to invert the image?
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      //   clear my palette, if I had one
      if ( tga_palette != NULL )
      {
         STBI_FREE( tga_palette );
      }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   STBI_NOTUSED(tga_palette_start);
   //   OK, done
   return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}

static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         // No-op.
      } else if (len < 128) {
         // Copy next len+1 bytes literally.
         len++;
         if (len > nleft) return 0; // corrupt data
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         // Next -len+1 bytes in the dest are replicated from next source byte.
         // (Interpret len as a negative 8-bit int.)
         len = 257 - len;
         if (len > nleft) return 0; // corrupt data
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}

static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
      return stbi__errpuc("not PSD", "Corrupt PSD image");

   // Check file type version.
   if (stbi__get16be(s) != 1)
      return stbi__errpuc("wrong version", "Unsupported version of PSD image");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
      return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
      return stbi__errpuc("bad compression", "PSD has an unknown compression format");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return stbi__errpuc("too large", "Corrupt PSD");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      stbi__skip(s, h * channelCount * 2 );

      // Read the RLE data by channel.
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            // Fill this channel with default data.
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            // Read the RLE data.
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               STBI_FREE(out);
               return stbi__errpuc("corrupt", "bad RLE data");
            }
         }
      }

   } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

      // Read the data by channel.
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            // Fill this channel with default data.
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    // output bpc
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  // input bpc
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,"PICT"))
      return 0;

   return 1;
}

typedef struct
{
   stbi_uc size,type,channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}

static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask = 0x80, i;

   for (i = 0; i < 4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp = 0, num_packets = 0 , y, chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
    // for the same channel in multiple packets.
   do {
      stbi__pic_packet* packet;

      if (num_packets == sizeof(packets)/sizeof(packets[0]))
         return stbi__errpuc("bad format","too many packets");

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return stbi__errpuc("bad format","packet has bad compression type");

            case 0: {//uncompressed
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1://Pure RLE
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {//Mixed RLE
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

                  if (count >= 128) { // Repeated
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return stbi__errpuc("bad file","scanline overrun");

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { // Raw
                     ++count;
                     if (count>left) return stbi__errpuc("bad file","scanline overrun");

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}

static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);

   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   if (!result) return stbi__errpuc("outofmem", "Out of memory");
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}

static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
   stbi__int16 prefix;
   stbi_uc first;
   stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
   int w,h;
   stbi_uc *out;                 // output buffer (always 4 components)
   stbi_uc *background;          // The current "background" as far as a gif is concerned
   stbi_uc *history;
   int flags, bgindex, ratio, transparent, eflags;
   stbi_uc  pal[256][4];
   stbi_uc lpal[256][4];
   stbi__gif_lzw codes[8192];
   stbi_uc *color_table;
   int parse, step;
   int lflags;
   int start_x, start_y;
   int max_x, max_y;
   int cur_x, cur_y;
   int line_size;
   int delay;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}

static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err("not GIF", "Corrupt GIF");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

   stbi__g_failure_reason = "";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!g) return stbi__err("outofmem", "Out of memory");
   if (!stbi__gif_header(s, g, comp, 1)) {
      STBI_FREE(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;
   int idx;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   idx = g->cur_x + g->cur_y;
   p = &g->out[idx];
   g->history[idx / 4] = 1;

   c = &g->color_table[g->codes[code].suffix * 4];
   if (c[3] > 128) { // don't render transparent pixels;
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); // start new block
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
         if (code == clear) {  // clear code
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { // end of stream code
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) {
               return stbi__errpuc("no clear code", "Corrupt GIF");
            }

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 8192) {
                  return stbi__errpuc("too many codes", "Corrupt GIF");
               }

               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return stbi__errpuc("illegal code in raster", "Corrupt GIF");

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return stbi__errpuc("illegal code in raster", "Corrupt GIF");
         }
      }
   }
}

// this function is designed to support animated gifs, although stb_image doesn't support it
// two back is the image from two frames ago, used for a very specific disposal format
static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
   int dispose;
   int first_frame;
   int pi;
   int pcount;
   STBI_NOTUSED(req_comp);

   // on first frame, any non-written pixels get the background colour (non-transparent)
   first_frame = 0;
   if (g->out == 0) {
      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
         return stbi__errpuc("too large", "GIF image is too large");
      pcount = g->w * g->h;
      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
      g->history = (stbi_uc *) stbi__malloc(pcount);
      if (!g->out || !g->background || !g->history)
         return stbi__errpuc("outofmem", "Out of memory");

      // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
      // background colour is only used for pixels that are not rendered first frame, after that "background"
      // color refers to the color that was there the previous frame.
      memset(g->out, 0x00, 4 * pcount);
      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
      first_frame = 1;
   } else {
      // second frame - how do we dispose of the previous one?
      dispose = (g->eflags & 0x1C) >> 2;
      pcount = g->w * g->h;

      if ((dispose == 3) && (two_back == 0)) {
         dispose = 2; // if I don't have an image to revert back to, default to the old background
      }

      if (dispose == 3) { // use previous graphic
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
            }
         }
      } else if (dispose == 2) {
         // restore what was changed last frame to background before that frame;
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
            }
         }
      } else {
         // This is a non-disposal case eithe way, so just
         // leave the pixels as is, and they will become the new background
         // 1: do not dispose
         // 0:  not specified.
      }

      // background is what out is after the undoing of the previou frame;
      memcpy( g->background, g->out, 4 * g->w * g->h );
   }

   // clear my history;
   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

   for (;;) {
      int tag = stbi__get8(s);
      switch (tag) {
         case 0x2C: /* Image Descriptor */
         {
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
               g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; // first interlaced spacing
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               g->color_table = (stbi_uc *) g->pal;
            } else
               return stbi__errpuc("missing color table", "Corrupt GIF");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
               // if first frame, any pixel not drawn to gets the background color
               for (pi = 0; pi < pcount; ++pi) {
                  if (g->history[pi] == 0) {
                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
                  }
               }
            }

            return o;
         }

         case 0x21: // Comment Extension.
         {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                  // unset old transparent
                  if (g->transparent >= 0) {
                     g->pal[g->transparent][3] = 255;
                  }
                  if (g->eflags & 0x01) {
                     g->transparent = stbi__get8(s);
                     if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 0;
                     }
                  } else {
                     // don't need transparent
                     stbi__skip(s, 1);
                     g->transparent = -1;
                  }
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0) {
               stbi__skip(s, len);
            }
            break;
         }

         case 0x3B: // gif stream termination code
            return (stbi_uc *) s; // using '1' causes warning on some compilers

         default:
            return stbi__errpuc("unknown code", "Corrupt GIF");
      }
   }
}

static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
{
   STBI_FREE(g->out);
   STBI_FREE(g->history);
   STBI_FREE(g->background);

   if (out) STBI_FREE(out);
   if (delays && *delays) STBI_FREE(*delays);
   return stbi__errpuc("outofmem", "Out of memory");
}

static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
      int layers = 0;
      stbi_uc *u = 0;
      stbi_uc *out = 0;
      stbi_uc *two_back = 0;
      stbi__gif g;
      int stride;
      int out_size = 0;
      int delays_size = 0;

      STBI_NOTUSED(out_size);
      STBI_NOTUSED(delays_size);

      memset(&g, 0, sizeof(g));
      if (delays) {
         *delays = 0;
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
               if (!tmp)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               else {
                   out = (stbi_uc*) tmp;
                   out_size = layers * stride;
               }

               if (delays) {
                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
                  if (!new_delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  *delays = new_delays;
                  delays_size = layers * sizeof(int);
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (!out)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               out_size = layers * stride;
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
                  if (!*delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  delays_size = layers * sizeof(int);
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

      // free temp buffer;
      STBI_FREE(g.out);
      STBI_FREE(g.history);
      STBI_FREE(g.background);

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

      *z = layers;
      return out;
   } else {
      return stbi__errpuc("not GIF", "Image was not as a gif type.");
   }
}

static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
      *x = g.w;
      *y = g.h;

      // moved conversion to after successful load so that the same
      // can be done for multiple frames.
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
   } else if (g.out) {
      // if there was an error and we allocated an image buffer, free it!
      STBI_FREE(g.out);
   }

   // free buffers needed for multiple frame loading;
   STBI_FREE(g.history);
   STBI_FREE(g.background);

   return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, "#?RGBE\n");
       stbi__rewind(s);
   }
   return r;
}

#define STBI__HDR_BUFLEN  1024
static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == STBI__HDR_BUFLEN-1) {
         // flush to end of line
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   STBI_NOTUSED(ri);

   // Check identifier
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
      return stbi__errpf("not HDR", "Corrupt HDR image");

   // Parse header
   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return stbi__errpf("too large", "HDR image is too large");

   // Read data
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return stbi__errpf("outofmem", "Out of memory");

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
      // Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {
      // Read RLE-encoded data
      scanline = NULL;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            STBI_FREE(scanline);
            goto main_decode_loop; // yes, this makes no sense
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
         if (scanline == NULL) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               STBI_FREE(hdr_data);
               return stbi__errpf("outofmem", "Out of memory");
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {
                  // Run
                  value = stbi__get8(s);
                  count -= 128;
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {
                  // Dump
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         STBI_FREE(scanline);
   }

   return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   if (p == NULL) {
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) {
      if (info.bpp == 24 && info.ma == 0xff000000)
         *comp = 3;
      else
         *comp = info.ma ? 4 : 3;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy, depth;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 8 && depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}

static int stbi__psd_is16(stbi__context *s)
{
   int channelCount, depth;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   STBI_NOTUSED(stbi__get32be(s));
   STBI_NOTUSED(stbi__get32be(s));
   depth = stbi__get16be(s);
   if (depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}

static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   STBI_NOTUSED(ri);

   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
   if (ri->bits_per_channel == 0)
      return 0;

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
      return stbi__errpuc("too large", "PNM too large");


   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));

   if (req_comp && req_comp != s->img_n) {
      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (
               !stbi__at_eof(s) &&
               (*c == ' ' || *c == '\t' || *c == '\n' || *c == '\v' || *c == '\f' || *c == '\r')
            )
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}

static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9'; 
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
   }

   return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value
   if (maxv > 65535)
      return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");
   else if (maxv > 255)
      return 16;
   else
      return 8;
}

static int stbi__pnm_is16(stbi__context *s)
{
   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
	   return 1;
   return 0;
}
#endif

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
       return 1;
   #endif
   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

static int stbi__is_16_main(stbi__context *s)
{
   #ifndef STBI_NO_PNG
   if (stbi__png_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_is16(s))  return 1;
   #endif
   return 0;
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}

STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}

STBIDEF int stbi_is_16_bit(char const *filename)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}

STBIDEF int stbi_is_16_bit_from_file(FILE *f)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__is_16_main(&s);
   fseek(f,pos,SEEK_SET);
   return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__is_16_main(&s);
}

STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__is_16_main(&s);
}

#endif // STB_IMAGE_IMPLEMENTATION

/*
   revision history:
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
                         1-bit BMP
                         *_is_16_bit api
                         avoid warnings
      2.16  (2017-07-23) all functions have 16-bit variants;
                         STBI_NO_STDIO works again;
                         compilation fixes;
                         fix rounding in unpremultiply;
                         optimize vertical flip;
                         disable raw_len validation;
                         documentation fixes
      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
                         warning fixes; disable run-time SSE detection on gcc;
                         uniform handling of optional "return" values;
                         thread-safe initialization of zlib tables
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) allocate large structures on the stack
                         remove white matting for transparent PSD
                         fix reported channel count for PNG & BMP
                         re-enable SSE2 in non-gcc 64-bit
                         support RGB-formatted JPEG
                         read 16-bit PNGs (only as 8-bit)
      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
      2.09  (2016-01-16) allow comments in PNM files
                         16-bit-per-pixel TGA (not bit-per-component)
                         info() for TGA could break due to .hdr handling
                         info() for BMP to shares code instead of sloppy parse
                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc
                         code cleanup
      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
      2.07  (2015-09-13) fix compiler warnings
                         partial animated GIF support
                         limited 16-bpc PSD support
                         #ifdef unused functions
                         bug with < 92 byte PIC,PNM,HDR,TGA
      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
      2.03  (2015-04-12) extra corruption checking (mmozeiko)
                         stbi_set_flip_vertically_on_load (nguillemot)
                         fix NEON support; fix mingw support
      2.02  (2015-01-19) fix incorrect assert, fix warning
      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
                         progressive JPEG (stb)
                         PGM/PPM support (Ken Miller)
                         STBI_MALLOC,STBI_REALLOC,STBI_FREE
                         GIF bugfix -- seemingly never worked
                         STBI_NO_*, STBI_ONLY_*
      1.48  (2014-12-14) fix incorrectly-named assert()
      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
                         optimize PNG (ryg)
                         fix bug in interlaced PNG with user-specified channel count (stb)
      1.46  (2014-08-26)
              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
      1.45  (2014-08-16)
              fix MSVC-ARM internal compiler error by wrapping malloc
      1.44  (2014-08-07)
              various warning fixes from Ronny Chevalier
      1.43  (2014-07-15)
              fix MSVC-only compiler problem in code changed in 1.42
      1.42  (2014-07-09)
              don't define _CRT_SECURE_NO_WARNINGS (affects user code)
              fixes to stbi__cleanup_jpeg path
              added STBI_ASSERT to avoid requiring assert.h
      1.41  (2014-06-25)
              fix search&replace from 1.36 that messed up comments/error messages
      1.40  (2014-06-22)
              fix gcc struct-initialization warning
      1.39  (2014-06-15)
              fix to TGA optimization when req_comp != number of components in TGA;
              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
              add support for BMP version 5 (more ignored fields)
      1.38  (2014-06-06)
              suppress MSVC warnings on integer casts truncating values
              fix accidental rename of 'skip' field of I/O
      1.37  (2014-06-04)
              remove duplicate typedef
      1.36  (2014-06-03)
              convert to header file single-file library
              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
      1.35  (2014-05-27)
              various warnings
              fix broken STBI_SIMD path
              fix bug where stbi_load_from_file no longer left file pointer in correct place
              fix broken non-easy path for 32-bit BMP (possibly never used)
              TGA optimization by Arseny Kapoulkine
      1.34  (unknown)
              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
      1.33  (2011-07-14)
              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
      1.32  (2011-07-13)
              support for "info" function for all supported filetypes (SpartanJ)
      1.31  (2011-06-20)
              a few more leak fixes, bug in PNG handling (SpartanJ)
      1.30  (2011-06-11)
              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
              removed deprecated format-specific test/load functions
              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
              fix inefficiency in decoding 32-bit BMP (David Woo)
      1.29  (2010-08-16)
              various warning fixes from Aurelien Pocheville
      1.28  (2010-08-01)
              fix bug in GIF palette transparency (SpartanJ)
      1.27  (2010-08-01)
              cast-to-stbi_uc to fix warnings
      1.26  (2010-07-24)
              fix bug in file buffering for PNG reported by SpartanJ
      1.25  (2010-07-17)
              refix trans_data warning (Won Chun)
      1.24  (2010-07-12)
              perf improvements reading from files on platforms with lock-heavy fgetc()
              minor perf improvements for jpeg
              deprecated type-specific functions so we'll get feedback if they're needed
              attempt to fix trans_data warning (Won Chun)
      1.23    fixed bug in iPhone support
      1.22  (2010-07-10)
              removed image *writing* support
              stbi_info support from Jetro Lauha
              GIF support from Jean-Marc Lienher
              iPhone PNG-extensions from James Brown
              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
      1.21    fix use of 'stbi_uc' in header (reported by jon blow)
      1.20    added support for Softimage PIC, by Tom Seddon
      1.19    bug in interlaced PNG corruption check (found by ryg)
      1.18  (2008-08-02)
              fix a threading bug (local mutable static)
      1.17    support interlaced PNG
      1.16    major bugfix - stbi__convert_format converted one too many pixels
      1.15    initialize some fields for thread safety
      1.14    fix threadsafe conversion bug
              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
      1.13    threadsafe
      1.12    const qualifiers in the API
      1.11    Support installable IDCT, colorspace conversion routines
      1.10    Fixes for 64-bit (don't use "unsigned long")
              optimized upsampling by Fabian "ryg" Giesen
      1.09    Fix format-conversion for PSD code (bad global variables!)
      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
      1.07    attempt to fix C++ warning/errors again
      1.06    attempt to fix C++ warning/errors again
      1.05    fix TGA loading to return correct *comp and use good luminance calc
      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
      1.02    support for (subset of) HDR files, float interface for preferred access to them
      1.01    fix bug: possible bug in handling right-side up bmps... not sure
              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
      1.00    interface to zlib that skips zlib header
      0.99    correct handling of alpha in palette
      0.98    TGA loader by lonesock; dynamically add loaders (untested)
      0.97    jpeg errors on too large a file; also catch another malloc failure
      0.96    fix detection of invalid v value - particleman@mollyrocket forum
      0.95    during header scan, seek to markers in case of padding
      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
      0.93    handle jpegtran output; verbose errors
      0.92    read 4,8,16,24,32-bit BMP files of several formats
      0.91    output 24-bit Windows 3.0 BMP files
      0.90    fix a few more warnings; bump version number to approach 1.0
      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
      0.60    fix compiling as c++
      0.59    fix warnings: merge Dave Moore's -Wall fixes
      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
      0.56    fix bug: zlib uncompressed mode len vs. nlen
      0.55    fix bug: restart_interval not initialized to 0
      0.54    allow NULL for 'int *comp'
      0.53    fix bug in png 3->4; speedup png decoding
      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
              on 'test' only check type, not whether we support this variant
      0.50  (2006-11-19)
              first released version
*/


/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
 JFIF       C 		
 $.' ",#(7),01444'9=82<.342 C			2!!22222222222222222222222222222222222222222222222222 
"                <   !1AQaq"2#BR3r$b4C              (      !1AQ"2Ba#qR   ? #'Spi \\\YY@FH-14.7{6 HB@NT2P8
M,	O#\UX	>). +J)JIMe_Y:H+rvN(Jfw=zV:yIoUX {lnU/3+ n|-i,aWF_ 7?e+^ t]9R2i L4 + f(Tsz	_x P i>S-mLF;|\q;Z$U&)W5P P,&kkifckb@$7&6Q_{I oN&&GUi 9AW|^}!$^O)\H2LBP-- 'z55}s8U~kqsK>J5 ilVnXO
AF'8	Pn.IEq "8@F=yA0A&@q-}QxQT=T o8!C EfJdV%z"@ =Xm~9%.P! l}|P:#kUMq1$w;PRXH)O84di(4W$	&teqiS{BtgWX@aib<(.DTk@:"$T-52 ed*7FNS)}3HqW_l+Ly
F\}<7VtWD<
v*l"+Ljd0y
I<)a-D 
2:JntwTz#c
[%lM|K2Vzbh`YspcQOC}h*0S gI+I!2CTS';H1ouwNHUfc%y*2A6B2GsD)&5!p ?+S>Sk`F`>Sb AU>[^h2k}JIc3$q;&icLk~%T'juxnh^T;;]["Y7{m
7xwp* <h1?0@"3$=}@O,8=}
. rut]
B0A|,Y{$@0P1&hZ)I J7e)`>	Jq  R d?D7Q@
=At +YRznRU1A PdZBr}<*d@)
t8)G8?/smdgLi=$~B_D  '3HtW9b)FeXi)MG*E:Rc+=p9VXW*]!L  8$YGU ,xf^IM0H
X!\uxMGU@%4}#YZ$rKrcZdu-sCX9iyFBC<B"Z;@zFC=G`IQW= ZC`:?heJ)d3t.7Pn?Y&SMR08Y&IV4W!-}=%esO-pB	Gwy4ZwP((ad>PIkLLc_E,BW8Y S10p<);	e @s~e^v*c^-MW!M(KaRb"aBU%s$$'u{Q &![A ,'Lf99,Eoa*#pu.$D^R42F#bm7V1A8VA]+;Hp}6VH_DX}y  P6R e.~A /( /( ;%x@	?;%Jd_ %pt| q  /<(!G7"7~U[R[Wsf?2T)bK(wY#)Ho	w.(f{
meu'Y,z)F85gK'JtX r 5&*QC\(,o[9 RL3U)I-zRW4bqZVAcpWcuU H'.Zs e8!hruMDl/ OcKdkp@JS%%FBR d&N?!nSE5pJLBZm2Kz?wI&kdE H$k
{[!|shu,NNDw8x[G<MG__MT]1'&a\*;d(oqm@J|aLw
5@1pqhG)$^6Vl}Qw4)*2Z,^Mb({+I 7pn^H{48Q#[.LK 5|cDeu1 ([oFSb f]|d
B=Uy`'!RbhV?& &s.`>XLA VyCkl+V$n 
z6)hmYFP.#(@E (d Y"/`@<Z ?o	J^(`%_BP~  Dlg) 
 )H^rL*5-PQ+.8U%G3B
2	H;P<{&'` *Rlt+@H4~7
B](0AcTwcM}@#o9YDM+FrEh^I5xNnI$
H;*?kXQ2GO VEN	Z(X0k TMSN$v@e.r~dC5Jy.i.BBZ{psu]2XDS #$S;i"FMa%e$_@bh4nx`Sx-*|p9*6S0MYFEnlHUFkK{t,-N-sJMp}qtdyF~YLpZ4xpt?~N	|%W3N{#8IBQ<#}^
IiaOO91#2);6-+uJ~D /[HM2GnQ*g&yLN5sdnA<4g29+A yR:vY8"9tYX_9uLOVV "HY'e\h@;&mc _pR8F\k dTYh''i3qK[!GxI<(Z65Fm0 #+ o;"7 .m( #t( l  ~{ (JIK9o* ilfZax$[v~k?2`8J.WPGi
>.X5WiU ;)#D@9	$ =;?uqHW\[0ik)'(5
eu6\[HNZmrA&78J)::\.k[< -ka~V^/j>[KNn0''EF6V9Z,)(s%Y`};:}`DZ5G@GM]l6K-cZmXK/wEgIa$$zd;54Nq
Zp8v!rE_NO>|yZ<ge4jxY|%5GL	Ao)h $6;5c.k> 6R[fYD8PXMR{8'0TH}Vd`6>w[M)zPwpUE__  P#NGKX ?l%cdQ/8@	@JT [/###R? pxF#~K?dpi (" &&"4C	$ PZFm~t~5eY$vGq~tgWp>;t*4vxI?/Y!qu`)8j&8lH;Smz/f\7KkQZKN1^W4`mq{,+%wGoOxi74d&pmA1Ild|Z,P2ME#9lMIE#U$P93Q^O` O|<f	| 9sJID d kK 9P4Qk#8B,w{$ ,fkO6o+R'ZF:8@ W`mlI+<qq+J'`F(MY@n THuMXN/)S9LDrE
W$;UueK(G5wi
V/eL#	q;hX;.`o/1xtq`y: g	Fc(18qW  AAElyAV
8Ect+/kdZT{7y9$/y@	A K~@&Qt2mphh9r0Gh8mIhkC{A((aC{R:#,K
xR[Vl:CKBIXPQaUAfe kJ`1d;#a>-3E| 5Y%8t 	tPv{w9qVoH ~Q( zG$p00Bgk5$qg$>t=KCAQb"ra}d*GF>0N1*ywKQyi
l]pk SMZ<2HV@ -t,{Hsw;IV9 6Xf1+|hmvl2K:V4=,96<Q+NF
Ka}
Uhb/|69YHl U+a_
c\!$r!5h8
`NerH"lmX$8e;*>Wf#Z"[2
O	O,/yhRw  8?5sX/AZG(YLOi CB!c5FGA0=Y;, >p,R\~I@ `:EGKHB^v/mh9)k>hg@	XxE &PhcK9@7n\$A;"Z@kJ N<0Ij
 (=L((PZhd0bKP6 D\yID	3`G} 2 Q8! %~MD3 )IC4RA Q 20v]F-wHGi9+eO9c/^7R6t@?X-wi+H
K$sxVfq+3fNdjX+Vkc/{WcQks>#Yn3F9[3tkl?QB0&027
'=$'8SD@7x2HY'tz~Ld*z(gieuC	. oKY,u#	k^yzAklpV_3VgGi. |=8iF5Rf>>?4h|C{l<~:%`!{Q4&wu=2yZ+e(:1,a#jVvREfG8isZK>#-Ef^#calqh3jqtx'%VD3;}N=Z_!R2&c1%P5{Q<	+Q#!_#_{
=i $EI+z QIF7	F}	k	vG*bxKC6JRF 	xh	9J'(E @!ZQ[tdn+`)FW8#	 9t). =F1p)!` c| uWR _R 
P;>&)dedx[
"&nipzLvr 
zwglcb~P=9hpSh$:}ciq?hd}CCP](:5bXvE]D[Kf3w'E~WPC]	[?HU)|MrvsC;y|1oBK 
x7K5YluF 6X34 VB]DWHvKaM[MI(2,St}!Y3@]Nha#b7ZchCMMDK0a-$uxtk oO>eu/p.}4ugq.-uRt_tOH]?O}/m<okWKsu@Ihf,6v(+z3i3kq#^,= 7]7KK9]DKX><GiOs#Hr|5SsHvr8_a{y$kE:~@VB=b$76yG{_Z(.j@AG4wE B_~ 7 @7FAgB(@ @#!>b_ a(G=SQLA -0#s8KT|$@ O3(cJB/%e{#|{ Y@s-6D'ub>(&ci>-<^Nc#69jEeyb UP~e%-3TM$>(~u=A'TA	c/&rF9p%`=\! +R%|^
^ooUiJm<#x'eIcuZ}7YG 	)c7Fmc*.H	 ~c`nUm:A%rSZ:Y?nj-FV#vvv!snf4MKc 5A26>X|jn0cFCA[6I wPo]a>;fzgnGZ$S{_ JY 6YVe:8tnJ	Yp=$kId0'i$8ZlpnlT^Fce(cTjf
4XJi5QL?1M-@qDZ}!lA]1 b[O
[W
k6-fpXnhR\#xVGM<IFrhL.#o*!G+SH!?h	2z-yH?+ ZA[;cQXm [XK8IHSgq1v(HAyJAZKF)GA7=i . /	+)) y x 
-kBL${S:%j?Bs_RQVWt+[otp3Eh!i6e$p*
i5t#I2[U2,E#hkXyY\\@')vIu%qNYmefO3A.8M$]{@4O<O4x\4|lW;qr) 6<o)kI;
) Oa{ mI|%v%H'/}}}U.?6@vw\A7vPj2{
(kI$A+Q8)en/=$0i
YK`nH@^3fK-p\s.Vv]D=n@wA;)O{N	+ >V-Vg/oh5U2XG$$#ln+v49>WkC(G{)+6F;A8Tc9w^S`,Xs	4qP7+!nYZK/umtjnII9S7c(56'et9T]W[ d@-#J6c7*G;~IobHpD&U5TFB+v9P0
I6vPNi}WEdi P'u|_in8c\-<#4?pjm\^XA_u;Z
fRo0k	lZhX0VotG_BB(E(^,n
:8\XWExAREFm~4
8KIQG R=1Ip3ioHQ(tX =Ih"Rg'vb#\4
2a);G)]SY \2$*s@9WFvYfE}yg.&}wQ#r7is`H4/ Gg(*Ms;
 8a!9!YOS]
F$ x'8=R~  U~# [	W >L/
e wT29z	.)|c&ko~
wDNDia+k,Bg#5+MX T#C \Yu 8 ;cfHv2R(h,8ZO@X/|,>*)L${;l
M{ba%J(u6h.$ RM RAUac+JFfgE~Yrq;McbrGs5Sa4%y Q
fS>lh=K"{ nX yk}k!^aJ8B+C/4u W5u{q ={g|]ta2,:koM{&	EIQ:C` dDXN2FFNHF@+XV
P7 N)Tg(LW;>,\El;jU-\R;Lw 5qaXh@@I_FnTs "(x)h}
{%=oRhE'cp@sR%[%l@@cM8XEiY3 bWsJJ4=RF+ PR~xNcM]RZVpn1u(pw)Ev(   E2v67%!y
Ap
MQ<pA=e<B[x>RDy"NRE{)$VJ(R)&3 @N{xW&X88 EU^"]?T:XjQtAO("F+*O[ =kF\0fiy\]lZ2#wfN$6M;I`XE m"F89y	m"?<1<mRWQ!*f 6!9>cu8N54	x%&frP {z$uh*ei2ZC[# &
vQ'p".i4=+@EF;^mOQNS,m.w	>wWC`rS[Dnhi>d/U!%dRk7Tq'4:@>8  )jb;O #|W)lx qw*bI#gi-n;f o<2cccqsV+zmcb<<{Kb%$p,nJ	yVi{px;n6Z,x|ab-sd}Bp}R4BZ@_Cn-.k %_	N{~3Eb4K<;$wj LXiKW4G|*Ad&QG]L6Q60
IW:sBB @ P |
" |$ ui,[J@-T ,`Rvw6
Za Xo<7)F+4och U )k|CM i)c~SH7Gt k N}@6p J$wGu$ Fl`0x N5HwD~%cGQuN6m>+u].T-WE8n'}	_@uv7r&XrVtbG2Vim4_n;v0*M.\Qzg .OpQ& y[#-~XJ|@H3E@<!;Wo+)"FumX5MPM?k+dZFB7X$MC|"O@lfGG
vm1pBthYpkEmwBry\eTu+g:\H+ j` 8~i0UKwN|2~7<$'QEQMvUFCMQ\:iab;Ez:K?2[5xU_#4 8l4>%Y ZG"=A]}|_'5YZ/<',p}DeCCV9I6	_8t#l0MDiz9$pW34Dd;!zDRkKoe\kwsN.	b:)~^FGn^6i{/?_O{5v/&33a :4dQMW>=I,?DNRv v(P!QkH@RcJ-tCsKMM3DPo}W|rGe{"T"8FmR|p'@o )< ]lQH6IXkZK@*)y7tE
r!H	$y@?.9&<O  9('C)MwH |s ;gt !=	`	6 FN@-y _	w@HF
eVw`m]c#Aav"i}6UYL ZJdz'.>.MR4
>/G
PPc4e=|8<}I7Wv[,mp#g1u%$v"XS_oz@=W/:c^l/\s$w;u63OW6\ztNh"i$#`@
tCAyVEJq.yyJhp:H4gNQB.zlzvWck=mzR#J	e^HKCt6Q3v> 3!q	#Cv^:[f!mP 	HHZT!ZEf5LI,2H{.2U$W q # TDaPeS_]*0z=Dm^]e=")s_#KpVKXh6EvvoOx f"GqW_Y'r43'EWaW?@48vX[}d:q  jI+hKpJzK+'P7`utEn)hKumt~>8Sb.V+Fhw!AB(|S'U ^zXdVpG6*0`P#zI TbHK
#b< 4vt.CbqRAk8ZDXhJk<yi\E&wVus;G6Ht&0P?		  ~Tr ]Vo#7!R\v5v| 	7uGJ3TvN{p KH ~8=Lv. R 8	 sT#(4	+mPV8%aAH5\dUI Pm9U|;3[$UdZ}k%=1EX,gu>pePq/pS `Sh r< sy	X)H =biBc!&4o	4%Q .0=cE5z'8h?Dl/kNm;	Lg?7$(eN@u_ v7rZmqfQ||2I=s	[t28Y>H  Wh<+(S'qO/tx)[.0MI4fg=\ & Q!;b#oA`
<$?c4$N
&_(#b=_Qkb pBI'"S=p'slKOug\	wi+:vYU Q!H']Xw|\1X1KkIAKi`%9+F;[rM2m#D:4V+#S=[@7~11tQ'Qwka7^nhGi~#\hSQh0=6+GNucEtHHFIZ]K?R/W$;vU+d&nl4c8LoLpU)>+Z(Uimdukgy)E/*A x^>s4z;E6Qu*0p	{B9DW]	94|*'I  4 uu ]2w;
KLG""VKF*N<+a8vtb8S/|{0uJ;	u<f>Ldcn2Q  U rdg9K b'6Rj/UX/F(pki0170)J`<osMjx	GA)jk
|Z C{( Jn38@pCt ,uFS\$F^vnsN KhN${y@/wJ 7;x0E<&nxnE@w{*##uYcGr}mE[UEgZfS#pq sZmk/M!nGbhT`)y-.CisOf"nrS>xF@I$^soEh;L{ofgOk@  8*#w6 aC<i\@6M{-s
L6
$,BhVc)ce%e>N&,0"0dw	W94lC`kA'=8C]i
*F=
/qoi`],Q0mVge<&idsrZ6f&N<YX2]$*QdX
JF_##dxbuGeRJgi:93u]v-]?Lk `+vCj/kCl&M`4MzfP/UwdEBILv; dlJ4QMp>s0kTV|t18I&9|6
%b<k\#+zv@Ud<OY4|-]LF	Mfj%'r'{<y&d!
8~4].Wibx$A_u	aqy4"M6$Gm' i3G|(h;~pp*5M a_tp@	E'wz E.C5XLKU1NiW^#!w#D NFT#9y3nShH!#riSU1A yO g08<Lb>2	 a8E@'eE!~cDO Iln0,h mJJm =% 8ye>i4n- 	G@utY iXoz'z |8/^3SXooFm!6;biC\-c,hQ;o|t<4R@mXf5<mf	.Fw_$7iF	L,}er|;V- IA'#G\`ule(WH7WnB{=T(/ uNmt m<>j-T~tQ)YNc2mxpIri>p'F/&Wt6!Ln_FK'C*(iaY}Ivnl\llrNg[t8@ 8]%XkMKniCG+,=J]1d7jl-7k&\K,3ts5Gxhz,*lmGX(j$:#F&5!?qcGT~ :y{tZA]I	
MN4n`O]qh\zVehp9W;\DZu}Lvhw[.w4C^C'ImZYc<x.T6?'NeN,Ctka o[xcY?CZTadg8`	0o0:O5?"mK):U$sK]Ss}%[s[;^y%!(;EUmi2hz+RXZ2=}J8 #*B@a?r[cz]=pGd_G#0>{\6?e,tR
{MP|evCydh^cyQ0#b3d
xfEUOGm'qVN08S?%]sY5AE7#e5U5Ws9#k4@ H]uXOq|(od7 	!9!y'bunkGtY	
i2<
b>(ps 3f-/q;_mBp|RH/;zmc cuI4p0u8j#J}cX.v
8THl[m1!IZE4hS1)-cMDs#i$S|-UY.LWb9&b; SC '7vz3/p~	e?8UX?L8Dr,+ 4HF9#:t9~1FKTI"KrgU&		$&P[;th!XyZ?;krTK8gqeW?Feq73D@6y*ORpS l+o,=oS~A-MJ.Xp77M)a[Z[U<&3T&Kwn@/RJ4U5Iut.&6JrdbmS_
i!6;.$78]|tz*<.{:E-f|+:IlQ8,m)KEY6ZHKM+VXIx _HZdef} pTg#c[@WFuM3^ii^Q5wc^bsay_O/6Pvx\n*H.%+VIl y*yZG}UT%$Ak
a dnQT3%Ye<b~i&V=)p>Z5,MJd	OZ OJJp: yX]`O4Vgqi FCud,l+aJ&i4WD>FQ6
K4G1|n=Q
r@$06UHq@$^7Ct<$"hGkW40_P#1HH'm)<yLbqF(rHCEcdc)t?U#@Jz@'kKjmC P]~DHI3&FYErAORE'd|N`aknJA\,dCx[rs jZZxPk\\rU{#7qhiu##14vH)pxn
>4a4>G}N-$dN6
lv}^y26vZ0.WK($0+7U^N*i .;)f5NT:unnrTpdr&DuS4]40QJ^szlM:_VVELdSu=AM5riKL, ZyZT]IzrLXFui]nN. c|yOtjC>KMWWuQ$C-k%= $_u~G&OtpH{@^+$2['&;]I=(^% ^1C?B&p2Zb\ |F)}S3MdU<^KE%h5QPkFj	QO	Cq7+7Fli$m![Bs[ Z&jp`# HGQ.$WM3=F[fH5yW|$3ZgB1xhBtnas;[d	;kzf"8Q$/GV^2k02oehaonFsz;c^F)ge,-DYO 5Dld'ct6-St> er#)y\[5V\ ]h>k#GOPUWktPU;]1ZC'eT+GX#QU&CC"4e8$:*j*M#~xLE@ wN$IH|EYqBhwsU]($$VpDH(E#\jd+\^i) yQpxJ3 .udeiut0^&4?J,&Mw8rUzQEw@) o))S#0aZe1;C-G'+:Z>G2Y4_Q;XQN ZXm	T;n]8c{9!Q@tFNC?K4-~Zs	HL#I
$|oaj=qC<{.||9q+i Bz'N Jp7j	AmH?:%c,FEEIS.3qvLu> 629iy#qkaj){+~3'd<Jy$Y0s:P6'h;$N	lr7L{8El6)r.k68{a"N+oFQhp 	oev@WMb\U7O#]-dtA:+~1#6O{.|EkFm. wiM3 mwH3juB=Y;q,?~Eg|$ Me2>3M30
w*;P3H<)x9i 	'Jy"yRv;NXV0|  gd04u(Q.w+os}wihWTgq#'>kx<$q# !,E>!x^B`o3<txY7W5Cc*db,$wFCl8$+2I(8 ox8ls+wa nC
`A8/IA-7 d`n:G]{=A5ir' C&]CYJ+gsCIq4EWO~Tx5v_B_}:.o,S+Mk`qA#coj;KDNk `x?I.*]rN#to~B5`#/hc6	62L8:Q`Td}DU/y* N W)Z}
VRLdM5}i/u f0o;nO:x4HV8rtL[+k]Y8Z<=q1t u(|kv\i'	?8(1zemcxn3K2ZIHN"g-OwV WT
Frv.*u9a6Q\&0^69@5G*Fa c%$foJ!h,pvS
d&'>D_;qj':H,-dIZtOf)@8+T	PK@%Q<q4Pz=GZ(9uV6%m%%lyOgugVmW)b;+N?HM./NuABas@TzB15o2Zn E/RZ24fdztlG~_/sI eP8N<&O:'<^c"T?hNC+` C{<3cH7'.#?)`mmi 5UH: 8rTscXtVXVAwY+ UeEoszLgJERPk>"/PyG<s_V<GW	=_Vn *inVH\8;*zwzK{SlC*Wv|(&E 8WMuEOk1b  1 )CQ97zhd-}'z(ho$dV[lti>Nc+;u9@u3w=?>u06Be /`46(bk@A@wA[8 eBFaG>t7`479lmcPT)RB}:>+oZL{;E&	3[)@9:mC.KS=NN%V-Y^z./S<GQNJ08Tkq|H gMaqNg]``,Cej@C]JJLJR=q9L>br:$xh kA+J	 A07qItOwe9qL\kAl>>hd,hmynbq $hJcpe^a >ux:1<~+pe8'oSDFk{{]gnI#WTHCtu^HOHvE!}'wL7Olvd_vN.CH @nfx'dArRNy4t E?}c7i{|/U}\[U' NO7!f.?bjYu^IhHbp93+$rE!`6jbs&Lu,xKZCa4v~xS8FKeFrNjb uu{YQ.Lt<l[BCm&8Idu=vVDHk4sDw+B+]D x\i#l5pis%k1^gMO#.q$i'EUH
_5.R$_u:n4z$nBT`Dc$lX#RVqwfhpd_A.?= W~CZvC'\TLJN2MZ6B \~Dd V;CF+#^N::*BU`E<-j_rZ:.(^Bt3O"kwS9QN/i<#z#`3R	m[
(B)UwZ	 Y|{C4?SqB"=PhtAM"|T!/ez!t
^l zK!/B`zAT" (B	}E&	B^}>m,4yuMTgM{.!C.D	|Btw+>Xm
<$N!{n,!r#,0$c&=+H!u`{9IHzpIM1HefIjg1!!r6Vmd~@ZYiABEk e'`	B^0{<L3[xBA^>Fl6B?^1~j_!`BI&_L>"qx0Mk(g|`8Bphcykl4ui'I V'liFY\!,vBL}j 
ghkUeI!< m03y4 XSQ0HKCcn |936Dd B3F>Yfp |,41_2fVuAKcE-^0ek7	Rm3$NgRl}A|:9P.8r|+B"Vt`(B.VwYeduBMT^R_(BW&#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

#define RFONT_RENDER_LEGACY
#define RFONT_NO_OPENGL

#define RFONT_GET_WORLD_X(x, w) x
#define RFONT_GET_WORLD_Y(x, h) y

#define RFONT_GET_TEXPOSX(x) x
#define RFONT_GET_TEXPOSY(y) y

#define RFONT_IMPLEMENTATION
#include "RFont.h"

#define MAX_ATLASES 5

struct {
	u32 color;
	u8** atlases;
	size_t atlasCount;
} RFont_info;

void RFont_render_init(void) { 
	RFont_info.atlases = (u8**)malloc(sizeof(u8**) * MAX_ATLASES);
	RFont_info.atlasCount = 0;
}

u32 RFont_create_atlas(u32 atlasWidth, u32 atlasHeight) {
	u32* atlas = (u32*)malloc((atlasWidth * atlasHeight * 4) + sizeof(u32));
	atlas[0] = atlasWidth;

	RFont_info.atlases[RFont_info.atlasCount] = (u8*)(&atlas[1]); 
	RFont_info.atlasCount++;
	
	return RFont_info.atlasCount - 1;
}

void RFont_bitmap_to_atlas(u32 atlas, u8* bitmap, float x, float y, float w, float h) {
	u8* buffer = RFont_info.atlases[atlas];
	u32 atlasWidth = *((u32*)RFont_info.atlases[atlas] - 1);
	
	RSoft_copyBuffer(buffer, atlasWidth, bitmap, RSOFT_RECT(x, y, w, h));
}

void RFont_render_set_color(float r, float g, float b, float a) {
	u8 color[] = {r * 255, g * 255, b * 255, a * 255};
	RFont_info.color = *(u32*)color;
}

RGFW_window* win;


void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
	u32 atlasWidth = *((u32*)RFont_info.atlases[atlas] - 1);
	for (size_t i = 0; i < nverts; i += 6) {
		RSoft_vector npoints[3] = {RSOFT_VECTOR2D(verts[i], verts[i + 1]), 
								   RSOFT_VECTOR2D(verts[i + 2], verts[i + 3]), 
								   RSOFT_VECTOR2D(verts[i + 4], verts[i + 5])};
	
		RSoft_setTexture(RFont_info.atlases[atlas], RSOFT_RECT(tcoords[0], tcoords[1], 
														atlasWidth, RFONT_ATLAS_HEIGHT), 
														RSOFT_AREA(atlasWidth, RFONT_ATLAS_HEIGHT));
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(npoints[0].x, npoints[1].y, 
						(npoints[2].x - npoints[0].x), abs(npoints[0].y - npoints[1].y)), (u8*)&RFont_info.color);	
	}
}

void RFont_render_free(u32 atlas) {
	for (size_t i = 0; i < RFont_info.atlasCount; i++)
		free(((u32*)RFont_info.atlases[i] - 1));
	
	free(RFont_info.atlases);
	RFont_info.atlasCount = 0;
}

void RFont_render_legacy(u8 legacy) { }


int main(void) {
    win = RGFW_createWindow("Basic buffer example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
   
    RFont_init(win->r.w, win->r.h);
    RFont_font* font = RFont_font_init("DejaVuSans.ttf");

	RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
	
	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized) {
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
				RFont_update_framebuffer(win->r.w, win->r.h);
			}
		} 

		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 255});
        RFont_set_color(0.0f, 1.0f, 0, 1.0f);

        RFont_draw_text(font, "abcdefghijklmnopqrstuvwxyz", 20, 0, 120);
	
		RGFW_window_swapBuffers(win);
    }

	RFont_font_free(font);
    RGFW_window_close(win);
}

#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_matrix rotateAroundCenter(RSoft_vector center, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_rotateMatrix(m, angle, 1, 1, 1);
	m = RSoft_translateMatrix(m, center);
	return m;
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Textures example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));

	int w, h, c;
	u8* buffer = stbi_load("tex.jpg", &w, &h, &c, 4);

	float angle = 0;

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        } 
		
		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 15});
		RSoft_vector v1 = RSOFT_VECTOR2D(700, 100);	
		RSoft_vector v2 = RSOFT_VECTOR2D(500, 100);	
		RSoft_vector v3 = RSOFT_VECTOR2D(600, 200);

		RSoft_setTexture(buffer, RSOFT_RECT(0, 100, 200, 100), RSOFT_AREA(w, h));
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 150), angle));
		RSoft_drawTriangleF(win->buffer, (RSoft_vector[3]){v1, v2, v3}, (u8[4]){255, 225, 225, 255});

		RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 200, 200), RSOFT_AREA(w, h));
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(250, 250), angle));
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(150, 150, 200, 200), (u8[4]){255, 225, 225, 255}); 
		
		RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 100, 100), RSOFT_AREA(w, h));
		
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(200, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(200, 600, 100, 100), 6, (u8[4]){255, 225, 225, 255});
		
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(500, 600, 100, 100), 360, (u8[4]){255, 225, 225, 255});

		angle++;
		RGFW_window_swapBuffers(win);
    }
	
	free(buffer);
    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/textures.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="textures.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
 JFIF       C 	

			

		
 C	                	 j 
	
  !1AQ"aq2B	#Rbr$3C%4Stu&(68EcfsFTVdv'5DUW            	 K   !1AQaq"235BR4br#$SC%&DTs   ? S@ @ @ @W)`%pF3; deMNZnmu">#C
ZJ=]MorquO+1'^,.W=Zq8MyW?lYj ;vvU=8 .?=W/  , W  ~_g  ^ Yc pd??{tXx .??Y2}9 C;|+ JX}9vSjjpV^^qZ jt_hGq6qL	C+3<sBQ]%P0xrR;b	 @ @ @ @ @ @ @ @ @ @ @ @U${x8 Iv&)|4>-)`$y]^eK R!_Qj[??yj[d EVAxq0nB gr6=t\ H?Z'b_er5K~ @ @ @ @ @ @ @ @ @ @ @ @MHFM}TG(|cn|3NcK[ P-rd}2+B-> JgnFxqRQ
]/Dq5\qoxjq[h?F' _e2is                         *XKoY]Uh\[D?>2Az:e6on[?+KfyX*xi{A}EhI>7Gtn "Z } _'PU; @ @ @ @ @ @ @ @ @ @ @ @h	>^)]t:{xegvd{~iK`,#Veljuuwa		^Jpw9' 3efLm( U~GEOM=}|q j<Val#F1Wc~eeYhi&6u|I[=yIH]OT ?U2*MIC^HsN'?q jo~v Gj*5T|+g	WN}{~eOZXg=%-:YnWfqM!Fqs*\yd~ChMT-(O(                        #\}M,N3@t.6YqGCfIrz-(@i` fbdu@-j'(G&vA4[ seT8\GPnlAPZG>N-V\9PO~r(V<y= @ @ @ @ @ @ @ @ @ @ @4V;T62^@b,rFJfecw  /( i~:+&PItm(Z]=^A;D4gF23=tYc< (.>{}
il13@yhKt.t 2D|[(j
'!: @ @ @ @ @ @ @ @ @ @ @1k:c[OX 4b g4 4PN=
ky2W$:{]CqWts-.Z:5RHq$=$|O>(y#cye>hlgk)G4nk(y,CUW(]C(-GF|=Eu~?8d}mn3)@Lz2qe[WPZ5@l1H9^>($ @ @ @ @ @ @ @ @ @ .73 @]R3goz A?+-*_)d4y67ZG[8!}<
4T[twOG(}1vMgQ\)|wi#@n96_yIj"fPkJheOu1=@zAD;NH*mDd*Mqn9u.Q]DEW[N6=5vp|Gb                  
=ot6m#v=p@t^&Q60]u(7% )kBAko	'7wq&d"*dO"'0z`qJH+swydUMoa @f$VYE6;w \BJ;(M_M.10?.Lr>% 1o4]U+47r;'nv }Ud5SUorDs*t33|<5S*DGf$>#@hP @ @ @ @ @ @ @ @<qz>4il`.?@`lq@\T{PKCVI\]M#y\Brt.Ti1<Gd ;RJXji^dvI@Z 8D,79hsHx93U?z4)Pk{5
g\wy<N+|{Z.bAPk#C=T$on:{#=l,;P %n4GQO3K^%5+$tMe@QY#H-@L9dm)tGhwV|ZZ#! @ @ @ @ @ @ @ @rE=;#`Uhn4Tz@i A@R~wMPX !)i.xqxZCI?gP !x_5qN OG\Gv\NotCngJ{I7a@RlZiE=l~69^y8AEV;zvp!@ih.Nk6VBCb>@^=z@@QWP5--.ImqWg @ @ @ @ @ @ @ @|GCW 6*v0&[ ^^@j-j
d9K;r+GR':GO^ Ax0gv<l
 @M~STA+$4o:TvlWzg:WpF	VT>x'2BIo@tk5_oMK>n~iw;ZDjao8e Gs3:CFY]Ep}$c[-zyw&VH~G>rL               *}-r6_!E&5PU8g1'  +<=	^
zu@I/'zy ;E @ @JXukmx=2jAwIGpRfpcp *6M 6kf]"9AP#@#!] 6x$ , @ @ @ @ @ @ @\ 6!u3Hrgi=B27@]St5 nP(-NA[+C0>$nks
:nvb}Dovsd_   k6-:*A;77@|4Z\ma (n<@[a.;|2?[MA=iVr)u( A;<              )5OH8,hlM@mhN@\trD/@(
r7iH]4Hbdn4o  5v5Fz= ;*YL8x@ @>ia;zx09pVhMIS/5Q	7Gx ;qk}Y}dU04-h3W*Q,nu(mr5V[vf!,'#              2<Yqc )o@t-&P8!uJ /-R@i!w4`=2QXc@V\	LydE\>FVtlwL$=[>z @ @uzcovpKG3:n@<	@u67u@vM!(&r)P7*WF0a
zq;(@ @ @ @ @ @ @ @`(U }f[<[Av(Ghks_@ZJZ5C26
r'(
:'<B#Qzo <,=m?i FchX/t\.z?5(    >j:_(-wgdDx .UW8sFPoH27g.&es#'g}, @ @ @ @ @ @ @ud,e75T.s4(:g)nk(Y
OT%|cuHPO73i@Be_Qw@qWE<.cg-cIyaDE?)c4   wI_+iiE{'~y$HNP[=I|ED@|jsQ3o              ^?gevd; -]@ZF)@]S0.TI6pg#M;k)1S	 `q{Bw !=s(f
b	UK##in#Sonm=GmOH/?g84 @y)	-
ih0,HD+AcXQ0Od @ @ @ @ @ @ @i s}9Jc;$P	=|PJs8sF*)w1bJ|D]cN<=g!2Gk B,ah7mW_/?4o@vvI }~@i  @+|cZY.~5cw}HF5ra(XI6S@`z*#(@ @ @ @ @ @ @+?z 0 4`=Tpr*BPPKl4 APja(hsA#y#9&&PPlD?<?@p0gZ2Ih3`+	Bx  B{}PX.<LNGnOT@utn18n/^ WVd}4ou4&H+'xG;'Te\#qhr"g|P0 oODgUvg:EYA@L@ @ @ @ @ @ @Z C=ZO7,!v
{Pv6PQH9 +>O@Gf1pkCGAHl|/!pV4=w82dlu|| =~OoE=6cH@XNAQ89y%ov~c/-H              :Ivs 4~zsP9!6@s9, a@{r{R@zb	
H #L0	8{G ^P}E@Cs/~:unecP1@q$ &@K0zDQ@4rOA5x<|S#> @ @ @ @ @ @ @ut>UIpZBv@[@XDw@Mz %%%a>3v]by:ezz5_-R<%hh1.OveX@AqGBtNC!8	f: 9;p@F@gn@lL+c @ @ @ @ @ @ @q h jbq>wdNt.l>c	?!tlwP79@&<t@D8'@E 	@p>>cKL($O~&@r/Dva/=D
dr_Gk-@ @ @ @ @ @ @]qI)iJN=wTo	QBDrJ\ Pa:|w@Ln~@r4(k<@@zh@q:o#9bDz4 <88$ 8Oz0 #J@@AeWReQX}Wc]q>u-H@oP @ @ @ @ @ @s~LH	 ?W6~T#Z[   t?|^#v@K..	P@NiA@rNCIt@	!{ z 8$}s(3*jwYVBXs8~Bd?2jhy @ @ @ @ @ @ @0SQ=\z;X\z?8i)c\dVcPh@P}`%U Pc1%L $G[; 1TW:Pr\G-j<~4wZ<~ $6D}@r@{]? <|BG3pp^O pP~HfqJo\,*TF|P5BSyJ}'})H"*XH;@l @ @ @ @ @ @$5'kI2VuQi>^qtUbG$%X*OD.-"csi?!x*jMSLqxVNf?r\rw/l.16jvGi/a&w:'gvDfH2w{jTo;wgA@Me	v(@r6C-T8B6v<m =KLM4 <|BQ3T@{@z>izV 5.BRw}R%?NV9CQ OyVy+e^5'?(8+54t]UYXYVR[t9F"> pV=            jA60Q.#fqWcJLO,QfRt=UMtQJjErzI5t5R'BB`<emIV) 0Z-}W{m{H$,A 5db*u7?BY-<FK1]^[\vL9_#2i"4u"BIdm<PpgIG[';:wvwR^n;DR[$|S9pllhc?Xugirjz5cukmj(,r%Tt{q#s3X;(7v =Ju(kr;nv6k~mSW%;*dwhCI'~6iF6R}Dn!rLlU*'l'^o#U_m	ZQl8epa`'5Xz-mw~y7qxZ8&ZF5?O-[p@b0Gz"(kqNPJ;J+GoT.O+)lSS6z>r@D .8 S*_W:nknj}tL.Lb2 2dd5JP?Jy=1|bt Zz6vz&Z~[4LU=Cv:j
XO4	 1^eF7+%JUqx
mE&-Vb+UZUHmd;7n ?/)~#W94IO-w%6G4Zya0x'>{,Op	bI)Z/76[xG)cQ#},nx\\S7dOC_wB0~qmFJmZk^?[6e{Ky $$8lGU~'"_IOg:ubUC]LJYkB}ybOvUOQc*9~
zTbkW+Rtw{-37t366
*U+K[}iJvSz{\3VjT[#[^
+'nOznE @ @ @ @ @ @_qR7	%f	gR0=2?KEzicHd,pB+QjA)+J9E.Oq6@K&kz6@OOC^k4Qg;/WZ5K7_Ga*k]b$v2f8[WF~|:r5=tN~Se{Tip^)z"1xI{sOx,9XfKduqv]%6	*MPq+/HK_m 1(L=hVew"<{WEeW]WUW2:Y%4alrCllIgFOB5#8r7wYh^^"cxDq7)U1='9Q*p&JW}.FoN4\eM[88.6z;MkxCU-9#u4o@ix\rzBrK_Bg|+z&*{M1qT\Ak}lt\A>rahwa"{r^?)p<(rJ^rR\<noMsjul<Km:j546:J_D`Zg'xk\0S.Z=KGC.t/IUe.eS{]ESSL)h=
vWTZ6;I(y_$uU]{J_)|:X*Jp^uGoCg'IuQOQGGf:Q-23:@9n".`3'YZm&xiBFZz*7[VodHg)8QSfV_8H#cqF2:&a{s
jrj$IoB-eMa8M]~&)	a"RL;UrU&+WE3(S$IJRnh]\5w~km?|K$VVP%<HSHkNjI[kCF#!>SU)FvSg+_WCStImluSGLyS'x950@S*)^/ZArK5$Ss~hihoVqKOwAl-&"1pWe	j_E_htV:ov$O['-uHkt/hZ[ws-U9UU*pmOYnI=f{l6[ouMi]Jy#5n6k@ORk-:3w.<q"8EXG*))_E}v	W.=p~yIVB<9j5.S<L`	t5 dk<)[UrL<QtOELx?3/,^ozGic{^5.2/R~sL~"W2nFR @8]i5nf6qi oTp/.)^u6G=Hs=,nCT9Txw,WyCwV^U;O7T(R4,:oNO^-wr7[L@ @ @ @ @ @ @=2gS6i[ f[
Fr>/d~ L?WBz+sV6eN:)p!Mt *QTH[
vQ0"k[&s+%2K>fLz%Rv$1^Zrg;Z:u{^ryYgzy{Gz9d-2N8
#:3WPRg$JiiS$m<= {B`[NTA+]"b$I*,O+,o<$J+*&S+'%X:mGU
6|%K?aOWi?5s,N]nkX-h @ @ @ @ @ @vJs_<vhW=>/d~^]nTig-7O1:aKhJgL6W!n|Uj2WE%oW7##wIfIc}P>Dm e9@K[9cI^#7=h^.N8Uom`j62lb
.UL[YmQSQMdt
4#|TD/F-'0a_-)swjvx:C/~+_3Mq&R|48*'tW)Et_ SQK%xf!QL8&QY5Wge,tr	$?a7gJ)E-L]#2O9_Ly%' .KDPjn4iY*"}a%ot#)]&'fdkW<wSHte,T5rLL1uWjK]KzHd=JPLPFI?b{@n cp'}'>7\%f             q]LEX""c='av=W4S^ 9tl7Wz)Ok
e=Za)PPn-l
u B"OIU'b4Q)^6Y)`
"}ETi8XyGY5YYF6J"=wuNgQSv,g49e'.N_-gIRWqRpC
+* @{,xk>{2ey/F?y5>Lq>kG ,V;>"{>k(jY$R~/w-4bl'_<.>idR^;2O;bRma\[I,'q<zUofv__fuJZen\h7_0}qtBEghco_pnEk0FM rN5{6k6|G(nbx4Wqn!BMWOBq/|l=-H9A)*|sj0Y:JN|ac_-=omZbz[-3L	or&i*=c2R%>V
^D{ #b|t,&uQsw^:._5tw\Nq-5bw57'+X%1+A+]](VdlWwR&RuQKSSU
oBg(U	p 
dSCmSgK Es*g;u/d+_k>Z            	FL	0~#e{,bfG~Tn?y~1a&{SR:,i#
\3ilT*2WlWe.Ez9Nl)uz{L^%ch2Hz6h'G=YY0<F>}FW:> ;Iox^z8/N]{O~(o(}%53:QS>ohpSL-s|~yqO~zmE-;pt#,5Rl&J`d{-6jCY &SpkWe}jq]n4:>N~!w7pg<Azy>CRS5Hq_SdpJ;-/ig}0p~,q.v
2q}Ks'5Q&STt`7/\N9xIqg^Rk8&X/'NGNfc~LS7w%^sJX\D3Yt5(;7aB8|bpA!YsZKaG?EUw'WSV9EXbby2||CE}zCG+; H>&*yZ/oJkik-hF>&xdLtqL5)F%fu&fn{Qaw	b0R|ixEsU}1_|vXEqhS .wn$S\i;>|I9bis_^o;Lx7E}.;/5QQndFCKt*5EtrJE^=B"}6etN*eT&S+*)|O+j)2! FlJ|ue:ulyN}\<Gq$rjNUUb@ @ @ @ @ @ @^9_UwgG27^eOK0eN]>Kg4)U0*=JxHB}G*h0"-IX+-!@D)KXm^x$C1+N^4dtWu&F8%UV<)IhgYoB%A !@.	fcZe}goeW[MV8 {8^oImFi=#'-G]i%%4#i`%xMW_f=}\]Ic1<~S~ldkDyf" ptlP~|:\*yToV[
lbZLPZ6Y7qHSe+W>=P`eiezRU7|9uP=xI2f^RxjN.QKx=V}p3}$L%H77r6k:?_x#Vqf=Xj)9bFUq,N_QA]MX"<kWjRO kwc:Xi=lg'o0e2"eMe9yJgcsyWp;T2?Ii+asVQ$WoIIka5i}<9F5T&)naWJF"#RBEMD"d
=jM3	N.HrOn#<W~.?[Go$t !Rp@ @ @ @ @ @ @6OkN'{,b~jGVqwZB8 rxUGzl$Ud'z)p"JE0jBp5wKM
Ji^-{Hg;hWapS*?G2. x)BZz> z]s"l8%HO+SkSNsmdq_`<yB
k).	}8/ kzHZJi+2	hSq yL~bWvG~P<KnymY,$ky5A<;{`Y/{.`glFC$cGpp#ec	FWzhrh25>h[fOktmj8y#51oh$clg[CNN.[0Yf*Poky+{H^t%*	#:$FY6}+8
B}?{!p]u5N&aw#ssFJ.wb>K-nerL"w`n*>;]icc]1$@a=F	[U^<>SN)/v_!yIM%vKmD4uR9KUML9$vqWWLe<&cNk5v
9OrO 09].JWee^
+/g
vk]%Ul|cs2K+l~8xgu 8s_	*5f:oGfv^mn"j90Apk\79qnw_/a,M{2:.t_c:u'
m_@cJW67y%.B|BK=<=S({[t^MC5wi=yiMY4v[=4lA7Zm6l3g>"5ts4*U^=zgev thdtus>i)_iGke:9ls[{=A3|1|:2o_e(yg9-B;3VMF`s\3x>'FCp!{;'y@^)qV-TwZ1Yh|#b^tTPWS;*y2<BlW>`x>fb0oy*QvJ->mv5F-mz=]3)WH\v >
0l?((tu]_\_ys	kWmM]Bv{+6'~HSNq-IeeE9+3	DHF<U8{yC~~tNg:/-C^2u:NEZU4h}\             OpU7 |)0 $lav=OHEQx!O 9t7gjQYc2dTDce&I6Imp`U^O[R,`^},o1 NF_i>|+qs- YQOJZ1
\|p]$CKI'6|2i/~v[|?j N4~o_yaUWTE=At %L]${g[ge5XRir~NRQob"XDpVCmZdhkOBV?OPSxidzV;5={=FLF{t>_n_"eq?_Gm<bkBv (?X\Ws g_I?4?#WK L_*U
/WvGf&IGN];]!._;- V;:jYuLo<z2</Zui +O|1p='o4*l q : v!<7)pAb	FCUKpjG
f,w7clke!|EM}Y43^1O>ip9;Lc+>a]7Z/}YyM[<s<)q 	\&]+nK<qjF~{JON?}([tg,{oo_=b<ogkf?@qMU+55(Zn_6j{Ln+& ++#]DJQ?U]i2:+l	&';+3$tfrM!Pd3T$/^{n=\<5t{Ek|             e9exkA!s
DgR?S?]G
r9&*gV'37)0#JW9
J,9\MOa]LR-ia$>ZYDiZY,dZfg:Z5&To(7B'T
x}]kfb.6lK1^<3
i-_i&k~%`?92 t of[fnZkn&Px6rnmK*eR-X
8j~p\MY,pE<n{y|KtxZ 39%	a)Ktt? -<+l{g};4M%Zw)?6<?j75mV\?n]A ^g $!# 2YTw|x')5'f[^*q"s)o,bst37WMk^1G7hk]-e;mtkdo<aa- yeeYam;>CS,,M_uv]0<9 T 5Y~7pb )St7d r?q# o&RrIu ,g  2^Qc7}G[Gw5U\^#|X+6+F_]>:cA-60;Akp^7e}7|fZTIjY'iGjhFq'(xHNZwGKi8IO,Pb:GG3+%kZO7?12u#9/et:P;[7zVVul9lR^<cDLL[:3UmiJri9J/F=c,n5bNq>'k$P~zg*UxJu~:}> @ @ @ @ @ @7Ngg~*ygR?+H*/zu<3~j7GJ[h)y=@JdZ\0}DdG!l <+V-sFp)4gu&}y}u=_A'~x
XV_oOIo.	2L[{::GP(nc5k
4crL_4R>N#F#U]5i5G7a:_rT9|f KymDWK:EXe[	'MTk:Pqq:Ge{O8l1,;Ya';r`')JWz6ZT::fJs5H!ysF;6*9.3 ]R53:FMWIKNjb0X0H&J9vaA9K[^Ua%fv`(-~+Ga3*|+KM&8SuuK55e5;$X9G($wl=$ZhA|FjZNWZ	;_SCUk}CP|'Dy\rlT-gRn5_Knir/*kk?gdCKR,?w;>3_i|/(\Lc|YD<&PL69)k	C 	YN6U::{_cx>IaR"fk=;U:oQ$J[a`h ;{L=\`#EogQcX9\'3}<vqK,	gzM91=8ecU\3^Y~]=E(15_rem+xei]6a9{3pUn+eJ8-

IJwgd$c$kY5s9`J ^~>"v;Q72;>:mB<Z94hX#MS9m>%rpI+1<nu&gJjKmKiO	mQOVVDbG4,pl:90m]G^[8SvO^+I29UIl-O2RCS=n_3<v<Zxe'<T7 8swwp[qKbJ<vUyj"u)!N\##_$ZJl0wZI!9yC-_0e%^go6J#pK-n>X: @ @ @ @ @ @3(WEI.ed{U?wp2sS'^u,/GW3P$lDy*&Aw{HkU7li>)/Q% 3j?\V&c~T F\%$mSJpoXiY $8	Y|*zT,.Ua1>V5^4y8/9Ice})ZYn_etVYm	2<~!p&8v-TT?@8S8W:*5M.xB~	QqTEKPe_/xFscSW+^sQq(9e25UhMqWVj~)oSUV1Hrzcl6C1	g<MIq~? ,?.@|97~1#'	5Vh_%]wT|1MW#\\\93;Le8Lm5N.^$jY;azgs{p&1X[{^{Sn/\UKp%&xZv  1-k.b^&Wk.2OQ~#(*50c	sFH(	upim_fXt+;/k:pSLGh-W5:4Pdi-6ORWyv6Xl}R:q3Dk#hJ-4V:Gg6R\MG+k7,[Ky{.8?k&3Ih_q7c'n4T:F=8[ 0s*%UlWq-bt=/u%+q
x~K#$4e>W*/Gg5dg[vB;EvNhKX_b3&36hDr9Ia\iV[L>soNFMgcvvI6u	yI@5V|W1;)]:L`N'9%o**
X+&[i0*yA{m3kg2\43Xg+_U j^f3sCQrqWlLOGuvR@yyF	#(;:rw1\Q_4@l6 :+T$PEr6Nx n8/5Rx:.QRs7hv)+fB             q4-@t c^<iIYw(GCX< .o|)E,UD*KVG1G3B^xtk7'B}[2an{kHz~{jJkqjs+nG4!#e
n7M]QXrQN>L9kZk8 !mQt8Ktxk\bFt
aY#o ^6zhAT9AaI#-W)-l=h9(=]'FTL7%C*uc:kDNUn[*^+}s}K,^[/g^NIu0X-X{5/u}-\1,9fz+:]\p|
f%EEViRC8 12VqdV
5*] k^<a=d#(~bR_AWY}Q$RWh]WH	5Qv%fSw$G4Ro}>`$Kn8/L,OK3acw+{K\<;~GMVJ/fkeRi=vROl\6N4NGcZ	*?3T^#V4d^\BW7$Z'M::70 5o,l/K#,LM3WuNOZ_r%eVRBZ0#r~Y\6|n
 a/n
<.CLTM}_+,f_{U;;o@%bYVj#f[_?TdGQkPA~%d5m{ApU1z/. 6tw{7KQAIH=4lG@e<:V#QM:|(aV?D\.U.=Gb1S)-8.qWE$K1$`d[V=:sRo5}hK^G5Hd,/y6,<Q}6nSR4BUy-7No+Z?Ave{g`uZm#9$8t?qMjV4~Zs;N|?<>7t<~' gB             qsr.v{Nrp]K rW2v'<U!O+S sb)rmiMN!h:k$S5VlhZ	i4GKXqqPI^ai.k%{-}VTkUJnBO))&Frqg<mhzTzAda%\]F](4K4hZZy2u@t5` @^8[=n:JSUBAd/qx:7pueW+c_|^|%(8_~X|W=8R
}__[nO7^R[nk3|0gB8g`pZrMI]eQW4r] SbV{U<4r^_xWn>sGo 59 MR6iy[dN.=zqs*_YxmZUL-dGHcsTH VU3Z5O&9H0K%0~2Oo3eW9I*}r'Gx<E,&]tGBkN \Krx'/5O`Xl%\KTA?g_xi{Je8+dlCujXROJT2sKolFfQsc#I#k+e+E$Ni|]ITE]e@^]\z7ol0xz*8^'}eI19k&UZ`
}>j+3WS-IX8#"qk_j},t8Ul`?6I6ci;wtr<<$y&=eZl!t0gI[v{f3[}TrR$QOYWE1p)_*|w~?}Fl             -#_r 1p0?twE i 
S4V'*5Q1:ZF 7;m`C4veZ'|0+a6l\5hsRniqWbC#F8}%,#sh046d#wdUM!J,h#LsY2+d@ mdZJ[%JRYu]qXhK5!n:rzq+}=|ziD}|?UgnSLO]ZAX\^W-[IvI8)u~>z/]OpUIT=22D;GE/.y*y(Ze~|{lZ8l P>=7qr,/Gz.cu,79u$+J:M7/8y9U5={E]DLg`X>j\+{>lur_K ,"Sw{x^)SZ+E{,:h4-ost#H>T+Jcd35vJOuS@O]VI{JE<z\~kN5&ckN}V9d>TpUo+g/KI*N,~*bJ:qG<q6[EDM>W,s#q T+f/ L|\<E->WeE] lVTRl4n\@#K_bDbQH$t;NpEl99L*wrN&M$j'V]OYqDFC|oRky%m-?8u8ZuVY             1aO}c	sx?q@~dd__5?_U)|Luz RfD# IctX+jTV[@KkM
'fM7<lFs87#Je>2P&RY-85VH04V9iJ=J:ti'iV@7\V+V+Ffpx*3LzNoIm-MhR[MtluZfYNbNFCUF*rgI8w54>XVz-U|mSK^9w%*\sQTt*>qE.5SKOErL  ~o6P4m=,L,\\&tU:6WA=J>A_Ycx#
<VJ_*~g
p\]V7%k[kqBND~LqYoj;p. C$o3{	k @x.,}8MzZk:B Ip}]1 I,yyv+TM,~%6^3H*h>YQ}6+&,3o:9'`7[#OH#4s)ckb3H|>u]MK[gRVZ6GX[(	y% 98J>nj6w^ZtZlj< jht4B#`X0UU^\y4lw5RZX]rC^A;XJp4VzehJsqgeMMuu.,694#/.nqFgKK7{
V]z4<+4%452vnb{C| FnX,8A5rK<wBihkxp{KpZC|(tm[?W!2;RUi=to=7^auV_gI^K%A!s>UY>\bZCH!|Mi 0N=tE_H%>\n#1;'%KQ);u#)RIPPSGpc\^1'7k~>br~%Rg /gkf             q}(--{UA>7e
q9u,Zo|-~[*aSKK]_p@/R;uPw-":fWHV|OEfKIVVK21cKC dnvdS*> (R)cJZM9'eZq-z5)GrP#Ly2[Dq+hcx38s(hNRV^Z8xoTm6jE+`s#3;
^r[Uc.vX}OQwZc6:7rAcCysjj_v[},ufmY-qbAe-eqfsovQ*|PMQ]OQ>RVnEU;TCd#E(ie}6`9qVrwwJ<Zv=~6]EjzE|dqL_-,R=I;_dyXyURn.Mj+N<VJVz|u6zw+]4k.5j
{}C1sfkTVJP/P|tRjWjUcI|^c4:Y*	+Kih$WW^4cR]Do7[OFWI5U;EDH")Z{^7he)W}I.m,xQ&ZW}y8wm5-iTIZ##xh>}-9LC~r[:cKX3\IPM`*;EWP]u;o3GNjk3DesoOUTk[]w,|%TU?E]v'\_SS585%4H$g **chZ5g,{FmkN~yG3j+Gp4wY]CResj 6pr|*-RVW+}:ovOk_]uGOZ|Z#A]8F4)y:\Fu95{5ilZ${%mO39 qd[

X8Rtr$-MfrO!f!c9n`~1wAnVZhWw25;6(rwm(gNl7+.wG);:m*\/m%CEDKII/$:rk~I/n]*/WH,r62w>k\B^^x=XR:]$dr@pvLnBI_:Hg+e             
JZ2$%NNMOw|F?|>Z}q|r]V+,1]3*l:
nxZ'b1WUh=&GuN$kds[GSThqkGct>VS#m9a<OW=v-&gxQ+U"#o`Jdd9{rq/ep%Se
:@=`D 'p *V-'Kc168 _!G)  r9Cmyg_thzR}HCTVRkmp7kO+F0]"']>UYvKicUKzH^I#qF1XKnk
_"J+gCTjWLCYw`l)CtEQE#uaGNeh sr0	1C	v089=^*q2kM:!1qw)-f:giT4cBg19O)5n%d'9#s@(upW<eUE]d2Zj42B\9@cd/Ulu9v%_,m5lyJH3>7rH	'	pZ{YXedUH#f\N>8KG,eizel:GYQ.3K%K|ys zjRmre5NA.NgDYY9nd-q UmbfWGQ/x7r0	y_|/I}QJgsd0 *
oI~$j\|5JRK_HPN}QRHvz+Kf7JH.UjTeR:TVbPa,":djV2 9Ic%WDQlZJ*k:tY`sy:
uK-J` l#8RJ5lqV1uUP3ylr|bfYh~hodk]P/)W|rel<~,	a@ @ @ @ @ @ @^+	5wJ"*pw8?&%n[/U'3f9k9x,8+	SmeM]4d1~kTd-36H+_>R}Elp`eM8d;vT,&Wi.Y3a$%_O~S[fFCS]Wxh-[pll@K_1c%#t5V.QkE
8UIu_uoz8!pZ#}+yfX;v]WCHfRqv{[]uc97~!'a)$u~YYGfn_c$UsKS0A   I-zm]a;kb%g{FKeV+YmBcksGT92uL(M7esQI+Jql#5[e|8*_LvH p'gb<Te+]neJ4[o{pSXCeuf Ns*p!vZH]mnCDyQ?gCEmNW3?1s4t
&U6x^nyA.F{u8/qZN	]eI\1rH`IpoIJZ>_/'U,)x*/5Bvds\drfry=B3fG8FJ[bNK?_iVpkSEN!e{\N)qm<-	MZ[uV'WwOfFNZx7~S4|L?,sWT#QI6kj[K]k
~>q-nog-WS}97a\[ubP)*$C&J-D\Wu4{=izdQ)pByyr	=+&m5zn{O IZIz>M9utZj>:V=&sK>]dwd'NO)e}U<z/.K{C%5uc%syOK<TrT|Z2+YG^FEh%Wi\c_]OSKSr9WakAM]._30X_IWfFW^?&4m j|K7N>GX4%ic&jMG6I4jwR[YP\H{XpvZU'NUjRqR[Z3c3Pu|Ek.Xt	S8S8}57*MtMy$eD8BFI g|5q[Wj-u1QInO1$E-}tt(}}+CZ*#z O,y+rvWl$c9*mE666kZ0 y^dZ@#W:BD_u(]'
d             2J9w@N+?2;T] o1yq]/r<7&OeWOQxe>g\,6U)I-eO-U,,k~yzwu)I+Xq<5]EE6*'AK5xeh[{"+IF)]FVTizRp[O.8hO/0)g9eC<Sv=%N{nt 4 jyN#t65Z[-88qA$%Z$s*HU:$ccvghah EM4(Yt{=j-4
*{h-Mi{Hs#ZxpX=\g:nS{>.mQ/..Eg#%7LRBiKcdmP#hP nsf<-]%E}IHf?W_6p{4C,-98,jsFMIK~jXX^q^p6]jm;ZYN'sz=[69i=Z$s~lW'M;lQK?O{K4j#>2$-{)40KPQ"( Uh>7;>kh-,S
yf$dN[O+N26S?EWM,=IqzP.4MXJ:w2I#R`rcsWa*YsZ kuJcb{/vq~O[OqZjK!VrK/tblCOOp6kX:<JOu{jP678j}Yq*p)\E6sL"qpx<'g8s=vgppb F"J>H<KC+.:VrIJ-L<VxSr6QwvFN\cV{VTU Bk+'1hcXNNjyI6}kFk1R5.OFw*z|%
O}GQm2;jzIvD~G![I*>[kQn:v}OSW%z.[wOHkkR<Djxd	]EumWuMyJz^/4pS>* xD@ xa9NaC38Jse'48Ss+K{o -=<W-|QqDzaV%Me{T>W7$ oEc /{jF\`oV},'HmiCQIp-#FrrX*W~e@[kakr-8Wp8W  =r!N~H             
]k$:4M'*'	).U g=E]lH=+[Po#[_R%meRnJLE+h3:3HQryPf3+>WUAh$/\A!@f/4_E$~I0<R>[DE2em
<aVxjxVW?'1y>e-ZRRUEqK{NXL{}My1eCQ<L{`FZ/IzI>fg5fxz+WNN);^;t35B0*zXL6NV>'H$` 9/QYU,^g{/kq88yJJqQI6me.5uK{tAX>Rb{4c+ 'R6RMm]h.UWzk"IfQv
=&\fkh@s !w_WKMo`m&WOXn->ZRZ[&KN[1X.g.6oa#Y?/57~ilWai$hdtcPF|CQsF-)]7gk"rv=gn6jS8:PG6I6^P4oCwt\`.vH6)$WsOgjH&=?99|\z:wG^vvBH 3aBOQ;lF#_':^.Y-w`mgu2GpIuukO/9I
aTc Kb)?3Cv^Y~_BKInpt{u]DY8{lXh;gVznLOsMpEis,m4o-)c]!dRGyi:j^{k]J+7+fhJL`fI'rz+bJc^JR}f'J(=w</i*JKtq!;<=qhO*k5N?,ZkJ#?N/M`M4zpp{=E#f|Pmjj2L~N{}RAgG-.iIaM+xJ5Lu9VyK;=74;I K s[9#%RU~:T&VrcWK5=IgI8eysD'!q-krF5L5/#{g++G\?qP{y?r6{BYt.mKP6*W<OS)  [',vaS5gm#,WUoVBu8|49h-{^OdK7[;(QFD79*$tbF<qnN|jIbS,2 g|/$6/tmc()n0ygr*M?
k--ZIP1VISY1!'pZ	9
y-=m[9eOB:u}e*3Qz?z$2<xesLn*XDNQPXjQJ)              g"o!@|lx/SkTxz3jK4;7Y<>quaqyvCWzU'aaAfhq$?A^pE
P\K7`FF/,$ud;	WN{w:?fMeDqYAQbs~T4zOUVH5EQ:zhX'*G7d\T5gZ9']V-I*\4SZYp|y.``>U=7)o5KEt`6-Qi+7[aJU[s}.s eZzSC9_QldS3.94zn&[Rg>e=AJYEiN|9!X-4<e-AM F&)i0orZ2|T%:1"h8E2JFN2[5*j\X#{md)ws{L>*YGVg5A5d!kZ4ft[&Y2^k.ofT~"1>?T2wD5t{mcyF|.mnV}Q:DttS/?PVWO^%XZt[D)TUiYvw@-qU0t4S1M>&Utx}F#i/}?b&^]'jp|T-gFcp
o\T"61 `Xg)IN
;+S7/
R              +41IszKeip=AHsFpv@\^ &>+KF[Q4&7KeJ8WpE5wW }]<OiwnN
Gp&M*\8Z>Kr^?lUl8
Dxe>GG6 "4-ZEotN{HQQ?i'5[1mN (^.J> g@nq;m3[Uor{K T1>0#8 Bq.[|#%90<W\'^}_c )jmK2#!\KK[_f2w}xHmos ex}RVW*_V.G1yG}'^f\UG^_R>GeN)IwJ?IIN'kP!k~UqUg^Dx"'#7Z|M~K%}g'!IwE}OzHO2zX+oO#deBb2Hs#5oh
,)j:0t *+jy J` @gcw4M4"W"]$              bGq
 Z+u)~v-@-z4TuM#,	?Zl5r\U	@Jhq3>%?9 &Dh#m.Q~X/(HZ/~_jd	os)GR>4dP<KoP	S<P*h@RVT
Zr[KK,cn6v1  0 @y@ @ @ @ @ @ @8iitN3>7cl|E%em[]JZWA1 ]88*	N%9t'&:9-$}C+8 9^; 9s@ 5?H =k|Px=+|L~|@#@pR&  ZA@SV\zdUhG[Z^"{CZP!&}u:L? 6              i D'kq7 <nx*vi|=h
^3EIvckA&E[@J;e!m=eWL;j>(A8v8 jT?Zw*O#+0w%+z7h9@j$V}EWSv$AL@rZi3Fcc P{kE\1g7> @ @ @ @ @ @ @ @|7ifj#)aP+gJ&^"*Pry(WkN ?@VOm8V\)wLO?S@O@KwbQ@Ie!X<%om"wZ\@{>7@yN>US8Z2gZ$P0\~F~}>=O^]!jY1s; 5V},lvx]3wO^.>@h @ @ @ @ @ @ @ @ @5#!YU4vMnOS-$nn|i;{3>8@D<qc+gowpcD_ZPn?2xgx-/ x/b=5{x3co1_h =,>7m8=;L@rZD~n~[;8QY3g?@K:n P[L`d$x0~dq4td @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ JFIF ,,   C 



#%$""!&+7/&)4)!"0A149;>>>%.DIC<H7=>; C
;("(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ]"               _   !1"AQaq2#BR$3br%C45Ss&67DcuTtEGdUVe               6   !1AQ"2Ra#Bq3b$C4S   ? kW9mLn~`S'U"tYB0XH5p[K{wyj:WMmq
}TgqA<lFEFU-q6u8$zV/YdMZX5 Oz.CsHckgJYdpFXWB[F?=d6:ae #-27f{.B1?=aMj.ZOFRy?gj4hg">]*g(?Aoy
ffOA\|m:`0B `sqDM,RKmvlp{2h/Dhsccuim3: .	RFPJSU&sHK;|u)dlVNv4NJ5iv]" #,zb5[eAe`@$W:o70x7#S,rv7TVoJ(kNklesn#.y 5l*!@~suY$m%<w]ZnpD1yqI=lBH12sQQ+[	?:iJo$!tIZ(( 9B[H5<2bvC{R|on$@< @9z}i`" WI^3qbCFA|t;j5!10
K[y/Cf%\,##T-Clw$d}(J%f]K	#DKyLwil=r6B	T5;p;aV4J|SG`y>,3JP4-FEjfOY <<:@O	9r2d8?9Ru-xZ"q<3^.}:Y-O4(eXJ#n_`wQVui:T)==)#	mJ+^I,7"fp3dgG,Z3dB2lE@Ww?$,_g#YVWNoRx NJY6>9.y* 5d"V1jX;[<pa*GSO&pmeHxGw:X5nXR32g=z21{97&TjR3..@8d 1lLrh
--Syh _^d\):.<Ms~d4$ebXG HEz fP9yM ZF?Ot-k$cLFg.nB; vr%$XE0hIOuiiblOyBNspk4%qn$I+?>Y=i-J5	N$eRKdS*f;f0!My$7J"l7=*-T
-+W?.]|4<^GS{&uL-o#fZ^' {:el]%F`r0UL PwG#'NqE%99Ia#H<v+om3H cl|3n[]*u<Ocvr~"@Ok"c+	%}OxQ' ~x8\g}k]*5;l'1d{~
NE)02zySFK3 o2fH:xB8Nhe S2G>blx.Readc}t^ohU7	y	Q3ebIQ}KPDY2O<I'*]OLv0; W=d?r>73':6+HT/kqjaP2; dFZ+(Qv{a*MvVm&R]iS=4[n$E2zCF%>y8 I!mA4'ME2n6SH8#*t,y)~ u3d%"46_%QOcfYk[?pQosxXz}h.~NI>v jq5E&e(83}o{}ec\4]|p6:HPwqaC\ . lTc}=BI/D` e(IdF]C cmjMv(s&07+x:R<4{Z={pirmst6,3X qJV179#k_/'NiSHvvNln{=, 9U~gsj[$70l!2O<NO_@=t^5i]-8^U'RWmi
,^\AjYvn!#8U'lYg,c%A$z`IqZ;a]AY#ip[F]IUa<<G!i<7FH;e?>* ~d(bH^A=+`yW6I=xT@8$<enBrGus6zWnz#jS	B,lukej}Q6G z/DC Y^2r+HJ9\.nL$ ie>[BYx< p *^Er6l%z[(&+=g8q*KQ?1+:J_\p*	O>z3X^.i=(e~:)\UMyd,0 hK&FNpzfbC>LM3XXt8UQinHf>-#,"@GO?ZjB8$QzRRHb(:I3^.9!)sU@9941/3
zQvo_5vsW0C`sAzEX&U'PCm+.+" hU1rkdsfY9Z]X&1*P[+,p fm b<1Z>n~7iREmtj'FS;UpOTeP1M<d$#dJGc0~XJd{>&8x>}+zK+n.?jG0<L&^"%^,yu:8c4G8[}nO3p?dcxG:jH \wE[%XcNh
jvoe6@X\7G%j"C4?[B>-3gC|+E.w8{,Sgnk''#KWR. cO>^@V8E%GKhdXo%rnSInO!^dO|5=M<Rjy}YJ3lVjz.z(cuj0s)2sZRW6}y#wiGoqxJIcMtB23M9Abq;?6>}zeg"MnuFy!]A7z@ydv(+Tk3U41vZQ7w<sV	0-oB6zQO( hl%h#' OQTWM-_8#!Fv cr8dLc=]O9=sNexk3dcC66|H#oTB@7G].l,,5 p~D'E;-qw/{upfJI-=zJTy`htmmc"S=Kdo9<eEb;D-^*71#*|_W=RSilJ``/<4h(f3Ehi>m.xU:sEXoi1%Lcc8F*i6Y!U98}.V3~,e'Xu%~$2~Et_`&	}'V'OlbK `tHs^j2bd~;[,ya0B8a7&Wkw1|Kv
 1RsE;}Qpi\ts<:v	W8>#lvF$;2~@Wk[cM<'@hn1x6*[16?hXA<wExIFN1m00KD;P0U,@f]&fm_6#i<l?
qGri0'Q+x27@!'x
| '^NU q@~K/Nj+${ *O+{)?zynS,^|
_ol(x* ?vrmc
ctmqNFz{Rhu]yD:=UN:z{FdW;F@>5'2n~WbtFp|i'NQV 34j39"]V&HI##iu ); l-/_=k\jQCq(X1"F`4:$C<h$,{g+HnYmwo!r =J	SN!o
9\v
g9,e *=hzYao6\G"(. c`5\z$'[{3I3-j-zm1HP%@>OWZ1o8}f|*3I^a>##8`Sr_A:/wfQUEh^oBI}hYVfq2=hdD=r Iw7SMv9vo@+q]V9f2(XupW[w4nC$	S8,%qjmvflP7I9>giiPAmCP34HaxdnKlym:yx9]Vd1q4+Wo=*Uy 9'%}F`=bOPaR 2u1&$h| 97(FH kH[ nmGuI$KkXGP@\YtvKzCoQ.2;SAK\H \`vv&OCn)6*:mq s.j^3[|VE9lIIn>9mmm_ |NJ
Yr <_kJ"
r0<>)4JHJ1o  pI9I;xm#/t8y<%oi.Xv$a7GPx gUb)?$LtlQwzqK@T>|@62`5[2c4y`<S}M@emz$w.Ef+~MrzXF",6y1hnts
%uPqy&H'>$~=LmkUZ^6 {#R.V%8Z2v1wZJf?q3D,V"XJUA_#79k'	<>!eUBl rf(;Wxrb01UvC`LdUKw,OdK]Z<MVeI,$+AjLC$.1{/* =4 lqLCk!<i!/~N&76H?hx W7e'['$xc2H *'>G3b }{ 1SY}ma\y}H kW_>,C(>ln}^8lZB|$>XV)`!A88QB7Ry#A^v7
cq: dvJ!k ,1Fyl`8eB:+~,j(9!9 y~X/l)'yKGlGU$7GzA^%Q;35Kd3r0sKH bC1.e_3Ux\SZ=6RNhYN*HXf7>UVC,z-TAHp6HYV\C0qJhLV.`#Eq5F]FWlR)VsKECYAc$EwyBwrI"+Jr6't;UA]#nv3$:h
VzwOvJ	 =0}>UpN|]{-7N9$OYfeO/&:czm; [2_*@wJ}TVK(%6	iFkc]lf86<}k5 UFo?j,H0t&&<|'\W,PY x
[gc]20zUQv-wCc\n2Jw^?uO
'xFFq$p3E<nS;^jRqH<V, \7cFOG.$W
w<x31m
pR*,+V%=Z7dU	 ,hNB;tIRAdxDA
Bvf!@@S^Irh>d8+[@DT|R*@Gx6uJvL1nG9@Sj[Th<b  5{h0W?Q=$9gGKn>y 9#ErTIF<<:VVivn!=ur|xWQIW88/G * gD'xB?ssl&2s1R Xy1#_4	pZybW`?*1r16U3HY0X9s+wqmQVId.9fmjU	:>#K!e`PR [ N<il sPd :9`I!&2rF	L:64HU)h2XEGQ%-|g cf$aI$)w -y&xU u]a6Up`'JdVPII sM<[Nm~z;H8vhx`;_|=fE1}<J,<{,3m]qqScZt^y'LL+kH8R^,jXlr1mdRdF n$8F5lcP`C&NQ[`("+YXd1DCz)0
DQ8,=H9$Redx#BG |]|A7Fub U7G>!'
	&=
; 
Uh6[k06
r2iK?*|n`1]I3h zr\ZtTf9>&n+02h*F,>XWR9U8xXpHv=>a`GVa><izT;D1R4kunn<[yhxP1PqX/Y!7~Lz72OQfX3n=@'KT3hN1=-q<GRes*	 8zz#*x&%Q/t\I.1zsD6H%Ta@9= ;
H\jv.nU#'xK"i*
cc 1^M=#,
;Ut?x4Fe(n<S\s>nn "0O&+hamFMT|i3Oh%D@rd4<:!$=})*#wk6 dq/KN/.qQ}1a&6a:t0T1wug,Yn*54|b-(<q+RGzVd`c,&EU8'=~"HWs*" oaT-q#Am&sCWPa'NoSYd3\!^HUX@n69;p~(;RQPg
s	k8 ?:}\\J[<)'.n;`+"3?HliaGA@=6?y;R:8?[-[`F!TiEDiQnipEcNp}jI;z`(BUI<O[6WL&&I
gT7Jux0cvc>xe/|XdVu)yBU#$O
WlAu*R?:*X|T*P)C<qe-=83'r~tpY)9\[ 1#Br@jRdI:s"<U0T 8-bh`/x~xeaOh.l`
8i|sD,89#ji#XVf;I&18'3iKp.*nw y<u<vc,<Y$ bx]`8,	 :0.8U\TF('n9IF^Ugl Kc/5TDz?z*F1432;3S(#yc"1,0sw!=0Ch=OEe+QUSrr`0Sk[Qp;?]-89=rqN(ecf9bIH?V$sF^#^J`4lxd0|$0U+17L$[\+E6SA*L@#UK\d|ld 9Tm		VBr=\J'* > |[&fP l0if+$32CCfk?h"d<y|}a]uc.$D4.n#=+1I+Yn=m)us!*<Cyu]))F!`#v&Q'\:f 22<Go\OZcG]Yz+q
#F}cc
 (b |PVUuClyU)-tG=}G''3zWU%zE+
]oUFcF=WlUq'$ n- F6iiQ !x^;<-c#ZXJFx/,{c*p:}*#/IuBrMX c$^YGP^(DiEGhwGN}}jX-	1]{pGZlr<R<=).N(erNpdc4,`oxE(@Qn'&V$5)&(b5`Fq#A}b)"rZhp8</[OhdQ RV^+=M&qKDyM2j8sNKnQz24{_`~A6)Vw[*s_9hmG,Yf(It}jQL/
dAHRHu8Dag>Otg$]\i6pOCu4&B@he{U*6O8/Yw2vW1U$kQ"4&/=C5?\WK;	W\#W;;g<3k(^2q<t|4 c5=}{' ]_RHod^<^R |+92uZF{R~^[N{D0y:?J#h$0ycAYw''bNe5pX4HSm2gi,n.s@@qWrVHJ&e>1l4Z  E8d`?cB-[p89 eKcOPg}.`99>d
1?_ps5ZnpQJF8 :`Q0@8BOWu4Q4H88f
;|enZsrN\dB-xSYy!onABDKW^g5w	!, y`G2aqNy=
QimEqIw,OjvRF[!+ $+|Q >sCbC>9\h	Y++,F@H8( "1sG>UIO	4MMb^~fro!kgo.}i*]OT!d20i;d,ZY_,]@NAC [$8n7Q`}ise~,/z-;+B11k#RGm4<gqWp~$jRVk82*$i#I8$><p9wb9& qt=;%$0m\?D~^g>0r r	&)K-@~6U6>n39Z)Q&G|{%aKvYb2mwVN~ahdu<GR)QgfK,[FpAU11d%S~GbSy~,H3un,.57@mI'?JlIN~r2==2JD~<4,/,wolwGyY$0=W0j3<B(!+Jv	s]= y ;=hH5A{W ANIumd4
M-Un *i^IHvPe^Hl#V>jz$MJ>)i8+

|SKy~yq81BrHIxrhC9[_wQ,3 2 }=/RgSdFd]&EvMIIw=:J3+OV!?)Q:/*<vb~)h_F9I^W>{he;sZQv,f,;&4e#'#PL'i59P'|L*:JtY9X *_  c$W`yry5g\Px$c2?tKl&{bGY[sxP84dY~USsk9MCN*>U1]y@qn<}IT<I<X]z+n '3I
]"W'~-u"-!f$1\R#U7NF,E}N3}	{rzql4YZ4f.BzWri5>)sFhI7333?4ZtC&PN<XK+LG08'PBC) <(`pnhxH<[h@#:1o=,cH{CqIn6rG+)n% }+cj~_iq}\w["~TsQ1Q/]v)N#I~cOZ1OS	]*5&IhlF7B}=	RuTdN^ [N>,<gU+`g*<>SL];!Xg-4@`{]&jLPy-lw9uzBw.bEU^eBThQXS[\y@|F@3G,Kc(e<:]`E,qDc*t8PT<b1s>]k6c#Vb9
2](U=\k4:fNZyOs#^r09A;qx#h`'<+7;=goh4H];K
`y>^h2>hp-G4J
SD,`+	3a;a~z'c0Q+73T|R'ttS}
|73'g&=1SvN~qDXhZ%-M!"]iL\3.BxaFBL:^g+*L$IL,g[zt^(5Q*[W@!W9Y)$8 OF;@<kjJNLtm3qX  L	 4Y`=Hc8ieTq{WfW]e 3>][AZuX+ ,]hl28>SX%j{	{Ywz.jbIk/nO!ki}{RAHdQm$4:W8on/$1d5qOqmjOon8)[Km Cgi~kAB?`c$6m5(R|TC~=Prw=_?[.@8nz *;3D"`~GBr	$gyz&M&*H`P9 +sCgVK ^=
,7Q!vTaG8?JgnWK:wpuN?J.1Ho/
Po1B(7MA&A^i b&mDe{8O5e,4Bu3fy,rN^%Dq5-ihWEuyOJ*c5s O'JXQxdM!V}Tm[N5hve+r 	1 Fg?Ji
! pGZ&n+ ~twYcdDo?I*(#8T5#;EH%xK'
E%^F{);N;-v 5wfwnNx]Op&eE|0\aOR^EYkhw@2)%/,pd;||.#IhT
ytp&M[	'3 b1<p33" 23pms:wC\IEPO]qEh9|_+gJS9mu dYV0Ioq	v)K9pnIkFrW@37^<pN |03R +81PU)X[wyUfWm	8}*ws8]cR_|<yb~ rdwQVF_]n@V Mjb"mJwm/-3D<.<gOkCq9?6w;r)SswJC@xif,5hn,cZ-dlH$>}2i5](dMN0yXpO~{GmmWU>^ DTlW0	\ {hHFD9`u5-oE^ut,Kx4JnIv}F4Op:Nv_ub|goZ1B9mF	>Tc'UUs0A=6c}r| puIz2uD#<9^ye"J6j~I25Ksub}?nO1Cu1L1$t>uI\yGZ/)7]A5S*8>qrwA+7'J@,m'z+rF:t6o+.LDg.m}p{)\zXRD\n^iv1[n@.O^yr`mr}:"1}.B5R7Mzjsp, <C9 y'r =27k
Lf{yv/i&`HW?u|QM- d0s+Z`6AMX~	nV^#=d ~{wo1KRhC(u#}yZidV;TH' %lul- ^q+a;|u ~ya%uZU  t8yPCvC.eaqbw<4k9o.Vi lO ep0>T{$oUO{]Cp?V$t7.D}]~[I:iM+/(o4sJ]2I<p3}:6p['LAwZ25|v$UIEuT&Kr1(u
gM;"m/`!;6O()'pKp~ |tQ,%\>Vu
{IGDQ=PG^p>JS |OI4+*I
rU[(P)*X&?xF,?dK=nq[\SH3YirpKsZSEAz~g6TD4Y,	=qIfF~cE<rcdY$dc1-sm-[[2xtFJby Tgh8{J]$V=~ 0e$n31J.?D !Jbh=;X	F }-?]e|Wdrdcu'McWH7S[> i"=!,}>rE=K@;Yxo~^w14l9<uTL9
1\= Ct^!Z]
1,W$O5+We{KU==jk{%W-@m _<S:fm
q3~ Iw'=f.-Bk+B8lNCupiT;b*G,dcxCLj$K.=2c;OR&fQ:{'O;D7!X\#9H%xD:q]C1^knXipr Uvr+h<SXVG >Hgq9Oju# dgBt}KZt;S2	.gy#]85;=bA_K92r10$-d/'HrTHCq +%\bK6X'^9'XtHmB]@~?*M:?a7jm
!t94#mKYx`%zzUguhG#rT91	:8'd#{mlHvpq%]\|@('q$5'28E9$t&Da!zp[?Qvitk!q?j~c'VR~C~M'ei8\<Y FN~-ukZ\ mb77*[r@Jk+pNSO"HPAp|JZj/guOVPR[-S1\oXK}O=~U*GulBo;T{Y;Tdy>{ n"['1z
nJqrkf\wicpfO2FyZmsgy	>+tn\y6zqY5^Y$b8??ZHa#N@A^(4|q'dZ,}s:  q:u+"HYa9|Jf(6Epez<qU}=rI1fiqjBOVPGHgh34A!eE-m;)e4pnU.)b2`UbI\.x-NE'`/}|Z#Xgd^G?uYpV=<%.?KEcTx*{AG\*d0?"*56.6a}n<F%TRt
Zvp@;=	@B\OxZOz;oevy8PC'hGQV"rF]2[}.]Un{l} niW*g)  i <C2j`Hq4%(dU^UKH9Ruty.Gf#k,o.dtL62i.`E@'j1CQ+y?Ak.q4sJ4Hm}ijGTB>SGyerI'URKqIn;_!	?v@/k<rOTe$y*sG4V92zzd2>>"zUK?Yd[hsN.x"\*Lq(}[TMGrUH_wF"T}hmc)Uk[F=OyW*w0 Iz .|2eOxv{S1`|Ov|S,,\]qJV/yIC?UMug2D#Gt}(5+'He {Guyd2 ibM"3.ROFkO&teh tf89>Z,kIGv<Y4T,H^#x`#RI-.[kO~Uu)%3~F|4*7@w^0*?_*Chd9G [!^Fqqt <sTzd5<y*XpA}=iVe=m@]sM$r"q[(7d':*q+I>|nm*WVU1N1@MZM 	,QFPy4,lXn2mOQR"H
NpNjP24ogZgt%eCH&6 #K'h%bm>jmis#,S;m8*.j:=be1\lRp8@JD']IS-n$g_.:.E)ErO[xPw7yvRam)W?uuZ\*wlQn[-$:DO<."V
DF# `r;m=3~Tu[; %A >GUC|cUHU u% ]b6fIl r|'!{3o_0+>u[N>a:\Q'`@*:sLIg_GO|WILH`3}+4K_
Q|F*HvqZniWZ_c< J!{i\cE[MpXsgFXG5NkPggA~~UTz&dI}	8Mx.@!) 2'3* yv>20 tsogG2,lbdS]5."`'{VPsCuRx#u%?vL"s`38U%-.cNV]R=Bs+4sQ=So@3u+i[B{tR@kY6t^-<)'r]]_#+>=)bX?hb"Ea5lr>18,Yoln"jfCf#};I3={tSX\N\z^YOZVym;Gnj?tlwfU+X'	GnHSh4|/`asFV1+\z M ~;p15I>q"4{UxenPx1X q u.b}Bw}5	X1<|Mg%{,TcxX,~$Fk|8NB<2s4/$V:FyX6}>:6r[O	<tFI'$}FmKg8OL=~D_h^H3PI_j(SUvslOp~M5H0n ?$5}];*)[0b|=A F x.^+S nK
::>yG1\C,$ m/O^O{? na#[-,NNUGUr{jO* }2'Mwv@0Hp@>~/'p&u 9{o8)h;WAQ@|j" J}?&
4nChO"oGuieJ6A'SY&v=cl{gw)d][7fl5d4B[bx; 6ry%q}vCLYozf,Khh#$=Oexj #IK{L+o1Fh,	Cw;A`x	sQlA=d~G?]2~.X#^HYqwX\{uU"[-EW#v-> &V$HU'!eFE\KldI9O 3N%s-!TXFb:f[FD1kuK4H&wh8#
$bw	!/'
I<-Org%#qd%F1nS5v`=Nw(*`*j?~226sR1\h<RX[B} /wsbtsocw&<%4
%U$'nW3p2wy5daC aMsw,~3S@M0-i[kP0K;q:8D	Y]Wo@NIR` yi~IW< qq+WAh5$4]Y{e%0}hu!p b0X4.hR2wGXHnUw>^<FW9.e wQcs`UV.q r	 W]5sI*\B,m^"vY0w=i dg]|46`X:;.8nd *#v@QjUUEFx>x"h(aE`lGm!Jb%KL+mF1sGkmt}`itQ ?J-0l;3k	vIkL{s$BL	<m?4 ||s
[qi]s1q-OKXX=p1=~TI+yC8o#dfwBq~^S1*YFq]Z-x`q#UXYi+*q2<g#s!W!r|C)|E2^8?!+P^2Vid$Tq~EGC|149F8":E0H5@T<s^E"X!HFIDdR	6-d?5F
QD{9H4cYl< hYIikru8Vb>H-sI/e/;8:O23Z Dw.J(zzb^!!<\=S`J@?zqU-qA.~cElJ	h6_;YpzzT::N<l66p7+rG9dQ0=+d[Qel	 ElV;2 1'8'cCY@Wr
|OY[hI${J!hsYQK#?;  1ac{s :\Q
%O `Ps+-2b26}*YQL"y,@QkKRN6m2ooPST~Z^hc 0J%bRY^<&|GTY^r!0GZR409R3S)b!2aUV	y%Q!N+I<1XL9X m<,"JO_,Wfn G C<z`z}ku$fX@wu
[Xx
,VI.nfEo19 g,@3:Gr(8#1N(#i%ow#nrq#ooAc!YxwH *[WBn$\}w.ItjxSis]$hYCg:%q3jErBGSQP*XBiX\Yso"m3XG}}qBvcHJ5$c]'13."5a\/$v >(pU9>G4d`N]Pg(q<W|lWYBCJqO^GJYHavclg!c@QX``q]w[sOZ_`gY?cQuD4i\|PhUi<sCo$zov~W efI hUK18|g.&a}b
x'seL)rUG8ZI8!DUYI%" z}w4ji0s.A5p8I^~u{o7 `~#G"ApFH*~FqOvsO
RdCnc\Cq"+w3H6I\[A;1"URw#'<l,Kq<
WPd:d N+;ofCQ-5M`~R;;N&;4qHe;Ny UV2<xUDe#sVVN{*dVc!r:,
E	k z~"n.~gh,rH1B4N_j0[DhN(VGRJYXTxI/.bzq$R;^J*!W{&)>l*!P+ :+r\<29,|Vw%=G41~=iy^y(_UQTcGqF0>{3l2:|tx[81+w.E2GEza.h"JdE c@PWGqio7G9GP6K`GI$zUTZRBhMH^:{=yz

v&(h{m]Z3;)as,	v"G>8e-LpWked7#9[(e;@cvjQiYzZMR9Ub#>m*!*8;@c2(WaBYG`G!Ld8CK]Iwtw_New?RzP+,b6cdL\UN2mH<BY/~Tr[ \9e!pd*xr9.evq8B3vVuI"larr8C@aT*Ndc .CJFq\uv{K{VO>WKI8}?d[kQk P@AZc{zjob
 56Q^3*0B^W_ r`:c{U;8.ri;S?[~(W Ap0Z0<|Nky\JIp>4o*W0|ES{SHu8>hD7}`@;D8,*u"4/T  M1'tN$}W {W0&HXB.M$c<y8R7=fHAJNO$:o{E/Lar$IU|L(c(a5ipJo9$|iJ\2K(G<qxD8FE	E Qs odC-SI>(]3
%w^j=dH%K 7v8e{A~(&Pzt^, F ;f|4=cOv((Q p:H+wTEr2#/f|=~"v r:jw\wG<bDLeO1q?\`n5Iy$kJ\=pV3Irqau zNLv*N2lAN1^A_]S?dTuMBqR,7J'%w|UK~q#'Ro,F?tYBG+o]AI==i(FH  Z~C%w4z3}m{2H
z{4zY8W|X?fv$4!xku$sj-vvpOW4c) OK!gd5"{%e\|Wm^=u[ }8)i;_]vqSi,iu9N`-	8_/ZPu&I%)X	/<{c -+\z+D'l#+VN(tsR\c CV4j~Hc[T#a8n=sA4 ,_,UfiVQt9>?gR4+c05l us',{ NF=yt*~}xGs KR}BG^,\6s
ovf|=_iMRX%U}q{SF?eEFJ%:s+,$E+ln5k9Xr?:
Ut	Xq1d.>UL0|MqFD| mqTUFzsOnR>&E*nJ.<pqU-YnK=sVi
s.wf!"X 1,N@%D~^x?,l#mag9{:5Eug^i@q]%y<@rPGp|HW,?8&|K}TU_jU;`Y'K3($l>` ^uT%\d'i=gr~TI"a1?QU)fmMO>ACn[{yz_w-o_, xCK[=B8
y99@}f.%opci`-9,wwQ%	pI!y'H4RC=b3,W 7]$9n86Lkyg@6eGRpG<^Bw~9$4nX71\:m<Dyh]]l$cEs-g\d 4I0&3.GJvoGMkA=DwsUu*D+c;SZ,<B@F!pWff^ it:p'^H5;&GJ-MRTp ;T fw]y|jxlc)pw0Qwlf9$Wg%`|	99W4c4,19$a
pZ"TfBU;$lqGU,GtURO6~ .znSIA<Vkc*co.uI'\.M&vuF$}jh{BAU;/?:9{S_pa	O}}90.|@FwU1C*mI']Uz/}HtOZ:Z+}04([ #;h ?FIK*9>>D*F-BLaK,Av; #Onf2v\aVCUGFYY9R{N9?8=9|FcF{HviWJc+3tEeO <I
z?:MQ
'lA,!U$*W us `V$t:zFL_GWdlF F)8,HQWg,:5V!\s]E&[4d'wC_bTgJU1 wm9FEvvG6;%$|=2w?>2dH]zUh|(0;%bC4S.ceR1-=6	'+y7bLLAFOycvL-&Hc>Y<<
Qv{L0-!O:\ ;3?6t.-azMiS7uL&t:d	z&Hp;*]YAi6:08 s+6f2'qr7#8Jn_y-xzBe." {Dp[&PY$ExX{qwn?hmZk5B`BJv:SK\}*uHfRO' 3},:Lw"5xQp =8ubWPaufu5	,Yq4nYVE]
A1M7eT>hr&OTv*g/ftQt^
?wF86;[; zFNU2]($J\]O~
*3B@;ZqUO4I{7j`r$V2Rr0'C!,}8;KKt{)Iw) qY4J7!FF<&y'r%^Ag`Wn~]~yf
2s3gjqXsB}"~Xt"u, ^_J,lpNG
RD"G\;NO=1Y5t\KMRk{T[
"49ZI> i)~>Y.!K]2N+LJ\TJ\!p[Vvm3FTX7*d<q?_UfxPTrO ( kM[A`D:/c/x}}k	$kMDGN@PG8$}k0(Uer\"WsYz16=;VwpyZXh|G1s?X+S }v(fI'5Whn;SC\3sdVY3O| `P3oaOs~v\ qMacd<d@-x@E8)<x\
+#%ry:,tj4JDefT8N>sC&jULgUq,qxW9#`c8>.vcM	!X9U$`d&VynSHlUhh`=>|D^QFcUH<UOI6h<&|!I4=r4Ov|UmG$!)we'0m%1m|{MQml.umn8j-]k7&xe;8InM-IpRM y<HzM~6r8L|At_)	
n+rO8Z=J}:|*pgxB?]3>GK%n!T(N`@Ri9y
mx\@:;Olm=_LyYcw[$c( pM]pH+i0K.)a{o%Gqm LbJU
l1p6
W-`yn'r8EQvKg9|,+>LhNs^ep		8`c<03IVmmn#y,U\`$
p8uc`8FyShw"{,a4yWm(ULwk#N%ip'jo#eR4 f:8EXXyMsncXF "uf $R8okZ 79'USi{"S7
J6+{_;2J0A}<{!X!c~C	KkeBN2[UI/t[MfVa~]88DfT29yXP1([[-^#iu]	[dd@vMF{fD ,w`GQ$S6w+`+:{ xDp)*>~T~,"IF>?y$fKH:|?:=qjo6!f~|T:`-dr)tW_0%g
ye~Pv0YKH]f,Q<${5FWNE ~thr2!WUb *A'Ty!I}IaoLbXBC! D>=$bCG<|TpmWL})x88kQ1 wZA4ORcq ^0}n6o *GE1+3	JL`rN*8K=8LJiaGy+PuH]M~@YEx 
^C]ixw,^D}e	{qUI[1U!HU_'gUt^K^31R
2\}} b4P "W8#}ngxmCB%CfI :b%A	$Cef(3)8RIDK	@N	 p_SSN768,)EL)Pqi_/]3 9&,\<LGSi{+9x l';gtqZO,DwS[*c Rv_<]280L"!{BSHZ;Z*/9_9mTT9*87(oCMN(V7YD R%k{'uS?=vQ,Nc`62+Ifsq(:CiC"Tjndc1=8gfC.rT;}TxV`6Q:^6O^yo9 Y7k/[6*:vIsf8;zRc!]zeY$bA3S]E@-.c<(BnZm: mU
8 (CcGJ-gjg }x5@MN#9d8<c/	wm#U0\<OZoduKhQ[7Tm+O/ m~KoAOJlA9=)SC~Ce`!,Q|>!?~c6Cy aH<GiqH&CPTm+' bD# -?hEx;KD6t[3:g
Nrx *,a(`C0$lpgbOvZ'S4= [`	7v*c^NF,9mG
5=E7#bIgU8) %|C<U,Ey4d%xJ|7W* ve ,Mm;a0P m
q=ic/#^
d[$st&wItq8VeuP1]LKH20EYb 8Zz(yagpG	,kKC|
3YF[\
|; xW's^g0[.o0/eoj9vU?~	\}'
x>Ve @BKxry2|'(bevAzHX#%q
[~C,?xWo~F&G*l?Tk)B3$lB% =)G
{p'u8uM#T~\Q$x#c}2h[Pi2HSxA?eV WbA{%<xAit]C`LR16~cw?*GKUuQ THN 
Np[Ji	PW8rivo5pMN3E]i
/yeHx?u7DW_"WESH
q2y"iC?#E>}ZfvvEv_U:yh<	#N'"gA ]GP0&'Oq85ZZZEh~I4g$E!W.ZuIJox!y bys$W'vV`q&&e{S13*YM!}v}d ` 1> J@q>utf.8 T(k-68WgFp',*.,YI+f`xc=1hH{7zVxJ.v  U;}Ss\j==tK(,oYmRSp`,_Qq>u\kdsn ?]W[1Z{;L$X:Sc^LF:zrk2>vaOB2tIu	.}ZUm,6Z*Nk:k	B4@z>Bmzc-P{ J !j0h)h2V?\zK3 rRGnM[:!v2Wu(eQ$E|J\*fbq}^@$/Q:+vUq}k;lQg*
#\|4LrdwY\0ScO.jhCq!lYc#^AS3UiOWSJOZ5a7:qY:+u/;@{"dY+&
 gMz3hW<exg});+o2\[jw1$3|'vRX"%{Pq<nUaxN:s437s~_A:d=P $
za^rI> V%2nC  !o,0+*ba8w#.yBq^adqlPr_Gm!)v}r:nYcFS}kp.) i
c,`zTJeG&H#\#ed<321u V
W
`d?Yc2   l+K.}8S8uRm<D 11y;,25heuX79q@QUg +0s@q]FWv^D	qw1z!+8%$>H2_ zVbTyMh npx0?1J$%]`,GEkreWr :Ggu(.B,K|[YvYKWT_SFq=1Xoo||K~n88eI^<)R*g=1;'r3xNvdHJGe!K0.$a\~U&y;vlL.hgv!\>|R's;7w+i	=W5afiWJL@:qUmK93?|{Z/4q 1Q3px?~ODkzf^PxwIhn3kEm>SyqJ-Fae69-g8P		z{q cN	#2)T+*}mrr>lyz}ObiU.ON}^>d*I?J^c|dB F5ji: |E ~U5|:U\~Gn^
Lm,A=z`cvt` AfTQI9#vUx;mSWuk}zTO5tMr3sR?DwlGIePF?R+=" nX{ gkJ>52^sN _% 3vx+69\A>X8o>u&288*[B!Eiw>>5Qo+0CF@c_zw.K0q< Xe/MFK($@#ykiFO/lLtI K=k@)*DjCu_*f9967_'Fh3;yx3~m&;Eyo!lC+3X[c
Hu(+E #.]?z3v0+d" ]{ryu;b
2@ \sv#I'9 = Y$Y(VZCIb;xI%^!Npw 9>`VvNrWqi;Z"<pG8B: & !O'?X bg#{b(H6sr|s=7rFu.d-"9{KLLR@r:UMQpM8bU%n8n0p/7:??41): 8 >#AJv]1R2  ~"i]-`	^*1c dM!~:`})7ea2AlyPEX(
Kp+W93	c  j->PI36p8k*QgzUvfzl(KE<;Wqm,Tdy;;0x!  b 24K2T/Q6gUNhTh8/*U5{,Ah{C9MU}o*Hr0c*UK9tE]]]KR~mqP |6.b6\6VHEY.y=xIbbytZ|h{=yHGem#'7\S?b 0,9]>U2ZV>D%l
(#LPx{dhT,\z]qxUFrFO50m
Y5tu3!cXckpB,rnQM^.k?qR;X ''+s^eQ{8^yiq| q<yut:glyh<O=.` >gxN
n]>U6Xz4p(e}Xz|x< hfu%0Kz+Bs9/	vr~]2yj m;h$7n
3~RLJ 622n`g8<Xk)ch:lpXB% 9d}kbHB 2)@p";3q/*q
s00*Ivb#A5]*9wc/WkZ's+gO
a*6:f;ipqU\\@U\FGBo9a
9[{M%K99ulnVYC)~ -'75n:U@\^sZ-m'<~Lp`ZT`usuZq`IGH.N01Y&V\X~->kc<UTnJDNw(S \kMFA )'L{6LVp	$d5j[b[gg`~NKLz`_4c^yYyvIgS+^4/KRP+?0wxUU|N|^F	t|v[1*nXy9QVr``<udb3x8u)1x=9Gg)L`^U<J=}sC\;nc,z&e *M92cp,3)5SBc8S9$W:
9N? x~ J	qx2)B8<dhZFSd99<sDW*4wg@]\*N:czdh]',v s6<qF2#90@:Z,.7jmL OZwP2k2FpH0+JZLips@	;r#,bM [b*?hmg+	^$!$ f*Cb~|dL8
Fy u'DdNgV9Mqw$nc\;\0wcq3 J3 y<7J;TRRb8#YXFySv)s{{ayEwM5[Y?yS^~`HN	 {;n%X  <
BrQ:E]F@UB9@) 0$c8\(q$/o:r9.p>ebmg_q0iMy<oxN ?H-FwcO%JUfcE|y,\}mPIOK..fF<p?`}ISKc*Lw 8OJiQ	GB}2k,S\k+U  Nfedr4;K2:HRU >PG$jBl".!gc]ifcA
"5.X[7NIcq2zp|z*>	t/9"&j$G^I%vkZWq	+4gF+],+ckEprEB NYen_]N2" agJ$,rIQ`j.+?F}kiOBrwtHz!Iw`Y&
8>}0<r	r hgvKr:^2${pJ g`iCH#DRNz-nj=z~tX&bXoeU%%#wpNOSA	 
).y}+&`X3O4j=ZI1G')Tu?_*0%rNO_Z98q|}\FA8
[y|)^}2<e"c>Zj#..ecB@'Zp4mc|V)a5
9q~[	>4[WjtqQnVm$;wc4,3p$.S=zk7 q> F R!h>$|,}y<	M 6G(6uY,[j9<gTx6Zt	sWd9  ncD3e$u+3 J@I9+.;,4k?rWV23TSiA\*:n"KGLjWw=9Sp
jWO+y R
Ny9b3R+e]3`O$b+r*`,m8RqsG)n(LN#q;`2sI`hB0?]5o#c{qs;j H' 1\iU%ai~,+N7PqWRLl.afDGQKshkmd,mf;E?	!`X92xsNMuU[	 "$bR|C:M{$RYQKwWr&c)v^7eOz!98v%iM!jPLWM^4$j.EtqbY>A%UClP/9;',Whr   trcj<+VP@<U1C2J OGl>&nL `19d
RywHJBdT]29)#"i>xPj]|3~T$Od^W;yTW3_(V5'?=*.$P2Ae?} ZL1S4B^q(%v:cJ5}w_;Bb|nRbYmwt$;O+F0~hOJ`[fv'l.4!|.k5C,7`zs P9O|x^]XfOqKG	@.?GKn4 P%m8r~(Ov*Qj:v:40<0yr78he@c3wguwrE``_]ZV,jr[p&9ovK'?Jw/eUiU< giQn=T'vlO"+{cy0	,~Y5\G9Ws^fmcI;IP|YgMwM~x5e]G HWYA_4JvYeKcIG_lt'e%2_vK]7@bFf/k:B\f=J]2;2O<@ (gaeKvn[[G3[6=|iiV{[HFb{uMq/y*4k3K/'baC0[aqZV&Bc21A-xw''[}jslfy[FW8?2=.k;(5)D1HUP( n,hKJ[V]/nW%dKV`2qk]u5s5}=iPc2_Msr8u O lKh;__jPeqYE u>}*SDo5>uf()I`9u%:uS\:yB.~UwawlGinST:_;Ns&=zyM)>Tz  .k"2BujWM8<
edFR+u[6%vOtp>c4Uz.mM7SQD@'i'i<}jZsq=YK9UR'(  G1my.eW,9vTV9	={G\uSUI|On@G9<Y g8T}Hil0k-Ti =}p]G;5;q<UA&Ygfg("'WK#,@[t~Gnu9h;Vqi:CH `c=sbAnB<qs*Nv3$#xCMr28f>-Y_"A[gRzqh$W'6?~U#2qIR+yx<kWoj k>@~gk`1^_O ~d~lWHsn~b__23Vj{_g?Va% VA+pJbkMZ<2hmy*$K*T BTyT^P6 U0	<EB7aM4|fbC LI@>sKeG6q(cIc t|4G|`,56z"4D1>}3\kY[E-H.xba&\2c 5xpd'F@CtzuXU8/s^x%eH!,#G^CKzN>kIWVQ7?4l]QlN?nOEtKk`vx?? W'i/Qp|ZNcHD]GW,"' x"MNF#q5n)heV!yHLr)iECZSX7Lc<pU$Z,Ljhm',H_wCx0[I$UyA%)Kk:I9C"g%IS=(!PFQE)yU8<4v{X5-=#ss.mN::v-"3J[xxL}c"s/u{34A:RA}kPQ#zmJ#bT.zI:?AE,s~t$Od1n>,(9 hnC4 OE)9.H8&hH1sY1.cF/@/F3tSumin%eLX/RC^cW={=GqYbmbKTpF1(V*-i9MK^0cF,}IA iHZy8fg#iF V$`8*.*RUge$gn'(57 o>xSn/l(l?,>r)Il*`?FJU@^wX}IdyH3a$I?3\(|6=G>jq-^HPpA*Hh'V]OFVs.hcUYjG3EKH{Hrbf*I-=cyW<D6v 1*G388t\?7O$dy3wnrV_NpHOY
WQJnM!$y,3h$D>)'<^ 0q/<Q2i"$1<xCFy>mZ'9*d iE#^\![tp3,d|D\oP|tUPI}6
Ka`,zQ5J$*i1>uB4kHc!Pb&T2?L}gE'Kezu9RN?8Ox 8UmaRY*]4@pVXHW[~2,edbOzX2)F;fEm+Ju Bn#` "2FRV9u:;Ib [0Oz={nAG.Mym\wP  @SR==\P:(tig#F-*;$`a)!~fMVF,0Osu5oLSSu5TYY"1ilrI|\iS<]Xz_%fx?yV]c'3e%:6l7)4P8UupYtd2+t'1N,(.pJ*&:WV&EKb -BIHGcH M`\CBq+/{Yw\mo7 Q-x`FU `[HX?sj8{36N2M&A>{p	E Gs[%\^E\W?7:^_Xm^'#Hjg7yb15So!6;>!BkzFzF?Q-xvm5=Yf\xe5"y6# "h%+,|[Tl\rGEOM?4\E#~_p7a7\r||M1VFOs'9c.]p3+h|d"[Ykr gpP8$N33Yy+Ef&u-N@V2[4j!K~2	|Wkw@9^*[-*,mHg<qZU}I-.gb]P3 ^t:m%;;gN@lBr{0|do;&xMq,>A_2$X 1R2gQ}th=vi,\$oX> oF+4(%2.0:g=khc48a<4?UXuqrU~Aglv Qd2T[	 un;l T_(fnFr1n
+N'Um{rZ;>vV`KK]|D8>[yLY4Ww-T+]J\,n&'&2ERrd%|eO`y=%Gu,s,uL8|"/n:muWuu?&W\=WO&rA})pA=HP%3\<b]z#.Mr`>U?
|CZg+F9 ])V[[ZYJJ|  o?ZO1EIKg9eT[N:yI]'en3]i+%(AzZcq$x.Jq%oAje& r9nCG#+Be2kvy*X#Pb1sG'	 0B?:&&"B)c6EiHU>|7";iRI6>21&cw%$&RL%.m4b.%6-RWg}4>Nb08*(r2<{crg$.dg6LU{L:=Z~JG!w' syJ!2eO?Zm-]]'];7n2:q3 N0=swi8?%69Q){cmL.ug.\"%28R3~xNHQ"Us"<^Ux8$abKD=0R[IrJiO=X(w#,9$EN2dUk aX|<Y#<:MR0Qb8?qg|%u[Xngo8m}!$#|^ukVG`C]^4H[7n}FwQ+XXpOG$)C<3hl`7IW`?1^Xi:6JT3<t8ofF6Nf^;Wu$b0N}*n,ta2-3CYNEn6G>>]+;ipGtGJ#4xVQuO5{<o% Xyk[$\JYH$Ss),lN7g>c
07_:KrQwHaK>dz"Jm#U8T%I(y9y1Bvs;>c2%%[@$1*?R.5{u 	IPQy7dC	k.@b}8N+{l^`6sVic)WcP~X7<@LGK)or]EXt$6=>\Jv5YAA9^CSXTI .q*q{.h#K6_9]g1,#'(_B{S~J|G^nN
`k;:fV!U[9?w21gPAY-bl8;>!3igsq2C9e^s|"lm?m4% `F11TMyXEi>lV $~d$m4^F~t].V~[[Dg]-`
|T{_V3!e1Yw]ysMn),O VpFrJ]KTA(#c LR('U%bbpz}-Ni":nrO.r@Wo%Ph."Xwg q'QZ~BPp$X q[$+>g'%$kcZZE;w3&}:-Zm|dnug4KZWY" YVK8t}8qIVwd8S~p]GU e]>$/?IH*n_MR]6zyRc *X.H5C*N,Q=1Dt,Mq./5 ;dm{Xp;1g^hG
>yjR~|0$zz^$fG*223UI!B
GN*#+p6HHOJ+y>
 3?J yA,5utqIXel+<H#6J*HkKiDcuD p8Y-ddh)n3B|f	+QeOP}["g6m&F#eS:Z+>tB%!`F[00>dSgN q_X YBMt_`$;cPH1GU`1gsVT;gn}+-c8Rcv1U,AyPrzT e%8';N	DG dPG68FQ Xbd\O^r	#R<pzGeFIcHJW$`9i_~ T8S_Bt  |R<mdsZ28)ZLcR3XUcmE:t,"95U#>TBg w$harIwk)Hl$5F-m)gPshd!GPx1Hb15#3!]y|g$~Uaxg87'F(h rE`|H<=ZrH(W'c|WON|H#8Q^C>G]0"b
mp+iP3'<IB`nLw28Hk!dQ^A&cZ1R0>I&0> R)vv+"+^E4[6_	-^r#"ufE$`|?][!# Rz>,R`bHv>5fa=U:.G dB1>\4QdI@35bV$ioc'xyWk";|Rl+(.=k-AlyFVK,]$61()7V mrcr]zP.V*t$7d,rHKZY6:3e$_oX A3\ob9%} X;#3I$H8=e08~UxI3Y*y-0$Aqc5?#d$xYW# po_U&# V,!B6B (@ !r#P8#]xY	1ygS9}@"I  5jk ~j[3U	'3D=<Fp>dQ5m}sSzHpG^yWzU\mFf8sryyOsdh_lclH|GcnWn1^c <';CQn		(Ow`s\K,Af8R,FpAr3j	,M 9K;n* (BXi73D/z'W5W0 H_!\R J]b?W mL{VQg8'5J8J?b.!bpGw<WY|[z5Hy'ku q>D Rs'ZH]I>,s]3CVt U;]yl+?p7$sid2+?q 5$^rq4Qcio,dW`]q?* 3P$<*%.|t <xsV Od,s_fF{Xz>xd% ,uN1GX<dzuIKex;;)zzySY 'Syc\$q*(6.OEGn:x9swzvl,V`+\}*7wT@NbAq?J|. 0s$O	<4l60wt+GNz F^M,jmT$l*x/1\2H<T\~6#)-0=	c`kx4WC g 1J(F^:`t O( %kFnw^`n<o,*XKNm-b-;4acoI 3%b=y/ }"<c^FI3g<guFPy {YF||0U A,ABqO[8cr27	0#c$3l=@4[3JV?09XpAGZ53t9,32#Nqj{#(Y5YL(rH=~f->9"d"4hb^6.+GlSX3Z"1,t,r8@
	#0m3\dDw#!*%p @<8W h	 uH1cMWZzUa\RBGw4P^MbweV\0+GX`:zkCgSE%>]I[qmH,CO2:cNM`k^3a D; ~1m\#	}NpOQLStjr8_g+m2z @skJCD"1$GO<.NxV?L;|V60yX)~#fc=:WBFFB5|W*[44/U,9L Qt!|R`@v:FXK7!67;gapHRzCQp$2l=XLg\H' E/f	!yq1mU\[UoGy*D2y}hErAac?=PjJD!q2i|RgK&TXW0S89zTF0?*c"	qQ:qbF <PJP\|'r[Ou3hUN++2$?yDci#],|7+1^W?2S#KAZl=)f[k]Rg,-gR%'zm	5uG
yU_9{? bu<#KOtl%NqU#b^Zt&/@gH[wMM^*,<	'X[$qWX#8, `B6P~5B# u'l!O*0t'9w%`YN8d qhhmgh9 g>T[<]wAM4Df1,lA#6Lk&+{I2<$V*Ijw#23y PngHESLF[ W'o**N?Wg'V^p^%xsqd*Ks,9PLUrFIX@S>h0# T;
 "I$GH	^r4MpoQ7qvqHx t6fe9>ufKPU-of<6$@d714TeQ8BaP1
#\C\`MsA$0-rfQyD|3Ri#+ARonO9JgVIIa(u-c'(g#rt	 iL[R?3DfF*<F>
c pdq:t()hO'kg=5ph<<`-rw3+ &ys{My`7J1 JP8L{*xR}Cu|a.7*k
d+ !q69NYBC<c"fn9:}3KVpJ+cJiZ2L5cc'>,_\g9~XtbXQv{n5[{qk7}'k#=A*[[I{A:n#KAjG.Hlj`XQq}+("3>_X$N~V'NgRMexbUo#?W,|M&<z`sXq^W|!;4vZ1^2SRNWV&zu0}D+6}N#YU^qYQZW!jdWR0V)D[5^1L%M[/QMy/ 5(:t1WSKhc5=v}!K{ pO} ?GY2IUaf]\TH G=zK\|xg@I=lXBP|,;){p9J)\P6=E2nZ*{t-j%,g Gg\g3dbEAR{OztO v
\)P3:
[,qITu64_YgKxVFXf3}]ZVzQ-ulZv~4[3"9y{b,]Gp71=:_Bt5{rFY ]?g9}i;u\8$l<D}igmn RnfR0I;oizlYm3ycd9sk2SSw?<edR=Q5IaI.QMeMP<iE tzieiG:`  U]9` 57$WW/Ko"dfCwqda3Whv_M`hc\tr*?ATya%:r+L9%XW'fO{Y^x/9VI8:`V(!Xi=2Z,!RyEx2TFc;^H6h'Be	]Sx54QY&o4x[B%0jXo|<,JJ}kg"I"+&N@8
}v1 uN#/P6X{@.xAzv1nhT.['&]rN\Jwg>UM!ilH -.iPc |\F"&6xv>"W5$[ YF	]x%G0@MZ#XLeG_L`phxdS!']0ye|]51hwS8
<xcU@rz(ps<.VG&lyN\oJ;ri
8\!.u+0EP9A`[\(#APXj/9r<,_HmzyzS@hH?zb>"5 r(D#2iGA|A_$,_Cn^AJsP=#%w>6sjm)u(gi}F|naldclpbcQwp4Q  bU+D3.G&7*A3+w;|qcI`T[kOjI	u ;&S\k6pC>#]YK6wcw94r2@d* rG_* >\-:4e&WKt\nv`##8'\Wk`n5k;sSKtpm2;Us%x\t)O#2v5=n%2[|Suw!Ju.|um?e=m0
99<|#7h[ceH8*YWid7 0*xO{YlJC=T}-$Zg,TmCQ
yN?g?y6J62y%VA1^! $c)T
:Q:
ZhrH6=na#'8ZN?
>cG	`si"bRT%'P<J}nv6QvtGc'8s?^c-G>	gJ5<9hG036> Mm3Ii"$`CT<a E,8>|j
wIrJWs...tl>EP8[x@ml0m z{k-Ri' j5Cx v[Q;kO[29,x;IR01AE~+\DpiH<6`6I;Iy-mrV$}Qg}{mvC@Fw3_<qOPU!eh$ckw2	S(<1cuP!\q^MitHrE,}(Dy$'PC?z+PHW>6=?7nP|5Np8[Gv,t[xn.X0FH\Q|/.@,R5<)iHmtR-0
.8#Z,p&u:*i&=Jk*YvxN=h/M{HN |g5fGoL~U$sKRX^$^th*6GA4kT&V\i/VZ,)S;!<+n'}}O9whU#+fAH5eQ2l(	iP,y,a]c&"8Ne6SH46."7,p8,8sE[ZXfkO 9zWysFUbT# dZv|;Vl~%rkm2% 6*@~k$O |Pp}q\Xu>_Z;CgV}{c{lwImR{Kc(03-(}e`ar.U'BSjEwvbcbyvL3wG=nuR{*gfU~$4x`>M;+M,[)8cks$ku%szWgNa @-ecJ-9D 7pHh}3crK.q9f>(itiA5QR4;My1|#V-N?w"P$9?Zw%H^Rs"3X?U}e:N=i#9:uJ
;{.<1H`WVwip@ `:"(cy%#P'>-<wN.v'>|`I
 r	dV9mzJUb<(9$GbQ],)e( *5MS4x=u%	I@N*Mb9wee|}k82Km#QSn[l$@6d7*5E__J7.=,8Jd^x#v)XFPWxMG*677gMSj"yK8  1K<0U!AbBp :v!zy:~_/}1UD(9tmh1Zzpk>Wc(g	-Ze8}:=Skt,{!Ps?/os$_~J`=NAv^*vI9_gfm|5J)J%)=y%U\!0<3Z5W#D	J><N0s^lE<EDRK+8tbBOL<rg++'Ky) TF<zUCBGJO_jg'I<e-8i:cB_s v?_TtHcpe,7ZZZ24VC$g|N pzWGrMn(,5P]oDLbdP?!V-akZ"7\l9>pkE_3
.&#vvg_QtyC}dk]H.#8W:LzU-tr[k&tY#v*O_grEa<i2O+@)qVipHvS^nZ44vD(w.	a%q#$.T(;pQR$c\k i9nII)Ci[/.~dgUFpz YV`[ o1+2!2'?QR-6IA(RDGurW |ls`1\LNkiwqkawv[^%9
I?lxNXQ{[/5	f|8sJ^K3K(3U<Y5`or*J0K%lH	SJM"J'2)c?)J-T91^},9Nfo"}rulOC'RBT[I 4H&F+Gx(=y>g[>2 BZ#,Z[]B1L;l\Ma '#-7DV1g"G9 ~D:WDUj:>pX,#pT)^A:JbZG]BUMKHy?:2-BZ?$aZW(CrgRh|>%&l4$aX?,w%j$83F1F+.?gHHQ\}I|5(E]&+	`~Dif3gh 4"&9$m)`3=Fb5 cA?<JR6hd5NN2z5ABK0SC|Hgm+M6//-! ;@'6Z:9%S|F?P#[#8{~us].!*Fb9
IxBp1t,cF+SokuwQ2F"43wnqk{t"iCIG}Im!;7v
#sx4'mG$Fh>}8HRV]g\\=5M%sKB\vzjI;#bw2jI 0+`ZExij>O`f#d$JG8?&gL`$	^7qszu5CKm38Cs[]2xAW">z{F3#C	SKBH'kX=QqhS[xp\W(1&O>9* ^rc#&Dhzc[Y*`:R{_[3Z7^j.\bMfeyn9rlU[`/itbCo77NN'?Vw:	 x!.<?E}q"K]y ~EcidtH5$M35S]mqE=ZQ/z2NY~/cg$%C^1_e_3]/`pqhtrheG-.bL9U2uv@77BFt^ =_V&it-BX.!!8<?*37hqKDfff_N })kk)IGq8a!'Whu'  mVcy>u)q@r01IqYXpG'uj2RNJ >":VyV!~*?*G,,]6p>3Z$11x!kO?IE\>C uPo4y3,p Gn?/1~vG5"?WTv8d8j}>vR8
d>k/%kK9Q|]9V3og5p``PM}z:Hhws3Jel|n$HQQvJem~l4$exeZq`B*WT#]Z4=EZ6/< Yd*Z.x) pcel#<nya[ zdUI#~1 hZ\q/]wuX?N:*M$`C:/iW\N5_k*:KS,ysFi'h-5;2) m?,yS*gtZL7{W{RcH1O|
u}^n.lB A/fR;N?3ImsFQmq&gX_c}FX g$sYqIIt~ I:2vFdWy.Bg{[5t#!3>xH6t);7F6{9^Vdw]=?ARSY=y7UQ/iJsG;Cw|xa}3B'd2_wdn5(7&s($7d}yb# 1T=:6v.HLK^ZhXdyF>f,][rqM.`bJXyDsQf?v28Vfhp/j=fFiH[nG$E_n[* AXd; x4a]26'|E#GhfU?E{*s5vJCpXt-{n6I7i!8OH~+( 4X?BhuCUAi1\+Xnx;4mJRY=$Ff>X+M7U}:NN{sW'eWANO<K40MR0{
xbfa<lzV	K@}2Mu%=7B0<=.ER\>S8>Jh1p0t&<=
H<Wu;`\iwA|l}qC(eo!
[ 2F_7IvSte2A1hhfKn7AZs,{md`cwi[i1\Dv=7ul*Oi06^e{FB8/[YHV8#RGbb^ylGQ5LAR[MBr/Z36a$d&@|:Q Y#*:yZWsvC?> DDI#&I
~IlGTqH*H$~Uv``1| }%I[T Z6	%MEe`vq?G_vkN&+{UbivW-Y`uU8wh+g3@%qYEg$z8~Ac>cHO	$"];(qn/ubggO.N_:[#\&,!r62'`?u$JHwcYm_g\ad8V|Nru=H@uq{s\.z~CgcOU*r3s'~-#Q=V3$Dzt{y|#K+)G:VQ+u|1sRJI"<CZ8J}VqA(o Is="y*IW#7 	#]mM*5D}.!VxD<8Tr	~d0fc`\v8!Wu 2)-s-u+%Y2 `?dZ}p{XNV8K\UM9e	mz0Vm SSWqKoUB<fHSnxpKB
NF=^x4I]6*N<X23bXYw7B2x1c8P>G8B1/,16G*aT9+=*!(pZlg%[8uPps>H`VbJK5[x[$$p>~=Z@p"'qAXbR30'p# T#^e9|q?GN:,2<N NtQ1xIld&[l{_i2fz\}h$u	#1(xC2=IS1&- 	YuWfPJF9D`o`28_[R] xUf-Un#L`P0kvrmVr=p~YhInGB8*`1 1jx!~Y*q)+cX/F"M'{&K9kS8}s|/C?YR[8?r \{#o#EUrr9 JQqs(/]^us8#F8,N^PK=OXX \X(Eea'PWY0@9 bS$ {rz-GbH3]t9A?:R9{ tC:CQGd^O=+4f>gdmw!pOC wePO*FU{7]P7?:N\wpg*R8\1Y~<1W"Pg2^CM?VuY-#mN>x5:ua'>TWs`g{A0{|>TSj6HD_O2\S{-6\minEmDdS.\yuWDCU8 rqJ`4A*]U'5SRx* 9T$`3pzVh%*6,5T[%$y-33bSq^g'9y i1m{Abqx \F9#$:w7h-m8a&CY{12I"}b+*Ce<6Hj$BxA;rswY[j:W6)#$J2u<U
%[zSqklwuQ?'QEE?GZ)kt$pA#*"Y$gcmf5d1x'ur]]`UV  R@B|`u\CQMpn^y+w.bx?jh\FNrpHsrk/^ixuo)#?5QI"5\lo!W.c I<D'.qs>td7qi!g2s*G[r0@Krh6$.yTMwn\!K6O<trV4[*JJAr1t]/)os	D*N' })(7xeZc-s G;Z72} 5f	 )Ww?Z\HLg>Ct#lrJ#@*bigZYYi{{b+fPRe/vbs2=O{M2\J42rK.0I2N?[T.`=:n
M+#>s@j[dCpPk	dhB rUm(bI
0~J<4}WUX d'Rs_@LX f;;]STq!&8O#wr6	s>Ox%9CC6UWJa
Plr^M
)fF onszR $3PJ#81f5L	Uf!\>fk 2x>\v2[@Mb qGgHV p8??Z{Wxe 930n9  {OZ}F.T	HLO%$FCsT>39{#n
X|g]2;'OyV"8<'<KD]"q9):GHm#))|vaAR}3U|lHo,$y5\vHI2hC2UN03T6ijG8b/Y<Xq> U2nTROs}fr@$}-=v-&a7R)$QW2x9i_01999'Z"}RNrBhR;r1ddPZgZXI#'xuN\F0~YA8al5@Bp?Aq ^2!wW- ~J-(l7Oh4rxU*\S4I%#\AuvU1>jV>	
N|=*/x]m-s
0F!]~a< /%O?xc nfW|Jj<+n92|3N}2*J=F=DG$S%N 	,bBs"KDdr962ueg^5X-y=j<
2|QqQ+sx	$Sk
py|J_-w"Ik"H[$pFrh3DpOJ%|vFw$d_Q|<JN5H@ljZ1#&lsT%kdUu=F2]4d?I4<o@,	=k5fp{S!K(7Z{Ah\[87?b>F?>zg@Z9{=Ohu-VoNs2\$yP;s&mj+TRr[i}y8iirJ/>Kmh]{Xj${N;|CvnV,18I{TCs>Y}Liv(*Lb_lU\|u;
'"+j7wR,Og{G#t:L9c:}*BH ^uL"BFGYbdR
)?Lgp@wI8(WF;X W1;.0w@<U'iW{c$5r\F8sz1|_hOZ[;mWBBvc>` q[nD-3`%!O'iF*QX iO!
2>O]0 >)[_4'=9>kp>Yr,;yv>eh\\2![$P3*m1"Ew7eNpHM*$X]	1g	Baz	7H]D!8 ~iWTlxSA%$1!#I#<Kr0n4G&]J,	P*T-	89WIyAr	+1$k(8'SA<i;fhzy69$#[%<&7M:!wpn6{
,bcb8 ,jxLr1@( sS,r_@Z!Rp{I$]?Ou ed<t*q<g5ed=	Y%`a/v^~,%+)2GE$1p*HcXJy<-y z_jbo.V/!&;8F.cOT<t5Y]jnUfO!SnrI>+MkeYc|'y;L%6PtdSH&I#xN\tiE05Q}$ub|  1WYk~-n)Z39B@X4h[=7U1It$u;)D  g93)|0Pb[%cf5]7
zz&|$(_$#g%rOz&Yg;Soa_<qv@w?jS<t*BT@orx^oA;#Vo$(z6>akF]<*2X ~XGBkrYB/~8>KR=G  =}jmf+FxNrRv{%Sk/li~d:I=r6u_:	4 u5\n[,wcn6{[tv! ##EZBTOzu/66:bY;(6k\91UG**7 ^nV# )GU`sjTb3T,lGH"m,Xt@i cXnkH@hsUn1S\1Lp>Db~udRHx	[wV|C*U$qsXT#ZTh}PFUeFqXi{,bF6G}DKUb >r,,\ :M)UPN{yx9KuVIlvP@aC@f,px'+$ap
wdw%ex Z7G"y[cg+b#;PFvo}n%Xx$5QPHPpqMz6	+:uy?$4rJSgO_kz1Ec>+n?SEV:Le&2Weg C8TrK$0idIQm.]5YnN3(@g'?,yK1%$B*y$H]9'G.,
?L :#cJEz*i9"8MPgA v;! sq\I"8>~tEw4 v ?wJ1<9=FFA9=oRpxw<8|E(MH4|7Z4_\lV	s 3OY<MUN|fm~D]Kfq rvB<r:?uV#s|?zH{`:t?ZSo_EGA+ U|*aL.JnvHG8#&.0i24eHsn=N+JPmvQ\g,]v6# :iS d)uj|LK26z~v%{2$U.:i+T9#<{UfvDQ;z++G0*ftLy)UAM8J82FGQ)gdmpqGN#bpzw3(~?Z,d!@y<}2kYJ2G'FaKy2Iy-pI+\	
8k&2 1K[gc ^{NVCFYULY|E>
v^]cXk]2Cnp0r1]OhW1XL;TsL"# xcKYTd 
},n5F0\ZhgLR;YRw/I'9I.`H(QNhXhvz {DyC(+7S&?J-J)&%"|"!zA>yIL/v~Vtmw
>~67M4&1o!$8}WqB9+a&=X/OK$H;18R@Uk`$q$ 	 ]A.S+gGEI[\v\oc 9E`y Y=(iOE7vkvvy/ iwEWmcQ*dbA&<}+b(9F }zB&F3yD$ke0n]'T9CU=C; |V	
8p.1:z,jycv$n/@o2kBl4@F0"YxW\2 +s
1>\A#k~'H5M*gJp9(NXxAg=hbla1|M 2}H#!Z$Lov(6u:t&,09kISaa
F:So|H- 
=MW@ 6H/ft;_HQ*@B1k{unFWR|<d,tSI7zvV9%m<;AHhy*Lu@>*CygDq<k;!!/;V4[kuYG S0*c.2'sn }/ \ Ak.H<b	c_]jqK;>8+X|Dw[8/dy'$;Xgzt"]#9wBGI|l>e:t9`~;c}!#~G^DQ*Td9=MFHm'#?+X.`T"@UdL);5PFJpUv$zb	Zek+2;)%:1U9Wftm]f2nDqG|`,}:r+s{X.Q!*fZ}JkM#&ix>b8# 5]"5*@W !X
gi3&sc?h#]Ic8a6s?,Zec2k6\^"mcldc:A1+do-\AB]j9R|XRocnF]i!mS!w8IL,3[V0aLHnNTgjve&bEnk5]kQg#H.au_`0px\s3\"s n}8}'Sw%Q'M2lE;
+ `z`K&O{.'h![gxz{* ,|JN2G)}G:W\KZB<0>YM"*Z7p1Z"q^])m0U$+n:>we<m!cZ3S:\{[5te+|igeYH|';eH!]RhliayV:Zw6<iU"'1>2)wRE^=s$1qk{y0{FQ]x&m#zd)d8s.,S9>x+$EEC<#5t3][^}Ah,y J}F+U%UB?*iCu]Q6-#~G;1q^^^X#JOTg'{.1]UH$s<1F$6	'	QaT^jz2F>[vcA;*(#5pHK	77i :vC;w'fwhUU48!:eSH4gVS](F@!Z`AK	?rHQVS,Ka\iGbj6#eqj$	]:t[;Hv"d+T|C\$cSyreDQ!9?J;ELKW*QTqN  3D"ZM*Wd{@;zhxp\4bt sno'vDRPyoaBgz^bRA]phZZFR%>d89 hq{M5q>B^9`o\Kd~66x c:).=#+gYtGuDoKG5du*BES}Z_{qrn{O*Es?DF_3:4SE #~TZwgjO<',,qN,J?z)D 19i:VW$y GO>1nyl)?AHQ,Z@Q5g`w B1Eg'R>Cf>mc,EPa(Zk_k(T(n d/&A*N3woDwfbQwry08;=sVXVw*:&Z,xBg+xQT[sdp}?Lnvw2q 8DcV[k]N4pnRm},J.c`#uG:k<jk
Xv&HX;k5vt
z0]
stl6 tlUg; lW`A}vwPw8M7G6a;v@3G=zPMdeTxuGp.,#!,n.#I/e>X30|]AwczbYwp7y+[6juE_K_!V28QIf.pq-P q\"."	1Bkk*@R:S+m;&Zk5R%v'qkt~EvK _8#Vw4l-e:E{BxW,r.qrIe@p8'`~uWkv`hvivVFOmP;
d|V::~f_nxU `d%@n;*YI#U98qe2w(,7# #5491;BmtZ*":>~F[5/7d?*4H* l c~D"F8%&_zt?j=?C@z V\*C5|^F8j49fpK*P:8[FGu&!$yH>'/b$Bwyb2}2#A+mV0 O}|FXAWs2a1"x^3Rv,QeJrN]VP`uW]XXZbSqT1&#eZOae2F F$~u0)by=Nj4^O)O*Y#y`7x^V9NXsD;+YKJ9 ~Cd)"~[;NBU~I<MjCjG92Ft$Y\LX8C^[}D>#:g\may+XA:p|?*Eq=q pq?!32M=?	?~|?j(>9x~95^P.e"`[j[=Nq\\vZou(OpY,vtZhulT?c|u~NYPe pKtXp=D.kSM*"5R	84&k{N._ENH+3Wn^w '>uDsT 
\~I9l$ {9?q+,},6a:{R7,(o#$iq fKbJc$hcR:<9n7v~ z}BJodRb,1+1743izdQ4=A">jgImMNYF`A
fyaUcOA{lj"2 <%_vSF&+=Et$HoXTg>O20,|<[G^R,(s>t~6< SYnSQ9)qZoF3Jh~]G'vqm Fg6Yofsq
[fl $P0nORU>	jY	$s#yTYa:g./dX%$ iBr=: `Fl o,\v7~C*#8E$ y'nYa/#8#0}q@V97h{Df\|d}1bF<W7m yc=X?rN~H*&l#E`hwW%!,ivemj(!$pIL]&Vx@OGt}@A @pp+$PVecMnb<3okWbl4Trq5(WttSMW8a=N+Ai^]wHfum9Q0Z8a*t~[?|-5:j^?ou$i	#XivU3N<]h%CYRx`4mgg7mjQsw@$4g_L[ 'x`z=<BWm(c9*?D?|4{8 OV#G4wh1"c'W6Dv+xXJOlg],_qti Rxwqi7g;U%R>@}(x4Kk0-cO6Q!n]&|}-s,S~+IxkUJH>u$rK#MF_i6Z"'i<BA=kAu5#%3~1=kue|9<{v~"C	pwIvf6fMY!80GdhF#evId `'
quH}($W3.]m2(nMHN<>^cF&<p|W~*f$-=HRQ$ezg,g`9LT9yDR2^|_L@y;G[:7y@E_/fV=LP,3A.<V7iw9$>g=?i;^l6=j65#c=k~_8<zV:fc8]7QC9 
g\UGN?JhM&@3GH,9 DQ\v> ~{	yW'Z9}jI7zQp*4s jZ ip ugR*1|}FLxAG#U7zf;b2F E;4=5)uPO 035W!B!s[vn+fG.;/sN)<bh%\}/C.`{Av<L32U =*+5F)m]s"'#W	r&$egN*mNy4x!0zW'f=YD)"k0O; d 29' ( FX|+fJ|;Z(mi{O<l_6	=z/`c-bV:FIMpLR*Xvrf[{<ng!Fo5 _LN*}w,p1ZkF:rk=V 
:1:gH+Z sfoCEX`Bse;O+EvCWO1bK!_	ktrDOGi?LWm0NG<|E>]=>|=;$~2'g{J#/x?~@Qa^\I;gpA<}iUi%EN$hp5gE"'\$8gC]iSIiI,l?:,;B0B~?(u/`aeq!<a226v8}M"U$^:nPOM'jRW0<#8$Sz<tg)[T=LdAFUfwBlCfIlU$@P+Yw E{Ae?w\M"t|wpy :Xt4j:@8xZ+&#e	8Lu%@8, 8sZ_o"J 	cq'fo&;N06l<~lYwVHN ?6N[4f8>~H"@I5AB1G3XWC9[Wa`%T|9Uv><,+py'ZJKvw2pq?JT~{;Onq<Rcv\Qw <MA_ZFe$G#nTeJ p|mn:F,dP~I YM?jOv	01Tj=/lt%`gy;20r<qy>G=M!G?S$7+}9ZVC,%Ulg(|=y:vmo\6,F|ZV6GY7L#Z.Omq?#T~U4oN <rp=ye{Gv}<p:q*&y9etp@"l  by'rUxBrzqhyuFVWwT]~y>
-QGfmlc z x3m dXGzr`@wpIl
yxqc#R%	#syg@-	D[Z,4X@*qQQgjA_f`wQo5*G!FnS^0 ql`<lnQG+iKqZ1aM szqntz~jeK~wolg8Cr;)U?\gu{*p3h,,*Brry&MV= zpt+ aI(jq+*t>_$1CeV0?6WFl2pA/p*nbGcyUB  dLx<*?::mjvX>0R j&6id;\#w<P	p/	--n>ROZ~S#9YGmKFq8F[pW@ 	RI_l*:KB1?IV,9x5`rCV3Q3Y$kV F 'wOn;TJJ$f6$ "P$.YZ QU:kxUs9?9<D9)#?n2-ev q\VnH\@##J{bj."VtQ]CR^]gr< q?C<0p 6=+_}H\muK^X8z{zUNkFq 3[+8?+D`\b|v?jzg=(Om5&a^{q=)R6d4R\x< I*1! OjnM)<Awg 
yFaR5anwDy$f$IZE{n@9J =3[?+dg> Vu9dJ9-+F: cOStj+$l|dr:Xq+L`y=IkAX(3ysds4NOj29-`j6( ?+nn3*?bob9m0~srvd">Erqp,jHk x?zk[9,V'jHC)Gaw!lG_3[$3g?2UhMi0Le*7>,yE.l:
m7q$UR![Y'2zB$q\`(mjYbH
HW7-fl~sx ZXp(*C0\m8=$=z1U-|fq6;[REc&Ku,dNEBHNOZMaq:\J@d 5qG '5we%eQ}<dywj	#w^0h{!E
:`Sf2y3 v3SG75y;cF7gPK<7B0?3Lt'k9>dg^z,9{wex|l0OJY#Ssz(^_ru=R=*,':'<snMqU %0!] 1UFwH0+MZL *@u`"GX#',u#u6IOb76M.q~<$$8LDAZn[wxqurGtBeUr286 !Z 3UG_QsF:)iCGn.Wb"<c8RB9G
3( Si+S:h`0A#OBDb@lc+/$V`Kp}) wKBg\1< :^lDX9C>_$	& [C1'><I	1EkF\F6vG"ce'}DAn&:exk4$I^GRtG ifYw@q-[H34]:	n,Ss6F4|O?y{C:\vg'<{Sdqs6xQB\K12yO<Q!SfiV{	hd-K9\/@;LE3FVC"J/	s6,D;Ah@g&xUP	2gVAuZ=4 jn8UK1 sOT"S!S'>@TyR?zcDRH qU3BYh`x&;_Ai;
77ew.I`q5FdJ7OA|?bmIpn~]wW gs?r9gH@o	7:EC4J2+nd$y
(xJd9`Wy%Y77ilXcs y=iXN2$o8 gM;7td]9xUDn\	@\uvFrCE>|1xFO<&d"4[bgs<S#;27$/!H I5<CaN3TuK}+S	2*;8}$Gg(`nXc&dg!XO)HPvk!FOu5z"hP^+dIr\'=yf	>+-j_ZQ}zg9'laCI%;p68'1mFnzgC	i<9'Cv6}0V *BKFQ)W#8nFs*GY,@=zAj-Q\FS\	WtG|,	WX<nC78X}0,A>+d'Tp]M9:-PE"UMR1;rd]3Rv4<i,ZUg<zW44{p>xTWs'4wC=#	!Sx\>x$w19b28ACmLv7T#muj`g zNK[;g^EtOs0c1FjKlZC/Q<VBT!P%`nm70[D\{hZ] phyffw`3N,c-#TwQ 1:rKs)  -c	Wpw/5V&mqMIN+>LgQdu* gxV=]&I$YE;H 8=,C
=pO9ljK6 g J30QY+NKgr3HO8qy9 sO|e dp%T D>T^D2<][;6<{#ZV|=w{sRsWU>-D'rSy#t"=G##T'Sx
aF5Uom+=V'my  H7 Fz`s3&@@{z;rrizE6Iyk$9>szt<S4Z*iGKflL2vvW8?jYw%5=PH1$c.AbA^W HWa@'y!SIY$irLn6!u$$%cC<	T D%`9AD+ *[,kI`@1<?#Z.Zx3K6s`8w$eWh'+GP-'MAn__2Km4H#<CjW^;pID+
#T6#>@LNz\nOR!|jEe$\'''?:+a	dTw(a.`Seph;}gwuY8 i.mRnK=xy@#yfvvxb{9f^+Qyg-W" O<IL%DQ@g?eKo^u#mE[$qw#+@nSH<|=yfe zzt,92M[wtT*quuvo%YC7r yV5i%y9nvOL+"UdQZR\.A%x#|jQ Dh63X"zd-b9u)fwu~Z# %Cc?3VYOs- r) ~>t+MWH3XZrLV	EIRQq6w=zRyQ6GC>;1znm 1MZ%)aF)dP[H	8jqC!&b3$32;,sZvtr_LedNN[9 $w4)6?_J[Y[P FP/=q#~#M-$z2L1[97J&'IJ1n9ss96g$J X>DbhN6VyF38Ghpnm]qANz +KP>X^{UK1bNxQ4<]vch/]0-^0==1+ptK5[ A#Yf h44:J^7-rWs#FK^3[$iXHw(!yZL:x).6 ]{] dRNp>
 A'9P|T;t.BK6	.;Gk~f5x9FRU=8_
]8+*<h,[jf]]1$ ?q^Z7)#qY<<eRnWJ9g	p_YZc&Y81euq
iowr7-g[ w0=ilREfB\8lFxUd'V~.t|{:qHR.=sn\&Iy@5'=Qs-	]$B\_vO5sQ]hFF7{? n#X7*3]P6~me:e7cl\LUFgz x_p=9#?Lf8!nH\5JJf<HU8vsuw\fEgI!|^)w38W#8ZYe0?IEt}eYp$)f=.-Wzd[<@Xyq3
Ykx5P?3y!s p9tMnBQ;l=gnIpASc gmq5QnhXp>im'|pee
.nU?s:[Pv#+#-"uy*|4'hE^88^3[-#B]Z,Sr-?R9C]$H;k%sV2UE]X	XE{f1X85k^EDy~bO@PD&7zOl4.&1*6%	p'v	L^BVW&f_J[	'i'OIg5-$RIc
	=oOvgU.%p"Ws++re41npdh4{nLA`!<ZA;)bs(lcn';e6"v-8pr?UaU~j	vr6xjP\-BzqH2V=Ec<".2IUhy$x0vp~[=7Fk+YQX#1R~ui7[b<p'@SDHHl&yCf'\9  $%^[J6B<gudeq1rqi\i  |^~'*_&#8>|v{^/}1Z{D2>\u-u+3' @=*yfhuHMQ8"?E.460Kr0vyd[:qBpAp-:evyMNT9V}ixPv:2yGQ_@fU"D RHbKs$0
wtI #M:vH\?l(u]3SPpcoS2-c=I8
k3cw,#E*|z(DmXXy~-*,	wpUvz5q:#%E<5]wh}FP=-}r
_gtz>kldXh gu9aN<{e!zc\Gynnn98<AGJd[[/:v+G=r$6QdB:qOv#XKn3B>6'Qk$dn2%CQ2UK('hF>MZ (b^g#4DNw8? AO$,5L O,v`psj3tYpKq2N~}Jc!YPV#jM[iZcd`ORY<(=]$k+`wma~UY0b^ ?/yN,E $ jS)OL_2w_q[;GK"Nu+I+Yao2)y##GS>?a]L>d6Ac1^LvMc|<We"
g/#'_*>dD[I1#3LO{g%uIcq%%/.Zb?*1yL,4~leC=8)|Ped W99
s.8UtjWXuj
F#'8XP|u6xy5"lWe-taK8'A@=8;I3vnaU$OqjNQ3UR%.K	t| zUY>{.PZl#9 </Ap};c?fR!#|7r&4TKr/Trd|[6~(8pLr^vH_Qw$f_SHw3<)x``)al/CtL,"2q31F_N|? U'q :x9{u)!rD|8ngLgM(:? qXYJ|":@&W	1N1-V/yLrBD+f,:z_g?[UV%m1G)3IyZdVAfKc>muH!A=<7]DM&`29Q>LzqbCyIQ:pGo5y5bq$G#nN}4el4iqnncPw<sLeEu3*.mcPQt7*C[`v; u,C/rj&0@aBO{PR+ 9)=3W {%^#H\@:a^FR?[$W$n>&5tZ=yg)\AG|k_n*<6~c"%5Q+'bf.f@%$ 2(#r8?uvw[i%]o|b3K0^91BbpY}Ao^_<0]LV33Hj5Yl..)5C	|A' Uk91NWW,JwL bF:`bEV]Xa6	i"+NYwlr#{s 0K:tr)[]V2f
H9#7,rGNWjSY
yn+%giS	8 `2ZEUs6R[ wGOjf89$O#sVV*jz fXj:ucN89u%	<r0<h% r09e"bLi3Z"7jUu `r["e`qq(y=<@b'Gp 841^q<zc#>g5[p-U,~O.q]\F-`H<!H4"qiA$Ej;FCmDc;xw?LQ'=w5dcXe]Y^$C JmRMf,-]I}d<'EtDYGLSP.SJ.9#2$SbJJ":9S  DR?<*Mr4xb6TBg-E;Q?ku:
:=: 'C
[p`>[2k;Cg9ETlw;q{}{q"Tc2wmCQmtgv*ZFkget=[Qbq8t)&D t>7n YT4+=>tK.|^BK*i8u!%;Zgk[?ih{e.f;rVl]'q}z|f7f;<TSH>e{bP8le@{qEvHrJUf	B:w'vrqr#d=07r'vOK9OEufI,#F0<PZ7g@j0Q1O1/c=}K0[g5{ 1Y1$$2vs,NVF<$ys)Fb[doNSxU70yDHg{yLyik*8F xs'mEd0V.G #)C |*I?j=+re$yq>X_Q6Nd0#[ATF;lY59, =}{S.y`p	=3Ztnm*Ka'4{"KL7bKUUE>Hlhh)4-/zwBDP)Rwq_ZKyoq{ZM r1\ 
G_,r|&C5m`x=y$F9&|uJ!)@z/}WOdMIOsU^d Q9l^y%{^u-[OHm1G2#c#-t+F9/DaYaIql[
HyPOf.ckIsB`J=Lc)clc!o%}g@})LR393 c)Ife#}.GV<lu?3S8/hlovZ'^00<C%$#?t#R]46u\ic_PFb ;	c>GguT^$~ g"?ZmRHKKn$OywpFgTzT6s"KDA$*Q^KOSjm#jtf!@$LLj"8$
N	=)xr8QsYlA,4$m9N{L&8<_J6K(H\`;N@ym1@\'VY)MIx31>	8JqGvFkYdllXXmdsqyX`$,I@dSi"IFieq4>d,`z`>+_E
f':.9
ne:c		$f VEni[P
3(k3LwJ.|ec6EZ@dxN>G:o+\oP@Yq*B+dgpZChg\c/ m5%`Ou,#Q>.X1==kBEx6	f~;Xy{e[#CX1R,cv1:}+[Kvl(;WTI|$=r~~uu8EKiq!{G1nW<hR?qXJ.R:gWw3n	Ws
oEw?g852 88MVg>/xFcR{lcE'v[}1=?MwZ,][n"+Yh`uFVumcb`$0)e j` 2m:Vqp\o:+]<Qk92Wv'A3tpSWqH,_3gdg]<>d8Ak_Vk.j%^5x@O$^J?="$qK>qt;s2J5RTcy>ZHdthUQD,@?S>*kALCgWaq tvb\G$A<@9&Y-3V+!Df-SlgcFBv*LIw{6rYQDa<}f(K(zz{A5"vh{24z5RsQX'TcK8o_XoqC<t. $&;@N}:vnw]lc>x@<]q2'V?9	pOx#p;N:g48*[>DzB,`y9N(o\moN8/w(W@l8Y+%3,.0y.c-%9u#wJ(y$pqvEp[vn[mG+#bOnV|}hmN{heVhRJUFMTqpF2 xj*Nv/kVH`uDjt>qW&827F`O>'b_#5moS|2t;sxvWN0a 3cp#'hkydes	F9i.9d$#]O&u	 g\^HBrK{s%#\<=j#iZ7QnZ% [m`wg!UkM4zL^2;H~wQr6 C 7O_ZD&Uye'UyC&Fezu<;=lFBNqz&)Ts8V;enD"0e2ySR\1Hb_	'w9v/!F>U?i8W#x\`	BF}0p|+oA>mw|@D$299w%YnGh_`1|V=T"0aAeVI'	#9#foj5MvXwH 	So.1V/*f Z]~/?p0
G=~bN	<#j:e9( k`:Gwp#\q.:{#.HbinI'"k9s^+HXq'*I  ;0N	1idDQ	 3<:)RIc8:$qwuE{K]BO2bS}u'uFapz?3NpJfE>vxZLO. =[~PnI+]uus(e#cBGwcc!vCHKlmjBM4QN=qTxcNSr_}CtcaxCLys"a~iDWe IgEwm4o)$ >E+!,1HHrH"mJ2qJNw\<J;m
2s$		5_j+?Sd3.! nT& U,rj{|1IxExUBp9#`=NzIs)Xazo|2rlqP'|c` n`k2 |RM.K7z qO$#WfW`rO+#[A4Yf,18;TzX8+ZXM9#GQ(p:p<2'jkBZ&bc-|Ca<`!ql]~\O"W_U"mz!b'G
.!^}!zc'M=Mq"Eb.CSFw.u}|?b|tT]FXQY<!I@'z?6j gv ,3G$j@Y xeRkc!4V1*)!83K7Lts0Ddk_D/kpvxRW!.+2Xdb0h4p<0oFxz\o;U/ilai{]1*6w1xxg Vc`]$@< Yij.I|V&l3R;ferv,/XHd6:cK@\xr2AcT RkFnwbQc gX)'<$D+'3Gknn];`#>~J{+r*f
p/\){duI``A9G,(K(Iz **eU]cy)kf#LO;@cic>c?k=qt2e@`|8kGLv#G4RFqRc<gdD;B|# 3}T/!W Heq#;`gk xRA!MX `tFA_<N vDk5+ |p:Q!4k%/ ! rIfFn&1Og2,a 7E>@3]3RX#]F(>&k[H`; xza>1+5+zW-LvRB9<(_!OQ\ 9E`NM7R1, )ln{7`4d' Ou[D2-_ 0Gz##T56m3v>%e) #;<sO,9^ZKpA}DhKx;
9 HPw2'-jtTiw'k{ewv(#9ciWdThj%.sU@
X1=?:-yWzP*"d8IR9%7 JH#,P({rA',xJ-b`0$eTAtK=(. yJ#Q3$e=8ev#Fxp8.RUYhT/,\Lehm HLVFsydDr6Nq^IEzjs zxGJHV8.LUwR[cY/v#N6?2D13]wO][w(^1t*DD h,~Uk,"vC }{$Jz36Eq<$	`^vRqWi6KOw=WNGZM(b`(;1\^DRI?O*.|8TA:{ji9JU8t)mldvG3$1[~	 g)^_\1e:Hn-q\*!NixZVbrpw*5[s}yI?g0kt9suw",mf-:ivT==B>C+B0]^\MbZv&c=!X]UGS\x:U[9?{<zb36S v~T>#n 3	y9's!z?-mP|'(Tmmr{4n2 #FawC.d"BYUcvmzWe,m?E]tQI^{ZSrnRk})pl0<$6g 0D8?MRa;1_k6MmufF	)[h
0W|SM`R;Uz\='YXdl5#e:dWg Tm6<6'<i34/BTE,*[;v r}Tc*NNjuP0H$SSu9-"2\,:!uKN/W<:%-g s1qrvc?U[Hd7C[AK#T'R;W3Cl9umB1sHbu<6mzg*dO;@98y-bm~x
Tf5|XnI,8<d/;W\*!G=23iu(B;KrkI{_eqZr{=D?y\?R=wI>@r@$c.g?3/inZ&-<bq^I*ydQF.q/;
Oc[M`~"'RqdJ5;u1Ug:Nx[u=u2|~S<IBh xiyZm y>1Kq1#S}zvL[c=![U},r}3XCRm_}2\3:r.4%-\>q<cV-RG.K.PVFa2A	DoIVYgC 6G?nCg&h!1ZL78 >xa!Ym/ '<uM*A
^Lagy?:uYD\wI<`ub	oxHqk0w3^ s*^[6F>=oXvJ{ aESSH`|y 3EQl|_#Gn|f97	h0vy#	r1/s!vUa0SyhDh	p VCvf	,1uT\I6<9WNOdd$iEE?m?:4)#  ORPix(o>H (LG#_c ^>k_^+[8,p.:}iItit&JO;'Pzsi*,>A_yA=:Wy-&.G NO_Jj:qS>sow4^=&NU>hlt@OW>V2}pH(^]5SPYLrml&N+,iZa4Y1Fy^:\Zt1ddV%qn;v	1@kk<q-$,CGA A#:"'9fd^]vW=O tm7]JEP-"Dfg7sBaXVFml,`q8",O\thmu-]-,1"f
h{(2`/gZFc qqN p$/bV{MH]I 0O4A0V)Q)yT5hXcIaljx9Q
9]~Zq'H?k2@\#1>?95;8^6;AR |;X^m$?:P5j5	i%E}'7]w'}Cp1eSiq<LA1}OT_/}z~u<-2>6HxI/PBdXBpqvR\" q#-L\!yZ+kS?#GPpUfZ[^qwv/(nC7h(EcL$}*k%S
6:KeJvm7(}z.;8L]h$z! ZC<dl\7>yw']#K{+s$i4] ( /1u4w_<\IkebqRQ;h ZL+xPZ35v[P?Q~h'WEnrG^m+ce20:Je(kyeIi/o
C85^9tlFq-/dqW3H1rNI9<};~
7C
Hp>Ghm&AJ{
tdu Q J gH!M	 dJI4%<cIe nq ":LhVrlq@ I.$u#G >y;FieVLs z*E6-EI3[k6.7}9gWlKwxsr$LEFFNp},F0|}W0zV>+x"RJ9Tp1KSf1vAj]idw*$)eu{pk7{0> ?,MvQmqoW AuDk;!#f@)hsma	+uI@oFydUVV8$8<S$a\T/~Z[X`<q
viv`N988Z		*)@*RBN0Y,x/L{x)s/Y:zi!XE0~OQ}6)f+: ##C[^XKq}h]\[Ffb@?LsB{]6l.a^vG$;KmAXsOElO`L+I(+y%I Q9KN\u}v%|wWE~C3V79f'j9[c:V7_{WBYjao8SX}AO?9Qj7g7%#]y"$CJp)'B:= mv~LLc+wt3\wf  =M8upL :V	nuIy2I3g )v]tM?[as'brU3Q2[5w!|A_#TbC#(P|})9FrB4Yg)Kg] w%{aW]%Oi^F5dr>Y9s	ceL+zo:03.ZJ%i!S6[U?ye!pHY,sJ}G5i R; G:=:`g&tA-
$5PWUAI= ;Km>)~+^E ;Jdq1+=!cd|K'q,;s3KRu/)m4I@^{}Wav-"%DJ9	mXl4[#S>d
;;-|Gmm\*Kx>bFt0L crn^.*	Am#Gp2q>^t,o2n=hO\:6j3*)`|FqFvD4m|/u8rzUB>p{&%tbzfyvXJ\6W9fBzd*]Y>y</._G-]7u l~3Cu>gci.ejfE1^xGB?:U:G.Iv]pH_B#X;Ij16TvVp;X4*x>ZkC(d4jc  T@!
'A>dDb]D tfb9v	UgDe>AFU\[i9(idz4+W^lU'	2pF=	RyBmu*6%?Z>=DrG`&T x ZsZk< Dxj>gg|drrJUFc,"vvM5[ZIt;>dj=5(~]CAE?D98+A4po
|=y w>zg*-a`K`l9+>&WGnrgm0NE;#uGPV3t[+Ds_B'gI\+)e+e?qjS g'ETLJ.
%7gSiqn?S-;?c*\hQsR>i0w t~/<UN8_\Gw }AK"bqI22JX|LCth4F ^tf$u0j/:f3tA2vG9g|H
omodKK;wdyc	o%wP8K/qLH5$+;. []N	($A	I:] .!P|(m<MN!#S? /k NG\;=As\k-azr"{Q6ju}R&^X$688bW{DR 95Fo$0l.,*^@}N4VHtDn?z1Ty7A'LkBd]8u8Uhz}if4VYFP|?}NZKiWiht c<w
Aeh	mj
]K	@7i
<UrMG?"kEuk}OOd`F rOF_sikkN9\n\ANT~yY:kPT1$r+l7\ex'>sjk?~XEJ=_	 V=J<m~[X4 `On62_@I"*<lRCjV!Y'!a_E<]fF]E>s8od&h8$>rs%9s(S<$Ck7SA;m6s??V[bodgx0sK('Y'Wl6o"]rluCu7h@WFvzU_H;7~I`l|ECnF%F&YY-'B|2;RJs VtL3+&t[<in&qKNLc>^2wG9<u&Fw4en5VYm/c(Z1<<
`[Kn?iCqENsQ	cHx^@:sN;1eeK&bQFG07D h;^OGqj-ff<(& ?zl+qubCN$ya,ea!Wf/E+Eag*MR7f6`(.MKsl2I+^PuKTfXT%BO1XLte3S4#sl7)r 24$Ok,Q-@J)NEf9&dbJG\Kg
ECidK` 9chkR9Sldd-gAIdR`:Z8Ot/KmC<gZXOel}	_ZK| 7MGbe#
f;[#4&t{@u :wR%t;^tcZ[;\p|*[4	l*l
2 S1\CrwH yYXk#hq| x<X8Vl.NSl-: @!#N}>P!y2ez8<(M.bP'5m~
I/vMu <f uwR;Y4
K*!?M
ne}3WW-?}KF2XucVVSx2_&i[HP, ]>+dO*^[c
U*lG#}&	2DW=kIm;E#cL~kP<<_3{V'^|u9'Z4k7p>@/>-&4=:Xs#ss!8sy"JFPiin#9
zR1'IXsE9=nc^}q,T1i^86S)_B#v0Yv|?3$cWq+.c dk1 <w-t}Es`{O;Goaj1[dH=s<$q6cYG)s?Y#Yfr=|vnad|9P_r<EIGqM>:MV)e7V5IY$MgG{Jp\ur4cdf*2^pXT?nX?	b/js,PsW Fe>9p1VTu31XjvfFf=4.|G1<u.[9@]."0)8>2F{iS#J,vPiq[o6@vsw(U9~ZF^|X9c UdOz69jQ5gdqom~H-IYX}_^6YF=Hv~p.clPC}1M<ajTp5PrIG$O#q*dJ8a*Oqc?S]{y&(I$
0GLSi-8e{C%7n?A>z7(73*nuS~0ZMj]eL> Y$sN	4[/gc5zE]Q]5Psiz#mD[zGgQp'W#rx9`b=R)$;c&82
=iZl&_ 7Iq	JN=+=2 #9G"%V-##<(M#A t^x,~EqIej3RKii= (kb^w+r.9*x5#nSO&D_p Td]	9VhVv/"klEEdP@#*@V8f	?oNa&b}su"Dk><Z>P1,H>fF6U1S?M+PQl>k-(4I x=A1p=$jwI|KR23Q	>}@N*[M?PWc7#@+iD=:}2ycsXH[Jg[>~Y/\Yr<=is<mBc%s rp0xuX)MBKk 4K8'=[B0
p3 zI!SSCB	|p<'G$`I0@	zqt"[.s1>a<,H&d<(Q64FHFlc^)d=E6a$+qsz}zZ<DK|B9#nf uRkQsY	;E^!ny:zS?xGui$C0Y	4naH6wGPxtY1sId-DPXd9*$h^Kxw+'=0s94/beu+_ZvXHpN?0x=JSY9eT7F9Y5_~]A+ Oq	5+#|RB#uxRIcb@E$b ^$c+pP?eN|iEc,WG!2O ">ZM+nTc> =:rgDFxA?J#R3o.zN{>X=)dGM[P[w)p<qAw$Nqjfq~o1AJK-CH2HKM2,B;m.}Mzo G%L	 Oq,qk
CF29
GOSDG_ [Enz_5nT+WuXI-RI$ H zB||bTd*RJoali";lyP3S@5LV,{%dCuck2;+Km$==b!8bzn~u(%bav}~WqK`-Dq$q#n	JzcQ/]nYq> q$rn 1:}\X|5mYYY< yzjv_) ],qWy[y;8&W1')[J@;		T G@O t&xy4-{yXe	GveQ;Kl9HVw[#'U~vS	]
Y=GOWm[]n:;GO
i*3^_E	sY4	F6X~f5SZ"fU1rq8{4fUt[rAUw81.2}RSQ'+_XAHbx[0R	kYgJoRN_&$FFv3z>U"3xsR2[x|020p~tEl6sMisI#>hIa9@vpp!%\}k(	rb^m"lh!PJh>Zj"e hJP6'tqqVD_pra`ijQxlY#d(Az$Hh)Lbv'3[*l'\xr^qH>@0GwmX~fUqc"Ldor^jbv26`bo&5!<=:rtA6JFah'chqdgiR'hPK]'aZ` &]=d|#m%Nr0G>_Z["}z`fYQT }=seyu~"(wu|?*dF?*y^*Czzun[NPdg >^kb`9xFhlN [=IAY#dq18__hB	v{K;1p02)ctX3]<6F4[N<(in+9,J1T2'\%lI#0>5omG=csyEB@3'IEXc I\`=t-b6Uz[W}xOi	aJ3T8tC|U%eYR{q) d9&#;t[TWT' 4td3(e8=DCJW(9\o{x$H=<KMa+mjVd1W8^7 *Q5Bv=VG0O<Ie2*M!u+kE%]xk.gZIS\\EaW;O}+b$mQ88;>38h#L	Y#
9Q@|h=@bmEH$hi(sy=% 5UJ'3(<y[,h	vR3&s*,M9)-GfUv4JtvebKDFk2g1 w$wCA=OtI'qgA].VE>,{9'8v>BKV9qv%G'`]t xGv_/8i#SO_@(Ie-pzGzgs?8rGaj6N6[QSnKn 9<N>^;_ 1.IOXY	gu((21LP~5F99s()R5sf.U@~9UXw|sd.kZ6n'"AIWS?8eu*U<)+gp\Y~ps[Ec[_6L9$+(
X^5" _
eq-/+qHdW=DNF*x =3L{i v<X3|),H7=4_izS wO	$sNE3FO}U+QsB(=KS}g7UpX1[5\^G8AWt0jR\BQ~F{9|.tc.|=Q!2:GZ_IKI8S(,DDXzcgY'c kI=hHe& V{_g19$SErO5Z*=O^| uL,k9]~uA2
KLlFB3LhY.H`:q+jjE!`ry=z`V [U"M3fE@S?4~/fBgr25COruQ/(u9"_Wp>}hIdi#F}3sM.=XL*F1Twl$ ^UFR==!P?s:zh$Rt`<O$j9w<[Dh=I&5U\d|5$@ d1ZNz	B|8`gJ`p:lY1,7pu_^v@9
.pY,V3HPX`o?YD}v8r*dU	~6:rlSiMp_,9!Y~c
Fd$?AY_q*3)}t(4k35Z#&{A?`&\G
UI6pyHHF,~T<NcgJQeU71p[#ZVLya;0I=)lNE`vi)67.f~c}jY?g8P!po^e#eU9?z:K\fl&s:`6n oD,yaO?-N|cAmb1218+mb u?W% %!Ca^7'lJ4BgJ,fa/L8ur*o]2zq]9g"6{1Vfej[pYe?JyBkN2Ci5k+TD
Q]}wMnI=it. ufW32vx}+#9juKvT:wil`xK =8($#*1>E;WplP^ )"vn9rMjd'on$q]#Ri0=x,irm9w 69 	&!IoJjmIw ID\>	`tvj>w(>F}UjneGw'NzJF%!%w<yQU;d$Lar-w?Y$yW>RA|Y5Z&S%Njv7Tev4 !zWI rMjle?U3Z 9MovsLZW['"	r6)ebqB7@3]V`\;>6sJWdxRX~8',I 9P: W~##RG5zGV,3z hxz(;M83Ol z`F}4z0\m\\Qnq9#wlNtTqu.Jb@Fpy s2y5[hX8Ex>U[r  8=ryjXn;$;O' ^rNu\guhU4h9dru*,P.I{*H#t<b96Y$v$yJ	t\=/QXn!d,7mc(G1]m`R) pN1{J}*Jk
/V4i]9R+<'.2n <B4\'5M)5fFxm~qn ccsz	KJk*7>&|+ XsO#5Q .m9j5l2=GDx_?ZR>Q_U
6_"qE[vUdb p<[F<OGv~W}@&yOhB'*N}/x	AE+b@y+dMWv}0k{f1,'?>!DPs4gq-9Fn}|&M$1PmcN%:N\s~s
9Nzj.{F\^8i'xN=<jM!*::Yu(,][wpmCao%mlb	`;c Ig% %IU3.R\,V+:~\f,:7YGM60u$G\(ZM  G; b/	];Xg#5Ucc[[ccg g|[xRcppHzeo'H 8o-t}5cntB%9?+Nm4-mms*nYc:89azY;{_->J6YzxV*\U+v 3cF,Ad)Tl7Yd(bl4Dq#'$?/*E|gWi4} 6>WwQ-("$^TwyD9QtfTa|k 7Lyxf|8+4cbKG+2R?V-R19#Z";4R|@AYp2jk; fS{'+~jS)qkn y?fVb5x<IV?0Kiv ebPI gYvee  y9V@qK5:]-'wn%<B]S
Np99p%gXxW*1+@cPUvrI>U6[x'Nk4ePO#s]IkK') #1@7}QVpd_:8d JT;PG_RVX'?k!l +|<gewSv{EpGp#?*e6].9!go*x,d7MO!5K%O[W ._h%Bsr8Vwe,}Lui[4:U[gIR!Q ,_6RQ9!U}@SJds)V|=`\rxDcscT}*Ag4w6h4?4AsJO#Q_3jruI6At
zaAZL^o3OAvhfibIv#|W8xBQnsGNfj8l)8U4LWp*&q^5
qYzTTt2)`wVS=h(&sw1]>[TPHg]p+b7&HcyX&]Wf![$_E{l 4!;Jz2B>Bddc?,;_.%@0z|{
CY`THkRr|TO3fXW3zHC1ff9sJi
qkdn\ghsSLA<`ccWAP!E0{=;k7izRK3?Py!@>d62}D!"jF\3hi @pk]9*^>^mN0	2`j"k{Ld$[ *N
,stLHr?J~&qMc+"3lt^)4d2AR=M'c-]Q$Y<( I vSygcK5=*;G{?$1wJ/	8+>~n;C.?FRc"
Ct
.kA&x3 '
oavCUc6#$'5agy|~nRVsWdqpy f1*>krFH2>4t`gq*=yW008S|jb\,F`#f#R# 1NH%:zUFe!OS9?GMrvS:~c}#F :1 )}]5+iJ`iu`H g9 ZYLnT
G>x5O+&iW!Lq!~5f4)ijbFq}=kU1`KcJKfTyp0G}>I!Z HI bO#=:85$WHDQf#'iw[p]fg<XiRoqAqu[.rqQmr'A,;RD6x2Z-o!a}{~n$,@OUR02N8&l4 9vF"+8dbr>W&<~,nJKrS`	hp|n#Wmam/H]+L$7aybL	j:\2Ke7-m46;0@v9=xYNZ,VDld&Ix{s	y{MZV##+/c\dz"3VBFp=+m1I=b|
$OrRb=\u=[XL'!XR}q)ma{0xuC/$V%bhT(-&??*w 36L")?4E6:rzPs<zGx(q.!uO	A-B?\	Az`v sNm:h.cp {0<s+p*RX1 y3KVc: T>s!`rZ=>i8}^L>-JiwI7DX>|AhvC3j@h
$4s#XH?W{vsUcf9c&6<q[O,DcI 
WcsWG}1 -0F[ [O zPj7r]w<}`p}]vL#= ul\U:en`u-rnI*8*nz]^$XIirdKd^+ko3Brw1%9ZscUc'k(^uuV<	r^@\Wp'|0_YcD!c}	yd1'uDs3_69|\i(= mX}	9remLQL;D9frzC^Te+!^A7W114AH<UcO?x
Su	gh6:_&>LX Fc7.Yi9k<j&E"vhKwVesG<g	'7/RH#\TO4rA$r0&fU/c$U;[g/R$FJ;1qQ4mJK6$ 9 y{%tfCeKb`u;#-<u97q\nMe^ 4T%}3;Zw?]T6<qA_P=2F?:+,c8*\O"bcFTV =8Z'T-e-#[i 09Y@<6',0dOZ[
i,Gn1RmPznQx(;VO"-y~ak24@I0GbzgauxT:zq  p|UvZ'Uf@:41@4&i
K@qdc-_kd_ZMV-?[,-Q[Hrxtpx^esf9JDQcR'rip#@bNkSz|OPhh{#igtXFFZvKq0Rsy<`Z#Q=f
H8fhlrA*qwT3lKq4 iRL0/ NmJ#"quFRw~ fj;ZvcU[iRe,~1sH$ |_j][K$>+cn>". #$0B<2Tn C5U
VVJ%{MlpF}:_ A 1B--C$[kJDg*?#il3b9	c"FL2rxwh>Mr5ggJP7z_k:Kxcb.8?)kKKZN1f2.I1(msldULO|]eGR2!?rFEJ[v;.d~GH*R.SnJ=IVe n1_WdU_>D]=X c+a%^gK-w  t;!.:h3w(lAF>@Tg4VvV{&MI!dg[JI]F@S4>v>n<7F G#';]s{KnIU5&=w02]AS ~h;-#oR|Hd @:I]" CYnquu}7H@,B=L C^`yRvq*LL$8'Zo fQ6Y/o[m:X?
+: &1qkr	\g2%IBOUN{>|~P|B^'>O,( 3{RsW$2gpAHgUMz dl74:Z1u0 ef9{kYjL?{<Gw~||3kdxYdx2t.%3JtHFK*xCKy'mXbz2+q$)m6:uo	FeoM:!t;02#u4W $6[2}M8KFw`qVFVc?c^]Uo /@}F^'{F%^!LWEZ.G4Qm$\{MS/gN@9
[wE IH+=}~<FlsH|X  e=Xmr,|j'7yyd+#Hm#`8$}=~qVc('r%\O	Z{]dyj;'%C 1w8ljI;ph%Q~cg*Im472 'p>3Z=Mu	;WL{D?>:QhvR\vGbq"O>xJ9iO,U1r+g#	9>T}Mu`E;#*0qR+fkR~-_v~=^$M6L9HPkSyW8a%h4{wn'M.*(_(PDI)`~W P	s&2`e
Id-MVn9;Wp#n2J;M6~M$%1;R3XdE3!e "x WF7i`x5uitrP onFw?oPc /Y7tf|&M\e8nCG,^Y~-wSe6$ZL+2PA4%@P(jS$,o4Q{i.u;!'6Utj-4DPz0\HDrh"kA[#|SW<HQ_RXH$Q\` k4dt%uWsFqKQRY83.@'qZ]>bmGI@x85iR=WLb[[$yyLEnRrzKV2<HN1C7	sif)!85U'mC`p+G_%dB`E-8sec%A>O;2vvAy{lu9	G9CQ,F8'dfarw(+};Q*.72=+4Mnn^'#=1x~`1qZ&14l$lkm<`c#7hu`I{ae%,v^'~	UMx*kve}I/Jq$^Z[Y'xC!//G_>4QWb}>\7tGLX
K8 Pc0\d|2Y:CBa$3]SQ_V>B$0xzi{;=~e60.TgEMa';so~ wns`GZDv2Z0XpI>Xg{@a2AzZ=nP--;pGHW$NKZ|3jXz#d1\xR^N7z|Vzv?sS(\eg@rxQ'99"]"9;gB^vAyo
N:
f>Rry5i]:?{m+VckV$KF)Z]ZHw?jE;RUxuuw60.
r<8 yqLnfx	
CYX8G@GU$y`xotUA= qRZ\;sjLLPgUJfe#Nq].\)_MJ,I@Tp9?t^FAS[GR+I%FyA+=O*TiNS\'_OQCMk6}f>~e1)`z(LL(pqE*eX3WZ[kN{=}s#EqrvYs9f!PriiuS[Kk_\"H
=*iws*YNM)Y(F
`cxC;>}KX<HIxWiRE:0=jNz,xp|/<];Zv!9@?CVkp3G`$-1`V*0k'AZ+S.nq q4;;1ukSFQl3VWx6> gtoo2pY#8   WVF+/#(O@F$kA4aX=HTc#gw=b883YMc d&/R0?"9:pRs]l$2:K#C 9RH<*yG4vsZ#1irE{c_fLnt U(I_\y	\r* ?M4]iEK!f`>^XTjdsLsKP3K,w3QpzlPxt6US[;n0pW>[_ZYO3yL@:y{UMh>GR+<cV=TyDwaB<CsDFTxn$?6Nw/z8(#nO%zkaXs67TrO1SN\	6Q"8kmY9 n2M8Lc BJ`be->`Tzyt4TkO'	'[:d3"bNp2Yx TlYr\v[SxE 89#e?%s:S3'-yR+`?*
[6[i{,Bp}Ju-.XS$m U@6' q/Sc.mbI<zs~rHpUd1!lW<1Xc+/.a]XQM=.HH&5kO f '}3IPU S-?T_CMLw8P^
DbX9$kcx_=;39KB  p u$G?(\Km"?S!vU8#iy	S\4,qmM:WwlBNy1*]#dLUH$z.
15R*T*nXH/dn$LA";m#Hq{UawB9 `6$. pv<N9vu@	'(NQXl{Wdor|~3Z TJ.kr$qOi2/5	Q	Fspr	59aN^H"$h>$F}GP^k7e2$: y7Dw$.G V(%\X{	XqT]0IsQK}Hef)	C&*&9Goc<,H<*<\0b~ieBX'3dy
pD	KEO.<Wk)f >t`.M.6	:DEwfnV .F@KWZu(o}[@`e=(qYdAC2p>+C<]J n8$}1mk9Z"K21+0\H#xnQ8JLd})=1R4C.L=i@;_7 `;H [hwD%-;;)D+X 1bH9m1 {>%C%O
4v<oogsS]^'!UgwX)2vONDQ=eo- IQ(	Ax24.]w
KgMoO{dHFAfq6mcHqltObc3%fFOxKA(JNE{>qK'cGvO%s)U;,O[J:c#n|==)\g;v_JD!1BGPj=[>14%F%Bv	&[vO=N,:sJvR=(oNXsK.<@>O}USE%Y+6	?QR+=	|qR2qus0>q9ec9r!.snq8oo+Xc` SY3,YG9 W&<8XK:y8<}  g]Ew2	# +W[%
]TP.Aohc`;}<i?i}FS]1YfOQOg ;\~1O	p|]<*EFaxF@#mj'VMocY@4v$xry
L27jwQ i',O-[C1y\&aww	O*PR[&AxKLrOh*)$sB%%bdTY]'SAHKx#BDQ[H-s\`}3Y&v xHo3+GYb0chir:WM qG dF%O|0]P 
9}u +`<G[D*ZN8 gE`2n3U}H9 k+8.Jn@z.1y[Eqr+#`y=llb0f#2[1P LV2pV+g)i8:tL1,Fnw`y 
V
NC~8*	<'we#z*GCiV:3CS?{9>OJ^k$3Az9G*3B9dS)uKl, MmcW7(1c 0-{0Us^`U.DR#reO#%Ny'dy2$]}<l R1qUs9[gOrsDtg'XY/&KcD/]nvG#5x@
N-k~n+&RM\T6}sH`\>!#R ru,
)\'9KFVSji.r;+F9u.7tIGRMEPy9 U97XHX vywjY*34Dg5`A\\ei
BG4[K ]q9QSmIPSoM@1AfYN0
Gec9ZS4rw+pqzgEc9@)eB%`*1W=3 qY6#nUJ	Nz[gsq4`9`M3N)FGYWmmV)'xc(1?,<8LJ?|Vb hx=:|#{$E'W[+$J_
?S
"8<>U{Bqz:O9H2V\{zc[\r9T0F8 y3Y]P5D= \Ump [Il0UJ"N'h/|n GV~J'$%ln<=6x[U$\~  <Kw/KPqvnvw6k]bX.yE$y"3~M|06N{9LPr#,.#${dqdU9X1
ve=aXvgR0a-%Q c V]m  1uMr*GeH!Ac^Prjb*V[{h@,yJGfyUjG\<Auu;" :R(?zN[mGR[.!AZ6Cv9i2y%$|k+:]LI0n\)#lP-3y)	{?<*nRTr=	3S<eY:{PKtPJm+3`\vRY2
]Ja<rPIc];&G/chA36<sqN[u	{ @<Ns$R'
?)e]B=W7GCiW-.Wy-n]~y5kW2-_zs&s&n~~@i~O\?L o XTJ.TzuM^E%|(0q=jp!xC+	}Eq26RE1B x_|T>J^$2
>^t]F|A#}hn--$n8RAY FPI>|fd9xEA9{{W*"nPS?jeN9L	i<<RBuHtckn#zu>-! :I|wRDys%psWdIjbU4RwFoJnmcJ7]5+#k9KnTrY]!`P)j=@[L `in4 iyjA#e66|"aNvYX Y94qF8 955),Z)GW~Lkh9=c\OO#nN?$3,
 	GS\,U8
 

+M6Kxa8u(OV|/j0+VU}16% 34w$/lv6(VYX#-XOBqAljkj@ t?\T|>T'<}jy6Yb=c]l;n]H p3VN q\*L`H+La H?m,fBDy
y*q,Ey9H$(Qn:S+%LuAcHXm^D{fFsVTFY%7.*:rq/ Zs5-xV,$.I,g)(Rr<lH<~tLeykfDh7X{q/gBQ!5&+n"Cw%8-SEqsnFwidq,Y!Hg',#?0Hy|6l]Ym[kFmJQ'Zc`I0C^r!H&v"s9)I$FBF={Vf#lhrp=-q3^TJ95rc%S~%-![Ao(KA8oLhn	:gTNg*s$	`x0}-Lvvcu=s*h8 e898*m1jV24.'4tXm\KdP<uA9]\q*cK;!N	2i1GE$S}HzqvS#CA|jsGG{q&tA;sme.q>=9_"/es]^iC$XQ C|h2IOVw=z^BYV-A_^4x%j|/NZNoSy+8/O4VE6Fay<RBAfAI)'	4Nsqr{RFG&+O
HWg'DYYoUGE-HSVg-*'\~-;:{SPO_.b,"Q	l}rnYJT' 
8B>[M&g,98R4"9vf`PQ;Gux[p~_[-j56f?),&$![sqmZ++I;&q)7&v22M|"03rzVM>$1>4bI(iq]r_2;,\+s?Zl;7).~-$e2Q*0!A#ZEt&$HR==~oM@ Uw'n 	^GYfHLC"[kuY e#Fq^4  |O$e'g;:q' Df)A{^_'nLnON-R"d$ol#[c;(wmT;bwq)#)c V Y*=85\snO?"}jeqv3EkiV21p {qC
.tsRAk[C|j6>YLUznsc$8jAW.[vCs!y,*[".$'qz6)P$f]6NGQ.2BtV1N.&*[701a[7a[i'{P,ly$ql[H*w3wFcc8|gbF)aZv_DpZYdqHvp:S);0k~Z6`I2W5WeKT1[g0cO;?N:ef^2 ;d2Aw D.S^4RNq8T8Fi])%t%ZL&F\
G+tl{#uC-aKl	vN>U6b3[!H qK~Su!YBGK}G_/c2rY^\E-,pyy"ISzuH=3_YJ.Ini(- kSooN{w*nC "o#ePy*2y3F8=k6Ir:wOu&g4nxtOj"7O9.jtT-!A$(\lDCyb>V+ _CT<qjj.;|5^yn`:Rf^2pB,VatF0YBxEj{:w":o)LUSCj1pu3Q?+=$[IX  8; x%'e-}^V+0n==x8yRw?E;^GyF~5_P}zAil)t$)G)P`)eUpw68g[Nbovea@x=0c9Dis[ZG8sRoF/kvNq =F:MvrHeAO4DxZ#i;[H~4mdty8rs	eElm:x Bz5;T={Mfux%-P%y`V;5]6!. {x=5xhK6pz/vCnBB9q#RfbD	
ElYX#tW}2Xb^$h_g8<9#\%\H	SCyvN^ipDXM,QI ~8f}PWTkM2D(fp9'g50T~#e(a"Xt]C=X4I0IMKIaT<]F&dR )? v{Zv1?:R]$qL&X f{
82D,5`:88>zn&;Qyvyx6hd u:7{n7<7&^Ius)Dw>T^[^z[\8W*XkfYej1~ 	narq\|\/<K"n`	X/A+=e]3:c*n*w/tvN_l]2Mqy{U #o8"wQde<ss[<8fus]B-@-$B0<yIi J# ??-(w1y#~BZQVq0]G -MTpUwRK(mhehM>w;q81kQ^2M70wU6NUF9aYm+9	=:)
vWTbi/zy	G;pRFgc,xUXD3=hn_IA9>'3<0}yiiZw`)`s>\Z	1 b}r:HecY%n'/rQ9q)n+aw=A,mpr+{jDMd2>eYU##ju(`M*TwOziE2<ui:?0t^x%\|M7>7l+569?Y<v$2.5=5%{/q g<k"GAf 0=Ec-7p/33W=wrkS\_w {=f08F?Ue<o*O5>ckG>EL:q9;	?EFQ&[xzD2V,NF1kP>&vmjYQ*dN}<#"#Nw5m1';~@j="mFx J_yi8e!I~Vm8N8ON	69j71:whR'bgj1Y9OO,1%Ra`ruYg*G?&@qhH?Lg	%JV+r0=Fw@mb?.T9+'; j&.D^W[7$HD@=G?TnT1uSvFFM:,n|8-J-."~!#UEr7Y UEl!}Z$fyD1n90zO
P+g7?V})U"K0tO%p3
"cxxy3Pm+[ixlm'NHtt~K2~(ID$/eL2\:olEl?UL9O|t"RCbPh:k=Z}d>tf.9c8 datwTa#D%^@UC4d#C58u!]0{JYk#2#&G#)[@+MS"Vw2a%m#;9r&#s(F4%o:X9d!pqG`2 w+	uP(k*n =3Clok9
N0Gh;'{mqkK% @P4?:[xYN>H=&E$!q[	<uJFuuZ8Mu58vK4#g{/YUX	J<p+Tr5o*M%9Z+M:&F/B=q>>#SI2%s$?K]H)5h;wnM88Qkk Em# ?_zo Ojcb$G\Vx'Lsw?@Y~T
 $$5EFv6%#mA zU\.0 )sGM)l`>/z{DcX]QF%8}KH!A9
&hm9'r|3#O	_F8N|%5=Ud
A'<`~C
Tv:aO=zga5)&#t$[pS]A4yg}=Fd1qm<-$ ..ev ULdPFJu.i8o&F	PG>^2b;`>^1CRhvc$<;ikV)E6LRxW&ps}8qXQct(@?z"2o2wgn0	MJ_i]	bteh2HqZUFyFg ~ 8&lH$jqUASiQ 1@1 gM1]%ne6`f*&W{j8	5s!RzMhmYH|0<=w5-Y7>{(>ZB!
$}f@ON~TBJM+~&K7>=B`2w^~u$E lFrwp.C(@tpz.= Z(nr?_SYy;.Pc-4l{tgO)KR0E{i9vQH3n'hO@wm^6Q}SS7ZE}>h9jXI#K[;hd	*^RB#C\[iI#=@lm3'~F3>*E+(4#2Nf]k9m#$m;q~n0q'\&i;3#[JoE{BJI-|84[68
bxR)i\~|%d##k@*o<D	o5V dU.nd$d4Vvf. e;H=rOI%"hW0PuY 04-%.}v-Sn=8v%v3#7hR;`ulqZ4
X0^:f>kac#blq*	t61|M$cn'\-uMdU Z8W
6#To<=kK6y.#Wy :G(`A.G gj3>&s\Y(CEnI gc=+{bcsj^#nG=/"[`2Ozz.]+Lu[	C	=|;nlJgS>1}pqg\HX]Rd8~+	KRI!\`I^H*wR0cVu-58)%~*nGGC\8_qs YgJm}KKWuj.xm~<WquuFrs3YqpUPXxho}mueqs4%rwAnG\4]GEl9w1[H$yWFG".N@\_j$,m$8#>[E{M
[qVF=3}d	V	7y0x4YGl}w0f_*CxcU,5>y]7[i@0(U8WK(iaj3qYaH,)!d 4}rjw61&	S#93vclnjPI_PH2^F!} }RsLG^Ne@(y40RGx/Zjx:"d*I, 9rn;FY7XMic463^o4+ bX8ZWT]EfbyxTc$^%Nq# [: C.ve3C+cj/BG4mzRloIdqo9S$I6a]el"aTJYux`zX+; c0,q30X#<g C}jtD,aBSjA)QZRF	?|D[]#>9<+1kkON{2U'>xsey,uYc]Ea5F)%jy	Q kUXwp}iRO	 7QX{qG=fe%v~u:=A&
sTw-H&K0n0	z{c}Ur(cku82LgpT'G'{<P+r<=z6$.z>tW+XLEDEy]KqPU%[p}ON<s]-2U*H \HK<en[]"fU| Xfw	"%^[_( I887N\-NW;tn=I.h94SYFN	Rp=qsSivkvw2fW-9LV!Giow1S `f%$< 7@>Ghx`owY-no=*?	#n=j|#)%nSA<~u:8nZH&Xg"ZdgwNsPHM]N>8=Z8#Gr7^1^rg+4K{,r^0SO8k;HH4u/Ts+&[r7#DZeg(RN@q 5lJE?bN:NiS8>,:&x|u1. 1-<m6I
L$5'WA{o#YG=Gf/ eP|Ay*JKX2DOl|#>}Y;jETp9qzdr8L"({H'.k 1M Nj/h,Y38FIFKw8>G4e,\{Xc8'\7?<Xu;X?f%N1M{G-]3"`9 qhd#}+Ghaw,qj&f	?LI3R6X2G&qJt PRhwOj@fN9&b#;e0:m<@Md(4!Fwv& 6)bSeHHZ#mc	oGV+r
FTdrw+&d(Je'~R%%%Fz~u,mR1hfd1 Z 9Rvs9v$6<~T=M$YJWuX!O|:myq7D tt#.:b=">hP :/c~/# rwmN0o
<GR"7<NP:>tnvQNG@L"KV!cL11:<r	
H^:1!fsA3C`9n27  F#! T@W&RRAr3<9@dZ Oaae:Z.;dP>~J>r2	Rr FybwG>hnMLCxAJI4krdZg302P~Y G4)xx9eK+8l9uQ;gybYFTT`+e#WHm=IngwsG0L$bH ^WqEaBj#f?` J=65F;X$9 :]@p8"	1,A?.xdA;m_WIp yTEq{g|xF*`3Qd;r?J3~$9 cp1d*# i09u|*xGn}1V@syVtT#HIV$UEov;^At\q!0zy8@vLprgu V ^wnB"c[@Ku(fGj$	>*<sV%p.#Ifv7*v+O.lr>-<dUN9F9R=x9W qrA+#`gP "&%o!1|YVr+0P1ot[c @-hcg>jLK QoP:O'5bL,+;>yUr&F>*X@7WBeZYay*9
^	?:e1<*pr@UdfI<me@F"0$s+1[TCgvl8e;y9> j%
	>y+'E$ O\#u%L+pVkG?RiC0;A|~
UJL^E/v2NQU +_%;RWY"I?J,"fOUL#b@HXc'41aF=	TFr\~/cM;%Aq1<g,O9#XF~gq`BEG
'!3LsG341C=ri;$I0DM"	OyI ^N~Tc*k3K o
g2"uHJICiF*#TeVF%*a?:Avq1
= |}3zlau6T7cf+8B)$P8Ghr[s;V&>6Z9ibmRY&<#,T*)p1~}m\)8b|A,d13P,I$^ ]I '94gXu r'$~t-v(L".9>v.lpy\Sw6w5<`c_;)6MX,GXl3`r3|hn# V{HAfd L+@VjHz})5&izvkM(Q\9$:j>:sD6r9ckK9'%~%*HZKw>R*C*KRNN2zc4M@id (3}f2<yQ?Pwn!nxM?E;q$L7m$$X0#Q@cJ;bF.>viobbT[vx#1t\z
7?%$9C`vO! cHy_u';{xy*Wv6a}5p()f~QHpwpeSw/G4%\!S?j)0';c9#&RKF
yCN O/Y/@=nd?pj$r\$eN:Rp z*H~.)`G!,{1@3i3Zx=|p8c#&8:uwjG\BI,QOdq>y6:*?v9Y0Bci_s|u;D
C bee>%eO+jh,ZX_3xWn%wzG`\"$LN>z^N[c#:a<nd.r~,s<-3h9RKQ0\xnP8TRe#s},l,lYQ17)b"VM[8!8d%p5Fx9U!2-9.r\6qv]JQ+G=0tr
),}PsSjbh^oAa2#Z}h+BKi,!TMEG+u?bph	F)q;'`O;L&H*pg5:cU->dL#NQ(z	gb_ek$8C$u'/s3x>t- \8+\!qw(  ImOj5YU^M>*=E(lwp29QH$> qSV7^teK1I[w>DeBzbn ZYg@+#IE57o`HM]qkd};Y]hO:)8[O(#"c~h5\>fg9> 5Ac=9`Ad@ =?a7qSX);#Z#$ c.&\gpgR2GS/f?T9[k1\CZCn}@Ok#j/ii_<L`# O{I"j.( W_VS?TBWh[,iI5p,M1?e>]Es!F|-*}7> KPW C./vE>9I6O ^Z2~K,SLni`<{A#!RF62=t1$kuWE|vl'w 8oKtn6A8g?yQ)*z /A#vn2 gW/dRB@~ :/1F.]g,]5pLVR|@cT3=q]<9Z\V^4++q(X{tPqvCnAi@g\1$^"H$dfa`	}qGqiw3 l~FX->s <9#D(CNs)$w.>w?#C"..&e xCEk {DBpQ$RYRkyWOl]73!U<wf59L_S<[,5w?Y9$yyWX;9\mJFQpD@X,h`u)$/+U1H djdv
T8E>JMF<d}}C8f+etzhyfvCH uYPzFs :qx<5>ZY6hpF/uK=t$X?|RP@8%}AD@}-Xmi<qd%  lG5}bLmE@h\D4};+'%+gmtN/-5FqC^vNZ6>L1VXYXg0}+:b1}4=S_Y]i-kIgv*.Wx!nlL*c1jn-C:Fr"F#,2zhV\K8,30V_Ry$qz~.'O;ZY/oi.Vwng2>?QS\x!ztHV7)sy n>F7!j/9n2p\|C@!pTN47W;vtb$.=C$1cQR	#,c5)eKogZ1@wJ<G}3#Up2d#3+HbiMhc7.>Tfb\lZla"*sdKwXdWI^N|
K?}mXUO4N*:,\JE :`\6Yc>uY5r6*&s<,#GyhwZlr!7 e^gg:pq["K(NJ8J4N!\@svciNdOj qP#& [=v76x `f%HOtYC@hl<0}9]v=>~c;ao,%ceD4g/<Ys#E jNgP9s>X(cOd^0BJq[ox@?:HmE"%qv?	H`bJ\qVEnN=;S#*ymbMdKGVJ',2=,e)e#-{B$<;5O.-Gmk!Y##j2[)L;sQWv#@%A<1*NC,hD*qx5sz X0Lm8]#'qz)2vZXw-$@}&.Z<Nj"m@T}W&	dC1fN2xhlb/c]Y:ns\n<V'a5dG+4<:X6I]? "k#5=P9m.U$	-FK[tQM,,% 6#$.eW r98;FF\_S]YcR Wd^
,mH5jZ\o48l!b9=56[F#~wWuwpM 0|D]Rxer14y"PwsE'eJ("M=te.Pp~<pFJDA~Nu
C2W24LlF0]?vQURkg9LLUuZk\=BTcs^/9c.$8a+ Qy`[<]+%0QFI!lQTu6%B4mt/ LEi A3SJ-('`|6-XJe$J]1&dbv7{uj4.G-np%nq	$:0{kUvT+0XGgh=^E-9IU  ]#RnW>@b
P@+qV,So+g9:A+,[j3i6ufUW>M`.M[HO@A~sw6HxN!cZ\6RK*y#@\<RY6}qFr3'\`(G?,[x(Q-K:T/a,Af8laa]q/V=Rh4 =3],Ktd=zs<
pjn[ x>4LzjA-c M _C` &Hom8;x$6'XtA (Q?!@:i>>j]O2h)-e61	-l1Y?K>QOW9$)uTS<}+Qd$<T9><{blU<4c\;'|d|Wr&Z:\d6@+q}$Cc)>{AZyVDf}me$6s"80 "5 d.s]wl2E
lg.V=knyX:H|=/(IZdde_=]]3Li70y'5Z	m*	[cy9xA=i[u&|MGPfi:?h%@W1ExMH[H Lq +oe"fv|OUe~2hBpU|jhy-1cx^G8{EI3dlt8Ew[88e9F6#@t5`NIHEE 7x8hIrdyPo# f}1CL}2&$9XYR)=K'>Bj2)PK*K/bpTa:dEe;aw% 2qQ`Fa.D}*R<>JkWZ%FN	c~
Cl$bgI/Tv,M<	HyOu.$h obM=F~8K_^;l#@<QEuW/${#2b$lKI4oPw$>	3bnQ-iA<ld[<&mua $1M1l#AbYn^*x0	?WkNkH/v#LtyDtgDU>| :jD&
nd
Emlr-Hz0iGdf]eO[$E  /gub% FQp?1+pN/m-5l)lwo?5N =NivVH-x8[X^NIb3Q[c%<&Bz jQy2S83h`1J	E ou$Lv=o1Ls`T<cMRKXk|]M!Ph;A=qumh*pc1:g>j.d]R,B7lrF;B6sq[4bjJXiwV1:IHUz}}j)n6xNAtae|>l:TR"-2P m`A	Z-HltMMqdD[#6y1h%g#l /fn>.5|vOw=	eBeqlcV(?< jK^DQ"	D[Omq<LL@zHi?]vl	d
	~tEMofmEQGcpClAK#`_*}Y!N$Itc.6sPd&\^_];I;Vrx7zf4Prx\8.#:tV8nWe&/:JKq\z`*qHzN>KWD?1;1L3&[~BvoIrr2	A{?~	t'+^J*Gx7d3PYg=SK(}O&m hQ;?W\%:	!#S[?wqvOiHq6@7fm-	c6\0)y1%4f.&BR3I@Se	o#@3ZVm@Rt0Ln]nSB:^H[d;mA1J!H 1V.. eN=g4;	S*FhTwB$$Tub^uvRfxH`a\+4@vs} et6m"nd obs1_zS:e>!z1v,G =A+f<hLz}X{?W"35ZWl7bk(=x#yDp8Q_(Ht 3Tg4GVX y$3ZdX@TdZKF2dj{m*	hx~_{-&d"89 }l^;;D2+3)F|=-M#rH>DM%YivU.oW?-RVV$'j68#i1./,vvqO_py4eS3Z;/3*jxWS 10:F^W]AW/kr;NtIvU%d\.hwoM2xp}:}:a	k_qsjbT1`x"zO|I(n32$)FfT"UA?ZvT_nYOil>r*;hr7Dd>I$QPB;n ,}>eRkmAgjm5eob<@;TO`~42+GQpxa3,7Y*X3Tkw%A9S4yc2KX\zG=r	z}kc?<1$~\vlo`7Zi<GY5cAzm/0AGJsfid\ 37-r[4Eeen]6ddAp{A"hQ}vMmv:c5U	,G~Cx7Rt$x[%q|ZKH	3W3r \~f0U
_?:,|fIB${~?:H?khCx2I:W\Wk&]FW=*T;TiygN/9$Ak;r|?8EBO'uTO:uHQ,=?19K@rxLg>T/&2)_*N2~^q}t#Vzu$q1Ojj	~TEg5umOG?+;[#``qU"r~rwN	$u40mbO^th|rZ+`|jt>[b[%C;X<9>:f 9Qq`NpRvNGl)7c\6f-~#0}E^&RvIeYRn<CUoJ:l8m<9Af;Icf8qb|UKIC'x3Hx;
~c]Xvn}P>gV%l51,0}Yuu'l2c2| ZOgPKQ31GEjZk[(IqKT$l^-t>~x-5K:8F4v*w93J@g}j-b1ldxrYTn4><EV+(3F>&8I)*t8u t;55`Q~r(}\7!G3iUrQ+-X>M-y$}j4 fv;[}I q2OelZFQh^DU]mak+i#wL}5t!VcXHZ{}b= =nIFRM7y
pxMUbpOQl&<d)84ctUb8{cm.=HPf',yF=M,ltJUyFG?!W@FD	gnO7zXLt?RMV8C{sR"YB?NJxG[HF6<W-4J	ay"H h!q q5=c7;l}=(s~EIHQ\3HWrW_;QbhvG-[F8>};-vGi'(=+VA<~tve(2ir`FJ})EsK"'qa}}^w <{c]T~"S<e=nI m+g.SU7v3swd,TrFqs8:Q<34vu;gS|U,%[h??W67:0 %N`iy5=+tzr~l+)=C[7sq,fHb)<ck$6X>B{SsmJ1&u' 6{.Lgs!C99?J]N/v VE@BqYvY9
%2@T]\ztzYY<~jX<y
X!#L{r1eBR=Lz/B|y >My#%s'mseZuOD-}xK+x'<gmiS%T*d`TcAoY#rR917i7Fs. ;lUk8}-$r#,:z`T=l]o{(2}w%C`,=	^EfPF99w&5Ky ]k\RY{MkDwQthS5{140.ex`Z"D3	<YwDbbCFCsdE<m+4iM4:>9Rd4p8 9R}puoo<F@8$eh >V6pT	@	owi#gMd N)enE+`C!~\V_ck7zpFG=qW\cSPR~)D'z$+ 7IvFY6r"mV' /-YSLQ@n<r `csM<uh\x)RIu}st9	I>tSEqFEa4x>HDm/Tw VM`g8TI;A JPf$_(i/{#\&2NRJM~G\'P0#>4b9svk(9|zS9rzP}?JFS?jG-m}I:sO;sqoVX F),/-HwlF[>\qJ*H_!#)_2's9 +Y/UvzA9;HkavM<Dr=8U(#s q~9njdAnKHE&
q=v4=uFcWFRI#<T["^!6/VRPo8d~,8< &]js:-5,qL
\uVG/S  5:m`bDA[Y!%\L~	K9j`:-w&	e)
=<f(XyG=iE uJv9cAEBtl<8ULu=0 o`)c}kKxj2o@NOQ\XJK,%}?io/^A)E;]'OrxN3nmYF:y
(]w}U66avf,nvueOxX$Mh?K&GHZW
A =Mh" B<|Zx!3yH%O\,maA J6[wh@/?J:F
P>~rExd)}zRZF@yIO\t~<%aor?ybppry?aVs^Fwodtx;RT,,?Tj:	DX(4=@wu%6:y+]"T mK8 F8S\,H<N`F"XZ%[ #zz=]^GAwPeQGly<su:'yP,%,2Y'OFe$N:^=Vt1^>1PGoRx:xG mbF>i~$Vn2E:Gld8`so=4s]oR%2YHYGmJsh6<!z=c|f IR;J{J%q#8G6my\w;u=isCYx9<IXT_[
K TmqGX5xDw$Gid~ybF :Kh%fzzx[Pg<R;[^E7AMGk4rvh['HVXt''wNfF,<*&NIc,	>oyJ%X ?:%eG}2/(FO:;<7|czjSoc@Kn
q*aAQ6i>Pua!Ep5zi!"T1U6}A>Gtq^?rutySe'k%i.(&p06b}R1W,r>}~BS:wHU95I'LZYZn&Y~Vh"Dc ,FI?NjFT2DGfxXHo?*[;L)<(36T~lH3HGKq"9kr"b#s'~85d%c6ldnUlF%#tq0I<e&x9,}DsWs,\E'v79t;IP@#~*_G:`0swp>HpmyK4Np:jq[)-'Wx$<<<a)vRl'LV:W
)vs8e%r]AT|_ziWhrs!VQ{`xJn\)p`ClZB=N+.3,  =*1n}feH(y+\tT! X`~7,$#rq`+(bJWjsO{RhONN$1hix[d"Ict_6F=+<jlNFO/ 
``@_UlaK'LL=>K1u$57]Oe"W['?oyW')y?jcv#>Nu$	; 1OUNq.7Zb>Us*9!12Cf(cmaul%2	X+/?wy1QxgQmkab9G#$KuY3^"/p\~_3[+9c~^NAl|]RNh%XV{ghKJnlu#Kw.TR<q*# 6#Z$`	bxQtN]'}3Unc#:	`sZydRA]^K:0g`2!*,q%Ao!@ sXjy2H<WzR3@B< zZ1`vUS7^(]x;i-PcDp^Ilw(=N;Kek7-#`kmnFM=H>?c3 !GlN{_d KsHjD1CR[v0TGjUN\ 9kiSlXqKW\@"0IP fSxtGiUPw.8< FdvD@=?94M6MF7h#
9 `KxQUIPp8kfB$1>nl<0zS:D]GE=6BLQ@8?UG.#y8pSy8u9X'? ytN;<FDs8I*$D22 m*XddE2|(|L+RF>B~[F
xL2 yCSB0s^<K+:x)&T7 9Y e @#e!OeDxr/eofR@5l: }iDFSU):=j=.#[Ml ,y^8?*6}%dYTI"%QT9|u"C -;H]:,E!
xJtpQ^0ik$3('^_*|e$A>qE%is @NIXS8 ^WPpy n&Yzu'_6-ONz5_mO;>x
*bzENzps}T-1b2H>;dG%4WZ0:^d^(Pcz.wKsu*[P5I?vr QK2g|z]PnGTh#MJ8HJzrq^Cowxc";<]V8#p?T$:m9;5zGN+]{Gb# j;nin# 6iIe2W998dv{6E6`G9EgXvcH95S4Zn* dre9#=je$uiB$^r63P&Vvf!=	*? F1iu1p4d{3r$FNH|^ eH4 4o
r|d	B_n>8a#.=S3MIJBNgdq|<q,  zw1w.\$vSyVAA`NB#AH`#:8*[<eEqnqPNG[jM6%dmFXG;xf;hDhfJYuCK4]Mamh!
Y|'9P|^]J%%|?*). 9G4e46	RY9ki2[64USM!o HvbqBK~@yyVm0YHF*ZUl}=O7M1_<FmVZEKh),6OL&6.koR;Q/98tWRq[	 :\(hJm]GvHWzu 0"-:{XcF'
gMAE=NHD8XZDKXU~3hG%"f,q,W?LR)EbO5S@ZxAXOVrBT1{hdF{%?}wRg<"CK^Fvp!`U${k+cmD6<@>u34c5u#8|V_M3DJtt$U4 {0 rh$~xVA-8%8HEU&qIX1#vff<%]53 n * 8`_wgbrb"Qc/:wMdc('''w#n,yXE~4y@RG Y	s7]]OYNq=3q1VIW$dr<|n`ThZD>zvdmga.^RW6o[k	p'ZGps?<*pv zy^QIgLnDC'y~G	#j8ltBYq!]JHTl woL|!)rV?L.G]={#3pO z*M&%.s	>_y?tW Hi#(2#s^TosBv3}ci',besmEo#j.GNwj#":dR"?f[eck(^m^V,Fq yG%hr]p?LcycSnmd'<h-P3AZJQ]TzysGgce#g_)@I (/		GO:eqi1CVkg 4&K.c'?U-d Ns9R{x&	,Ha9WY//8^[|L0x8O]5OI{)IK~>nFp<G5<r-[i#%AbMs>Ri
u_m8u5F0#9#:$|5y{:V"bu[ l3' smRu'<AMmw4*3.!A}G>2T'i<E}N6Q=jH!uj28ZFNi9 +3[oN_3\FY"'ea.r=szhJh Bh sd`q. [9f(c7)ZA~I!%:BOFmNFlw\[Et<HAG+xu'."a/$#-lW!d285rl94<Cy5d~os+Ia<V{P53J8b qRp'-;OKu],y.^}SrA8'@P03*=HDSIm=Eu)?[Xh`ZfWo7qn\tJaMrpB9H9:vD|K3xo9\!Bq"LNxN3k*sPPViav4l8muOQ
$<s1Bt}6PvHN u? 7#-(i :qiiYxW<t^},4UESV,6%q([&X.~O%;q,r|T=dpGE
ZXZI4$w<BH_]f6.@P7L6r#Ux>@C#=z&kV.HT@s#rqE2VjO ?pqi-$Yke[4Xq|WwHm&+V1	smvu#Cn f[XW$'*6,]W`d``{._BNn /aoz.iyQq+{MrK376cI.V(YNNOFI<"s#!?y-8ju4{A^\liU_*\h6j7p	!?:>OAm\68uXtQ-$?sqwy"6> *P 0~=Q8,5J>yH(SEPK=gKg-J?{HbrS7/.m=x
)KRNjXg)uSXfs3rUm]q}>TL+Kh$G8>x,{
<R*MeAd@Gkkxc#`{rrft-x7#,NsD#,\u&t]I.
2_F3mCTa-T)NH?U[-'0Iq+/	<56h?:_:UmqX	Utb+r {qoSimC~Y< zs&c0B18U6PsH#]2065^L:UKE:wSr,Y) ULaB~\PA39<yBO8^T;CqR4ycg:u=NylVtD+,N.?yUw:tRh>9 DGQccuY]So[]+S0 UK,~tWNis (%G[2r7 `zDwvv8m#'+Fm9C\p*'*vZ6xAm$1/9IfO8WL{ I J
)/M#&ylOPl9qXy5`d"PvX8 *onlm#>kNI5P  *8'<|N$}]O# Gv3vO=?Z;`DIsWLDs(	& q *qg/Mq& qpI5Ji_@<8,yZ}> Ba?2S>TknXwGm{/ejuK,Xshi!.eKg	4Tl>$7\m	=2e#c`ycQIef&(+)H]\/"U]FV+;>cZ;nX.[aa Z9u9aF8rq}iuV_0e6&,nQ0!;<;=3iZu&+u'mu1X{e^Ph CpZ[{('#M-lSv#ue]Bq"9C34%i.yb|I+>Nnx["[n*	u\bD#;>K>]84NiI ]XaQG?zA/i0Ibhh9R+rr%8dl:  ircwaBrR#?[Icv}?i1qJ.h(,$BY<FIfX;EJj\ 9:$[O;\Y$qL\Tr$elf[x2h`\U78iAMuvO\bkF;n"8h}b<2Hq;Cdy~#GNroYN>2ac"RePuuikM<vD$eb5p8&mthq6Ngj[K);_W1oK!/#@a,wq:bB;XhaCc#v	V7go;"	6(;g	(GI	J=XUkvR=OZ]fU'I t294w23^/dm#Lsrk4r=jo!#-*2'6>pA=DWq}K9u#Rvg[_F#ZH3~!4.*Mlb\#Fzh6z.rfIYe0pN	5H8|o/YC:6rH99pXI2j6 %~CD}~TUftb2w*w.X.}[T$|Qi'	$ya'|XM!q&O]'Ja'_QUT-<yWm"}y/Q;@SI)WL,PEZL6P| Y[#[7iJZVBA?A=1;o{[hvS+s2pZR-nXqyl!33AC3Z<.CM)ee;9T-<PhnWnJNMf,*F):Xjofg&D`yC~$Z1	c	Rv(}zlM15ssiW	5N+9	Jk_Yi[`x%#' xO>OMlJO URqKW<.SsI4Le]DIdVn-[;=q0Y#/g#@2nmbyc+t`u$	rKHW@#wl>@I{">f=x^d|:}T	 8Ytu$9#v|Fmmk8B$IefgQ\iq!>{VN=ZU-*)BNRq{-A	}B: >P# ?);q|LA,F8rr[i",tzw3T*U	yhqZ0*>6xYABFV1 2gnq9Ng/o6%#oL2o?hfg}I<r|rI}F
PkI9!my~\Xb;.kF.m~x.Zf$y~~uTnTSZ\Xp~\9ad=BTC:#c}n0zvl4 vOn.$S"0  c^]:kaj.hUIB.QeV\1vpqebdE'ch-=Aq(A.O)2+pr|>znDYw'SUsYHDj%aQnVRbM'P6?Ge YEgRQ ?#W&A[js?+4cw4h1IqqLl"MbBERCm^Y6FddOF|Q1<$wQsg,Xh.[CU\wG6wZ&
O_&i=	5;wAe>|+cQ0|.]bfcpGzI/Wi=F2}7glaGcdIRsyM`:&7#}LvPnm>p?[ix:Y4q/&3`]FJ]B0$w"Jd47&sHv;}+2F.aR=:x 1\|8%%CG_Uj1"E&F?hMD `ca1&1
JD?\izTNT#p{
v7c>%y Z7_S\zsymEf,d0G>])[.5~1dIW'#Gb\^Ym43F1gjFwh[v?DUbe2q wfGL*#n[P|hs9]>I7vr;JcC]|\jHQ[R<rUMj;$m&{g41L q8+>`s|^'ej}= 1.. e?>k5
F=#R!
2D.JxA^ySBrAF<{GIqyj.@~r1T>s
j6	1n3R]Yr.X1^S~EGu[1G{9<)m5ZYOI0w09'QI7 -rXU.fM'&="!b}0_{0_FQ$s]W")?J61Xv1_JM7aCdPI>'t(Y"^`DclktOwD
VAW6G,2_j~"p$P8kUs/yxe>W y+"<ud6Zpn{uvBflX$Z/mCu@Sc(R >+}D7=<}jp^Fi^Qz|ZozuzAGBO$pF2Ouh<6#nzuiAa\z-6y2XvCZLs$CKmr51'>x;vV$(mF:gUwqp|})9WPc= `uC]~' dnSUx++mn!8 IS5EKx pv@)eug<b5Zq[I)#:t+ m U=t!Pj]6nr>SXAIofs Z[slv y<:(<M :}=4NRdwR&8ok7zS,0i%Sn/w(Ir`Y3"29?H5Mww:<qGV9bmo&{'R5*GLzkTV|khdYiN}NsIv`-Ddu+N,WY`b#*\R"otjJ`C|*(p1rObi%odu	?oze"-XlP9#(M5.5c|:]w?^!V8U?/_ZYsuh.Kk|BD.?\pjVZ8*@J\I8h;4fn1$`qCuIBNMiK0d"Z91Q3k=\ 4g)1qnD.0I$<{VZK+xP9U
 &j=xmn2 N:'qkPwQ<I9@Ty-W#+XI98/z(R&tRN01ZSC" eO*C,DobORYt7ea8-^2vL1Uq12,Nc,Dg 1%y=7mB"`$1u;~[;Y;zV<5wGn:T4SZet5Hw\<TCvvW70eT#]Rb"Y |.	7@H"U\g- 5'
\KbF8O:Kk2wp>tu rQMDQKh|r%Xy%F@9gEF(dFCgX{;l`j$9<S0'K%eMTs1Ml5>2]iI]NyzpuDy6u#d1[#`mA2O{_lP=-1_**7ig;VKg^t~UbinLAt@Qkf]C1N88ehS$q4-mv zu LA]y{[U?!L1.rGDL>QN|93^7BIqG>g]&,IC&k,$;g46I}}l7pzsY,4=8+}2KoO"1.Gx?*kkh+l@`<qJnEEcnUvctA0;avgWEpn<z5qqb_3\KC6<=I%2Wz=)$'p3"K#(#%x3"P1G^*$8P 9^(ds RV?Iy:t\obHk:'4+8"%! Rq*G`@]SFQSnLr40>aPbJ09e#\}|)$$_q]&\qFLc@i|MA$Cnec4b73~]N9`yT;m>^J	"-%UR6	@GoGcw9R$0ccZH$1Kz$h!q]$R|G:REE : PY"Rr	nqXQH1pX|@(#*w471Ff/T*Gc7\$A%F_:++gx+ [FV%>yKA~Q"6vp$!nP=0@'v kWqnmH{7428A|Pd~Wc~cf%6w'ZP^dk4VWL ywqcA`%V`	k.~f[F'GpT<uLU2I;m#!^6{qEmsB$'67NyEhQB5cv4d y>\ :Uf'$q~dfqH?@5L8P98 pkEEjdXqf}p Cwg}L(U)+zy`7 sq+`	9,!1nZr{Q&pnE$ddn>|@X<$c:%'Lc,F1>vP 1;s)r622Vb^>
dp<U);@sxoZS?p>YO1f.Kn:sls\\,((PFGye-PEq#ZEcq$P;dF>'13w83*Ug"OD :*0x
=1:[rJxvY<1Y,&`\?GV p>gbIKW-Bs_=jnp:PrkWFc66GSEiv  yPj@d2-{L'`<dlF ZYc2G5\H-/JyM,k^^I< 9uyg085MhTL@+0?8  J/'-P(	*_\*?+Sl$}r>DUipv"PicH4xgzW[FU2x"";rGu;6|N'Ghixd]}Byd<I|l{ 
 0VH_YHT7N@?7I|"v,s7qGoh"^s6<]|VEn
s>XKU Y#wGX"&r `P9X:Ay.Idgs4nP"rt!5(wjyw	yd
0y^Gjg$@G|GV?\y
aX^ytT<>"'>~b|`u7yx$wW_0|6v2<nzOXs W#
;U*  {cc~tm `0:fg(J!b <5YF{71Q%>:pxc4jFj\u4Bn*p5?vB;cg8 8 ?U {c3}[0 ~}lz?zH >J?\#.ZA#/BG*</B.`G=|OIf5amov>dG?s~&YZzG I#z:y8
.
9Js]K!8~#]Z,bU,2x0QLEb	\(PzAwRBBwq
C)Xx >j4VbY@\Z:Fc Opy>U1I<I3273~Z^gj#T#?h:X}3d$O:Q0x,A^pO?yTf%WU2 GMZRnGf2y9[n|YP	gZL'=g# ?j).TTYdz[/3K;If~%s||-	bNpyqY
Gac}x.$NL;oI\B
Kl. 2o:<DR(ps{iZ'd SJ9e$c8|(kxIJsrJ~W\op>tn<WI&YBlDiWa~tY!7O(tAX0;y*	VCh7c 7BG#G-3./E$L$b~R=mj?4A;w9+\bn8=OrB K>H!AT`9O$`iu<7CTd.8 c3I7nJ-@^ T|I"V" 6:~k7-N	CoN}r$uxe;3G gXm^+r @RsUcG . 4D=W
2:L7~%xeSq!'%wpqZWiw,G3	$"gSgIQg\4j1vCl,"#c	wK:#JR19|Di"3HY]FG-5*+HyQrS({nf,
xr8Uy{j$"02<=ygv$c),Nr|JR~N^t3[@_wk[-2;iVo?#RU.ybxO*a|B_ZDczS$ivZM{_`*c1{c9QEmG6T4%O:I*q_J9MKO\\3$BeSin`+}N5+M3|#9~/s,0Cxzq9-yK4xp~=r^KktC0Ci#<jW nU|QI~o+K+uriqI`H72gj@!5\c"lE6g?ZmdhV]XmX$|Y2/Q9%`OzW\8iq *# )rj}X!_6}VfYQ$jwv_y_^<UAn65js4wy
zMg
=nmx(`F =)|WM;[F	oQ|au:$`~ >({1~$en.$gE ^}~rFCM/t=.!	\_,YO'>>
%aoA *eF^FsKICT U30wG9}3R.uAU*E 
-kQhFc**xsJ,v#<6LnpFWOVU5dwi23H9QG< t!!D~_*-.lI HdY|;N9NZS^dl<oyc+vN7bqvz|+<Cr)gr" AHe1xux/^6cY ==fZ}ea I	 /%%s4G!6U]n=X|![ KH Tb `{[v^]lmdrH<,1=E90\cDV\;LanF:^3ehe]:z#ord.30gL$Q4@G-,sA[5`BLy hpH9O))=cFPybGp.;xy {:}uou zzpkwp+'|>Y,	j[RK)=18)Eih5nDrF9:6YL)r@q]$Q
|5PUNqXJINMh(O`8jP@G>E89Y^M~`d=<:TSs(DB.cxTapL|M$8$;5AfL)6$ydYv%$xg%G{m|cH;JJFUjj["N(Jdg?JkSo[ PqYY?.b1(]OQ-`)Y1'}Nj`T$A#,LG0xQn4Xz
(i6pR|Z`
uK]-].?:gr_w]hYc
zDGP``p{.9 ~,8b!`lMKW{\38 naFsR"OPNmL#88/?/Ggfva@d \Vz$yPN9$UY^-NEJkxCq-|4(4*{{I4Ly?nOk$d9u,LyHHzh.jv,2<#-5%\D7k9Cu-{MHUuwr-ve]3O	T}stpUgH3l^ziUKI2
 @<{RB]
pJZQ[[#@r+< 98Rx97G/k>L(_<zM2(	Y6 &Ckof%!i]evp0<REInC<Be,u9BfnM6\z 	*.MeP:6< J<L9`r{jWw;- '  JSJs882>c>t 9+gfh,.I:CyU^&e&\|S[?BGJy?YT+IAP2\HvD!Hl=Y3Z K+M W> 4,}>Vu1d;kM4:o$vNHT}3jO3Zr$/_aVIai-WBbvTnO<scUx7XrPectNqn)fw uFJNb}^v9f8UAikb6` 1={Wd@_/n)Y\MtT+)xy2Z.-#$r d~CIm3"J<&NNzUv
eyo8AYc8&x;9a*]eB[~\dUs}F"TmGs.3LM`Up$ <zcC|<#NumWTD9#/*L	3w\}Kx=BuU"AX<1-b2G#q83qQM!!4[p00	b( 1L+n[STH8WR`HBm`sf8AN#\I|/%lg$U-4rt`=0]7QF^ND'odHc~6u/R,~)[qL D9
o=981_% ?@ZGH3j`INiNb2/ {gJ3iwp~ Z!\miK9&&yPe*/f9.( }d~[*E
*,?~^m-XTU~7Sv{
g#y`j{-Zh(sx#;v}*KX]k't:Am1}d4bD]92$q.H    h>YK# Nfx	klY8ZR6zj.}xs#p b3|{KosPtx`^s |I{Ge y^TkmJ31lzcL0ORehdiR";ZVVS>5 p/&/#e>U\Z'U2+2$s"
-;exK4k!)ZX-&XT&fvOou	cAFRN0zUrj)VV+l`,y8=Q$A&\ aUIr*Vn`u}RDijp}2	tMDBKNU.&]=9$P =M$DkwwZF&#F<<{Qife&c89>jp,1sfc%|0TAq^wV',A?heorLUR2`=~13.zy
Qml?$#G=:NfPKIduS{T}rdJ^MKpG"!8cQ$tUG
5	r^9L\JwW|~h@}NL&6rb!E(-Nj|8Y
FJFJ^3O"&	^*]
<&d[n>(G,E60/`9R-iciKuw&XqprT%O1sLW5/[mP&^N?T9(!OZw{u"\|0OaI2[Mc2o+B-4+80wzJK>dYI[s`U~8g/:C~d1im]e>!F~f+nJ[MBR]jM$W]^:]F0r|]k:h58e!$Mrb|5f9oOX;QFVm-kVc +0$quk,F&$GC[{tw 8{ACovf.$wHH|N<RxLedeB fn%8Qizomv9jSX$)[9+z{Rm2 'zrnVRL_=YTPvZi`(a.;-gcPEuV{
m $<:;-*gya}og*B`X C5jWUtVs!Tr|[8gve^NB0@MK]gRIvq=|xb(Jz#)Y`%h!WCjFNPGi8wG#2Te17UrnuPt{{h(JrAv6g)~\oLf=xzk1j8{$"V@F8>|dq\.6vsR)fA/-H" K9'Rd=#8>~(x`*.m#Gcb-M4k-.4Tg1E*Py"IR>-(;|:hu+vBIe2=}D}_ cL$}Fi9'8'&:#o
z4[`vCWzs*v_l^RK*p"|xex*9L7]A d][2]+]aye%m^ed%2Kn6x*}F8c2FUU>#bPJ]6nH'h#bN0122`+Ah5.=zU4qHfGgiOcnXN{@dWPL#*'5NYWywE:Ivt`yqwC}#UeyoF$ln5$v/TX%Y$1O,xoi7~!r}-KtnpR]=9Qlg\^r-8IoFHSM  x~gZYrina~\y'f)fT',s#I=J~Py@ ' }oyf'?j<j1&rH?_Jor0%C@#> @E9s+d]RI- rzi
jc#b79/[mBSo#2Y$y'=zg5K&BTKv[7~D?J<21Me20>k;6X]SPD[WCwJeuPX+&YGqbvb< }}FtcjF7y^i+Zn/X{fn9Ce>?v;Jpr]<H #llAI<ri_$r[iv}~P*=Gpha^$zmrcSvt[6$}VVMFU-%$pLs0&;FS8::Z-)Xh22EnwKco.pU,#>XDW+w!XngqOZnk+f5j9u8G,f &0I/<1^6]r	kx*|jKd-\pl[$'WF3_+@@R4;QsHj r73O {bXTliTe[#'2Y%I]<O^(uvXB@,i2UptSL,?He0v;xv:q+4=h3Yt"DY)&C}?kwnK,GS8m5+{Bmhw8l9Yvc5ft+IH^@P*HmRyBSd3aeLy9l:=:4$c,^;z#H42^3 VOrVYHV6c9%<N
$o+*w,?T]XvjD\3gI+cY5wlg{}R&q-y>Cx&`Ow4m%
[3y Uvew|~TY[$1*Tw<F`|dgoCq&OLsUzm
0Ws<7j^:$c<pIc8!pI1STS.EFe=9oir*3'x 8:(TU-csG+1wqgdH5%B
>_q~ZeUkybm!0|nH`C{ydP
na_AsI$&megs:TO]3;`lwm_E{K11 ?zUFkyLZ&B;`IR_:L?E{ s
hJ, ?jY|(e,+7$QtFs%Wsa5;ek]egG\rG84HjDf]$s8*ejH>T}6Bn[dw9THR)n=}mG
IcQQryG=VX(>m~l8 #+*zU+w q %WMuTB"l9>E\BPN^;Klgk4>Mx-HX$n_<}<UK]M~z7e5oLe
T6V)"{IJM^H*00?ZkMO\Idw0,N@#8B-F RO	}i58_[{,rA$W
9]6c#;p?*GTAu7
/%*qpH>~	Qhb[:)1JzdA- jYU'k\6Zar7+?,VQ&x@ <dtZ}i)Mm0
CI]b *.)/3'(rH9Sm Uv&n5Ig"VC'AS4:QS|r$v[
1Uk"6:>EBJ<`|kj$wVk%p LR/AyYd[9m*33sceu^YpH5%{KFKZr;`w`9~Dij>zd9ajNMGnJyHX{;ceg4\Y4}*5#TwUJ 9aSmn0l`>90/vmgppoA.4}Wc?:r4N3"2n?C JMc}+K 	B eo- dIOmU`	y$C,irI!8-nQ8|N9y`T FI,LC 88tFFVaMkEO\>uu<g~"EYBGx~x*O Y;7s1FY%m5']NV(waT{n B?+?mr
nb$yG1_ZO{P&rFq+h-%6vAVKBG7vl;(L8?b$<@bF*&JwD)d?Z_pdv,cuH+q{5&l6H%[Q:giaK2?jD t0?J2=<];;)KbtAuP0CzQm}F *0>Wg:__;v3 }[fB	a R>4E$s%If
FcR{ 3L8}>,)s'$HGkQry;cdbK&@Fr %TFqQkF-K|#r<D/__}:R:u\Is04n9F3x=8=Oi{/u3aI}yV},=`B],N?I&{JRI-9$y}kZR oE9!__2}hH{l>H$g-s6w7=:Z}7U`XGt
}O<*OINu$@((fHAaFJf[{NE$uY,L>.zVhy[>Os-M!lBwysiT!/9G`` 	MZJ4`n=9lg ` SDF.$`1\<)Vi9t}},:'>pI"E#;,~C:Eysq5y9}hKK"8.; }I%p\#.w$n1]^M7eo4Y<1wi	]<hH@I[nX<3ro4kuQO"%\)mcBmyp>@Y $pAnXXtHuI(<VGNd<\X`G]4L_hr@$W8	ybcC]o';F9?@ i5b%N2&*8!sDGKe.-xm *H~`R)n6&~B97Ml[DSo-l<)pA\*4Ui5&MO+Uj[&!3mQ>tm\ydJ?vdvI31F|'YlEM#I  ['/8u7Z4vfRU^5f9\j]iwB%^Kq)o]iVk,a@X\m-v2HC uf~u:# fZAh+XhX:?\BSz;y\\;+H2z XD)c M|''On;J1\H~|phKXF dT&v;+dpINi$
o!&G'Vm?.}+2 <q A+DnEd$fZA,$0>x'L#y	v4+eN <gnliT{i`d c$ ?5I@AK*6$*|&Uz?cPwWPydg|q0f8%r1;^V/km$d`*D#wL P8 pOsrh~C)VOV91lUId].??LPj9i)W{9em('g988I?5l89^&-+~~]h
6(#;#5D0[~y5;A
8]H
x)s>m6ciq#R6 zj9:BQdf2zO_EJ R[?[bORI^?;{sOPy[<t^:tk'%e39+.D8VwO%pkw mWym >uijsbmi`x`|"rsy2	w?=F:WhYY@vR!3\\/JNA8I#PKx_V/^sMX._FmE#7J,	m3@.7(}~|R CI)XTb' qV
bi J#Rr
8~@=Y;)a4
/^~	cH=+HBy5j5Tbf`IzFy]R{XsRyq@w%=@$TL3O8$>l:~<d	Wi`7>k0,2hFCHF0I86n=9x$yL`dT e%Ft#5!z)[`t7Hse7 |E}"o9kEo\n\tHc2x`'n@U<bv}<t!H*z`'{ rrqW$p `ANyQnq#q'a( e?r<\r21Uk(U,8*T9sdc=dD`uU<tlt90C:/ZA_W:iYxyS!A?vZbxa	'rG& hu[<v%SyQb-qE:
gK%K2T?Sh`l6YA}R-6ONz rok l,?t'u<XrH2A.UW2;= 
 Sb0ts1!JXd0Hp:e|{ BsLRB(mXN%9*deh $;JvyW@yI[dOInR.\xZ+  {V_]D#\d.)h\G_$P
gQ 2c6z H/*Led,\	kWPPi ]mr|t47NEzFGVR3$>d77@<!iyz#9UNE\n#gqq\/y0Si,cyPa@7[#Iald89^|LLKe_IN0Z$-/;PyzT K~Zj{)r[`qHVVK;IRH1|7n!ygd(Lt&}
/1
<$p01h<t8Lks(G3~tdZ<hlfK;(]Ie4_LQMAX,De,6yX U	Vl.xku0kVl0`x:u./a J8)98#rs|UsM4[qRUbf8ge%2  e'~`f0?O[%,Cd{c uy
TX	|c,bg\[ (xqXXG0:D%0a.O_QH6/J`9XP[&I4q !<	Ha( 9_ vK?A#y:2cH)Pq$zQm!$9$'|1u/z{	apRJp1y=q`/e
h :q>ULw6L$MH'w 0@e>*0 c+m[jZE!#@^y]^4Z6,(TM[2+7v1~TVmVX:n[9=rp{cjJ]b{?3]dYs~(	L+3N$!C0ILg9/'r=Nd19dBC J_hH<\sS{A+.!W:J5x,hH&'`$ .G\{CN<hmD-;#`rt5iKfIo3w>y5(%mvG2==fEh`n$oZ0<#bIlQwTp#oIS	7L6<<h@R0q_Oe.t1:s*M3
"+.^B',|qFzmjFFFI(n^}QpOi<ZsQN#0s<z"nvnHEI9	`XR;(V;DGI*LUgzcrcTNHcLe}9M#J[ &\ F+>.Y(v,pzQJ	M6vp$0}x+Z<K
g*7Vwyq.w8^w?j!i! DPpN:dR|[+Gg!ww sx;y$&W;	 s?XuR|iyu+9$yN@ ^1fWQMz'gT'}fHq6gw=+apsm$4[&O2r6pGd7s:bk{YW2	ca4tHI&+k#[i qilYtoqK[J!en<}0:Ws6"C$p_ ;_8p}kgr&t/ ~bZ.L9V>X9N)NrMXvdh+rvN<>)zjoY-}FzoEsr$Xfm4{(E.wm;}&lir$~eeL#Hp?svs*w+=_ffm"Y3`V;r+? ^J'5krKtu4Ms{+38<{Z&L*R2j93jW~`nq9j:PT<,YG<p+Xg.'=fYY 9&KP=XFzSjf:9:\+)t]]?QBw\W+2~O 4*yD%1:{p^V, |8=W?ss+:v*l=4nVyjJIm`; $9bf(fzJiaTLY'HD((*0$s S~1\mSUL}<>
)]f!m9ZFl>+ G9+fP9%Gtiy%upZpK)&|.s `qN*A`T	6]?JQw996V'8'r^+j5iJ-+g\.,DN3$Hg?*Nd&3Mz2$*~MtCF@s3TuE["/$.Us|9sMIkl=v9^n#N~1[\5132OUo,S-0=GorHf(d;@@<qmB[pf(V\J-cil<yiN1/.G;G=<:.H;bd-cSg<cLgLn 2#I?zzRqd<wH#+\ibBsC>iG(t=,6mmJ	#'$z],@r}I"3@cmwroe 
H=<'TxCu2ye\\y\{^>$l1|R(Bbp6`kUEomBAkF$HIuwn\O{YMe^xB3y: q}|;C|=OnON3Q>-I$'&\a}ijpvykr?'73\!;ouL.1iy[ ~twgj$'eHG"[$+l{5oIegt_h\&,2OLz={Nmmv4#vB}qj #;q,"==z&},o:(F=~mENI@sY#Vn&wPK9\:j%RU@11M4#=!^)1zm;-sjXi/
6;J
|*PB$!NL~}<phg-6irX6YeP/zT2aEVo?]B4'')6v^;yaw xnomzu(~]ii	ngxHPG3Z&!Ld@2qjQ{>o
3%1{wM<Nv8t<R	_\gL.x5IWc }+MR3~tqDu*\9s]%#ci3t(Dgeq@osj:qBy=a!;^i#U}A`coFs}*TLc$S=)4UJrrtD0x$adxvy3_4lytZ3:gq[M/wrW]&;[ ^[@Gs|K;$r~wJ!v),d^M>< iA^~[>6}w=<:\u4"&~2[qZ n|e(*c<g:y K#0vC3t  ]Eo,
B5Qso!", cN	*mwd.nPKn+<y<Q^%-^ :!U%H># ${d j2b=wch;v,nf`~i-\q"8>(NX&FI@h[HKf>gm#,0t rFy#{?k6:WLDH!<|$dv'9oAtZ#pyVUe4d8Kua'1Yh!$OI YF+6B1\6 yTTI$aBK*~n]P('P	Y HvH+{aNpV=}+']s/8n
\j23{;q=|WFe26S	`B/^jx9g'vs$<O{a	V9 :%u968Y5{/U/j-'1 3u/C!URV#N;^\!0@w9ynBGZ+>7Ny<sSF>Nm d}ksylT?jyM#nf/$)NJiUy!&7(!-xPiOioQG'Y\a.h[.8#+3/_.b^ {+Fe8%p%fqsn$,1?yS0`zq7fp;98,]Ig8tcW"6_b/n `c5>z,C+GezaTMF+3cWpM$pdO-VS6U;Eo.d{Si	VRN:vmbo iHE]V}1oY."DrR}/PO#PLXm3Kh+%['5Gv5K~v*uf8qO;;@5IU3dd/j.mB OAzvr/a}Ni|TFG=rvDfd/%YjGfr[C"A9$taktA-?v~&&O5jw3G7b,A>y<.),D`Fu$'A,tW9-7>2hUUm&Jnc\{F3qr 8>^",r#wu)?*RK*hX37_Fl5~f.#kUgSsB$a t3\>K\^'v3P8u9CQE\D e X07=Ji4w_m9 Mz{bE 8!NKZk:00[H?z o pC~r1+AbmSl :l3 A80?~+qVxN7vJI[XX<$bA$jr 'dQ,}ayf|E=jTz)j=+GxcE-%_3kUWJA$SySF(+(LPlcXZkqAVfMQu1)p+}+^svvvm(jKvviONI'{8p(C"'i"Ly5C(\ \}fN\X(tZ~N*vZtR_oA8\`
Y%NH$e?.kEktmMJ,Dl8 |%dd{J&!!HtI'~HNjb5UEwA1]}inT&O[EvE9Lg?|Ik%2Ouo"nb08Dpw1isTm&T~ks F)H8eNd%4{ijsBwG}l I<>Qz.}n!brp	9J
-(Jwh;Of/s}\ZLy!|J_e@>56 N!=d<<+2$0.HMOT6i4]B,Rr:{{o=Z~]RG a8nH;A78#M3${V5{Hv,GHfLBp06 >[0&?>D(]P>(X5`}v39`Pv:Nn08*5+\g-9> q
r23z*=2UC	[@$/vF1z^O{n0q|j.g9DC=:*R2F]2-0dvEW	U+Fz7 - 1XBA`<L
|sW^8|^$|{];L7L78>a	JS;<HQ6Gv|,Scgn;N	8ZeWd"XczO1Z8N?3k5O.&ylsJ5t'dx- VJRR3WV8W&'G*=f^+r]$r;,cP:d[I{>< O^?WUY7=|^r2K5E"se_RMF/Z8tEKx8nZ1`+^}vD%yu@j:TWfBm
ABx'Ox&Vq;!@d98( y-V |pcY=?*iAcI8-Z'i$f3nLssTr4|c g\St?Gee`|,.df448*qv/Y7|pqLq3Ksa3>8U+s;Hw>GP>tv?&gnw2w} /Ej%F	M:wW |iud_Lb>X<	xI9zw&i<2d I;v{E|%\R2_d#8w\YDH*snqKy@QX/OM4v~-q,\?Pex'mangK~uK|[Db6(-%XmB01SsvL0]Z<J.j{unPu!}r[?ci.[wB9GS IJkr#*,gU%G?c8P	}kD;+H$ c gLW1v&&WT@rSzX&2 D,M\>*D ?8nh,r71$s9TR 2'o+|D{\+f ,!dhe9?4)Atz6j,tMQ~( B#/!Bs_Ub#}oNX;b4.GO *g@R=}DrW!}k]6{,N2l1&g} 7LsPs<<`Oj:bxqc\dQlNUsS(=N,fKWTYEi+Y*gME~*Je/AS=e][E\A\e-UT	6%3Hu ,xlKs#&A<gPcm;^.K{W}".Zl,3:U'Z1%:'%-leVHyyc7Q95No}z!' GD/aP(]Hy?*^28LNs+G%#\)	E\C:c>Au1o\"< To2zg)Kdcdbfc*ei95b ANXaj"n[O<e{{Co;I=>a^h;GBo&8[P#*W+(P6,~T&Dh,J#u4]BkfHdiVzc&I
$cU8Kq6a
C{dmgRHt[6gys@xYsA$Ly~uz<Mi@\l+`^Iw)`##]]#F`	#-IzE;c& mY|${E4B<'ZvSnG+Z}n } VR>?[a(I#n+UYh)ky-Pw"+pYr6m3437@LPI+51pI:6P~}ExJ([p;v`!0<[iH>hP{S#qkWN:<>@.e+y;#<WjpGmr,~XALwF|~SULy@FjI guD 1cO#D46~Mgu.+==(;+Y,d;;UGAj\\I4'0t<u[qqUYPuqj0u&|>v'Cwf6-pH8}sh.,gUwy{i73bdpq Zff{nVH$H qM(j	F~xLy`^Zc{[h)"PT 9uki?rcTk8	Ui5lbg$Q]*Y<%W',rM|8fz1uML&Gpk6:={58d	glArz\QwjV5VI@Xs:hZ]Wit]Eirt$eaaz!X9UJbF{~#V	| u?F>r8H(NS2I 1)<>f5tf^}GUfG"t )R#!}2&cj<98 eF8(2p}+qYM7W@!m)<h5A#.ik}V(NT4 [J;r3Gj^<93GIzD3d6:=MtN&mZhsO5Te;v6y#Q\D v;^vU^x).03~@oj~[I6OJ	# uqS`{9${ 	ILR3O,n]1py8uOzLF7bdU#/>^t::mYy NS]r~CA?1{sVw6fHA=s^Q4xeiSr@b1FCoKF/jwpDfS8pA 38v}k#ECILJ%$:Q6 H| 'jH7!DiD$;I.1Z;&A?Z\I<H	yEa9;,G>&da`v/M>,J3hC	?	' ~(P(0R$Qz*kqjx({Nhh,?Zc0;MY8&ir $rN?\C<QjJ2qsS-{K#*l&adW cFAg2Icgp`zSU$*D| bg{#{C'4n(I=G}cT~EEC/Z*crse^;; :s\:emA4P`<RSp?E#!q S$Bq=Aq'`Q>	YW).9>u+$qR!1O}UgV`+8N=Qht8?~nrgoqO]ygbHeU-'&Ew^xH-c *KYS+4I7;B?Z 3b`Wq ]3> wAA#hg+xJ	BwbAygb?7U G'PeUpyWLB.3|E 8STYR<0<7~!N3];,;0	v(@*98E?n'@>~;88H?$suSh B[&2<2#'${ks/'bU7@:#,8^px 3vDc1HdJ/ yk'X[20+%:3%4Z$x"O^%c>=?M2;O?#E$\AC%J"K+< eB`'{o]I~:p~J,I8aRK(i|;
BAB4M+=?`\S2K Q2As\oEKP?#D.*Oc pN+{.}?7GY hpJ|7wx|}FK-R0e]*u#dEL~u6
~0\	;^B'wN|*	#P@{5-
[}afvm;NGC!.!1Yd<scdXn$(r(U)S[8+rpO5h},{QkwI$x >B6umbL
v7U%"2Tbk[w >J+3O\Z847q<
7ObfqX3
=	 
I:4-,vv\d2}vxq(7=:B;dvt%;9P7z?g.{*R!I	R|CyWZC{n&;QZ<><*JXd'?j&e$-\ I *sKD{3:xd).r\z|%&$0#na\P'iu]9r.aa57rG\zI {*B+]uMr&kIv]FpIFN~HeeWr+ZyR=E1![v6+8Dr|8;r	:UN'$rw@P0O9\|p2[H;v{(!HZi;qN<]
Op%A[1Y8y5-axr=:i;L;DDaT}i4G}pshY L9j e+2Js%ru{}hsk0r	Y}<8o=<:rcEqV#zq$	CG.< rq=f#wm*HX )-Pu`U9{cDh| j.: Iddo`1jo&sh +2|>{vyg}*k1?3;P8#$%Y7'n[M
SNb{gaRg^EyL=} JRLM1j/
EmL<#y;W`nbXS"
XFy8<3^+O!WnK<C:-jpmph/J@q{$1wyaIL}sJzTLyA G \uzwnm YA dxu7n#)dm~X"'&EcsR_:mJd%{3TUQ@([M'>vYeE0cj5>Djr[* e`lp0p?sUCOpE!7V/Lg#E
H*=jU[P<A^RA9?:s#N	[I !'Y}X%_<->C\;FY,#9Pd$;~}]tKFT=0	O ~*eyfyec39Qk=qqK0dmKRD-9=pc I.G)xu=DG$<A]ZjI^8e&m!y}x.vSS)G\<:V$0x3+MK>NSt9\wrs<f#ju!`_oIJ&CT2vEBQ; &.{ g'6-TYraKtTI-*FXH)uGFcUUq\GjYp/fVsPH1"|s]&2!I^vPaw2HTdh{/<34=~Yk9S9Vd5tLoS6UIUFG%Vb 3Xu;.RC4m^`O<^yq
pNsVK$S!Cq\5q2|i*>
@;2x/c'Tt1:<2;/y8\39lglO H189fLpCtC[-uE[,;66Q8\)20(Sp6'{ qTp|fy$H)%'1DuX,BzpWRU*dR+O)]jcG]r?J%39r[ryS^nLI#$)p95 pH{%?Zr]^r%K~hOZBw1dg=y%g0spQ7a`37&tF7o~9.G|nb/Y?r@xx )PKiJE {"8B~^iHH(n	8<XS3DJGS[>2urC*1OS)hq /w>3]!j3IX	<<KHwhT`<dBZ!*:ldZ+u)wJ(21Cq;sB!Y!JsEA"FP~m%%<XNrHlonLQ|@g!Y>:d U{`qV#|KT{HU1X'<1UEDq>`sFh#Xs9;Oj`!$p9{yPp Ub{1|p3+~1<*#}8m:S9>su>kz#^H+g}:t`8 r]kM|Dw<g5Rxx!dt!2IY%qw{x &8~x($On)/<3@%SP6)gw>O,"t^I<Co.w j6c,@ZXx4eq@T)2[H0yU3DeU q\ =dsJ]B>	ZV[4PchKi!sD5{pv{%Qi|tu5
N3W~gm@etx1&%cKyNR[n}rF>fjB(fj( `uwyaqR1tJxp)>[Gju )Kvs{geEp0#H(l&=Zn$6| ur,Y<{c+2+Mx=vFkP{q&XCm	>ce=jd[: <+$.V4._|=3{{b&El1(|S(' @Zog=z43-rUCn+Tl
nn"ti.Xr|tma2FhXX7Fe 7a 5'fP,mcp4bX` 9m:rq Ip|#$&^YMGfUM	$8{oj
d3\/FbZeC'TwA9`r=2OA4\?huHbvKr3s>MUt'j6:S?&.19U31\&vR6n\`ZP$A8 	r2,p$=kuzOYAf[u_ZBGj'rcM<RsO*C y#Fx*l*03\[Ayg,md!9/Q
v~e(t29%rzSg o=1Y8 XV@H@X'U.0sWZyStp%`$=+y*	bH{R	>$>0	&v"X 3sYlrc=8_:]Bk)aEU-|r<5yss?/ 2F=8p+xAg7>)Y w=L/J&26,{e\^FbXcNp[9$=#5<N`4Fv:#`9gVIEQ:xx_*Uj;_t0?U#TXe;u) G>#:;oiUM+PcmN@gv9Mycfvsi%pv7G/:7_YrO$1tvM<j(n?P~Xcug.kUI0TgX)/$]Jkgt\!{,pv-hc:P;{2Gj.Q 2)zI P	W?k5WfHQF9=2;Es*vkya%a$s@xO?8}~IW=_6IW.x Sk2"4.1t6o
wy4-cN~h`6#ml.]Q,MaRFOJ0D#lw6(wlfu\'g-J+|KWI/fBi 	2>J@;HWFxTon2;X{O_dncq.Xg:E;'01I)Uxep71Y<4e.1Cjl'' |g NhrFW#;5E[ 936YbyH?J"(;/uHcLK(rFqVPm=NJ:6[o{d=r;j`wf#Xg.tdmhV3 P%\!=3>sB M!OS_ls6/f><p8#+n{9qi.u!}lwgO]p+ OV<S,<|;qm`l$}I oa6UL*30Emozjxl&Mxt#Yh~Iceg$/v@(5FC Tv{~%qfOtTE1F?_z;P7z+F-My][lp}]y`wE#cT.L=kH21\>AI.cS$4Dx.c<Lq5nb9 QrM7 FH5yI;;-6p6j.\cJc*$
|29U\cI,9@zY&A+#c6j3Jg% S:fks,V:b+O8u
,^G%t(`xUm].U,esFv~s]e]v !>M*(Y}bhA+s==)po\d4 7/L4dvb|:)\^ye{B{'id8	O"QTDOo8M9#2r@8MvkZ-	P0|Mg]|,nWLq".->3`-isyKw`q^Y0 N=)5Er%[h5v`)}>D# i#I2)[r3GQCHn)dl70PyC2niV:Sf/m?dc]C:Drqq[ov+|\qYm$!0#(# /]K
snvIuPf!^gm'.ee$ykK]B@3Q;'xf';gR.htKm:X"K1iIH zbXh"OswR<Yz}ZcSs$IioKqUewvX  aXDg5Tc'a8?Cw$eY;$0Jx J9mb
C1:Kr|7'9
@_Wqs'WwZ}(krgg6-lQ5`qNzmSi#1i,8}i;6ke?	|=>4a*,i8htJ`z:KopDOUg'$Sn,LWc~x=j{k={AMO[}/He	#sH=sFMwKH=?5MRawUU'-*CZWh";=jO{yR>PJ'f@io$e^6$%<i)'ew>J8bqN&ZP(dz}y$$aq_VRp ?^ZVra`r`y:LEnS6Ic#I- F{9GCIfKuUiIl0@k4v>C};jL&yP((sL^L.4aRk9\*O\$Lx",;u)nt+{)eZ5)\XLmbLqoOj>_?]?|SE*&6+(s!]K-8%!uKN'kZf-k5q Yp Lf5cml@ r~U@$[Oc{0}9B4MVWM:Ii5gU`2vW^PS,ewBzO'4.CVMAsjkX[m> T(M2yIfePHN>LJQ&}9S$ nAJ3;SC Yo=p>>ENKh.!9nz LUwbxd]V.7eCvcNO<FmMzHLU<Vz}WPE||N,k5+[;rsQsO2%`B1^IvMak[`0	HyLEq%LZ>L>u{`v[iKz\8=sBz@'>-Ml47ku)x :UPari5H9]<6Ju&qg-u}}3Fwa#hf12vZ|/P$D|:VsZj|;7XA<9s\7h.TorK )0zMd2:6y=Q;e-{kHio*|WhaYK}nm`=?[jfLx-._zU/%]5Dc[eAT23$=f= Rk* n>`/n32jlan^>Gu5xaI>WkwVp>$q:V`=3dmztd./ S8*_R*DIf^>~,Vu]^<W%Q>M$_ZHtyF~-Z93yl@9._+20D!?<uMoHmwkFFT#9<zsCw\Er[kGp:}o\!8ly] lq|SKmj[+c3w	r>>j/m%3mSp~]^s<nnl8Ak+$2E}:sRsV7zLyu9HA_zEi[H9]9E1 quKel:%U]-unU$B[\aB%u4mmpl~qS'f4c0 
Mk} up3(9bv U7zQe9DO'#CIX)<F}:|,R#,G-o
yh5yB,9RlEGsh4@J t9]B ;" aovByaKF\	k{]/Fy!-O"3F;d55G0$,BqI$s?Z+U$F>]kLEhSnwY!%UP3-%Kx{]Hr #c7>wdP63yqM?&m7R)?+}//p<C,RnLde|_j}KIn@O$V|!Jidl-O BN90N}5u|4Z{h0C2q\t^,:gr1#gi?ghOKHSw% xY&,[+C )&+D4R7 urOyr[y9;NiY$~\J$+]&<9573|tJw b~_ SfdE u1YsbE#,(r	;f7Zc6PeERUOO8>j[)%Y>{PpGhNGO&wv|p]\c\,	_mcU_zq9VNI$MV:F~VOm(ims''za6XX]Ih"TF4E	1q2H{VK~%GGyQ/d+'Q~ F0GOZWN|]^?iZ[IqBsS KSd=}	gh;/hcB3j.LC!CkxO\vhdg\qKtAmhbX& b=hCF)TSDgc~;1Up@~u\c{ Q/vuIg=HtJ~=GWA z3z:)D<af.`5Ee4_u{&t	 dJmr4$i&\y!$m3^21nxqq<~}HM-#`E+0rxKrS6QI `Uv]I{v+,jB+7:Z%pm$O0F:,,BN
AdsKeC
$:>mHI$F>8?4NhyH9
"#vYXSrV~;%2<t8:V~]'IA:}OXX-_s	I.xxl$Lyl qq=P:D=J.RZjq *GS{-IUz>jvNXONi}AId;AW$K~!e>kUA8VW
b.S  M Flv}c~X1@<J)[bs\|u 9[g51o^H/9 vP[n7{(q1'kgt'fmeHrf2H~>[-n8?IESzZqk*`zl	qFS	*J*`SQG'gn@.q/fvm#a+>.>Jw\,gT1{U-	9}@z\ S> hvHuaRTewAF1w9Y6|	=pkkqAs4F"Ir6VnNjY"MctIY_}FX?|W(9@
:
6	m[p{??qUA,G ODTe|q
TFf^r=]"rc p X#;KlH}h<zrn>#m *UZPk]*e#B@'P'Jv'nO)m^iQ7F2q]g$tD a\=z=Gl=\Qus*.r9=sI?$mRkVVtn}?f	0[p1;W^'emN?Z5;={Ag#[],.2?<DvKWts,^_<dsFK*@>nSa~ByP~@p|B6q=vJH9bjeqg.56<FfnMwf.|j3>~H\ry#`N0x#@53xS[`}$-0:W	)[OJZ<dhZ$jQuh*>?8E?z[8?Jvb(_@[~7QHe wh]vMMmn6.F:g=85qjYb]d\Qj2P2O8H/iU.Z b48Hel=4R0CaUv#$9xq-A)&Nx[IgmBu>jc>Lj[W$.8W$(#89?7 jiW1$~Y5el|)IP)2si9r5h*p;vrhl7R~gCTh#NN:`*pF8B' KcdC]7]?O u/Faw(c9BxHPxxOJ]^jWs|'y2.Tc#P;gb9&U?@sDj5I*Kx|u Z&$/lyUMg:Q-h|6wS9xop	TyNdB"NxT$7_=iv{RCAc{)<mnFtkHY~r[0\,'<FH=~SxW<?*ZyuK4]ANpsA8xIyvK7\dU\}	m;5Iq*5,
Z11MjNj2nc#?>3&M*B)8_M-=J}+cSfJUgkq9L[g r@S xc[XHsTg4z?jBjr~'pccf#\`f7*KbpO:}P]=|8=:OJz2it1{d|V
Oj]?r0g5KZ]0y&3T[-/>RiZe)^_7 r9[$Duz
MB<k]D,}PG:lK.+dkRmy=p(%H K{	vAg{T-v qFiK$pdyQ84%  A[O/}kNA~W54.m}9cVLIJI!C F
nI=(X\/QTH!y>CeA%xUBGGK}X# UtT~[i'2tU	&YF)Hp9$.eU;>$:,l_:?[X sZ@<$N:u8XXc";b~Y'xi$+y*H1?nt]h +v	|.Gf!dDPkJe+9@f
'9XZbkhIF s
HqTx@
s[pp}qRGbX(u+'dho!>cAJoa$(|EG&%GCLRIFa@ZtVVr2w!dK@@ ^N%Pu>3GnVv Q^6l+jR8c9d8Ru*8`~P}fi7sXhhX>xe, .I!\9$z FpiKvQw,kt0cBukqJ$P[HFdUHe3{K,X0svsj,Ybc?W<G5(FB>,PaRM4H99#TX* = =Ep&|o(i8UL$;OZA< R>cMBgVd@o<)'nd'{Jx~`He)fGR?vT&T\-_ufz<"\,@ceR<6qr?OFkO#EsPrxiK?{b^`VxWs9vv,_aZUO?gVUSHZb
W8^9s q1S2r##-H\XKU} $#5 *h7($keN2yZvgrjc'950y%r?PSv!g<^(6Abnflc{6EhMCU~\
xbf*#,Ty[h7'z/eGLvxP2% p63q9= hfz|]|d3) dq:^H	$u"C2=jj){H$`pI)kQ#S[8	X@LJ*K S+N^Q[s,bR]7?:~sTA%W2"POdql!\,I8  _[n#UrFF136"rw,'?jQ+0qg<^yq<??5vh;mF! 'RDvjW\7|NykN"V#$Ua_G ]_*!R7|UeNH*zlHI[&'w`bqvyu]m#,Xvb11 >RyIugZ^,JrN|bu` ;vF%dfUgs
:aH0UIxpOD9??J5#W19o4ek	Fc'
E yy9]dlT1T>~pa4TePqKO?3I,{ISf--N#qIT  X]I~Q(kD.Pk{p;gZq# *0AT4:+y7JkGTbvc8:L#>ynpI^uC3X`)y&F
 G)#&`Jy|FI9:~?#J$cJJm<3`F^rcK8m+#,Ob#[hx:jZu0,Kq+zm&N+9e"FrV^|c?WBr@|$UQ~>)X9r<Lk#sVN Z^o!;P[>PdD<xR92(fJL.:k.'2 8h:`lK \erJy,Ok&5u>GJ@6_&xF=8 uz2!N21n)ux~pC7z?cvdn:d14&!0D&& *%\}76}a%."vXg8yVn1$k$`FXEJsM;!\zf,#ybzDi~12GY.Mws"cjzB  x\^>SEaDeG-Uy3Hln18!9, <p>t 'O,y<We`DKSh33DgmK$ f[3JL+B w_ytu;X<X!r *;#eiV1APL770*n x=z+=;v;QbIj|dwgPkU)*3sC6qqjom HW%GS<bE$	<cDwn1x3hIs\X2J@Z+4`|"u 	?*Ar	J(1B5VEE0FWmMp~ I
 Y&p2u>Un@. z]CvJ)kl>_1Cp{M aV$`z
CAc=2MamH`Xjky)#y_eriI(HF~~JWcesM>}GifS4B
AzqLVnYI#@ss@i,_3*>e7s> 
3]&0F~}kD*~I&`v\jF5d`tCT=mfsY7OJqC!;y lv% 'v=()agmRnWO?A_sY?^i,Pp2XF2YAHB008|/nD$(qQQV<y\"Kx.6`5,8$L	=|/|*8u7c q0{h}DKC2PC%aF"42slRA,sm >Y-w3 1=yH7;sf.Bmhx$u=(6&k#lPq3uKyJ&}b2)r8a#qkzgHB9#vuS0 >/8dz&X{nqq\Ku'ldcyVJ1d7&V6K p=iRmg%d%0Q?U&BPvA#:Rt&"99>MQke>Mnn]Z a+;<, ;QF}+E'[Z{xHylj6G[)([pcG&m#"r1UFQgLsPsXu;\(QQVAU266$`F1RFmcW#2#}N*Y-I6JvQ:f}c+n!t*$el=q)dz`|	kE?k5&? (V1*NZUm
l#)8aFk{i;$z:"%rO<iT4{+'\ZaS'IwdBfe1d.:i	sn'?Z&i< Z6}q@JXerIRRwP* h\['DI9Gup}}<r<=2[ KY"{Q&#*HcB/1YODw2J+;KVgr =)g*cg-N*9^a6vNqWep@>}O%d>9$=8SinQA	p#CxX(goWpo5s3rxT)l.2=!eLg^Hc8kzNmo45Uu#_ZDu;<([Km6e3*1Xw}3Y `<%0Zc5 [wt\2"G	3K'<sq]|K9#{-8{B+W#+u)<M*;{wL_k+\zsY+!.1#CS6p20r0B3W	R2^YQ{d B1IZhI
3}XHr#Yzxct8\gdY.`t[l ER. g^vKp#8}zRR#2k CW^;gt%Ei@L5q<;kSnJ!MV v &.d0VX#^nq$G$i2pEG?gGWr5{i',^Tn}LPP9I5e 8s`z/Z.J|+6=[N`zeK[Z5BA q\XPv@JqRK
ZBI s,qb9b,q>".}s<"O_>i6YC 2W^1]XN]fK`spt+XH
{T`>GjOvn
O;^]~#.]z#4[LcFo(6i#zx-8xi|;HIJ l1Gi?^F0o! a\3onN-?	pGoyqZ&x$w}Ej:W%h9ec*tnhP19l7`>|K%Jn=?S49fr$6;6)8([nj2*qVEp^n4w!ccRWv|Z 9S].o>Yt$~H!-^n;K;av;08f[/z=q!D>`x888|b>V/#XN4;C+k eC-tTZA[xv((fHqZ;Z'/ pn?,c[dG)	]}ms[%2ZtR<wXVe?,u2w4ylp@F|=ctHp_lj*pq3.*!uS)T)4K |<76rI*  J3Z4sx(n%Xcx8R7g^ .Pd~4*vVAf= 3Y	TFw|]RJM2B]]1d^nMmh`'0	8OQQG>\()8#'q}iucQ,iw1J(@GSg\h%\Ch$L|}OhlG+)qvS1@A9rYW%wx4b<AG]Zv^)4xv':,e> g93Jn7) *g`8P@Ff <zT;v\nlX,s7L\4jb38e\,@IQDQsG\&O}6TH~7\$*wM+G>Z}*jok
/z]
134T_,se&"jr >FIykA;jZ6(O^@=EPrD15Lv ]tKucNJi jFlQHM.Sq,}t?Ws9{]I0wvqV+'8Gf(Iyym-8LHTVpcD&<l2%mYAa" XhlSP!2J!R:Z GdK&R3L\5+kbwLB}<s2I3dNi{2*+sEZM&U$zgp7 6	Y 2	6o/H'9TXFr3=2sG}p)h[=vl*8\gkgQl8M,&Jx'j	$<,^l3<{[=?WUePG$8Ms]H|DlQ2qp 6H]?:T`3xa OVGnDk^kupGv{u8m3u}ZfZ`Xkvwh8+m~Orf$:= eR~5+~"X% l$,0[Iz\Qw6:5m<GqQtmMV$rCqDC6lR^so;86A6K=v1xkW\ ^@P	hOx3$)qjN`h,+x{h/v|[~t#'8|H@[3}zUgC0Y#9\ *:(1V3@V;flp3'*]Fu46;&[s
-<zRD?fOLZbnv	%>.\:^jD_kAnF68D}[,
2KDkJd<hwW#f$a!hOs#>E?jyF(X$wAV!Tg\I<D,hg?JwhCm'^1Lp(${v|9Ow}Z1Gt!@+<X^Ie|""l!IUXCg/`Uw`pHiw !;9H$%N)#S$$}[[F,E]$E %iUFPO4\vbBWMe
tC'Gl>(f646n8gy%%Bswsg<EHPPNl'\Vdqk{7x :u"|O,sMxV%"I "H f98128*up,F?i(co&?!V$nA[i9 OY3jxDW* )#sTKe5^?$I{)hT7d$UXG.N@36!86vC|A$[!(lfG{IiFc.i.V1&s_F.#[y_hqt)3LY,-%#(|,'4vSyHb*G8l;Ig+wr\$GH8<>~NN(?d5SkL-(6GCPnm~vR$v$vMg]b#_['E=09ro^k62vb194CvH
I }0k|`d 	 )8$F/4[3Z? ZYT,hu|DKosnw~|?Uhwg`6l\S])yJ3fwd;k6+>G\ zs\Uy?iB2r3( x
jkG&@.6{`N=x{*6*3![;i:`?ZZ)_,kqK[fKkHBK8 ?4vYm\0n<9b-2rk28 duTJ%rwxUdc [yYk)"ka3,4cE<Q`Kw|PF$ %5sxgjki&XVHP8"@;dF=0rvr]Tzj[UxKmc1o%So@L21B8  jV^aL	WI%ndAe|-t@(G|F/w[Tn6,*(v(46BpDXUzqzc;go0E6Y <m[XI4.DlL~)~iZxxI"b{PcvbgO>s\@?z8Z;q#Zhu640gl/lYHb>gRiSg/]wW(9>x[z6 '>cmv[k{@W}8$`rZt;DYaqVw5HR0Uom$XQ ?AA<~uE=[0n@g>cW^v~k8H~.yNFr9IrQ.=P{y  Gd5+^+kbGa*V/YC$P6WFlT?vq;tFJ\!9Gg-]>`z')/+m	le-3xY1YTul[oYiB<	G9,=3AKyMWC%)Tw\S4p]Gck} zi5uZSJn?y:.Kb->mZk,7@?y\?@,Xz/Zv1x a>HA\RA)h{=bs_aWve$$?Z8NH~gY;=_Rll?,WQWe$sp~v$	+g'D$vd}OOqm)!HBuE2+FGPykWVYaFLktrNL`ygL_~d=	3'1;("8pq;5[=*-V9.IIr/`}ziZpO\bEgo~ r1L"Q_"/:Dh ltkPOAf" RA\/,(h@#Bd>J:(nf<gN 1Qc/ "vN]4 9 pH~GVIqw e8kL}?d~u!9\M>=&}:$`G=ilvr[Nid&'^V[%vN#mNv@ k:$M*4Gy'}}w-JqDgogM8|Rvbe~"1phF9e`cX3a~K0'|1CX++cZOY:k2c9J2f[t:@ ir.26zZm[Pd22F$HdN	90RnX~1ro!g$(1|QX5vJx[JlHV``$Wk'f ."Eskm>G]BX$~U;~$m7nc9<H0Z@<.XtK%=a6zrhb(;>fWNVc{)eP?$p^W3d@2V$zqhUat)w*> O\Ogf#R74XG'-|J@X%dm9=n!`3 *,bR	/2=OFrk&i,U. c	~%pHa\1EZr%W}Ewh/4rn'lElIMHIe]r:h\En]urK3IJ; f 9=Zg^h@ @#~)yuy	 o|>T\qv6i_j#^NiencR\,~+5F<O\r{ 2iv~T,Z7gnHA"CM(fYLJb`\z7!vnl~t=bbD	8`td`rIs%TWD2H23ei%m)qwr@1Fishk~!Q#1T^YnS2l[	mCQA?Yk'/m;,T_xm*v/)||R# H6YN)]'km$B7xr(aYYS!Q\tCp (	nrgrOY0BI 4Ni5s"#*A;mAZ[jQN	''*Lo?vf$4DI?*{3EK",~x^\*a qZ){1zwcR[,Noz9,kJ"igMb@xg1rA+&29kpiW=m%]vI`qcm-oWcv$yWDr<+,vZ9WVg??:8-99g=[vzC&#7w<Te2Bnyu22w3BNYn~YB%1 <x0qc39Ot;nb0I''4!%$[	Ag5(XWmvTv :sghT:gX=Z4}*MN8#^I[nljw8+/cH4""N}r$LVi/fvgvbK*=
f6pP)`]lC-ui;DeFeFI3)
DiY|::~eejrYfTGbJF|&B#4a	qnEeU#wH8Nh(^m^3 xbe| ~IXEK0 Z8;c]&{w*;Wc(Sgh}9w<{o;py]cnp_blWI&ha$09f^(Y.ntW0:,R5Vi"ul41GK/#~:fN-.{59A?GJ`3Id^
u=M&}'<-?;M?EU}M3jRD@<c'2z~}!.lrP!lqH0X49$;p>u$6#Ye CFR!^ lgpvF~x@3V{kIwZ/}cGC]VL	eJM/]etX	I#R	>G89gdwI(<d5a n84<xX'
g9n5cu!Q*=G^)+K5o,omq)QYCYCU+RG#R-@EMNcn"
6n98S/>@<Od?+0#ol
xnGw35`9)$WIp9|s%bbTxV2U\t?{Pg)02sF;!  0>u*%'dz`'Yj`3\20+ <yUE@^ kEt&tw-Zn
?z8^ZTCsXN=hMUc9Jg*(J6nrG^}_qX/<e|~h' L\9vFA1^D9?KV+,I+
 ,NaSd,7#oyrrN|\JCw:FZW:I63Bl{<ors
J(@{?ze$Q-1%w61+ y.Zc[89b[qw%0b):n`U0 r CT-rx>*s( 2bw!YHS%|?evA8sJ{eY*6uba`ohv<}M*+p9r|j ]e<L|O1
sBh3x26Hl+,i#{f6
<LsWBP//"vN=ODl
G_T6!"DXeXl*F::>w@!tFd\,'#3]rkn#sdRd 3Bcp:
3MFc#$DF >|;hA$`qHQWCkJ9`N[Q\xPsqAwN$ 	Drr
%jK<iz>KCEs0G &Vg_'xh$Dz!'48|/-#+>Y"N^%Rv>"z[mR:jpp|cG  !<TSH<Uo	eP,D|Q06	$cf	;OfGVe5d,0~ :I}Lqhn3mI `H?XC .X cU,,BHdI)}jmdOqznSj?()@>YR0DHNx</"ep)jV/*co<|I`kF#YUmS.dlo Vn9+wml>t]diLn/*U8aGFLxaVIQ%*n|W6-`?j\:FP<GwO$7%I>+o&a?SIT6TEDpe@dc8EfI]#*t:{18b^kH9/v8|CKW;{l`!j;!|)Y`y?za6$}'lZf_,F9^I OdQ=Wi"')"[zI4j8'mZNN:2d
_O$8za#1{kfsdR/w,D!vIVTdy#)oWrczh;&o$2`9pGu#UCr'L;GcsKJdR3)ZH+eC%*w6[C>yV84
\;~~wRCo-U'7bK(@$2\,MQ9%[x>aM3qF /R_/ VumrYHa9pk0D;3Z2uaWHHC\n[ X&|UM7k7WJJ<]D,rOSA?+{\q.Zm^4m1:`HcR)]8&yrE$(q<uz68 vN*ViCw?NR1yyp%Z5.{3"x/QzPDP)0S>?9a+`m8fQAl$t8VF;+Tg(#f2Qrnhy;$(ZhW$qR$w{Pq>^1+e,}=_3p1	O6U)r@2wqs<`G8*;uc9WH>^urri1F!l@*<~\nA3ZaxI<+U]HY(302A?1YEN
*!G]tp2;PL:q0<2$rO>zY8`Hc<m |W',M2T7Z.;fOPZFaQL`17@G$`{t+ef9uk
<'Pdw)qB)D/kT=K <&: y?C]C1<=QY=?jt% ?e$cz&ghH!\`HCwWOn'Fl	2y7"x((QC=cs
c|L0>trv02:~uDebT	2Q>~ pAIm-sr3VE%wbr8~u1s2<py9$C++Al(l>O"Lv lLNkBgo.#_zs;_ \&yvL2'?^ UN$9>q:Z!v;f-g*C\AP3{u+c> 	 c
/ :VX8hs i1^F{^3Blm&9xBw)\$`yzkYU@4\Isp2;	x#<f&)%Di`3V6e [8 {U64q?;<p=M02r
CzMFysj)Cp9o,o?$
7addMl$;b[/tj.Djh g@bmcc]uF4TEB#mO%f29\3)V;h418A *oe`hdW*?Pck
d^<g%@<yHDxTXtn=z`jUQ'ch+@.Kaf9[0x% gCCl
X#d\)\)F98M}*[vaiOcah5i vsWvjqm[d3B9zqCv_TvvU8_!88sQ_"7z P,X( ~uf|Gej-p0{srFQ/U_cu/yrF0=pC/vGqWVG]NP\5(\zL@+o%Y]d
s|kqR&.KsF<uI/_ny q=i.5e	2 oiFbygvVY--3FB2FT ]j6%E8= D%\cz:JKs3HIU>W=z|(pqOA|T( f9Wyd+q[P0>98$p5+8n:{RTt8Cs\T9"=UG <5+v.-<4Hy=@nyT-4]r\PrTFr:$BC9uKl*OR8}*g	d
[3#[H?V3H$@z:PV</&IDOLGgr^Ax$vroDx+A6iceX+\z|(#O_5l#e.g p3tT|Wu$/9[m[.7gFw}5". -@3Y!~< Z69a=}QCvc{ka$U %3\d+>3<`zBEm`rs<W!QZ\*BMtd<6mD3ws;eB:yZ=!" 6yFkgV((L5x8"9pXcmb:S>zDL(['aV}N28Xi>/:Ny}C'<+c!nk$O){l:c8[T_9bb#i7lSGG$@:Gy8YlCshxSu?Pu\\}im0O=jx]Y3+5$#^hzKW2_Ht14cxSH3U0|\|MhOQ[R$VsH;M/oY/e+Ucg f:Sm[VN4.O!>W =3sW	,>r1@2k\8cf8QxZWJ\\8{W26OWLM}O J=AaY7k3V]Cf#5EiP^GmfBG84&8$Pl#
S7$gTc?W\j:yd>U-{dgM>@;=b3zI ;+l9	Cv	f;n#A!ef<mM<-BF<	!MRc<qD^]05l/0^9P`:P!e9 >gF?h`Iv- }96!@$r|(odmL6sq/_c	u& lrO'CoG9]^
]!^*dG#TclS$Ny{fo@%Yk6Mg`$3=h}6L%Gb>T}3$nUr dI$Y&ERs|r,5Mi:,Tsi,)HAxCgG'5].c|0$UWQ<'=u=zt$ ^[_ g"zLSsUVM]wMqs{P\I;T7PFuh*N\*NiK1xF 8bCki#L4<u3(-c	=6v/nX!UB_>siwRx})4QIXXZfUluVICB[)[CFUVx}UAjzx ]8&-T$F=[."Um!X1rN9dtG,z	rK wk=^W`lQNI.mf1 ``W1RMTh,H_h d)$Y#mM|DDQjW/Dh;
+C8X`V4Qkkf!++Z2W]0k.Kcps[8br_ogOMl@!`tl|Ev=zt F/x"9IEl%'4Q%<[*
	LqHW<{vH3/$:k,'$N? TSv{JBpm;69	GP2x,-FYiW2,	CbmLH}Vrn!;
F9Km.vq=fhQBY2A9RbE#D272Dd/|:%p]nR`<9F9W7Zpr	3"y$i"y#trx5FkOiY0I`WVE:WhH#lyn,JR@GC}}kRF+53iO)sXr]55#cI'Y[K)8oZ
=bINrYWiOAWK$;PpOQ5)42;x,aGVhh*u8
]cRPxL|MrO4K"BF|:F ?:T'c,?eu2=0zf=NK:k"@)~gnsM\l 3}jJJfY U)@ *e(E$dYs=vKEw3L[q1'UArH % {qRuOJ
ZUz^ZMP.[nJ;%'96#"k).<rk93Y>K09 :U5Qq+$R"zbk"J[sVYKkvpZvVHUy1$rx8/|Kejliwg;~uv{{Q0^9l{?>i-tvHp ~A&N=	'{mBYT9:t`xcIcRpyu`kV
\Zh"{Gt.z>$*-,}iLz6tRMu%IBQI4gK O nX4r"C$j-Uqt@q( xOvA*J`f $\<
h_q s R?JjFf
=
M(9>3DIZ7)eF $K 99<VP-bn,`(Lz{yT\V[GqQoKTtVNqHIVhU6Cdq5xJ<y,YR7XWwbfi sk?dfv2!Hya4VHCP_Z!msWr>C6lBiv 	|+pN|
qI?hlK!I\AC?:~0#@>0	0@pq
2qKL,>T}6ifUjnBG>]qdZwc$#?jk}AwuLw0:)zvWZI5q.Y9I2:Xn|:Jn89#EfnK9~v9;! *>nv[xA/=?@@fL2sSKnay~f]T9V`|w_o:d~ses2rC*A(xvSr7R#YZW /C 7}3Y#]RB^W%O\qXIvQ 3<g@|mfB+U$;E60X$9 V<`+aa_Z'1J9AUWo4Y1N}
&-w*,s1@N9g\ww[d#
5k&,ArM_5Twzy/ERu-AeI-u.d 0*>=
H6:\ZyA+u	BT1Qp>ckKq<'MVeR@) #?Jh"M[^9#TYXv(Pyyg5rh2o:4>`-LG`kdm46$J}3P]+sdQv75$8#m>Z+yE+2y'gG\\yf=L+}:wcen<} Yol4r26yJ}r{#]>A=D U23?yhukKZk(S<^LXnu??zU9%n9 #2_gW-e<p|r^Z,&Q-o`{+z!'yQWwbHmgC y\~IE"Z
7w|kjbq 3/u[+yevL@J!gblYOq5kp(b Z>gDv=wP^K!ccR]VRif'9?ZWmjZZ65]()&RB15"`Y/J/Z{K-(NK0 qG&$P:&$'c9E4W`+s	mu_6_?eb_i2 iQ{+WMf )~}O$gdO>^t{orq3w*0F1b\<pJ[K9{9BG_'Rhq+:VqBOxqsvnap:U2Ah_7n hmk{7_ HMJ;qs%Qe~@/=jS6{
O15gn h=X3p#B~0Lmd}-#J}O~7N]wpU<t#=)d)_h`+c<pQRb'sg{Yw@A%dcHa.M3]G(=9%y5pQ##y+af]q9<TW5Vz=o&;D.i~'xW .IW_I uDz:) 
S|k!aMLVe m~Y]hqF9H6jZb7Ba88i^.NVuop>Wd-r\MIbZ(06?ZY?qu3d{/>'8Rfr[j?by2co,$[YPZIUnR7tK	*gs)lYuHEGnzmY7p0m[y9?jf;O}!nY7=@|^eyqR|RBu+7[[H9;B`d9iWipb8:yQmw,l\ x<!Homm%F#S'OtLEmJeK?JcM&,,dBN@|IYL8M428R	`@*,@a4e5kwsp1^rm-^[KmB+h|Kr }9i2y
GkP\2'nfF
=u^ iqfme j(DYOOJFH'b9 t3jjomm{`&P|ZhWKiPXp dc9}@}>!m`}@V{bXc!|+?6`u^D)V})}* 1KuT"Xp&$Pj!k`$$1s3HSmuX\\V^iv,w:Q\,\z%{s\I2<%\G,W	8,F;$3' >+M[j2 U2(xbW\yC!}LLB	*RSe,ol;RhFj. Hfw'Fd,4rO#)|4{D^6 jzar;jrF;B	I f$$)\6FjGoZ@8Y*`+\b5
Y(u
Tz@ s'kfsq SmGItn!kREf
IX=9gkg:IGa9ZMgwQ~Go,M }|~g_\_B{c^1QY99JjZD:cY..cE5O8|k[[)lLq:M/JTfiz'>Ue1U#<*y&O/";D#f'pZL$8<:1z;N@?uUgG:eK?6gJxBN9T)aypk 8=ht+.u; <_wL(.X_9{?$Qfx' r+
VM1[vO>D/l{:d7N@==j QNzW#\,uD08;$vRkzgXbB[t5(.:08XG?,*j_/ggI5')'^ilC}JHw4:qM%p\U.OdhZ1i2:TIP"]i?R@Ik[Puhi"RcOj>+UFE[5T\ns c:>pXq4'<`|tB^/	9+VnqvsZs{V$R]Qg:
Z[62N8~XLI/R1ke.[0:}(pQLY V^x u-*=yK3b[z`G/7bn*	N<5o"2nGn<)e{]]U;-I<Vg$hSC 7_s Tu6 bAiEp?*5V_c/\biUU<|"2#\a	Gwsj6QQV
^FPXP9]s3WEB?_VE\mB?gjR:IG.pNr>c|e9 :<h+r T(<:h6hS21'0_oz]2~@I W;l- :l;H9/_cVTY%'d}z1F,c;VI	qvIA\I6vb+wu$VvxJ\Y&2WP~`?NI1f*8}hInIbw[D'<;vl-ZDx9vEp0|XC/D>f
EE1CDvkP^YY>)9Rs'{_Nr3>EdU}>BtLqF"d>,L`"(?	KyF+<[Uq}k@sF<(C,	7IJp ^cFKlr0XNy'j*ZNYXa5e$pL$aapU`NyEk1?#	'MAN#1vZ{B&#hc;FW'zlU<p	8d`5lj1KF@n3[IU<2Qj/Lje#*)m'e[y:uK4IX1|1F#9 Uv4-Fgee?JP0*.1x
8<*J"8 '<`zu8 nTpW@B/-cg11xP@Ygw{W1[;X.2IH\'1R {eF >O5II\/s	 s]K"C$:	&#G>T}`WP8@\('t6	cHcOXQNd2| VRG10MQ#F3<Ggiv2M,zvcP`})7,JkX%V<B[W \s`h^LO	y."(TfgyM"	qU*$KKq 
PG^MxOtq.|+ktX1`Fp||E Z*-$}V+#V. +b=L0zsIlJ<3N6s"2;iy64H$IzW6I SHKE@3y{b%?}RcF??z^B3rps*ype.A]K67WwBY6wG>*%Ix]|q4~Dc#j#
G=3Y==tRj|&#G4!>R%YY&V
yV*`
n#@FSU^ggQU#,pNq%W=E2=GtSXt>KmI'$yg<ew:!m;px:7'6"a$wnQ3:\0>Dxb72=}2Gv0tmRq2S CE@y} *vY$.R1/zA%S#$Q=g$t+S
$>g9}#vGH-jf\.e8>jtcDRFJx!e%\T`#9 UPO|M.I:Q1WW=[?w"K>Dc1B;sov"@V	l cg<Nk$ulH*;YcF,<:c(iXC<EK>O[lKpnZk>eOzq%;?*95CDn}(X0_L3] x>UY-['),w9>/T6>xa\4 !;*M34ZV?hgG)e+C;7&2r n';~h[)3]s.y]FT6={dNT 5:"G K9gDqX.#6cUJgD{XGsT yzGpKS ~HH!) j5N
u tc^sX!PX@84D,7+< <0;_#3NEu"0BmWdH^R,~ubn~.=CGf<+ 0eR08| -Z9!w[As{V 
g qS}Ed.Hds`=*G@46wX*'CHl23P<#TR*0ry>={SpJD48PH@ R- Xi8P\m& &Qbi'*	to*nB*O]vhZB#O'd$N@B'`-I$BCA[ub$9|TaIGL^%D "8RF>`o!x #:u2Gv2=G^mWmk'Luuly	({/y6mxQ[GlI,0V*]OcM&Rc]{[iiKh w:n$A00/P1$g%YC.<\Ul_sU%q#:$A[8bx`$A!`sA<V[NT*`:N;"cWG.ce"8L@[?:FX=?b6\z~W8W+v'NFiKns)9NyS_*GOx; 0\2@(yl' /T.pOjF $cqsj&R\` ?/pz	e.rIUa%69~>uSO>v+$!=*SY{HO_s<'Hx'#pr=k	A?y-stuun
  >kL(`v2 U1m,9-zPpRF(##K(Cm6y +El&3xY'u1:9OR=K	excfe%@0|x?Y.T4'$|P<K>=(+^$q8
Hg :YI3RfF xU/z>NsCATW!)%N3g6]Rp3&p~ex68i' BTMgQCYBxTt<
MKq'pr$ Ub$,Afir>w~Dx>GKw899N^v8<,p}iB]EQ >~=ve#8X>\UcKghk2>m1.11$RXaUuv@U$VMyDh2ll :7c/4|AW+s WOF'DF> #}k3$W}{^z=xOz$Hq-e/|tV{@,XTwzV,;:eSnRA8:~D%=O5dv lVXC ~_z &]BE2w![BrM&;:p+#2 T	8JVBtrXc$P&h?*Q_6	)u5SF Vp&?,3DqbrVnA |Z]#._2W>W$w\
:c9<QZIKXC
w,~w#c&	8xHW$UWD *LO`kTIRpwruKCzPfVqNy'PdU}w xsL;i%c3 *e`[pm,-oi*pO>U%Ed#/yA604,b#zU%97mFrVR s^>^y$imA;@~cV*JpRciC5^	-F!pSr!gXOhDfm7g8ZjI*G*VGg2&5B:F$><|^VXvXi@UKbF Pz+.2z}g8+qu.2HDG&7y A[s?5Tr2b?&{(l1tj\RF509c'=-?-``3&dwdq'wx tZtzq5s1{z-7HecZ{;@3Hz3 THz6k'^!{rFr]>]pVr+w#a,,z$xQ#4W$sDRG5-$P2l	51.<Qyx# ~46Uy@I+!m4Q_8B}G#85x N'C*. DHVtBIKb663>jnMPYna$C#n-SMr 8 dt^`Gc
V~**,r0O	=2+kIai(@QJI2)VoLL{!|+pTd(8DX N**St{i.(+$JwgNIWT2RG#$?lO\4zd+;N"('C%-6y29IfoF&k8=y4uQr9 % qHUoBdi='-FH=;QF/XF8T
xMy%$>);mA p~ySRYg\3d!)wr">?nG.#>E&E`Q|tkDN@yZhY7K:H.[d7wGeBe6*u'=h.p-F, -3nZrda)u)l@C;]|*oub	< Wqz~UX{wr 4*?A}].YB p9H8vO,VPs2?	?ZrnFj.u' Fn Qg9 >/qhz HBhvsSC1 k` !zuk(MQxfydM}E!D(8?0@2C>'P17x>$m#:FF{\Zx+,1p@??l-?HT-{yVaUI@I>mrbye'*[C=,DpB
^wyxqqG*;!GtpRygSHb{rA8yeYn~i,eUn?\Hf?cN~
`Lm>)+ivp1 ZZ.a~X]V/'AC Li	4J$dkb] P]J" 8*(PT9R1 mI&P>j
OIxwcWX=0Gc' Nwwqs"K?zP)*CZa*#=`ch>d6>B%`nFzvkPd*y\^YKpRYc7&D</Bi@<*{C{-V!.0zx[YHo32Tj! l':[\j7iu]Fq?~k:|Oe xdBWoYWx WF|VJ/g/p?V/$'";,#E`*1TE7wp	*}IV{WFdo@ (*p8rMqe$ml&>0c *C,dSwW'9S6cXmsDPAGib#E>j!@'2)VDHjz\Pm<dn:.K`W?'bw,W>I2>rr^@k0(8>|=3t1d+ZLc/A = p8q09Sy%dgxMJ_#m*4T-2o0ygNvNd~db y;#$|6'Xt<R-neZn82uw<:T%!m696w6s}FHsfvSsIuLEb7&B29{fj&cy0?ItiE%-iebCgu1s\Zj1Q~"@7gig:Ux,,fylEmQG.g6pV
U$kK}j0iIu1H-.uNR[x: }+OSBb>Xj	I nvR+9xU=c9EymQHgE3Ydr}?t-9g)1ks[s}oq,Z~.TSqo	k[1X]*= -M*pS2B%Skf# |UjPl9lq4/gW|?hXkd494VuMsrbDt'fAd\ZD1JjNzdwS_2=.I@REkrGY?nF<[Aw	Z!ojvj2{G@#%ml{hl!95.S0?!n*;ZvcnlH
_Ve-*bzskgcOZIS/jl3\rE R^.lI0@1J+f5,u]\ MA3t>Q~X4rq{AT$ZbtZpk=-em*3\-v^8'=k;x 'M#HiS?Nh5[		!$>9s XsytZSvnX>d|lPq
+<=FJJpF*+a*<`]<'f,k\n~Unh4O0{ pxMR!V3G2Hku"U<g?V\NF]ZI;xsX1)hqr~$Te 00uEcyeN@n~ Z!5%m" Ki6>Q;;YM,rzZj:
W^vc=KEX r4< :$n5LUTMehnnXi""Dslwxf$PE{WqJ$7grB]#t2&y5J%d0uX{xJV^qYdY9e%j
kT!h'RL>izkvr{s^K=%	'-N
>?	$}hncyV;^qWM'!W%J-#X@~*;|j<h4ra?OZ[FO8gZoK1t,!Gu	`0DX=xyCJ4FC4G|ECl<20}=W\e7Vz-@fMx]swQv^{]Cs7!N>G4M
 \6f zX"rFdmR8=^z{#' 3$rHG;yRa&+E_ST5\]mi/yQ/Nn06xaP2$h(%X0)]Z963%`HzTu`{9, kC,%= ;'DZR+aK~AqV pyUv(79#9:n/P3.\lKz2}{I-<#qw`uE.j_s4z #j\v=h-)X-5ic\:MeCbWYRGF:kq-eQ8).rpz_/\Q{!]NkY>2/h!RxRqLB& g-<--_65Y*N.3RwFdnpkW<T$b
i*s#*wY[if.s,.Y}g=iouk:&N$]Ta=}2ErZ*CFx#^>_:\7`$mjF{ qZVBrig2 PI\[ywCY=BMv+t\m?z_l,XNib5\$;CvN<sXu vI{)GEQ2+"os?z%g<]7N}VUVuXTxL-KMR-;a1:#\f7Gel1v:aMBD u NhAq	O< Vl6yL'
(?bUG>X4	W/ Rv*-kt (aO7Q5q8C
<yPP^ks/,BL1~Zkl;J^-TWb--Ai<-Ha 0?@;YU
Gs/ju	.pa=}>+W=*2'F&W=+-G^iF|FZv5ej]x/; |.Fk0S<w'<WN]GH#
/R1H^#Aq)~$[$y :&-^ Rek px.Y/bzl8=}E_uLO(9=qccj9(R^LhLre`|<ta"S*:?i!pqQLk/<r GwkX"H yKf1)B8i&U|Jb,[3t ><Ng(i[Lbi^{cxp )5Ua5R0[aSI(\M:dl%+JXgK@v-zo,mDe8gsfVR)FIV`aVA<Hdd^<q?kn^O%JRa7*_B,|<.k KW/wm= PM7eztu,,7/Y 8dW8hRcg_JX)Q$s u"PN?Gad]O1=#ZLUbBL*9G_r]BU>YKHhg*5ZlvI,!S
R?(PLsO;PWpxSOMue4xg$NYX^9O4}8}H[FGDw3>g3sU8<}LYM.j@n"^Aw`*? *\kdP-J?yo-' :,x:TeT%:!}dSOI})v	>M{L|<7`>^F7z6g'N\wO d-rLQE g}OAYo<CK$2$vePg88.tIcc.R3}sVqqI>hY59I9$$}V7 df[yP'} ^<Jd]}r\e;N@A-WR|gTU6sx>V9XrG\ya0R<I%ss+'	CM
-\kZ+31y]sk$C9!N>` 24GIdSZ_.]7FfU]aibBRKaso4[K[*>gvZ7XYB`xtP=*x@.hB66){kN{iO$PB'51GiE+UB% $@}p)_NQn[(F O9NI(4k'Bvqc#XsyzM*P[!d-H9 s.kH6v?|F7e(p sTCs2*`ExI>j9Wwv =o@Jo2Ro6"deRqmh$1CZ/@G99By5NHY;^VK1da76IODM!*1G0V   `[OHIR8*K]zwY6qvi!oe[Bp@|9UE	x=kR(Y/ys"  u$VX@H/+zzveKv[SC+fe0
wNMFX)p m{2M.U>#fj]-\/85EHY}gaqyn##>U#eH`,W+|NujZB{Ks"KsGi{;-v( n=Ec{YUM3h
zS=?GD^5x5U8,J8HK \T(b ,B0=`IMx`}[kA%p>b^JGT/V(;8>m rMR%)1V 7p.oX1Lv Ui,c\)Pw#`,:>ga}SG?c	#<:X][,Zz'#!~L;T#aH_$BP8T'g5[7M#ZR!q@HnZ[t*},Jar;1[R(7'R9y|EfLH)q$nA8 zVR6Yr[Nm%spIb0|1W9vsQpYo3}GU[97F$;M>li?J,n#y '|c4{;{qtlyrTI"1<sQDCI@hAmJZ96e	|<Q8,G@	V&WAj0f'Nr1DO vm-h $91}i3van{CN
e]p8F#)#7CHP	<{V'q[I
- .1?>zW}Ir\iWlG}"e3I#vKQ\?cH5 IN0\>dzvo:k\uWqF8G+J-,;  qR6 | yUH?hg
T 	$qpX5/i% C)(mL}<@qL}xlhn?lQQjVoNAQf;"	-0y)il;ZHP7?BEqhgM!xm;cg)
s;_.kZeomf)#jWq#+O>LdvCWh>C<Vo	t s##sm5
@5x5=7*Zh}uh1p?R)t?C!G}BB([(GMlw1;>.}c]Eqo$wSSbGy8?.JE]fE8SWJm`j/;K3D$6 xWsR@REnA hzgj<R\L~B ='o<&{-kl0;0w hBm&Y @ 3ONgftl h{];^\(tB_=ly@_^@>F|2T^`irD x%s*R[i3[p89Apdd8?4tdQ[B` lPomor:@?DS,<-\Z2]_1} 0N{\i|BLmjmu+~9F>@Km&.,d0ppFr(6|#4`5l,c\}iN?# C$gut#Mo -npuVcq'Zh[w9Fg^#&iwg+dG7
}Xi{/qjw1>LRG`pq)DxQp7fWAD@WO:%?s~Y]FQ$q9>^TFN5@GNwO+z~C5//o}x9O\i;Nj1 82ch[u6&!Up<\\I'9Lm`L{&|!2y@ofE" F%Q<~T4#GGKC/w4M9rp1xW:dGH/G
B1UN~^rw+CT_HV]!d?gnhnOy(f
r	djJ0rNKD&w GF6QIi 9~\j;r/ztztx2om?DvA*0#dy@Uv`jVz?wo&!l"p|-^X)wI-F
Ee;`A0lr<pfT zH@7x\s'cVD}Nrcv.'4t=,$4d8`	yqtp \|RF6`	ht+RkZk.YV_HMu7g`KWHbyxz%'<4#Hx{\$PAgebL-%5(J~NAGQ[b-%79F1VgY%mBI?9MxlDU\UeM<2J
!JW\gXI)*"gaC< ,9v9Vytb:NK.s~X}{{GxD$
?.$2{xaa $g:#oze62x$LoDl l p|V,j8y-[/zgXr-W5?bk/), }ggH#{<+:e}mnBQ@|a d$Jxdnf?@
>$JSyA('xA uJpJc9SNR&&(q1R['5+)%K*~py*<;cT4PG2d }m2xXK}T% wnD!Hytd#B@'y>]=+C;mVS.mTBwmY3ij2InI,Y94H 4$Ds>*(q:bKr"yjB%&z:eJ#FV\G(,8::b[ang!uC+wVwSRS08<yjfJ'KoiqHqbQI8/f8#>9{5"sa^C!My&{U}I9 >+\e$*wFc
#:F3Ecl7P6:FxWQg%AFE#?CDrUN@a%a[9CyGy7QYr g y+Co,1i/IvXPZKwLIvOPH-3OT1"7BJf	6E7sb`iqiePMq!xl%);
J2@!:Qyn<\"y./m% ? r+y$OD{O8]byeyy#QMb0v'csT;`Q[REQ@q?:*|2qT`;06SW@7s&,}h1wnbqFNH'^E[	#e0fXxiAK3nugBdtZ8"8NOu:Gr >Ey	;~,9e`?//RQ0JN}6Y\K+^L6,F$p#/|oM <r[eq+<g[PP%2rq*A,gpI6q5V!zP1Wc&qy8*&zMcv5
28$y.NA]tz=vD=U*zj'`If@1>tnndw@!bz(<TR.6T6!(uhI^OO.)|bI9GS>1Ogkod *)2^$B}F3Kkv$Rwy>|sVTB@<D1qUY9%6r6HHaHB&C]C(`w
>#\,;hh
I=<>U- eW}Mx*?$ * onf>xd:[h2?J+n )$AXS3tbxxFBy|H%U,hbFZF)p1ix5m$yF`Q1KV$~uKVm9 =A
n$?"+WJ3k?nvN9> kC=q8uqu6D@8 T{Ee`2y>u[aRelHv?i?jHNcyr"ya:r==i;wGvf22Gyp&r@Va>(!t`$J HaWL*Auv	p^fBX	,=zr M'3m0 #X2HK;#"& c_~:wiql@e2>~ K6Y% ? goP g04Du'=!
o
jWEd.bSF8wapyyp	O^w(d\mo
~Z{)|";hQYSy/zw0;X~!z0ipzu5r8c\ES}uyF]8H[ (Z>$0<xY2|"Yax!{Jp3dTZ
mx<PW6W&""%x$ypicv7d<*exytq	$sR)X{ow0709 "4!0\GP?5eB}:&kDC^KCw}HW$
pJMj;_+d4q* p0S].W1tTt!
Xyo37i##88_j{ kvwhgihHl%%;s:Akb1 ty2+X KqTOrMlGt[ '2j0p*Gj'L'c{lUY=WY8<X9=fwuh%'k5"\D=yWTD+1,nvYtR+>][Co<2aCIj[$2LsgELr*?tp ;@/J2b<j
"qwbGdK%2p@9q]I`zq<Rp=
z4:cH|7T`}Z"yE	b=<O61U *xQqiyAEf;Fxhce*T4r]yNd}[\QnS'r-cTp8}92dWzGjn8SC>6g+)\cQ
#'xs:9b+:UEM)bp6z8d
(s'}R`O W&0J8orl >u@ H#A1)@bs^/p|?>hD}/DtV8Qb@ttVW `r<+*Wq\-b9y8&)i^I\P XZDdc Rkb2^rC6cl8#<#;wF(a+V<72kTM(I	/nF8_K![=ci=}9-1,+E; g /;hD(>Gzq\KO:toAEC'hDZsOq_$@}?s@xvo{acj0,0aCt;h?2Bud=9u+5\Jx>!ZqikMs.mq^+*.^m3x_qO`m4qBf;vRG9l#kqcegC"Z0FY2g =:Ye04*H:{f4J+?/l[d=NDDP ;IbIc ok+89gK\^Ad17@>:rGWfnjm_k@?SrXA J~WCyqJ)b=*YOwr&`H^k<4$!VwI#s`QM<_ib;h@O5:6D vH	?kf 9g!z7oUl8_],
p''I[J	?#u</8
1IM ;G!fo,yj{}b\*-VMg`C`d88
uJx 7r2?c3vWH3FvP8V;b cXE0<_JHW6 IZKQ) @r9of{-oM%H/s+W $l_+[	<	+1tm+	Fp?L
Yl+i
}p\Bb@e 8YC+1GLGz"qVB``\gf-<<{zq\Bq3,yzK~1u${:lsl[QZa f!%@>?J I$BtRp D
_:"RVXaS
|\>M[S^,ho5'i{#*6XU.'iyvHV9?RfK	
1~T7G3!	'!GA:yJY%2s\ #o%X	SH069zQpZfU/HR!sWAIpse]Nex!O@@|eah8D:j;uqq)2OMZ/5QJ&.P)UphjO;4w2@a)G("qTb?I.gj2$l:5[D;v+dNQ$xpO:( ~1)0v2i.5b3nX[8ugQW(^(E9CyVeh9p6u *WG<}"f=^7bc>!@Sv.3S+>{D#EKDU>nq|QZMisoG1t6zz$qh v.5o<*h{Q3E
jlSgRwX{=GCZ=t*](-R(1/OSFS'omVgp?<`Z$lUu	?KE)$>T`>UIm(q Rjp	n6}$gt.~ i3L^)'8r'zNsXPHH p8+WEsD vCi/L,rQrD$%k1^N1=sO \< BhF~/ sMn]B6 +w }yacJ]]Xz`OJK%lQp9'_Q&]*rt<>7gQPG8<|]O*dG\fdFFh8Z6}x&w2HNG9<<ug-MPZT2, 2m]$*vQ!+d]:rKE<_aibSspw=iluDS{~@OLY } F]Im;1V.G?!iWM~Q=nFpAaziz}w)W;c$yY|CjHUy  AUBDy.l<}cU .79'}P<ajZzn\f5ly udz}F dgQT)>b0 Dw$:zIPk85ZdC$d1AZ_y7}bc *	8=<=YG\y^UFQMCZsh(G|~?Yv
VY|Lpy
5>|5fy3G UQiaILcXD]fc#kTD^>)&]Yu00p5F&kL@<f}b==2V'mrJTL34#8lEn LL1t"5pgu@o_,F]CQnvs<q)t7Ww6M90Bpad-Q~ PeZPvI$H}jSh=@?
2Oj.itB>0;d9dN%Iy:OVh3YE[I=?4BP-u"!U 2{*$,#z|n[gju&J4{K|Gri127x@H-b\;mArY9R^U@-C6C"m.QAW6ov<u`)dA9R&y/xn-$\Hjm8[1!md,%j!I3$2SPFNSMV4cdvC}2fD p 2 K4y2pi~8Z %
@A9?LsX3L53#rbvOia*F
#110v*nYZ-ki[1e?kk0F6$ *bX ~qt#ac~6}`v&5~Ev G& wj:[Hz)y-h&:H'?y<=zf]b-6wkQx#^afMwp9V>X=o8IDjT.pOv6UcYTrB\ u95}	eUn29_qJ%=BHghzm9'W4prg'wA&mQv|-JXf[2fXhN3qnj>F7\P!&o;?xsBre#(mgUrkf&V5#6_guakQ_OiU,>|?/u
dr[U5-JV]dNe^~7.\c "-% X q+8Yc](;nlX:pUW_gE&s$p8<ZvkKemaY!:(>tmy2Dh_w-G~|=s/k;|M?kj*XE?@ /\|<%
 q)u~ukY_BMr0})|Zfl![ %Ge8cm[HdpG9Q'l\fgZ
`I0d"<G5zhBVq2o?r84vBme,sxQ)	[FN#
3N2r:Fg.D_M\{9<.{f;SPq}k]N	9qe{x2}&WW<c|zjB#Z:rJO	*U}':-[KpcGi:xQ!7H85h8Y5(]n=,>jt{=*# ?g*jx5+x<8bGa]@*XUii6p2KE4q	DDS;'>^=Z9f(!x8W62gs Z:,o9;[x\  xXuS4uxWG%[fDO%5F+o4>}z46wp! ytzPdpiNK$g2~]C`#p)GR[#O4)~&'G(GR+ 50?nBnaq8<1bGuG,b\ba=J?Qcx/}bRFKis crjNi0D]';'6fG)$'9G^Z dIUxKrT,nKV' sY19u)[?$
kvdK&{S!Ra60>ayn-V%>iw="Hwlw:gcvW
~H#p[&O4&:q+j.2F:QZUMG4Had89x'T51S/X5A^=~a<4kOSji6y#RTw[+H9 Ai1;^	\7(>dsscU&W d6c4\",1c#[#tc)N.gba<qZlF.`<zN(3o*D@75Bc%~^O`c+UpYYmijC w(wd-#Qm_5}$TEu@/#@7j>EwY
o/_[xSQP9Rcv@=	lW+[uWy ^MkxexD,}jN	5fScb\}*MG<xKb~!:iYi,qisOuugYRulv
!rn30fL-A?2qnIF=x$}Gl@[d #~, nQ<+W\ ifE"{6=JW/~]-L J*=_,WnzvWIx&$x78Ge kedTm!hg|8{yLZ$2zeF<}+N. u>< s F$o,y#L 3ZC<+k(M98\IcmCt1CjsXF<dmRKMR[C3;= y2<VMb*Joh
zqAwi:liW|M,Wp2H^6	)qxiZZM>%&q1A ziZzeN#y$F1J*!@6uG6P+B?:bx*<xzCMf RT'?..Z! >sx=90<RE R* h:HhcL$\w*bXIC.8ggM5?q 
>a8Tt
A3F~rH,g N1;B~@E<c<OM?n n !)$V852/t?jA|4&NVjx>1 f\0l<\N"A]9bQ(3c$qDC=P&7)'99#8}3R?gGs={}"m?|Whc8p7l_)[\r| 7pi	1*u>:8 *kiEo q|"_wWl#](CIG1Y=yYl==|f+!! \UF G;|KCy("[Lc}
fY<)98+k7Zm=698>IX'Qk.Ls t4#Y49EmY\zsx"d{<eI-<cE_lDf.\+(gFaT[E@xH-59X'?:hJY+;ODJXFHnO)cyR	ed0/L2AE9&m.$
\kEdQu V^I^u!w k;2d$+s)mQLI(-D"[=r8AT]";G:xY-cL^%&*Sv@td*^>z1#Tpxd&pzQvZw(3nm6NGgl3qU;}H	-Bd<W4GvwI*W3{jvb:"e@?c36TWwBsyyu5[Hzy$C%ae~g2x6YB5Gq5r9|zxw&B;q>i;?cm0I}ko=Fca{^= ,OU\aJ6?~(T i6+O~1&v(n:U!':LeE.6;azT
E?gJ7%r}Ig5}^jFuS7+9ucLBA7x R| Saxm&%174%]O_z;_]XL{-9k&U`qXcsUH-(WH-@ $xg?CTDed1_8wCh
*}Mi`l;M= |\}8#ZLdep8@}k;K'Y}>*a{)Mi"K(YyVIuwqc{>`V: #+7D4MF6V|[p
sHK$`kQ0mNmH%.|^3kJ^OKIbzdm{G$+B\bp39?_J#9`
}+Shb+R]
[U /4Ez~X0z>dS2x2{"y	}9;IlW6dR={r4+)a^_:<%n'mm_sHcB|8O)>2Z^O7~<2H!=<co|ieJ>b1QM"BEig
\`Z 69fB6|	,+3@FL
As3; k g'IS-``R|Jr'=?ZvRD6UP6Ri]E!1aSN?jVI OP5>yPXk<-.(#s/qh8v'< :t4APiJmji'g{3aklo([+OtFSNOv3:>/TLx>m8~UKs1wbXc=ELbq$ZD$-H()*C`FhSg\GI!>YML:do 8$u_$.{3qK#,,Cc$gOszDZVT\]0: U.Tv#.>2F:\b~]3Dm[v8f tlG4! 
>\b? yW01&[s%^ o N5YjO1EdgN=xg GgWcueguZey^mX8{}28mLtgSc_l*#Z4jiM8}9_F#gV&(&4UW;nP#}ho6wl{kpam\OHg4X:V\]VQQb[4)'przIbK$i_.AMwY9']02>"$3$s"$0>23*n	3ZScvFjdUimg\-I"Xx>'a#x,2G<Kc/}sulrNduLg>F{[iKqVH' 8OK$-k"f9 KJ8V8zSYb2#[)[s+w_rF V`NmuQ\>G5[H*F&2`rO[GR7XkG@XLA! c7gq{)8Nj4<QIo\7[N[c/ (=O_iamwB	A}A9$bETE=i1lwN3Vnx7( @sDvW
[?F1*
No@R/Pbfv>|gFvJ"531bcCU'dybu"4#1	SM} iQEyd8 A4&pj :Jc^^7c~W</:h3J=tEA0	r}SPuM=MQFrF\=DgjNej,g$D,_";OQGn~*cq#Pr<Q
n'o.=[`,6^:H~ Y/AfUOh
Y!OJSO!+;zDtb+5=798IFXw.C#$[Hux1MJc;sE,<]a1um'wkjp86C^9>U	uekw!
U2!%* Abl`p0+GyrzP8jzaWdb`G@"! cd.OS>w:Eu,g|0u@B@hzn~=s]2O99*)ic3vT06qWb+$Jmq,:3"T0X/!f?@*89M^~WsqOD%Iy`gdX]#=w?j{56:lw0BZz$`9n$qKV tjC<gyU$\awzO:)lK`T9<scBK@i%{J.	 p4@x][#;2A:B3>fw&97[Cm>^fo O$<`vbL6SUI3R`dMun7jWs)YwU}2<g};<)$9|&VFW#/8\[Z"@Xav$C;apg<cmqOc$npN99-a8(Ha47vkIA:o^1V~k0Lx=}z\:gjd+$#4,~YMYA(:I	0;H-h<*cd$dsL;=&2 2N3:],3 as+b?*\ty_`uvT,B=|1!H
ArA}Lw;I&uV%O\~_D*w`_>*K"yg1v
F:U|M,9iTz~jY|TJ<}ijr~6uIvS+6zr:ufc#peqlLp;;Xo#9W%pNI\ sm)"-A`|$2?= 9m"$,UCN&^&lmPx0@c2:d5s$I
3Q8P|[ 2NOC!Vi?2Szg$p uX.)UsAq f g;$E) ??Z|(@ >tm<5K2zs.2ob l<ZS~e	 N{?xE$188ZX_ih,|.xAK]>gMqrF;< *WX41Jn[zQAv@l|r-	VOuDK A\8+I(?j^n<fB?}~_%rKce%d#fhA,OU[3phZ8=r(i/(7~2r6xQ '8 :Vl*a$kXlZ`3c@9=a#c<^U]VtY''QXyn#Ak&9Y2|9tUk9]"QTBb}^WH!cn?r8&]-O`Qg0!vR[*0avg.+CsE#*KXHLx_}+HWwO,(WSM	9-<UBFs5CB7O}#H X2-,-1e)%':R,L+;s<xrfyl-Fxj^(.M+]MVSfuM3Ij
Q$_*9hxbzA$t$2*ryLvovxMeP$8!gzzTvfSO$e2a"gMT3!e|,'h$-I- ZQN>uKIFprsR5$9'JSMfWmRFyPa1f2d#v`rNv'iFy R199,< jPn3!f^*9gFcr!kdSjbHwPJF#Y :6/scuv}*_buF$f} '|*Z2E9f<1|v'v9s?`}zP=I:8vB	ji pXIHn<c ^;pY0(s3C8a*5)YWnti$XUc4?"V+32eURp(JbvB#\<DB"=c-?_*}	#H$ \3SWF<s>	j%9	/8/2uzR8\ qE[#~X[ aTHW>@>zYE,HR9?3^+8(a,m*Il?W	R<dd0^'T r\V$C*@%|O  x|t0GNsZ]"c7atA\19Dq*gd;@'`aMWN b_.z'EBM@?rAo+`U]e;U&tNpV2 g]n`@ Z~Ap:m#rzig'UIF'"HQAEJN>Ck6sp)rIP0Q4uh>GAsJ`X}cO),aD#>ljllk$!2zs>UTq 7U^p2>uJ)<$,Aa0:'?*5I	?@=1*b?BX)dtZ>-3E2orH3@I9R Y9-wWE+?D1w;(TF&0(l~uIH%;\~C".D2$P+P@Ho%19ahQ<TP6H=z%qK)$@Y" #z?*	ogLW?"]F LV=9RHN8Ux'$9(?	G*I{Q1xoLE'2Yqz+Wb[
,	=89SH "6fDBFtm=<T
t 2|do#d *1 @J_nn<"3Ns/>u;8Uskf3DT9'<CX"rN	TS<GpGVS?G;T|O({TVm*U@A#9$9(e)#.ci3,rI! IW^:bf4{RB,r1 vw6l''<sKd#)s8VN[{, *JokaX,yTojw2A xINE w3}:by!| UnQ"L1U|7vP}z<k>m1o]H $:d:)cw! $ ^dWQE30)2REmxKq8Q$b#fpxO g 	I<dKfb6p:n/MKgMys!td,jJ8VG^{1oko-Ub0YB;qr|hJu$0J'.\X[;2yV;$yYR(umF9*51RcXz#89>5M4&iS)H><&5p]A 5H xeu-5Z3wdc}yvS'`G>p8NzrH'  <U|</<&A:wLrFq,W^06NiRIn<Coq<yK(NSL-g.^ $W8H1<]+==+T(V"Prd?8ws&R|h7gf'sZ>%|ds#9:oQ-Nh d|ponY&zz$y`prs
[Y;(Hi6TSh	H F>"kX~"8GQ26|/:t*L| J7Ci5r:aXUL*Gwl)A$B0FOO:.<gfvWP V;U-JR 3q<nDnJ9=?dHv7=zV&w*7ho"- `=<,*E=DV29I?#]),	'Orlq.faG,kX~lq\B)IS)b/h  g,qX}5Om %Rf+Y-b"[>*Y:	{Ps\Bi[%`p}[81Az:Ml;;'Ft1^d19$ZMo"0Aygt	Li]Y-#HImBjp;nxC.q]
5Efk*3'q,y& yp=ds:&)%D|e/A6i"m8[8/#hc=$MBG$G.Is1T;J+2]sP4Mp6]=y'Sm}kq!h4%JIlLn$y8a}k	2A G UKqkYhl]gB-qVQR/IIc9HZm	XZF2!]JyyVNQ+fX:.xU),\\XNslPAR37i;?&QAvx 7'*3 ?QPgc"19bKnJ0c[iXdydM%7$Qvse e#uI_x"L'Pg:5;ki"iaz"76vzd7[K
AYo$d.9n=8bKI/!H =i+<GZhROX&>|{>#a%.O.W 6?<kWUFYT{?bxi<#k/s *#P4AJZG?gygQX*	nzKoQgr>22I!,`K+TiIb{!K][j3zL7m'	P8 ^BrG:/*4.@ 9RUt}OpX&5 [<';`*4/x4A	d 	'qT1?TQ=8UzQai	2vR</xqm+@@^$EtR\.[ jc{cI-.4g[j|,Cm,9Js3A\\M+Ln`g zx#[lB^KO-cw*{+*6
Rr]E8clu+ t
 f{)e].{6w |Drl#4"A@	G!I`O\Z/2]1'+&ko0|Jxz*xIgb]\5[^8*z$2pJs*6hGwCx5")e"&XT{Wr|JqCSx(opgs,dn|q^#Es_~;{d3Q #'^$NY
 2=M:J"fQ_9:1-\e0
NG5B4AhPMDN7OA@ w;X di11CSGAz\T$uqrE:jqJ[~rFvgV[^77W_
A_~M5p3m'8 }&#'B-ZKrT(A^4a#z\evn'*}3n^B]1'Nr Zy$)l	-/O!EU{-603rjWDJ@5vToniZ%1uuOPFjGAh5p b1NEum_t]F!yUje$`<' s"DgKdhI&ePG}zY']w1R?M0> *zf_nC2z[k
)Tx6RPp+4,6d0bcwrx{Els?'v>^QD!'j>VhW?E=Dss}.uA2##SQ`zZ;)$jF##e%R -Z23Xxg-'(nC*RJ22bGq(-	3S[pS{u3Kf
;/n7`@|OHO =Y0Zu(qjD"~-^}^A sic/"$C<B2?:ss2BhV\!UxwQhS. >9 RxPYkK7fD5jh}@s~.2 yNA)x+Da '%'q<Cj"hl,&}*)BVxlNwkz#8e*&2z6x?<Q7"vRSwh<_F9zbi? =jGOQl<egf{ImcBc@dqL$=mB(#TRn>Rxf( Gl!,/?sR]KsLtD,j#0lqzTWE-+ pGPsFHy:[X,~y>PXcI[rF7  lxWi	QsYx@8.d#JEBnI<xkJ{n-"H|/WM51<$Q. qf }G=NU8C$OY @Xr<9WMS0un+jX
YG@ypOOZY4SM;]-o(_*tw;esZNecA'<QW7%GI5MQB{XqNjX zkkr7c5+	;h,J-a+zdLNIv<-&t8:[H\-F3TwaI:F'fOgb}Us }PCqWAh/6"8Tcz^#\Qp8~&l?*6cM[A`G956jSp ~b7gu+nHf s)~`+VhVS
ky Wg?]/cs\-bYTx Y"8=)tLor0jySGi.Cw1q c^!A\<8QVQ@u;bQcZd4	Vhus6H8~T?[g{CmlG9Wvm{bDYqvYv7dyTTr\:J~Kt>RU4az)rWb#;?pr=	UVtk\tE0{W>/ox|)2m8\aO,q[]:H\qxUBtK<`	k[+9{G;,g`qXTGZ:;szRw~_q:/vY U MFgmv']|5/IgHeQyV/Bfp8h9`,eq*;+%eJNw<]3s*pTrk.q$ji`js8aHsi~y}EDuh$*3+9P\J$hfC3}@MEied,WVHW Sgmu<
fKa[dk%Y%xd28*e8se>=` -*C\!{#v;WSK+U(bOmU$39
8jWEp|
Lb8zAe3c q7H*|uR?!.p5.\4UeuU}2CR o&6kpT=
s[ge >gU#$%+TvC+63]u/cIIcAU2nOv+p x(w|==)oQ+ _]`0d@:. nk]i6Al'sI^^5fGcx95[j_7qx 0<dsRB6w@@BIw4d79U~	03[0v5i' 9w0%H8>%h$=PysLVLz>6>\;cR1n<lOg=qza]!?	yZ;+WVd'>1(r;m{MNV$a:UkieV B(99zv
4p\#0*5z??h;$&1II!b IFddVY")?a@xNzj{L`+g H =OO*w.G#$wt=1<\y#G8e"k+htNImQb_,if,ldK!W?h1BX=^vY$v[s
^2=i(',lM6Wo?K/L3s/oxhC	1
YOpx0
\	fE=	Sf2Zl1 B913UlO O-NF
$oUOexT=j8y:^ jeYYtAb6 Akn$wNx4{J:jz0nQQ]WRrc\Lb;-8.{{'y~utooE;TntVMO]VjJer)bP@3H0")>nFYL(1W1h sqG7LW}Nw*%lwb3k/4:[I<xh$.nif&1:<=Id+HB1jO}s6Wv	2E  )\j!{Y2'.@c[wwNr6V%uiG&E8sf{;x]:yM&'V(IK/}!02p1${zmogpZ/hY\adZwrxI
R
2s	/n1hc
i\My4G'qc?iL
Kk|)q=}+38q/fK"%o KFNOL1<kZpUbFtx5=-d||\~`HakcLuw)om<vn8[+E{{2L<Fv@[Vq&' -`Lct6N:hvlv:tw}dV.Xz9$rkwnB
YA8~_jx2}FRxd=G$t7"'5THW4Rv0G4x$HBQMB~;)fN8;xVis(CG#-'x[$E{sH/v`(.VNdte{Y{g&B mgi-06+" =+W) ubi$UUsr)WiWKXrqLoeg]<;Fs^^rNr	d\4BxF>|`mcwV1$h4r.m55P2~Df]?J0]|hpx*@JuI:WQX] T=Q #6d[dP3vit',b	C.yG?cO>t_n p v@=	JKzr98^=%QqH>T`zS8edfVe/+;W<{4YrmDk6^C42o=| SufKV I#Fn D($
 x>tZpMj/U>33L!*wilh5#*RH93&H	Q W~Dw< O q^X*F^r@A{bonygHQM
A|$m5Qne1!(}f{
uEx#s=5qmn#9?[icHu	Xs!\c|;mC{RK$HTX<5)+v'Zg.qKY[	?|1_z.w.J#)o$1L%,Ha>R<<dyV\G#8O\!<JnY8dlw<(aUp7}=p8Nrf(fMot"Ei6gzrGuE3RijA<<}+?,6oEPGE|+tHlR!U`5wcFKMQrpy4-Aot#0J&je0T.+,F |j*KBY8RGCQfny<qZ>OX;$;9>,qk7Y,& dA##yU`O
O+\GkV$L*SD.U~xUTN<7rOSV}yEsc7f[k sm6n1b?>b}K#@p?U#]?y*Tz9vH ,^LFiQ7eO\Wvxr)>x ($B,Q[FWL/L(?(IY D2:z _jNpy:Ockw\?L
rlXtnKp~yq~S5~;@?KV.~Icv7(cBW >[d\/>|bq$&3^C29t+*DT.7yrf% f+3Uq-I` FG_#Fjv4{hvk1-x	4ul}[TgnqxFqd\@ \u5M)COPUq?*;n!2HnrV[%pY4U^k @ t;.{@
#%mZs1 #oaX]j[aT`8 WUQztLn3ON	$]A=N<[iu<r9v;]BFGNx5[jr3R9e x6HS?Zq+m,<}:SW|PM9XU	>	r0rJ($AKoSe EreE6FR7 S]u,uZKo#;D8#+0mv  '?{#Fp?h!!3 A%{<Jc|=yU~2Bq|j_Kv*8Hu+tx?OnN)gYzsz VOL)>UB6A3UPb0=q<O(%^xNUsdp.Kd%F3K+ bqukV<C{M"d9_j8q FH|}:v2F6VPK}l\AqJb**{?#5[s$|`2x\}v'N(e J=FqS" Uu8{J;#DpInYEu",<]+CuV@S>|Ct+0"Q
8V#@}+A	8qDI!RIIa3L2Bw2jP(c}x3R3}us 8!I)7;wJ#<}^j:}K n iw 0gOg!b`qLS@Mqm{-Sizmsup}3HsL#'T'A0)1:6i7)9sH%-\^om [q+>~H<*%|g")~f*I@ 4]O	nA?sxI 	0H$ujK<B=HmyEB1~Ugb9H=pb'$g`=+:nF!y@VZK6UutSB-dM!oQp;FqK9<r"FLds]%SoF{Eu}]**Z?GPot<5/fH\\ crf7}Eh;)d@`LI?LV9j.[6!|lFKSFQ8$UA10]2zd7k|?.
j^#'*7GtmV;G \1
Em1A"*,jd<P	?z
"H6Csd0Rg8F1ZHUbzK]}]Dmu;Q[w4nH$iwx1\KrC1ZW6^1[.wmN_2@#. bLN@8i^^yA|*FU`LNQ szQQDHSS[L29	\dW;8 ,Zr4Yb0T6:zi$rw qI#^NBCV4S6]g&m2le##qJ^x:?R]S 9P?C+`"`mv9\#jRF'? $'cI|,7c~Vea;!T?#$OT24,HON! xs#x=k>vpJ }@UD0Vy5kB],A'{$+q9U2@'zG,$pdX:M
 NxV8)ahn '#' 29ROt@6y=:4Yf.hbv9 y q'm8O c+1JbGW
1QGli1m L`}t~8g,%cs>_H{<HSxGQ_f9J& Pz/=GgX|R U&v 0?*  z ?qpfuYI
F==(P5ivG Hxa8`]z,p";ls} we`|l-/:M?X"KC<)=?aB&H3<q^xns)JaDe`wE8?:4ZM5R\Q"A ~w>"	%Er8KixH329_*eG%2TgB_PS#:<6&i$TXG>X3-hAQrB4!YyW}HXr%G_.7HH`<k3D pV\ YI. 8~juTL"*R+QQ0k'QK &`#D(1=@Qj_#9 R(*sl@g+7+^7Pv:NnBD=um.+q#?Z)`\F8cK;b9>3`&U$XZEBqYHfGI$Ua n}f=,LpB ^C<v#1`8ZjR4oq6!?$rOSstpRK)l_:|UR5W#Cw[!Z{px9hv#MI 
9o?t7e*7w]]vO'5kDk ]f.z%l`	Y#=`O/ejOs;;8GS 8]8Of2A/ 
-IWnTu$ ] zW}*8<>kU:2|po$$6H'8<5uPD,%q8  F#$p#@x
T zyV)cZ#{($Yiz}j3.w\U}$}'9s/T[\$nCwWHU$ZjUO:qQmW)K~6>k+TU,1DSiq/D*Faf: T6zF .jCI8`gL+pB\o#'<z1hn9Y6<,sb]uZ{~o~#F}FF[T+S@Lg0pO4Dl:`0U[p":Tu@\ H89,	Xdlt#~k[g:I;Jb)dYoi]z'b.i !}(<(Fv .<+F&
R8 yq^\:<
uuV&/shI"L7tpi$ `qq\]*'Gy-F69'X6kT~ZFrB2:{U@;Ltq'$ <=q@,j2MtQz[?a|J_XA_.@HH=yB#d/JJ:)tLW6yJ5H.IZ1,as6bhdm8iRN2A. ;_<2(es8>_1My7S?fzzVMGMqN<cA,gV>{U +zl\$<|V6s0J+o(B8``p\7xxO9N: O^C9GOYMhog!Tc38;)2*S13EZ[w.2FUGZw`C.ZuGLh^9#!S14>ql;
764!#qCn..W>HIuy^ $Xt3< e9[52PU{*]#lqJ^^GAyxt^Bw9F0He,7!8J]LjdI|*xY%(&4.
_Y],{I<<s#ocU2Xzjc6R2I *G:[[H{c J{j.iyg#4ZkvH@wwk>}i(['-F+p(~|tEWoyI#	 $!iuyWcb2>|61O87J\eAS55VzmdGpAIig2f=>X* <.|r/*TrEr{qk.v#r*Y"6FCcm[f3A9U* VPGQyYX7^Cku%vrnWx<|Rf#/d+h{/IxP#V).
C1IZpl
h8TcZX';w`uKyo4]m;'qSMvY)lqMK ;z	l[8`qBur6@	uq4P0RN~tt7v-PC:ldp>XNr>p]R{CvuS<#/F_A4Bu;.1"2.=# 7Jy FO@}kU9U\(n#m[I38 *k\X.f`ft<VWjpH:imlqU!epX>
9Wzen& 39dyRv`,==~bU!wAk y|Kch-[g>1IBk`7n5f%cis2nz46rwIb6*s=sJ |=)1\1eOYv(csr8I:7hcY8?z81c'+;<D0c1Ss\7st 0~gi5g@i]kU}_S[Hw9d$ ,!sh; =F>7!b(@>}a&l
o/-qdt,,vx?gA2&sWje6iqQ/yA+fvh	?d
Lqs*h@ch>mnoJP
'f&P{ 1vhQ	di<HC>{JZk`<zy{<NI5>`m&-
H>-,V j H>#LMpN`d31'8rQWe}Yd*N
=c_vyM}cc~~tU Vys*oO%1R~U'?LZgF^pq(N<L*Cp|sDv63w8u]=;y99#
)sp*'k:-3GJ`U?HIB c$uKF$eVlzuE/cYc[<-!O@ivv52S,@C.S F`Y7Kjzc *i!' 8|$$mes/g+t9 1#\GM2F1xban3kf5VF|qV*9ld'lyRpIvH0Q'sW3ib34F8>uECx;)TK#Hu2E(VE<"8kOmCTSF$qa]Uk;!;nws>YUH.[9RpHn%H~|<<3G*R=?uZA CyG&QWFXHae
N<\\.
\n(?9cf$gogvV9\TWf;/ 5oHOFHZUD@200x&on ~(w
>{}g! TJsF]jWL#O_:vFNYX>|`i$ VwdA}WTm4f{;`pA;xl"n%sSIVRF<5BN9ST\r^]$+=	p{wJR6TI92["rq)1!awefFnjT]8T<UBAk(wO}}+:(eE~n5/d	>5n5 X,,8='TSH ){SZ2]Hh#fnT wQgHp|'<^848C$mP(h,
	Q"O*vxkWA}y\ArOj91GjQ:Y$Y G~D40aI?LVx$Q<q?[3~#%~UOs@5fu@8k}%[im2:
|+c9=pAYHT	a!%kiQ%3Aa!A?<})$j]7/;zq>|6UF!9V:.ww&J9hq]GwE
; Xg OACO1[nZf*c<:~e]0uUL"zT 3CgI.-KZQ_#~]g5w)rmq8#Qoh,/kp1,xC+RU^9 o^@}Uj65W&Zqohl-m@vTIWu*WX74G#/^_$|;5PA^irK[2U>2vEY-a E/OfxAlV"3BUnRw?f1yms(	x.l#1U!dl@h]{k^Zu/GHx *CvX`
MoDPxY 9||{39RM1mGT{-^u(0cU8 *&	 |
\L1k s56zd.m[zF\h]iST|Y+PE|Dn|c$>ZoCx9.u bm
RX16tvsRIXan^[pU'jCHyS#~
L7:d,H}*7;mx  F
[#B{OSTg+4O3i5Vcx3J@--rIqUP~U.cNe99}Kc9` <xIr % l{#`%8;FNJo~%JaCNC` m/egiyffW[ Ca,!g?z
IJSW:5  3R]>11;{R>ei
6~)H"TtVRQxH+sf{/^wHG"5U7gH`q)dyDv.YOIz/Blw|<WUk 'IZMALuxB/sO4ezD~\-0 3Kfg$rkY#rW?!Xv :Qi1*B~);O9I4Uf}wSzUoH6
 ?:/.Trme`s#xCD9$YL-}?T2_I3,@f @Rr<tMkw|o`^O,m*$YH$1ikdNlU0[8)p<-5/OOrs*Pl1H=+1|r?$EriS:k~e:yBSd$(y#F30 >qi,m-d$NzR 5dq"q,r0e\_~>]BmGJ(qNVx}j\`fM5txkRH%k8m-=rg>M|7E$~R`n_KSIX YwNpvRe
zytB9''>KyX!B_w<xBP0uJG;Zb VTNGs)k.OVIO$8zsYUa%(8 z<pxBZ3Nxer2Wt:\<jU]6E$O\Q5FF.'OWY984+CKMUgKc38DH!uw\|s$+>4g	>TZOz+sa*F.7 uTm# y:P\ Nvr2F:lhy,t81euv]W[q9qzRD$Fw* R2=1R0;=x K|[$WSW>Wv ANkwW*>;n9)f& J	ff*#'	hMb$Nj1CoK4$!<M8khF]at}R\coh8}:zW8\X(IcExxWUwMRCh]A,+r93IOj@J[!@:un.V23!2FFFEI5Hv2<satgf7CGg89c&"M19}kO/idRO	$"!8>5qZ'g,=H8u8&++FhMq,%2)?.8>Dj,>"VMe#'?}=6c}~b#N ;{tcZv-<w
 y8CAws) EA?D]\OiqASWG%[ftrPuNxAXT(?hF+UXdz6A=JF0>Y9j8LI8WElFdGwBX%3Yi ;~[Q%\w&r,EpI9>BGTr+ d{"F	b{W@"${n"s6&8|gzq<e;US<v]!lR@?va^4iSrgt_Oe<C3SbdmgcBz&I6
lk-P p>^"'oeU,6A.9>Fv;]tAx	?,\8Xgp8i:D/"OffB'g.]tC hMqQ/QH6unsa<nh,=1b>xGOy+Rq	b\R3|T+Je|FE( #8\9!;\j<<`
%]gqh=;0A=3Nns)Y[;e6zmXJKFqAgi{H5^2??*uK	eAO{;iYKw{_jtIG3|"_!}5fx 	0r+)LBw7?kl*9Na(x''8Lnd0',0?^}8oJJ-$nHd0JaOS{t?:g/ V[ooQ-W/P^wKHUstEvtKPm
I>^`5L:][+t|4G[mLwJH{9#I kTyW7%t6(  }(cW.][k^O3 }Bg:p-jS(#5	&%r2OQ:0f pg}vZlKlWh}Gg8:Vv1#d<y*>#vP16- *sAsF}K..m<$9_,$gSb-82+$u9<g_GGXki4~r\\/Zzu5Mm8?<R~J;,L``=9Ea#I+L!k8G1z;=g2Zx( .H5&;|a!Rg`Qec!'3ZGK}&)	|;>@^09)h{NY"wA
0n9m=rKx#m8R(I.do4Rb *6BP$d3XzT"]jP$&ZG+^8)9Gz35WyWA X2W?>Ug +XprHTcA c'~wE,&5ASh$v*mE&`|B>b[Y ~]j9$<-JqA  e-d	!`si8<]o#0&2 p
N?$^MdnR$P\!	T$Q]X9#.Fz YhmUqxrM
0n:{o ckfCC>,vN?\U#!erXed[E hR77Lfg{lSVQ72:WMYeRZE~=:41#XCjfh2(G '`>~$gp08KWa'N6`>$F>ipxg4UVYK(0 @zY;BqZ,!RG?\S-$B"ro`[{q	tld!R"19O_Z`;7a{.0%w^0u$<$g*wcHnZPT^vCm
V{?qX46V;b&00|'<|`7lv`?M/Pt+cwunn#Gy :K^D
>2Jq9-M(QPb8T#? OK[gv: ]z;k\x^$ nWvf2#Q'<j#27@kwX1}Q/3S@i+;FStw#i_]$2FC)NNVB<F8yXH4L)-{MH]X;ip/qf|+>[Lbc8@db%hQq=i4V:eZ1^ z ,0<g51VN  O\mT}=e)weBcc##U(sMhlel9P9},m ^[L}$IkTI$p5:cjZ\m@	ca[X"U`{'cp%'$  -/f %H_,r/S?U+oj[:N0e 19?F/jH$-mt)sMu,OMMunFU,vXb?YdeV==*PQ8$=/#pK@dd[ , #LW62=2@7r;ce/'~t;3/"}(a w`>!S'D&D.+
l?zL]D!Ns#Ny{+{jW
<n?1Ty np$oM4*)A{1}<ciiqF SsBLF6YX;, 0tzm*y==(cl]b $8 8Au\.&HAxGZ\wD^5VV>JS%	nF)[WSmsw m8k{3$7B0,sQv Jrz PO |v.T
?*;+5oxN>(;+P3:2KgV9c(kv5gIK|pvUNZN%s1_7$IgIZF3rerOchrF"SR J7)'~TdC 4N'?#V%=>Rn<!
8'v3Z;im8j$d);q@#B2[Lp38'j9G4,K93I>?9
O^`SV2v~S
	RtZ7s!T2{MEcz"*k(fP?nWGc.DtJ; Fg{vxpNZ&l!|`gsW%'>.C+u4/q {]$*E!$c|t-rFtD
42HwnB>VQ'V"s2Z.il_.~^*[P4D&
s]NbkF%aqZ^Iq79fbT6^}(1Hn?ktRJvPnb Qdq:c[y`	}BJTgsW;$HG^JG,Q$C]6:+Eq26.qGuQ$g@<$9~>hCGEX^x9^/*  -_TV;FFH}@4gdw
 \ zt]\k;R=\6+" :rcuIt<+  b	tXOl2I{Gl%BeBAOiOy$Qp_8\<1#iLL(pzB  l4
)6$uA$wgy1@1 NvI#w,,"O9<B(|%`f*$#z^IW y6]Y6 3q3AFDR\1Sur\g9v=3TOb-wa8U%+0
8iRLd$q! z4pd<*/xYv L%o"YESlut-sIlBJ1mxL_]z7'lSZkt|U(A<p~~{ayq'w+7;<iZpskn& 0z1Dn'`+;%W>`q+iFo-~>#_K$7v%%G5p YUxk9B1%']='fa8Sacri u2
!=f!rs8^WXT=AF	i6+=:yP%-1*kM@4)mVD1 Jq:CI"LW}:.2"byI7A5+i(	*C##4TIvp@!$_xXKEs,7p	xN1Yk[q$]jnX,@=#>+)28s6X@WOj$oETe`?.07/I2Gn$`1VYC={0tQ
 (gG^`VeKp%BOSU]s\[
+HrOjIUnB)[r=2[8#E*=vQ9wS_BIU3]+%93IdZNq6bjn+f2C<q#:P"`x#]G1QJpy
osC`	QsT:*6o :;!&sUeZ1</#Xz:Yx14rwzUG>VrG4O>z^,$$#9(%W20"sgQONa5r0p| " }3g%sJeXOju=Z_I,<AH85w>C2Z79xlxx&	F`$*y]!$t'99Oq[$K-xhrzR@-&2'NeAd~<TIlI!<O +CA)B6I(nH	Grz
pE~5(qFMs%	r(j(q*@#_],	\O#h;|rkb|jI$I6v+fb?Kz=$mc)N;u'xlv p ,};~DqwdukEloD'qJHdPpSy}_z+U8'w,B^1,sq5&f8qCn,srGDTyUN|hSR8/1F{Kvo s{iUBH7a=:Wq)c`(8:#~~)|q6
1,X #Y>{&M:6
ecok(:a#`v;LbU@\9{)J\&4
#VY),~.=}}2Vq9_ Z-8QV.NA`~uz4Rp& 
k[f(V9#;my^ k.+.m]+!4,c,6zg(z\LgfwQk;]OhZ3|7'p2#i#Wtvr8~cZ@XlvBS~3I#[-XILx2TXU YK<'w?^0r?]`y5 w8]8Q
q,
Gt`% Jr>:Y&#s%sONJ99<buy%Z3>b_<TN~VAxBx~UC{6@'q>PR1r)ba##UnrEI&+O!79zLHx<u$H(IR=  	ie;Yhempz9	,su9$sGJj(Nrl,M4=i6aCS%2<qD'<qyeBlc;{neqfN~y*l{#ihi?AEA@;$1aT:y(bV@DM	
"GnN@WSF Q2lF>VI")4R>]*%$`e8Rvx?*;2p)2zF F3Gvn{
`0bA''*T=O9?L;8qX0xd[VyhP?gAlu >p^4%KW}/ho?1hs:I
dB1FRY/
44yK}|'|x0r1(o/kM^x-]OvIf|4/<3>Tw\~2y;IAcp n#k{PG,xNzO+j=QyI]B5V%3(OME<D	AT[od1wRH?L^+>[GO@@O~WlzU#q9EvPHXFNy*G2T mj$[<'_RJ7\#Qgn-A0Fsk$[A+NAUqWYc~-0JVnNK1s\vQd~qIV|?B0mjmy>'pP4T?:URwAL-RP?Lu:{RgRD`qATi>MRkuybL0N@ |k&E G8?ATF'=;vH?vRVF! 0HfSZGRs.2m:f#nZI;[v[qXsg(AIaWO]b|O#R'NPM<iY}> CuSm$VX1w:T9vSiiWesI>$n`sE'F4nMn'UXBm+:Hcppg]R	e%/vI	?Z);g3[Y9SAJ4RvX;%`=?O?bVHm2(C}p81fjQ{e	psw~.8ORMgVa>za*{U9@<W=ngiu6G' Y;L;hE{K`~l$%HVb\H{yD%w;;~EyWPo@ Vr@_0/'$O(_;]ii0}RMbh$R0dq5dMQGhn=cVl?c?`hx2 ]/c `{~cjP=z(+k{(
39Oqsw aMJ 'Dl? +-}'Yb8I \2 k.m^L1;E_sZNnnB0'p{1Raiv%y( q$7^ 0rH|zT0/k"Wy e~ Zof ,}J [eFb8S?LWW?j&2hOd bjPOg.wiifJTx`Oz <is*5Y H?2OXOksZIpJ%si/MKXl?#V:Tl- ?cP5vKTFm}yKv{b#$?XoS\vI>k,>lTMX_{c w @0icykR7-vi`yj}UJ Gu b5 Jk@d;EnK},7~u N\B#J Kki#OC /m:/o= '?Z j0KzYnY.ftP"H^>9 FRjI7_dc.+BkDs'-f*Q5K^]LPU`%G
Cm c<	|K?6OekMEV^9o.yyT3I?lV?g4%7 {c$qE$gYmR?^,Qcj$!+jW7riGRi^\}mR9V{4MwpG@G4bW5j0]wvs yj  %9Q,l@>0+pMoq1OU'>z >[X J4Tf]]E}o
#'9Ax-RD}P1W?s1mf|Q *F^MvSGQ T~W [UYYi6M%Bxop'MvQ9]yJ}+TK m
 ^j
I| UYz7\x}0cF +aW (\/F9vPpI$~_gVFkO,:x {l YiFP\gcdw^O_VYUG?+R(5uA&E/jc[ J8E5 \mu: YzgCHms*;uFAH-o
u(wh-n {qo*A2 Zr`'\ UYYxfY?mIc# EJh1+%?'oTEQmdB7 g /RCw#vUb6j 
7 ]ot ,6# JWwX??Mj6Ga??bV]~M]^<ZX9 C7mumi *l8oFr %b$\lz fQ>?fk_&-4d]1h[	FCzpejSA0YnQ?vSvVRf?;\FW0mLFeQ''$s W hZN-# eQX?U05bMPsV^@%jj[!A t /YnDX3'G# n(I rXl^ hz[Yn n5<-mTp2ic&u+\zlo
VxwV8+gjL}H<rQ*{}(qi *505n3ofq WI)
<m Vj#;hn5,m<#rTJ1gr~RJa	RJ *T	RK8HB
.qw4DydXVwbO@2eo%-9$`s]i7zojm/ JY|CG   mhJgoYvS_
>_fAeL=p TtRnJdBz:~vmnu?!M $O5vvsiRBhrJeQpI`s@KMqOs-|>[ClzH ?'jlC(!QP2OPR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PGG_IK*qH"w7sH	4 J*PR Jv{Rk+n1w#nQWK[m7f~>x Ji'fh5p#bT.
r9# WR6O!0)=9#1 t-lZV@CIPq|@
Uc=G{wD	}F:n{+|-D qlYaO~kWVXKIE$R[&TYY)VS	RJ *T	RJ *T	RJ *T `-z-snG* |ie#W?+9a6
O,|?}Mc!6tO'[v{Rl	8Dvc' Y%F3N  "_ / [Q K}g /}aP H;Q6O"Ae-]nVGC<~ h=]zIay%qqhm3Mm#$@::u -cy06>eInKEwu`WWAVF *Xx 8 ;   /G?n-6AmRXPT *7mo]ho7v#/ *5? J6q j(U+YH?s oX=cO KOoX=cU W TJWz b F*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PBm0Z3,Gj5MwR]w0 w/x_!Nk5(WzvBuvNBp]zI.mUc?x@_0t-Yw	R6G7t{[gh>0]nIo$vXq:v{ 4J3/F8iE%TKjKgokiv07,Y$>@tP>v:XN1d/lz>DzN]{i,t?uD@ylS  1?jcO_'ok@Wr,1Zd9t,A }D9d'D`pCAcKyn!R<&vckt5Xku<|>2  |kXR4(a$h
$7Zh_Zu5Ol=WT/i/4>(-)#n1X;W7M=N9<a>TZ5Jh4-i++{$oE0biRvjV4^$Dt*\R(TR%J(TR%J(TR%J(7#[ jJ/rvUk)yO_ltOP\ys2;mj7qZO3YHsxN^kYR#OT!ydD'G@: -m W jY q2Y#QE'Ci:#8[v@mi#@AWa}>2ivg1Qy?Zbzk=+..%noV;SG3$YTc
P?l;kWlmy8^BpT7F`1p  g"_? Rm 	O3qXW5kFFo6,rSj?  `E %?kS.={MyN5c G!:N&Y!Ec,6<D   jO8<( zvF}J58[4bE b,V=Z<3y 0X+k
FDk~sjF]_LxT*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@K,dKI&TW !;%ru 'px  [h:fE]m|ry5eDy6mtx}BUe;<yNGvJ+-vW lGeOJ jhEzZIm O=^mubB:<#_RvmV\B1On4&;"dp~E?* <{-k9")2B8![YcZ2}O-i6}-ioO*'j2vGR5X3Mb5c	< c)){I]is\=N,LxJ1hMa]/}/jBQm>Ups)o`MQ\$)ep?bT#@"oVBTJcFI<_{MG7~ 1{ ]7X,,qnGN
99s/h5tv]J5-TP @$eXX~Ffp}k>9KA$2u*Hx$DceHuz-SI{icqOhvA$'hcim _{i{Zerq/s>boL7uapVbHGm)W6\Gr7>yk+[Y\N!*%1p7`q(~~!Sy_x_c}g?GBUV"Bxyh.rNf*(a29GRyZ_?-l*>)u	RJ *T	RJ *T	RJ *T	RJ *T	RJ *T	RJ gOkmF&&
kvF)Ff[G
>N67s,`^G4 o  kQIU<8k_w}wM^Ms.1i*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@>-h?w,A8nY'#v=Xk*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/shapes.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="shapes.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)

  if (!Module.expectedDataFileDownloads) {
    Module.expectedDataFileDownloads = 0;
  }

  Module.expectedDataFileDownloads++;
  (function() {
    // Do not attempt to redownload the virtual filesystem data when in a pthread or a Wasm Worker context.
    if (Module['ENVIRONMENT_IS_PTHREAD'] || Module['$ww']) return;
    var loadPackage = function(metadata) {

      var PACKAGE_PATH = '';
      if (typeof window === 'object') {
        PACKAGE_PATH = window['encodeURIComponent'](window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf('/')) + '/');
      } else if (typeof process === 'undefined' && typeof location !== 'undefined') {
        // web worker
        PACKAGE_PATH = encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf('/')) + '/');
      }
      var PACKAGE_NAME = 'examples/shapes.data';
      var REMOTE_PACKAGE_BASE = 'shapes.data';
      if (typeof Module['locateFilePackage'] === 'function' && !Module['locateFile']) {
        Module['locateFile'] = Module['locateFilePackage'];
        err('warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)');
      }
      var REMOTE_PACKAGE_NAME = Module['locateFile'] ? Module['locateFile'](REMOTE_PACKAGE_BASE, '') : REMOTE_PACKAGE_BASE;
var REMOTE_PACKAGE_SIZE = metadata['remote_package_size'];

      function fetchRemotePackage(packageName, packageSize, callback, errback) {
        if (typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string') {
          require('fs').readFile(packageName, function(err, contents) {
            if (err) {
              errback(err);
            } else {
              callback(contents.buffer);
            }
          });
          return;
        }
        var xhr = new XMLHttpRequest();
        xhr.open('GET', packageName, true);
        xhr.responseType = 'arraybuffer';
        xhr.onprogress = function(event) {
          var url = packageName;
          var size = packageSize;
          if (event.total) size = event.total;
          if (event.loaded) {
            if (!xhr.addedTotal) {
              xhr.addedTotal = true;
              if (!Module.dataFileDownloads) Module.dataFileDownloads = {};
              Module.dataFileDownloads[url] = {
                loaded: event.loaded,
                total: size
              };
            } else {
              Module.dataFileDownloads[url].loaded = event.loaded;
            }
            var total = 0;
            var loaded = 0;
            var num = 0;
            for (var download in Module.dataFileDownloads) {
            var data = Module.dataFileDownloads[download];
              total += data.total;
              loaded += data.loaded;
              num++;
            }
            total = Math.ceil(total * Module.expectedDataFileDownloads/num);
            if (Module['setStatus']) Module['setStatus'](`Downloading data... (${loaded}/${total})`);
          } else if (!Module.dataFileDownloads) {
            if (Module['setStatus']) Module['setStatus']('Downloading data...');
          }
        };
        xhr.onerror = function(event) {
          throw new Error("NetworkError for: " + packageName);
        }
        xhr.onload = function(event) {
          if (xhr.status == 200 || xhr.status == 304 || xhr.status == 206 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            var packageData = xhr.response;
            callback(packageData);
          } else {
            throw new Error(xhr.statusText + " : " + xhr.responseURL);
          }
        };
        xhr.send(null);
      };

      function handleError(error) {
        console.error('package error:', error);
      };

      var fetchedCallback = null;
      var fetched = Module['getPreloadedPackage'] ? Module['getPreloadedPackage'](REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null;

      if (!fetched) fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, function(data) {
        if (fetchedCallback) {
          fetchedCallback(data);
          fetchedCallback = null;
        } else {
          fetched = data;
        }
      }, handleError);

    function runWithFS() {

      function assert(check, msg) {
        if (!check) throw msg + new Error().stack;
      }
Module['FS_createPath']("/", "examples", true, true);

      /** @constructor */
      function DataRequest(start, end, audio) {
        this.start = start;
        this.end = end;
        this.audio = audio;
      }
      DataRequest.prototype = {
        requests: {},
        open: function(mode, name) {
          this.name = name;
          this.requests[name] = this;
          Module['addRunDependency'](`fp ${this.name}`);
        },
        send: function() {},
        onload: function() {
          var byteArray = this.byteArray.subarray(this.start, this.end);
          this.finish(byteArray);
        },
        finish: function(byteArray) {
          var that = this;
          // canOwn this data in the filesystem, it is a slide into the heap that will never change
          Module['FS_createDataFile'](this.name, null, byteArray, true, true, true);
          Module['removeRunDependency'](`fp ${that.name}`);
          this.requests[this.name] = null;
        }
      };

      var files = metadata['files'];
      for (var i = 0; i < files.length; ++i) {
        new DataRequest(files[i]['start'], files[i]['end'], files[i]['audio'] || 0).open('GET', files[i]['filename']);
      }

      function processPackageData(arrayBuffer) {
        assert(arrayBuffer, 'Loading data file failed.');
        assert(arrayBuffer.constructor.name === ArrayBuffer.name, 'bad input to processPackageData');
        var byteArray = new Uint8Array(arrayBuffer);
        var curr;
        // Reuse the bytearray from the XHR as the source for file reads.
          DataRequest.prototype.byteArray = byteArray;
          var files = metadata['files'];
          for (var i = 0; i < files.length; ++i) {
            DataRequest.prototype.requests[files[i].filename].onload();
          }          Module['removeRunDependency']('datafile_examples/shapes.data');

      };
      Module['addRunDependency']('datafile_examples/shapes.data');

      if (!Module.preloadResults) Module.preloadResults = {};

      Module.preloadResults[PACKAGE_NAME] = {fromCache: false};
      if (fetched) {
        processPackageData(fetched);
        fetched = null;
      } else {
        fetchedCallback = processPackageData;
      }

    }
    if (Module['calledRun']) {
      runWithFS();
    } else {
      if (!Module['preRun']) Module['preRun'] = [];
      Module["preRun"].push(runWithFS); // FS is not initialized yet, wait for it
    }

    }
    loadPackage({"files": [{"filename": "/examples/RFont.h", "start": 0, "end": 120577}, {"filename": "/examples/RGFW.h", "start": 120577, "end": 411143}, {"filename": "/examples/doom-like.c", "start": 411143, "end": 415545}, {"filename": "/examples/doom-like.html", "start": 415545, "end": 417385}, {"filename": "/examples/raycaster.c", "start": 417385, "end": 423925}, {"filename": "/examples/raycaster.html", "start": 423925, "end": 425765}, {"filename": "/examples/shapes.c", "start": 425765, "end": 427870}, {"filename": "/examples/shapes.html", "start": 427870, "end": 429704}, {"filename": "/examples/stb_image.h", "start": 429704, "end": 709056}, {"filename": "/examples/tex.jpg", "start": 709056, "end": 733664}, {"filename": "/examples/text.c", "start": 733664, "end": 737136}, {"filename": "/examples/textures.c", "start": 737136, "end": 739636}, {"filename": "/examples/textures.html", "start": 739636, "end": 741474}, {"filename": "/examples/wall.jpg", "start": 741474, "end": 782701}, {"filename": "/examples/wall2.jpg", "start": 782701, "end": 1083261}], "remote_package_size": 1083261});

  })();


    // All the pre-js content up to here must remain later on, we need to run
    // it.
    if (Module['ENVIRONMENT_IS_PTHREAD'] || Module['$ww']) Module['preRun'] = [];
    var necessaryPreJSTasks = Module['preRun'].slice();
  
    if (!Module['preRun']) throw 'Module.preRun should exist because file support used it; did a pre-js delete it?';
    necessaryPreJSTasks.forEach(function(task) {
      if (Module['preRun'].indexOf(task) < 0) throw 'All preRun tasks that exist before user pre-js code should remain after; did you replace Module or modify Module.preRun?';
    });
  

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');
}

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary;

if (ENVIRONMENT_IS_NODE) {
  if (typeof process == 'undefined' || !process.release || process.release.name !== 'node') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  var nodeVersion = process.versions.node;
  var numericVersion = nodeVersion.split('.').slice(0, 3);
  numericVersion = (numericVersion[0] * 10000) + (numericVersion[1] * 100) + (numericVersion[2].split('-')[0] * 1);
  var minVersion = 160000;
  if (numericVersion < 160000) {
    throw new Error('This emscripten-generated code requires node v16.0.0 (detected v' + nodeVersion + ')');
  }

  // `require()` is no-op in an ESM module, use `createRequire()` to construct
  // the require()` function.  This is only necessary for multi-environment
  // builds, `-sENVIRONMENT=node` emits a static import declaration instead.
  // TODO: Swap all `require()`'s with `import()`'s?
  // These modules will usually be used on Node.js. Load them eagerly to avoid
  // the complexity of lazy-loading.
  var fs = require('fs');
  var nodePath = require('path');

  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = nodePath.dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }

// include: node_shell_read.js
read_ = (filename, binary) => {
  // We need to re-wrap `file://` strings to URLs. Normalizing isn't
  // necessary in that case, the path should already be absolute.
  filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
  return fs.readFileSync(filename, binary ? undefined : 'utf8');
};

readBinary = (filename) => {
  var ret = read_(filename, true);
  if (!ret.buffer) {
    ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
};

readAsync = (filename, onload, onerror, binary = true) => {
  // See the comment in the `read_` function.
  filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
  fs.readFile(filename, binary ? undefined : 'utf8', (err, data) => {
    if (err) onerror(err);
    else onload(binary ? data.buffer : data);
  });
};
// end include: node_shell_read.js
  if (!Module['thisProgram'] && process.argv.length > 1) {
    thisProgram = process.argv[1].replace(/\\/g, '/');
  }

  arguments_ = process.argv.slice(2);

  if (typeof module != 'undefined') {
    module['exports'] = Module;
  }

  process.on('uncaughtException', (ex) => {
    // suppress ExitStatus exceptions from showing an error
    if (ex !== 'unwind' && !(ex instanceof ExitStatus) && !(ex.context instanceof ExitStatus)) {
      throw ex;
    }
  });

  quit_ = (status, toThrow) => {
    process.exitCode = status;
    throw toThrow;
  };

} else
if (ENVIRONMENT_IS_SHELL) {

  if ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  if (typeof read != 'undefined') {
    read_ = read;
  }

  readBinary = (f) => {
    if (typeof readbuffer == 'function') {
      return new Uint8Array(readbuffer(f));
    }
    let data = read(f, 'binary');
    assert(typeof data == 'object');
    return data;
  };

  readAsync = (f, onload, onerror) => {
    setTimeout(() => onload(readBinary(f)));
  };

  if (typeof clearTimeout == 'undefined') {
    globalThis.clearTimeout = (id) => {};
  }

  if (typeof setTimeout == 'undefined') {
    // spidermonkey lacks setTimeout but we use it above in readAsync.
    globalThis.setTimeout = (f) => (typeof f == 'function') ? f() : abort();
  }

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit == 'function') {
    quit_ = (status, toThrow) => {
      // Unlike node which has process.exitCode, d8 has no such mechanism. So we
      // have no way to set the exit code and then let the program exit with
      // that code when it naturally stops running (say, when all setTimeouts
      // have completed). For that reason, we must call `quit` - the only way to
      // set the exit code - but quit also halts immediately.  To increase
      // consistency with node (and the web) we schedule the actual quit call
      // using a setTimeout to give the current stack and any exception handlers
      // a chance to run.  This enables features such as addOnPostRun (which
      // expected to be able to run code after main returns).
      setTimeout(() => {
        if (!(toThrow instanceof ExitStatus)) {
          let toLog = toThrow;
          if (toThrow && typeof toThrow == 'object' && toThrow.stack) {
            toLog = [toThrow, toThrow.stack];
          }
          err(`exiting due to exception: ${toLog}`);
        }
        quit(status);
      });
      throw toThrow;
    };
  }

  if (typeof print != 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console == 'undefined') console = /** @type{!Console} */({});
    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr != 'undefined' ? printErr : print);
  }

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {
// include: web_or_worker_shell_read.js
read_ = (url) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.responseType = 'arraybuffer';
      xhr.send(null);
      return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }

// end include: web_or_worker_shell_read.js
  }
} else
{
  throw new Error('environment detection error');
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.error.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;
checkIncomingModuleAPI();

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');

if (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');

if (Module['quit']) quit_ = Module['quit'];legacyModuleProp('quit', 'quit_');

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');
assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');
assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
legacyModuleProp('asm', 'wasmExports');
legacyModuleProp('read', 'read_');
legacyModuleProp('readAsync', 'readAsync');
legacyModuleProp('readBinary', 'readBinary');
legacyModuleProp('setWindowTitle', 'setWindowTitle');
var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';
var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';
var FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';
var ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';
var JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';
var OPFS = 'OPFS is no longer included by default; build with -lopfs.js';

var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';

assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");


// end include: shell.js
// include: preamble.js
// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary; 
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');

if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}

// include: base64Utils.js
// Converts a string of base64 into a byte array (Uint8Array).
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE != 'undefined' && ENVIRONMENT_IS_NODE) {
    var buf = Buffer.from(s, 'base64');
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
  }

  var decoded = atob(s);
  var bytes = new Uint8Array(decoded.length);
  for (var i = 0 ; i < decoded.length ; ++i) {
    bytes[i] = decoded.charCodeAt(i);
  }
  return bytes;
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}
// end include: base64Utils.js
// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we
// don't define it at all in release modes.  This matches the behaviour of
// MINIMAL_RUNTIME.
// TODO(sbc): Make this the default even without STRICT enabled.
/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed' + (text ? ': ' + text : ''));
  }
}

// We used to include malloc/free by default in the past. Show a helpful error in
// builds with assertions.

// Memory management

var HEAP,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

function updateMemoryViews() {
  var b = wasmMemory.buffer;
  Module['HEAP8'] = HEAP8 = new Int8Array(b);
  Module['HEAP16'] = HEAP16 = new Int16Array(b);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
  Module['HEAP32'] = HEAP32 = new Int32Array(b);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
}

assert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time')

assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,
       'JS engine does not provide full typed array support');

// If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
assert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');
assert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');

// include: runtime_stack_check.js
// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  var max = _emscripten_stack_get_end();
  assert((max & 3) == 0);
  // If the stack ends at address zero we write our cookies 4 bytes into the
  // stack.  This prevents interference with SAFE_HEAP and ASAN which also
  // monitor writes to address zero.
  if (max == 0) {
    max += 4;
  }
  // The stack grow downwards towards _emscripten_stack_get_end.
  // We write cookies to the final two words in the stack and detect if they are
  // ever overwritten.
  HEAPU32[((max)>>2)] = 0x02135467;
  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  HEAPU32[((0)>>2)] = 1668509029;
}

function checkStackCookie() {
  if (ABORT) return;
  var max = _emscripten_stack_get_end();
  // See writeStackCookie().
  if (max == 0) {
    max += 4;
  }
  var cookie1 = HEAPU32[((max)>>2)];
  var cookie2 = HEAPU32[(((max)+(4))>>2)];
  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {
    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
  }
  // Also test the global address 0 for integrity.
  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {
    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
  }
}
// end include: runtime_stack_check.js
// include: runtime_assertions.js
// Endianness check
(function() {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';
})();

// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;

function preRun() {
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  assert(!runtimeInitialized);
  runtimeInitialized = true;

  checkStackCookie();

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  checkStackCookie();
  
  callRuntimeCallbacks(__ATMAIN__);
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
}

function addRunDependency(id) {
  runDependencies++;

  Module['monitorRunDependencies']?.(runDependencies);

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(() => {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err(`dependency: ${dep}`);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;

  Module['monitorRunDependencies']?.(runDependencies);

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  Module['onAbort']?.(what);

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  if (what.indexOf('RuntimeError: unreachable') >= 0) {
    what += '. "unreachable" may be due to ASYNCIFY_STACK_SIZE not being large enough (try increasing it)';
  }

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // defintion for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// include: memoryprofiler.js
// end include: memoryprofiler.js
// include: URIUtils.js
// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

/**
 * Indicates whether filename is a base64 data URI.
 * @noinline
 */
var isDataURI = (filename) => filename.startsWith(dataURIPrefix);

/**
 * Indicates whether filename is delivered via file protocol (as opposed to http/https)
 * @noinline
 */
var isFileURI = (filename) => filename.startsWith('file://');
// end include: URIUtils.js
function createExportWrapper(name) {
  return function() {
    assert(runtimeInitialized, `native function \`${name}\` called before runtime initialization`);
    var f = wasmExports[name];
    assert(f, `exported native function \`${name}\` not found`);
    return f.apply(null, arguments);
  };
}

// include: runtime_exceptions.js
// end include: runtime_exceptions.js
var wasmBinaryFile;
  wasmBinaryFile = 'shapes.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinarySync(file) {
  if (file == wasmBinaryFile && wasmBinary) {
    return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
    return readBinary(file);
  }
  throw "both async and sync fetching of the wasm failed";
}

function getBinaryPromise(binaryFile) {
  // If we don't have the binary yet, try to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary
      && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
      && !isFileURI(binaryFile)
    ) {
      return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + binaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(() => getBinarySync(binaryFile));
    }
    else if (readAsync) {
      // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))), reject)
      });
    }
  }

  // Otherwise, getBinarySync should be able to get it synchronously
  return Promise.resolve().then(() => getBinarySync(binaryFile));
}

function instantiateArrayBuffer(binaryFile, imports, receiver) {
  return getBinaryPromise(binaryFile).then((binary) => {
    return WebAssembly.instantiate(binary, imports);
  }).then((instance) => {
    return instance;
  }).then(receiver, (reason) => {
    err(`failed to asynchronously prepare wasm: ${reason}`);

    // Warn on some common problems.
    if (isFileURI(wasmBinaryFile)) {
      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);
    }
    abort(reason);
  });
}

function instantiateAsync(binary, binaryFile, imports, callback) {
  if (!binary &&
      typeof WebAssembly.instantiateStreaming == 'function' &&
      !isDataURI(binaryFile) &&
      // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
      !isFileURI(binaryFile) &&
      // Avoid instantiateStreaming() on Node.js environment for now, as while
      // Node.js v18.1.0 implements it, it does not have a full fetch()
      // implementation yet.
      //
      // Reference:
      //   https://github.com/emscripten-core/emscripten/pull/16917
      !ENVIRONMENT_IS_NODE &&
      typeof fetch == 'function') {
    return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {
      // Suppress closure warning here since the upstream definition for
      // instantiateStreaming only allows Promise<Repsponse> rather than
      // an actual Response.
      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
      /** @suppress {checkTypes} */
      var result = WebAssembly.instantiateStreaming(response, imports);

      return result.then(
        callback,
        function(reason) {
          // We expect the most common failure cause to be a bad MIME type for the binary,
          // in which case falling back to ArrayBuffer instantiation should work.
          err(`wasm streaming compile failed: ${reason}`);
          err('falling back to ArrayBuffer instantiation');
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
    });
  }
  return instantiateArrayBuffer(binaryFile, imports, callback);
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': wasmImports,
    'wasi_snapshot_preview1': wasmImports,
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    wasmExports = instance.exports;

    wasmExports = Asyncify.instrumentWasmExports(wasmExports);

    

    wasmMemory = wasmExports['memory'];
    
    assert(wasmMemory, "memory not found in wasm exports");
    // This assertion doesn't hold when emscripten is run in --post-link
    // mode.
    // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.
    //assert(wasmMemory.buffer.byteLength === 16777216);
    updateMemoryViews();

    addOnInit(wasmExports['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');
    return wasmExports;
  }
  // wait for the pthread pool (if any)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above PTHREADS-enabled path.
    receiveInstance(result['instance']);
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to
  // run the instantiation parallel to any other async startup actions they are
  // performing.
  // Also pthreads and wasm workers initialize the wasm instance through this
  // path.
  if (Module['instantiateWasm']) {

    try {
      return Module['instantiateWasm'](info, receiveInstance);
    } catch(e) {
      err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
    }
  }

  instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
  return {}; // no exports yet; we'll fill them in later
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// include: runtime_debug.js
function legacyModuleProp(prop, newName, incomming=true) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      get() {
        let extra = incomming ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)' : '';
        abort(`\`Module.${prop}\` has been replaced by \`${newName}\`` + extra);

      }
    });
  }
}

function ignoredModuleProp(prop) {
  if (Object.getOwnPropertyDescriptor(Module, prop)) {
    abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
  }
}

// forcing the filesystem exports a few things by default
function isExportedByForceFilesystem(name) {
  return name === 'FS_createPath' ||
         name === 'FS_createDataFile' ||
         name === 'FS_createPreloadedFile' ||
         name === 'FS_unlink' ||
         name === 'addRunDependency' ||
         // The old FS has some functionality that WasmFS lacks.
         name === 'FS_createLazyFile' ||
         name === 'FS_createDevice' ||
         name === 'removeRunDependency';
}

function missingGlobal(sym, msg) {
  if (typeof globalThis !== 'undefined') {
    Object.defineProperty(globalThis, sym, {
      configurable: true,
      get() {
        warnOnce(`\`${sym}\` is not longer defined by emscripten. ${msg}`);
        return undefined;
      }
    });
  }
}

missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');
missingGlobal('asm', 'Please use wasmExports instead');

function missingLibrarySymbol(sym) {
  if (typeof globalThis !== 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
    Object.defineProperty(globalThis, sym, {
      configurable: true,
      get() {
        // Can't `abort()` here because it would break code that does runtime
        // checks.  e.g. `if (typeof SDL === 'undefined')`.
        var msg = `\`${sym}\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;
        // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in
        // library.js, which means $name for a JS name with no prefix, or name
        // for a JS name like _name.
        var librarySymbol = sym;
        if (!librarySymbol.startsWith('_')) {
          librarySymbol = '$' + sym;
        }
        msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;
        if (isExportedByForceFilesystem(sym)) {
          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
        }
        warnOnce(msg);
        return undefined;
      }
    });
  }
  // Any symbol that is not included from the JS libary is also (by definition)
  // not exported on the Module object.
  unexportedRuntimeSymbol(sym);
}

function unexportedRuntimeSymbol(sym) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Object.defineProperty(Module, sym, {
      configurable: true,
      get() {
        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;
        if (isExportedByForceFilesystem(sym)) {
          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
        }
        abort(msg);
      }
    });
  }
}

// Used by XXXXX_DEBUG settings to output debug messages.
function dbg(text) {
  // TODO(sbc): Make this configurable somehow.  Its not always convenient for
  // logging to show up as warnings.
  console.warn.apply(console, arguments);
}
// end include: runtime_debug.js
// === Body ===

var ASM_CONSTS = {
  70580: () => { Module.useWebGL = true; GLImmediate.init(); },  
 70626: () => { var canvas = document.getElementById('canvas'); canvas.addEventListener('drop', function(e) { e.preventDefault(); if (e.dataTransfer.file < 0) return; var filenamesArray = []; var count = e.dataTransfer.files.length; var drop_dir = '.rgfw_dropped_files'; Module._RGFW_mkdir(drop_dir); for (var i = 0; i < count; i++) { var file = e.dataTransfer.files[i]; var path = '/' + drop_dir + '/' + file.name.replace("//", '_'); var reader = new FileReader(); reader.onloadend = (e) => { if (reader.readyState != 2) { out('failed to read dropped file: '+file.name+': '+reader.error); } else { var data = e.target.result; _RGFW_writeFile(path, new Uint8Array(data), file.size); } }; reader.readAsArrayBuffer(file); var filename = stringToNewUTF8(path); filenamesArray.push(filename); Module._RGFW_makeSetValue(i, filename); } Module._Emscripten_onDrop(count); for (var i = 0; i < count; ++i) { _free(filenamesArray[i]); } }, true); canvas.addEventListener('dragover', function(e) { e.preventDefault(); return false; }, true); },  
 71645: () => { return window.innerWidth; },  
 71675: () => { return window.innerHeight; },  
 71706: () => { document.getElementById('canvas').style.cursor = 'none'; },  
 71763: ($0) => { document.getElementById("canvas").style.cursor = UTF8ToString($0); }
};


// end include: preamble.js

  /** @constructor */
  function ExitStatus(status) {
      this.name = 'ExitStatus';
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }

  var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        // Pass the module as the first argument.
        callbacks.shift()(Module);
      }
    };

  
    /**
     * @param {number} ptr
     * @param {string} type
     */
  function getValue(ptr, type = 'i8') {
    if (type.endsWith('*')) type = '*';
    switch (type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': abort('to do getValue(i64) use WASM_BIGINT');
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      case '*': return HEAPU32[((ptr)>>2)];
      default: abort(`invalid type for getValue: ${type}`);
    }
  }

  var noExitRuntime = Module['noExitRuntime'] || true;

  var ptrToString = (ptr) => {
      assert(typeof ptr === 'number');
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      ptr >>>= 0;
      return '0x' + ptr.toString(16).padStart(8, '0');
    };

  
    /**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */
  function setValue(ptr, value, type = 'i8') {
    if (type.endsWith('*')) type = '*';
    switch (type) {
      case 'i1': HEAP8[((ptr)>>0)] = value; break;
      case 'i8': HEAP8[((ptr)>>0)] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': abort('to do setValue(i64) use WASM_BIGINT');
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      case '*': HEAPU32[((ptr)>>2)] = value; break;
      default: abort(`invalid type for setValue: ${type}`);
    }
  }

  var warnOnce = (text) => {
      warnOnce.shown ||= {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;
        err(text);
      }
    };

  var PATH = {
  isAbs:(path) => path.charAt(0) === '/',
  splitPath:(filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
  normalizeArray:(parts, allowAboveRoot) => {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },
  normalize:(path) => {
        var isAbsolute = PATH.isAbs(path),
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },
  dirname:(path) => {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
  basename:(path) => {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },
  join:function() {
        var paths = Array.prototype.slice.call(arguments);
        return PATH.normalize(paths.join('/'));
      },
  join2:(l, r) => PATH.normalize(l + '/' + r),
  };
  
  var initRandomFill = () => {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        // for modern web browsers
        return (view) => crypto.getRandomValues(view);
      } else
      if (ENVIRONMENT_IS_NODE) {
        // for nodejs with or without crypto support included
        try {
          var crypto_module = require('crypto');
          var randomFillSync = crypto_module['randomFillSync'];
          if (randomFillSync) {
            // nodejs with LTS crypto support
            return (view) => crypto_module['randomFillSync'](view);
          }
          // very old nodejs with the original crypto API
          var randomBytes = crypto_module['randomBytes'];
          return (view) => (
            view.set(randomBytes(view.byteLength)),
            // Return the original view to match modern native implementations.
            view
          );
        } catch (e) {
          // nodejs doesn't have crypto support
        }
      }
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };");
    };
  var randomFill = (view) => {
      // Lazily init on the first invocation.
      return (randomFill = initRandomFill())(view);
    };
  
  
  
  var PATH_FS = {
  resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },
  relative:(from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      },
  };
  
  
  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;
  
    /**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number} idx
     * @param {number=} maxBytesToRead
     * @return {string}
     */
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      // TextDecoder needs to know the byte length in advance, it doesn't stop on
      // null terminator by itself.  Also, use the length info to avoid running tiny
      // strings through TextDecoder, since .subarray() allocates garbage.
      // (As a tiny code save trick, compare endPtr against endIdx using a negation,
      // so that undefined means Infinity)
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
  
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = '';
      // If building with TextDecoder, we have already computed the string length
      // above, so test loop end condition against that
      while (idx < endPtr) {
        // For UTF8 byte structure, see:
        // http://en.wikipedia.org/wiki/UTF-8#Description
        // https://www.ietf.org/rfc/rfc2279.txt
        // https://tools.ietf.org/html/rfc3629
        var u0 = heapOrArray[idx++];
        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 0xF0) == 0xE0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
        }
  
        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        }
      }
      return str;
    };
  
  var FS_stdin_getChar_buffer = [];
  
  var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var c = str.charCodeAt(i); // possibly a lead surrogate
        if (c <= 0x7F) {
          len++;
        } else if (c <= 0x7FF) {
          len += 2;
        } else if (c >= 0xD800 && c <= 0xDFFF) {
          len += 4; ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
  
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);
      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
      // undefined and false each don't write out any bytes.
      if (!(maxBytesToWrite > 0))
        return 0;
  
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
        // and https://www.ietf.org/rfc/rfc2279.txt
        // and https://tools.ietf.org/html/rfc3629
        var u = str.charCodeAt(i); // possibly a lead surrogate
        if (u >= 0xD800 && u <= 0xDFFF) {
          var u1 = str.charCodeAt(++i);
          u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
        }
        if (u <= 0x7F) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 0x7FF) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 0xC0 | (u >> 6);
          heap[outIdx++] = 0x80 | (u & 63);
        } else if (u <= 0xFFFF) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 0xE0 | (u >> 12);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
          heap[outIdx++] = 0xF0 | (u >> 18);
          heap[outIdx++] = 0x80 | ((u >> 12) & 63);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        }
      }
      // Null-terminate the pointer to the buffer.
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
  /** @type {function(string, boolean=, number=)} */
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
      if (!FS_stdin_getChar_buffer.length) {
        var result = null;
        if (ENVIRONMENT_IS_NODE) {
          // we will read data by chunks of BUFSIZE
          var BUFSIZE = 256;
          var buf = Buffer.alloc(BUFSIZE);
          var bytesRead = 0;
  
          // For some reason we must suppress a closure warning here, even though
          // fd definitely exists on process.stdin, and is even the proper way to
          // get the fd of stdin,
          // https://github.com/nodejs/help/issues/2136#issuecomment-523649904
          // This started to happen after moving this logic out of library_tty.js,
          // so it is related to the surrounding code in some unclear manner.
          /** @suppress {missingProperties} */
          var fd = process.stdin.fd;
  
          try {
            bytesRead = fs.readSync(fd, buf);
          } catch(e) {
            // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
            // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
            if (e.toString().includes('EOF')) bytesRead = 0;
            else throw e;
          }
  
          if (bytesRead > 0) {
            result = buf.slice(0, bytesRead).toString('utf-8');
          } else {
            result = null;
          }
        } else
        if (typeof window != 'undefined' &&
          typeof window.prompt == 'function') {
          // Browser.
          result = window.prompt('Input: ');  // returns null on cancel
          if (result !== null) {
            result += '\n';
          }
        } else if (typeof readline == 'function') {
          // Command line.
          result = readline();
          if (result !== null) {
            result += '\n';
          }
        }
        if (!result) {
          return null;
        }
        FS_stdin_getChar_buffer = intArrayFromString(result, true);
      }
      return FS_stdin_getChar_buffer.shift();
    };
  var TTY = {
  ttys:[],
  init() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process.stdin.setEncoding('utf8');
        // }
      },
  shutdown() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process.stdin.pause();
        // }
      },
  register(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
  stream_ops:{
  open(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
  close(stream) {
          // flush any pending line data
          stream.tty.ops.fsync(stream.tty);
        },
  fsync(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
  read(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
  write(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        },
  },
  default_tty_ops:{
  get_char(tty) {
          return FS_stdin_getChar();
        },
  put_char(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },
  fsync(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
  ioctl_tcgets(tty) {
          // typical setting
          return {
            c_iflag: 25856,
            c_oflag: 5,
            c_cflag: 191,
            c_lflag: 35387,
            c_cc: [
              0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00,
              0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ]
          };
        },
  ioctl_tcsets(tty, optional_actions, data) {
          // currently just ignore
          return 0;
        },
  ioctl_tiocgwinsz(tty) {
          return [24, 80];
        },
  },
  default_tty1_ops:{
  put_char(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
  fsync(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
  },
  };
  
  
  var zeroMemory = (address, size) => {
      HEAPU8.fill(0, address, address + size);
      return address;
    };
  
  var alignMemory = (size, alignment) => {
      assert(alignment, "alignment argument is required");
      return Math.ceil(size / alignment) * alignment;
    };
  var mmapAlloc = (size) => {
      abort('internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported');
    };
  var MEMFS = {
  ops_table:null,
  mount(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },
  createNode(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        MEMFS.ops_table ||= {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },
  getFileDataAsTypedArray(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },
  expandFileStorage(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },
  resizeFileStorage(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },
  node_ops:{
  getattr(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
  setattr(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
  lookup(parent, name) {
          throw FS.genericErrors[44];
        },
  mknod(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
  rename(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },
  unlink(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
  rmdir(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
  readdir(node) {
          var entries = ['.', '..'];
          for (var key of Object.keys(node.contents)) {
            entries.push(key);
          }
          return entries;
        },
  symlink(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },
  readlink(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        },
  },
  stream_ops:{
  read(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },
  write(stream, buffer, offset, length, position, canOwn) {
          // The data buffer should be a typed array view
          assert(!(buffer instanceof ArrayBuffer));
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              assert(position === 0, 'canOwn must imply no weird position inside the file');
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
  llseek(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
  allocate(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },
  mmap(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the
            // buffer we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr, allocated };
        },
  msync(stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        },
  },
  };
  
  /** @param {boolean=} noRunDep */
  var asyncLoad = (url, onload, onerror, noRunDep) => {
      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : '';
      readAsync(url, (arrayBuffer) => {
        assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, (event) => {
        if (onerror) {
          onerror();
        } else {
          throw `Loading data file "${url}" failed.`;
        }
      });
      if (dep) addRunDependency(dep);
    };
  
  
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
    };
  
  var preloadPlugins = Module['preloadPlugins'] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
      // Ensure plugins are ready.
      if (typeof Browser != 'undefined') Browser.init();
  
      var handled = false;
      preloadPlugins.forEach((plugin) => {
        if (handled) return;
        if (plugin['canHandle'](fullname)) {
          plugin['handle'](byteArray, fullname, finish, onerror);
          handled = true;
        }
      });
      return handled;
    };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
      // TODO we should allow people to just pass in a complete filename instead
      // of parent and name being that we just join them anyways
      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
      var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname
      function processData(byteArray) {
        function finish(byteArray) {
          preFinish?.();
          if (!dontCreateFile) {
            FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
          }
          onload?.();
          removeRunDependency(dep);
        }
        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
          onerror?.();
          removeRunDependency(dep);
        })) {
          return;
        }
        finish(byteArray);
      }
      addRunDependency(dep);
      if (typeof url == 'string') {
        asyncLoad(url, processData, onerror);
      } else {
        processData(url);
      }
    };
  
  var FS_modeStringToFlags = (str) => {
      var flagModes = {
        'r': 0,
        'r+': 2,
        'w': 512 | 64 | 1,
        'w+': 512 | 64 | 2,
        'a': 1024 | 64 | 1,
        'a+': 1024 | 64 | 2,
      };
      var flags = flagModes[str];
      if (typeof flags == 'undefined') {
        throw new Error(`Unknown file open mode: ${str}`);
      }
      return flags;
    };
  
  var FS_getMode = (canRead, canWrite) => {
      var mode = 0;
      if (canRead) mode |= 292 | 73;
      if (canWrite) mode |= 146;
      return mode;
    };
  
  
  
  
  var ERRNO_MESSAGES = {
  0:"Success",
  1:"Arg list too long",
  2:"Permission denied",
  3:"Address already in use",
  4:"Address not available",
  5:"Address family not supported by protocol family",
  6:"No more processes",
  7:"Socket already connected",
  8:"Bad file number",
  9:"Trying to read unreadable message",
  10:"Mount device busy",
  11:"Operation canceled",
  12:"No children",
  13:"Connection aborted",
  14:"Connection refused",
  15:"Connection reset by peer",
  16:"File locking deadlock error",
  17:"Destination address required",
  18:"Math arg out of domain of func",
  19:"Quota exceeded",
  20:"File exists",
  21:"Bad address",
  22:"File too large",
  23:"Host is unreachable",
  24:"Identifier removed",
  25:"Illegal byte sequence",
  26:"Connection already in progress",
  27:"Interrupted system call",
  28:"Invalid argument",
  29:"I/O error",
  30:"Socket is already connected",
  31:"Is a directory",
  32:"Too many symbolic links",
  33:"Too many open files",
  34:"Too many links",
  35:"Message too long",
  36:"Multihop attempted",
  37:"File or path name too long",
  38:"Network interface is not configured",
  39:"Connection reset by network",
  40:"Network is unreachable",
  41:"Too many open files in system",
  42:"No buffer space available",
  43:"No such device",
  44:"No such file or directory",
  45:"Exec format error",
  46:"No record locks available",
  47:"The link has been severed",
  48:"Not enough core",
  49:"No message of desired type",
  50:"Protocol not available",
  51:"No space left on device",
  52:"Function not implemented",
  53:"Socket is not connected",
  54:"Not a directory",
  55:"Directory not empty",
  56:"State not recoverable",
  57:"Socket operation on non-socket",
  59:"Not a typewriter",
  60:"No such device or address",
  61:"Value too large for defined data type",
  62:"Previous owner died",
  63:"Not super-user",
  64:"Broken pipe",
  65:"Protocol error",
  66:"Unknown protocol",
  67:"Protocol wrong type for socket",
  68:"Math result not representable",
  69:"Read only file system",
  70:"Illegal seek",
  71:"No such process",
  72:"Stale file handle",
  73:"Connection timed out",
  74:"Text file busy",
  75:"Cross-device link",
  100:"Device not a stream",
  101:"Bad font file fmt",
  102:"Invalid slot",
  103:"Invalid request code",
  104:"No anode",
  105:"Block device required",
  106:"Channel number out of range",
  107:"Level 3 halted",
  108:"Level 3 reset",
  109:"Link number out of range",
  110:"Protocol driver not attached",
  111:"No CSI structure available",
  112:"Level 2 halted",
  113:"Invalid exchange",
  114:"Invalid request descriptor",
  115:"Exchange full",
  116:"No data (for no delay io)",
  117:"Timer expired",
  118:"Out of streams resources",
  119:"Machine is not on the network",
  120:"Package not installed",
  121:"The object is remote",
  122:"Advertise error",
  123:"Srmount error",
  124:"Communication error on send",
  125:"Cross mount point (not really error)",
  126:"Given log. name not unique",
  127:"f.d. invalid for this operation",
  128:"Remote address changed",
  129:"Can   access a needed shared lib",
  130:"Accessing a corrupted shared lib",
  131:".lib section in a.out corrupted",
  132:"Attempting to link in too many libs",
  133:"Attempting to exec a shared library",
  135:"Streams pipe error",
  136:"Too many users",
  137:"Socket type not supported",
  138:"Not supported",
  139:"Protocol family not supported",
  140:"Can't send after socket shutdown",
  141:"Too many references",
  142:"Host is down",
  148:"No medium (in tape drive)",
  156:"Level 2 not synchronized",
  };
  
  var ERRNO_CODES = {
      'EPERM': 63,
      'ENOENT': 44,
      'ESRCH': 71,
      'EINTR': 27,
      'EIO': 29,
      'ENXIO': 60,
      'E2BIG': 1,
      'ENOEXEC': 45,
      'EBADF': 8,
      'ECHILD': 12,
      'EAGAIN': 6,
      'EWOULDBLOCK': 6,
      'ENOMEM': 48,
      'EACCES': 2,
      'EFAULT': 21,
      'ENOTBLK': 105,
      'EBUSY': 10,
      'EEXIST': 20,
      'EXDEV': 75,
      'ENODEV': 43,
      'ENOTDIR': 54,
      'EISDIR': 31,
      'EINVAL': 28,
      'ENFILE': 41,
      'EMFILE': 33,
      'ENOTTY': 59,
      'ETXTBSY': 74,
      'EFBIG': 22,
      'ENOSPC': 51,
      'ESPIPE': 70,
      'EROFS': 69,
      'EMLINK': 34,
      'EPIPE': 64,
      'EDOM': 18,
      'ERANGE': 68,
      'ENOMSG': 49,
      'EIDRM': 24,
      'ECHRNG': 106,
      'EL2NSYNC': 156,
      'EL3HLT': 107,
      'EL3RST': 108,
      'ELNRNG': 109,
      'EUNATCH': 110,
      'ENOCSI': 111,
      'EL2HLT': 112,
      'EDEADLK': 16,
      'ENOLCK': 46,
      'EBADE': 113,
      'EBADR': 114,
      'EXFULL': 115,
      'ENOANO': 104,
      'EBADRQC': 103,
      'EBADSLT': 102,
      'EDEADLOCK': 16,
      'EBFONT': 101,
      'ENOSTR': 100,
      'ENODATA': 116,
      'ETIME': 117,
      'ENOSR': 118,
      'ENONET': 119,
      'ENOPKG': 120,
      'EREMOTE': 121,
      'ENOLINK': 47,
      'EADV': 122,
      'ESRMNT': 123,
      'ECOMM': 124,
      'EPROTO': 65,
      'EMULTIHOP': 36,
      'EDOTDOT': 125,
      'EBADMSG': 9,
      'ENOTUNIQ': 126,
      'EBADFD': 127,
      'EREMCHG': 128,
      'ELIBACC': 129,
      'ELIBBAD': 130,
      'ELIBSCN': 131,
      'ELIBMAX': 132,
      'ELIBEXEC': 133,
      'ENOSYS': 52,
      'ENOTEMPTY': 55,
      'ENAMETOOLONG': 37,
      'ELOOP': 32,
      'EOPNOTSUPP': 138,
      'EPFNOSUPPORT': 139,
      'ECONNRESET': 15,
      'ENOBUFS': 42,
      'EAFNOSUPPORT': 5,
      'EPROTOTYPE': 67,
      'ENOTSOCK': 57,
      'ENOPROTOOPT': 50,
      'ESHUTDOWN': 140,
      'ECONNREFUSED': 14,
      'EADDRINUSE': 3,
      'ECONNABORTED': 13,
      'ENETUNREACH': 40,
      'ENETDOWN': 38,
      'ETIMEDOUT': 73,
      'EHOSTDOWN': 142,
      'EHOSTUNREACH': 23,
      'EINPROGRESS': 26,
      'EALREADY': 7,
      'EDESTADDRREQ': 17,
      'EMSGSIZE': 35,
      'EPROTONOSUPPORT': 66,
      'ESOCKTNOSUPPORT': 137,
      'EADDRNOTAVAIL': 4,
      'ENETRESET': 39,
      'EISCONN': 30,
      'ENOTCONN': 53,
      'ETOOMANYREFS': 141,
      'EUSERS': 136,
      'EDQUOT': 19,
      'ESTALE': 72,
      'ENOTSUP': 138,
      'ENOMEDIUM': 148,
      'EILSEQ': 25,
      'EOVERFLOW': 61,
      'ECANCELED': 11,
      'ENOTRECOVERABLE': 56,
      'EOWNERDEAD': 62,
      'ESTRPIPE': 135,
    };
  
  var demangle = (func) => {
      warnOnce('warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling');
      return func;
    };
  var demangleAll = (text) => {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    };
  var FS = {
  root:null,
  mounts:[],
  devices:{
  },
  streams:[],
  nextInode:1,
  nameTable:null,
  currentPath:"/",
  initialized:false,
  ignorePermissions:true,
  ErrnoError:null,
  genericErrors:{
  },
  filesystems:null,
  syncFSRequests:0,
  lookupPath(path, opts = {}) {
        path = PATH_FS.resolve(path);
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the absolute path
        var parts = path.split('/').filter((p) => !!p);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },
  getPath(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? `${mount}/${path}` : mount + path;
          }
          path = path ? `${node.name}/${path}` : node.name;
          node = node.parent;
        }
      },
  hashName(parentid, name) {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },
  hashAddNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
  hashRemoveNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
  lookupNode(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },
  createNode(parent, name, mode, rdev) {
        assert(typeof parent == 'object')
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },
  destroyNode(node) {
        FS.hashRemoveNode(node);
      },
  isRoot(node) {
        return node === node.parent;
      },
  isMountpoint(node) {
        return !!node.mounted;
      },
  isFile(mode) {
        return (mode & 61440) === 32768;
      },
  isDir(mode) {
        return (mode & 61440) === 16384;
      },
  isLink(mode) {
        return (mode & 61440) === 40960;
      },
  isChrdev(mode) {
        return (mode & 61440) === 8192;
      },
  isBlkdev(mode) {
        return (mode & 61440) === 24576;
      },
  isFIFO(mode) {
        return (mode & 61440) === 4096;
      },
  isSocket(mode) {
        return (mode & 49152) === 49152;
      },
  flagsToPermissionString(flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },
  nodePermissions(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
  mayLookup(dir) {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },
  mayCreate(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },
  mayDelete(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
  mayOpen(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
  MAX_OPEN_FDS:4096,
  nextfd() {
        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
  getStreamChecked(fd) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        return stream;
      },
  getStream:(fd) => FS.streams[fd],
  createStream(stream, fd = -1) {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function() {
            this.shared = { };
          };
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              /** @this {FS.FSStream} */
              get() { return this.node; },
              /** @this {FS.FSStream} */
              set(val) { this.node = val; }
            },
            isRead: {
              /** @this {FS.FSStream} */
              get() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              /** @this {FS.FSStream} */
              get() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              /** @this {FS.FSStream} */
              get() { return (this.flags & 1024); }
            },
            flags: {
              /** @this {FS.FSStream} */
              get() { return this.shared.flags; },
              /** @this {FS.FSStream} */
              set(val) { this.shared.flags = val; },
            },
            position : {
              /** @this {FS.FSStream} */
              get() { return this.shared.position; },
              /** @this {FS.FSStream} */
              set(val) { this.shared.position = val; },
            },
          });
        }
        // clone it, so we can return an instance of FSStream
        stream = Object.assign(new FS.FSStream(), stream);
        if (fd == -1) {
          fd = FS.nextfd();
        }
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
  closeStream(fd) {
        FS.streams[fd] = null;
      },
  chrdev_stream_ops:{
  open(stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          stream.stream_ops.open?.(stream);
        },
  llseek() {
          throw new FS.ErrnoError(70);
        },
  },
  major:(dev) => ((dev) >> 8),
  minor:(dev) => ((dev) & 0xff),
  makedev:(ma, mi) => ((ma) << 8 | (mi)),
  registerDevice(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },
  getDevice:(dev) => FS.devices[dev],
  getMounts(mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },
  syncfs(populate, callback) {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          assert(FS.syncFSRequests > 0);
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
  mount(type, opts, mountpoint) {
        if (typeof type == 'string') {
          // The filesystem was not included, and instead we have an error
          // message stored in the variable.
          throw type;
        }
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type,
          opts,
          mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },
  unmount(mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },
  lookup(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },
  mknod(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
  create(path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },
  mkdir(path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },
  mkdirTree(path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },
  mkdev(path, mode, dev) {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },
  symlink(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
  rename(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existant directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },
  rmdir(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
  readdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
  unlink(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
  readlink(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },
  stat(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
  lstat(path) {
        return FS.stat(path, true);
      },
  chmod(path, mode, dontFollow) {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },
  lchmod(path, mode) {
        FS.chmod(path, mode, true);
      },
  fchmod(fd, mode) {
        var stream = FS.getStreamChecked(fd);
        FS.chmod(stream.node, mode);
      },
  chown(path, uid, gid, dontFollow) {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },
  lchown(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },
  fchown(fd, uid, gid) {
        var stream = FS.getStreamChecked(fd);
        FS.chown(stream.node, uid, gid);
      },
  truncate(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },
  ftruncate(fd, len) {
        var stream = FS.getStreamChecked(fd);
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
  utime(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },
  open(path, flags, mode) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512) && !created) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        });
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },
  close(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
  isClosed(stream) {
        return stream.fd === null;
      },
  llseek(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
  read(stream, buffer, offset, length, position) {
        assert(offset >= 0);
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },
  write(stream, buffer, offset, length, position, canOwn) {
        assert(offset >= 0);
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },
  allocate(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
  mmap(stream, length, position, prot, flags) {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
  msync(stream, buffer, offset, length, mmapFlags) {
        assert(offset >= 0);
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },
  munmap:(stream) => 0,
  ioctl(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
  readFile(path, opts = {}) {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error(`Invalid encoding type "${opts.encoding}"`);
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
  writeFile(path, data, opts = {}) {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },
  cwd:() => FS.currentPath,
  chdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
  createDefaultDirectories() {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },
  createDefaultDevices() {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        // use a buffer to avoid overhead of individual crypto calls per byte
        var randomBuffer = new Uint8Array(1024), randomLeft = 0;
        var randomByte = () => {
          if (randomLeft === 0) {
            randomLeft = randomFill(randomBuffer).byteLength;
          }
          return randomBuffer[--randomLeft];
        };
        FS.createDevice('/dev', 'random', randomByte);
        FS.createDevice('/dev', 'urandom', randomByte);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },
  createSpecialDirectories() {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount() {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },
  createStandardStreams() {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
        assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);
        assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);
        assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);
      },
  ensureErrnoError() {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          // We set the `name` property to be able to identify `FS.ErrnoError`
          // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
          // - when using PROXYFS, an error can come from an underlying FS
          // as different FS objects have their own FS.ErrnoError each,
          // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
          // we'll use the reliable test `err.name == "ErrnoError"` instead
          this.name = 'ErrnoError';
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
  
          // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack
          // now ensures it shows what we want.
          if (this.stack) {
            // Define the stack property for Node.js 4, which otherwise errors on the next line.
            Object.defineProperty(this, "stack", { value: (new Error).stack, writable: true });
            this.stack = demangleAll(this.stack);
          }
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },
  staticInit() {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },
  init(input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },
  quit() {
        FS.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        _fflush(0);
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
  findObject(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
  analyzePath(path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },
  createPath(parent, path, canRead, canWrite) {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },
  createFile(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS_getMode(canRead, canWrite);
        return FS.create(path, mode);
      },
  createDataFile(parent, name, data, canRead, canWrite, canOwn) {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS_getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
      },
  createDevice(parent, name, input, output) {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS_getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open(stream) {
            stream.seekable = false;
          },
          close(stream) {
            // flush any pending line data
            if (output?.buffer?.length) {
              output(10);
            }
          },
          read(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },
  forceLoadFile(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },
  createLazyFile(parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            }
            return intArrayFromString(xhr.responseText || '', true);
          };
          var lazyArray = this;
          lazyArray.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }
        // use a custom read function
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position)
        };
        // use a custom mmap function
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },
  absolutePath() {
        abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');
      },
  createFolder() {
        abort('FS.createFolder has been removed; use FS.mkdir instead');
      },
  createLink() {
        abort('FS.createLink has been removed; use FS.symlink instead');
      },
  joinPath() {
        abort('FS.joinPath has been removed; use PATH.join instead');
      },
  mmapAlloc() {
        abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');
      },
  standardizePath() {
        abort('FS.standardizePath has been removed; use PATH.normalize instead');
      },
  };
  
  
    /**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index (i.e. maxBytesToRead will not
     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
     *   JS JIT optimizations off, so it is worth to consider consistently using one
     * @return {string}
     */
  var UTF8ToString = (ptr, maxBytesToRead) => {
      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
    };
  var SYSCALLS = {
  DEFAULT_POLLMASK:5,
  calculateAt(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },
  doStat(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = stat.mode;
        HEAPU32[(((buf)+(8))>>2)] = stat.nlink;
        HEAP32[(((buf)+(12))>>2)] = stat.uid;
        HEAP32[(((buf)+(16))>>2)] = stat.gid;
        HEAP32[(((buf)+(20))>>2)] = stat.rdev;
        (tempI64 = [stat.size>>>0,(tempDouble = stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(24))>>2)] = tempI64[0],HEAP32[(((buf)+(28))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(32))>>2)] = 4096;
        HEAP32[(((buf)+(36))>>2)] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        (tempI64 = [Math.floor(atime / 1000)>>>0,(tempDouble = Math.floor(atime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(48))>>2)] = (atime % 1000) * 1000;
        (tempI64 = [Math.floor(mtime / 1000)>>>0,(tempDouble = Math.floor(mtime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(56))>>2)] = tempI64[0],HEAP32[(((buf)+(60))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(64))>>2)] = (mtime % 1000) * 1000;
        (tempI64 = [Math.floor(ctime / 1000)>>>0,(tempDouble = Math.floor(ctime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(72))>>2)] = tempI64[0],HEAP32[(((buf)+(76))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(80))>>2)] = (ctime % 1000) * 1000;
        (tempI64 = [stat.ino>>>0,(tempDouble = stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(88))>>2)] = tempI64[0],HEAP32[(((buf)+(92))>>2)] = tempI64[1]);
        return 0;
      },
  doMsync(addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          // MAP_PRIVATE calls need not to be synced back to underlying fs
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },
  varargs:undefined,
  get() {
        assert(SYSCALLS.varargs != undefined);
        // the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.
        var ret = HEAP32[((+SYSCALLS.varargs)>>2)];
        SYSCALLS.varargs += 4;
        return ret;
      },
  getp() { return SYSCALLS.get() },
  getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
  getStreamFromFD(fd) {
        var stream = FS.getStreamChecked(fd);
        return stream;
      },
  };
  function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = SYSCALLS.getp();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0; // Pretend that the locking is successful.
      }
      return -28;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }

  function ___syscall_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty) return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = SYSCALLS.getp();
            HEAP32[((argp)>>2)] = termios.c_iflag || 0;
            HEAP32[(((argp)+(4))>>2)] = termios.c_oflag || 0;
            HEAP32[(((argp)+(8))>>2)] = termios.c_cflag || 0;
            HEAP32[(((argp)+(12))>>2)] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[(((argp + i)+(17))>>0)] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty) return -59;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = SYSCALLS.getp();
            var c_iflag = HEAP32[((argp)>>2)];
            var c_oflag = HEAP32[(((argp)+(4))>>2)];
            var c_cflag = HEAP32[(((argp)+(8))>>2)];
            var c_lflag = HEAP32[(((argp)+(12))>>2)];
            var c_cc = []
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[(((argp + i)+(17))>>0)]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, { c_iflag, c_oflag, c_cflag, c_lflag, c_cc });
          }
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.getp();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; // not supported
        }
        case 21531: {
          var argp = SYSCALLS.getp();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          // TODO: in theory we should write to the winsize struct that gets
          // passed in, but for now musl doesn't read anything on it
          if (!stream.tty) return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = SYSCALLS.getp();
            HEAP16[((argp)>>1)] = winsize[0];
            HEAP16[(((argp)+(2))>>1)] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          // TODO: technically, this ioctl call should change the window size.
          // but, since emscripten doesn't have any concept of a terminal window
          // yet, we'll just silently throw it away as we do TIOCGWINSZ
          if (!stream.tty) return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty) return -59;
          return 0;
        }
        default: return -28; // not supported
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }

  function ___syscall_mkdirat(dirfd, path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      // remove a trailing slash, if one - /a/b/ has basename of '', but
      // we want to create b in the context of this function
      path = PATH.normalize(path);
      if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }

  function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }

  var readEmAsmArgsArray = [];
  var readEmAsmArgs = (sigPtr, buf) => {
      // Nobody should have mutated _readEmAsmArgsArray underneath us to be something else than an array.
      assert(Array.isArray(readEmAsmArgsArray));
      // The input buffer is allocated on the stack, so it must be stack-aligned.
      assert(buf % 16 == 0);
      readEmAsmArgsArray.length = 0;
      var ch;
      // Most arguments are i32s, so shift the buffer pointer so it is a plain
      // index into HEAP32.
      while (ch = HEAPU8[sigPtr++]) {
        var chr = String.fromCharCode(ch);
        var validChars = ['d', 'f', 'i', 'p'];
        assert(validChars.includes(chr), `Invalid character ${ch}("${chr}") in readEmAsmArgs! Use only [${validChars}], and do not specify "v" for void return argument.`);
        // Floats are always passed as doubles, so all types except for 'i'
        // are 8 bytes and require alignment.
        var wide = (ch != 105);
        wide &= (ch != 112);
        buf += wide && (buf % 8) ? 4 : 0;
        readEmAsmArgsArray.push(
          // Special case for pointers under wasm64 or CAN_ADDRESS_2GB mode.
          ch == 112 ? HEAPU32[((buf)>>2)] :
          ch == 105 ?
            HEAP32[((buf)>>2)] :
            HEAPF64[((buf)>>3)]
        );
        buf += wide ? 8 : 4;
      }
      return readEmAsmArgsArray;
    };
  var runEmAsmFunction = (code, sigPtr, argbuf) => {
      var args = readEmAsmArgs(sigPtr, argbuf);
      assert(ASM_CONSTS.hasOwnProperty(code), `No EM_ASM constant found at address ${code}.  The loaded WebAssembly file is likely out of sync with the generated JavaScript.`);
      return ASM_CONSTS[code].apply(null, args);
    };
  var _emscripten_asm_const_int = (code, sigPtr, argbuf) => {
      return runEmAsmFunction(code, sigPtr, argbuf);
    };

  
  var withStackSave = (f) => {
      var stack = stackSave();
      var ret = f();
      stackRestore(stack);
      return ret;
    };
  var JSEvents = {
  removeAllEventListeners() {
        while (JSEvents.eventHandlers.length) {
          JSEvents._removeHandler(JSEvents.eventHandlers.length - 1);
        }
        JSEvents.deferredCalls = [];
      },
  inEventHandler:0,
  deferredCalls:[],
  deferCall(targetFunction, precedence, argsList) {
        function arraysHaveEqualContent(arrA, arrB) {
          if (arrA.length != arrB.length) return false;
  
          for (var i in arrA) {
            if (arrA[i] != arrB[i]) return false;
          }
          return true;
        }
        // Test if the given call was already queued, and if so, don't add it again.
        for (var i in JSEvents.deferredCalls) {
          var call = JSEvents.deferredCalls[i];
          if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
            return;
          }
        }
        JSEvents.deferredCalls.push({
          targetFunction,
          precedence,
          argsList
        });
  
        JSEvents.deferredCalls.sort((x,y) => x.precedence < y.precedence);
      },
  removeDeferredCalls(targetFunction) {
        for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
          if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
            JSEvents.deferredCalls.splice(i, 1);
            --i;
          }
        }
      },
  canPerformEventHandlerRequests() {
        if (navigator.userActivation) {
          // Verify against transient activation status from UserActivation API
          // whether it is possible to perform a request here without needing to defer. See
          // https://developer.mozilla.org/en-US/docs/Web/Security/User_activation#transient_activation
          // and https://caniuse.com/mdn-api_useractivation
          // At the time of writing, Firefox does not support this API: https://bugzilla.mozilla.org/show_bug.cgi?id=1791079
          return navigator.userActivation.isActive;
        }
  
        return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
      },
  runDeferredCalls() {
        if (!JSEvents.canPerformEventHandlerRequests()) {
          return;
        }
        for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
          var call = JSEvents.deferredCalls[i];
          JSEvents.deferredCalls.splice(i, 1);
          --i;
          call.targetFunction.apply(null, call.argsList);
        }
      },
  eventHandlers:[],
  removeAllHandlersOnTarget:(target, eventTypeString) => {
        for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
          if (JSEvents.eventHandlers[i].target == target &&
            (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
             JSEvents._removeHandler(i--);
           }
        }
      },
  _removeHandler(i) {
        var h = JSEvents.eventHandlers[i];
        h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
        JSEvents.eventHandlers.splice(i, 1);
      },
  registerOrRemoveHandler(eventHandler) {
        if (!eventHandler.target) {
          err('registerOrRemoveHandler: the target element for event handler registration does not exist, when processing the following event handler registration:');
          console.dir(eventHandler);
          return -4;
        }
        if (eventHandler.callbackfunc) {
          eventHandler.eventListenerFunc = function(event) {
            // Increment nesting count for the event handler.
            ++JSEvents.inEventHandler;
            JSEvents.currentEventHandler = eventHandler;
            // Process any old deferred calls the user has placed.
            JSEvents.runDeferredCalls();
            // Process the actual event, calls back to user C code handler.
            eventHandler.handlerFunc(event);
            // Process any new deferred calls that were placed right now from this event handler.
            JSEvents.runDeferredCalls();
            // Out of event handler - restore nesting count.
            --JSEvents.inEventHandler;
          };
  
          eventHandler.target.addEventListener(eventHandler.eventTypeString,
                                               eventHandler.eventListenerFunc,
                                               eventHandler.useCapture);
          JSEvents.eventHandlers.push(eventHandler);
        } else {
          for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
            if (JSEvents.eventHandlers[i].target == eventHandler.target
             && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
               JSEvents._removeHandler(i--);
             }
          }
        }
        return 0;
      },
  getNodeNameForTarget(target) {
        if (!target) return '';
        if (target == window) return '#window';
        if (target == screen) return '#screen';
        return target?.nodeName || '';
      },
  fullscreenEnabled() {
        return document.fullscreenEnabled
        // Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitFullscreenEnabled.
        // TODO: If Safari at some point ships with unprefixed version, update the version check above.
        || document.webkitFullscreenEnabled
         ;
      },
  };
  
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
  var fillGamepadEventData = (eventStruct, e) => {
      HEAPF64[((eventStruct)>>3)] = e.timestamp;
      for (var i = 0; i < e.axes.length; ++i) {
        HEAPF64[(((eventStruct+i*8)+(16))>>3)] = e.axes[i];
      }
      for (var i = 0; i < e.buttons.length; ++i) {
        if (typeof e.buttons[i] == 'object') {
          HEAPF64[(((eventStruct+i*8)+(528))>>3)] = e.buttons[i].value;
        } else {
          HEAPF64[(((eventStruct+i*8)+(528))>>3)] = e.buttons[i];
        }
      }
      for (var i = 0; i < e.buttons.length; ++i) {
        if (typeof e.buttons[i] == 'object') {
          HEAP32[(((eventStruct+i*4)+(1040))>>2)] = e.buttons[i].pressed;
        } else {
          // Assigning a boolean to HEAP32, that's ok, but Closure would like to warn about it:
          /** @suppress {checkTypes} */
          HEAP32[(((eventStruct+i*4)+(1040))>>2)] = e.buttons[i] == 1;
        }
      }
      HEAP32[(((eventStruct)+(1296))>>2)] = e.connected;
      HEAP32[(((eventStruct)+(1300))>>2)] = e.index;
      HEAP32[(((eventStruct)+(8))>>2)] = e.axes.length;
      HEAP32[(((eventStruct)+(12))>>2)] = e.buttons.length;
      stringToUTF8(e.id, eventStruct + 1304, 64);
      stringToUTF8(e.mapping, eventStruct + 1368, 64);
    };
  var _emscripten_get_gamepad_status = (index, gamepadState) => {
      if (!JSEvents.lastGamepadState) throw 'emscripten_get_gamepad_status() can only be called after having first called emscripten_sample_gamepad_data() and that function has returned EMSCRIPTEN_RESULT_SUCCESS!';
      // INVALID_PARAM is returned on a Gamepad index that never was there.
      if (index < 0 || index >= JSEvents.lastGamepadState.length) return -5;
  
      // NO_DATA is returned on a Gamepad index that was removed.
      // For previously disconnected gamepads there should be an empty slot (null/undefined/false) at the index.
      // This is because gamepads must keep their original position in the array.
      // For example, removing the first of two gamepads produces [null/undefined/false, gamepad].
      if (!JSEvents.lastGamepadState[index]) return -7;
  
      fillGamepadEventData(gamepadState, JSEvents.lastGamepadState[index]);
      return 0;
    };

  var _emscripten_get_num_gamepads = () => {
      if (!JSEvents.lastGamepadState) throw 'emscripten_get_num_gamepads() can only be called after having first called emscripten_sample_gamepad_data() and that function has returned EMSCRIPTEN_RESULT_SUCCESS!';
      // N.B. Do not call emscripten_get_num_gamepads() unless having first called emscripten_sample_gamepad_data(), and that has returned EMSCRIPTEN_RESULT_SUCCESS.
      // Otherwise the following line will throw an exception.
      return JSEvents.lastGamepadState.length;
    };

  var _emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);

  var getHeapMax = () =>
      HEAPU8.length;
  
  var abortOnCannotGrowMemory = (requestedSize) => {
      abort(`Cannot enlarge memory arrays to size ${requestedSize} bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value ${HEAP8.length}, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0`);
    };
  var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      requestedSize >>>= 0;
      abortOnCannotGrowMemory(requestedSize);
    };

  
  var maybeCStringToJsString = (cString) => {
      // "cString > 2" checks if the input is a number, and isn't of the special
      // values we accept here, EMSCRIPTEN_EVENT_TARGET_* (which map to 0, 1, 2).
      // In other words, if cString > 2 then it's a pointer to a valid place in
      // memory, and points to a C string.
      return cString > 2 ? UTF8ToString(cString) : cString;
    };
  
  var specialHTMLTargets = [0, typeof document != 'undefined' ? document : 0, typeof window != 'undefined' ? window : 0];
  /** @suppress {duplicate } */
  var findEventTarget = (target) => {
      target = maybeCStringToJsString(target);
      var domElement = specialHTMLTargets[target] || (typeof document != 'undefined' ? document.querySelector(target) : undefined);
      return domElement;
    };
  var findCanvasEventTarget = findEventTarget;
  var _emscripten_set_canvas_element_size = (target, width, height) => {
      var canvas = findCanvasEventTarget(target);
      if (!canvas) return -4;
      canvas.width = width;
      canvas.height = height;
      return 0;
    };

  
  
  
  var registerFocusEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      if (!JSEvents.focusEvent) JSEvents.focusEvent = _malloc(256);
  
      var focusEventHandlerFunc = (e = event) => {
        var nodeName = JSEvents.getNodeNameForTarget(e.target);
        var id = e.target.id ? e.target.id : '';
  
        var focusEvent = JSEvents.focusEvent;
        stringToUTF8(nodeName, focusEvent + 0, 128);
        stringToUTF8(id, focusEvent + 128, 128);
  
        if (((a1, a2, a3) => dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]))(eventTypeId, focusEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        eventTypeString,
        callbackfunc,
        handlerFunc: focusEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };
  var _emscripten_set_focusin_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerFocusEventCallback(target, userData, useCapture, callbackfunc, 14, "focusin", targetThread);

  var _emscripten_set_focusout_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerFocusEventCallback(target, userData, useCapture, callbackfunc, 15, "focusout", targetThread);

  
  
  
  var fillFullscreenChangeEventData = (eventStruct) => {
      var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
      var isFullscreen = !!fullscreenElement;
      // Assigning a boolean to HEAP32 with expected type coercion.
      /** @suppress{checkTypes} */
      HEAP32[((eventStruct)>>2)] = isFullscreen;
      HEAP32[(((eventStruct)+(4))>>2)] = JSEvents.fullscreenEnabled();
      // If transitioning to fullscreen, report info about the element that is now fullscreen.
      // If transitioning to windowed mode, report info about the element that just was fullscreen.
      var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;
      var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
      var id = reportedElement?.id || '';
      stringToUTF8(nodeName, eventStruct + 8, 128);
      stringToUTF8(id, eventStruct + 136, 128);
      HEAP32[(((eventStruct)+(264))>>2)] = reportedElement ? reportedElement.clientWidth : 0;
      HEAP32[(((eventStruct)+(268))>>2)] = reportedElement ? reportedElement.clientHeight : 0;
      HEAP32[(((eventStruct)+(272))>>2)] = screen.width;
      HEAP32[(((eventStruct)+(276))>>2)] = screen.height;
      if (isFullscreen) {
        JSEvents.previousFullscreenElement = fullscreenElement;
      }
    };
  
  
  var registerFullscreenChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      if (!JSEvents.fullscreenChangeEvent) JSEvents.fullscreenChangeEvent = _malloc(280);
  
      var fullscreenChangeEventhandlerFunc = (e = event) => {
        var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;
  
        fillFullscreenChangeEventData(fullscreenChangeEvent);
  
        if (((a1, a2, a3) => dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]))(eventTypeId, fullscreenChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        eventTypeString,
        callbackfunc,
        handlerFunc: fullscreenChangeEventhandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };
  
  
  var _emscripten_set_fullscreenchange_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => {
      if (!JSEvents.fullscreenEnabled()) return -1;
      target = findEventTarget(target);
      if (!target) return -4;
  
      // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
      // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
      registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "webkitfullscreenchange", targetThread);
  
      return registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "fullscreenchange", targetThread);
    };

  
  
  
  var registerGamepadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      if (!JSEvents.gamepadEvent) JSEvents.gamepadEvent = _malloc(1432);
  
      var gamepadEventHandlerFunc = (e = event) => {
        var gamepadEvent = JSEvents.gamepadEvent;
        fillGamepadEventData(gamepadEvent, e["gamepad"]);
  
        if (((a1, a2, a3) => dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]))(eventTypeId, gamepadEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        allowsDeferredCalls: true,
        eventTypeString,
        callbackfunc,
        handlerFunc: gamepadEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };
  
  /** @suppress {checkTypes} */
  var _emscripten_sample_gamepad_data = () => {
      try {
        if (navigator.getGamepads) return (JSEvents.lastGamepadState = navigator.getGamepads())
          ? 0 : -1;
      } catch(e) {
        err(`navigator.getGamepads() exists, but failed to execute with exception ${e}. Disabling Gamepad access.`);
        navigator.getGamepads = null; // Disable getGamepads() so that it won't be attempted to be used again.
      }
      return -1;
    };
  var _emscripten_set_gamepadconnected_callback_on_thread = (userData, useCapture, callbackfunc, targetThread) => {
      if (_emscripten_sample_gamepad_data()) return -1;
      return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 26, "gamepadconnected", targetThread);
    };

  
  var _emscripten_set_gamepaddisconnected_callback_on_thread = (userData, useCapture, callbackfunc, targetThread) => {
      if (_emscripten_sample_gamepad_data()) return -1;
      return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 27, "gamepaddisconnected", targetThread);
    };

  
  
  
  var registerKeyEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      if (!JSEvents.keyEvent) JSEvents.keyEvent = _malloc(176);
  
      var keyEventHandlerFunc = (e) => {
        assert(e);
  
        var keyEventData = JSEvents.keyEvent;
        HEAPF64[((keyEventData)>>3)] = e.timeStamp;
  
        var idx =((keyEventData)>>2);
  
        HEAP32[idx + 2] = e.location;
        HEAP32[idx + 3] = e.ctrlKey;
        HEAP32[idx + 4] = e.shiftKey;
        HEAP32[idx + 5] = e.altKey;
        HEAP32[idx + 6] = e.metaKey;
        HEAP32[idx + 7] = e.repeat;
        HEAP32[idx + 8] = e.charCode;
        HEAP32[idx + 9] = e.keyCode;
        HEAP32[idx + 10] = e.which;
        stringToUTF8(e.key || '', keyEventData + 44, 32);
        stringToUTF8(e.code || '', keyEventData + 76, 32);
        stringToUTF8(e.char || '', keyEventData + 108, 32);
        stringToUTF8(e.locale || '', keyEventData + 140, 32);
  
        if (((a1, a2, a3) => dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]))(eventTypeId, keyEventData, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        eventTypeString,
        callbackfunc,
        handlerFunc: keyEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };
  var _emscripten_set_keydown_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);

  var _emscripten_set_keyup_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 3, "keyup", targetThread);

  
  
  var getBoundingClientRect = (e) => specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {'left':0,'top':0};
  
  var fillMouseEventData = (eventStruct, e, target) => {
      assert(eventStruct % 4 == 0);
      HEAPF64[((eventStruct)>>3)] = e.timeStamp;
      var idx = ((eventStruct)>>2);
      HEAP32[idx + 2] = e.screenX;
      HEAP32[idx + 3] = e.screenY;
      HEAP32[idx + 4] = e.clientX;
      HEAP32[idx + 5] = e.clientY;
      HEAP32[idx + 6] = e.ctrlKey;
      HEAP32[idx + 7] = e.shiftKey;
      HEAP32[idx + 8] = e.altKey;
      HEAP32[idx + 9] = e.metaKey;
      HEAP16[idx*2 + 20] = e.button;
      HEAP16[idx*2 + 21] = e.buttons;
  
      HEAP32[idx + 11] = e["movementX"]
        ;
  
      HEAP32[idx + 12] = e["movementY"]
        ;
  
      var rect = getBoundingClientRect(target);
      HEAP32[idx + 13] = e.clientX - rect.left;
      HEAP32[idx + 14] = e.clientY - rect.top;
  
    };
  
  
  var registerMouseEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      if (!JSEvents.mouseEvent) JSEvents.mouseEvent = _malloc(72);
      target = findEventTarget(target);
  
      var mouseEventHandlerFunc = (e = event) => {
        // TODO: Make this access thread safe, or this could update live while app is reading it.
        fillMouseEventData(JSEvents.mouseEvent, e, target);
  
        if (((a1, a2, a3) => dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]))(eventTypeId, JSEvents.mouseEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        allowsDeferredCalls: eventTypeString != 'mousemove' && eventTypeString != 'mouseenter' && eventTypeString != 'mouseleave', // Mouse move events do not allow fullscreen/pointer lock requests to be handled in them!
        eventTypeString,
        callbackfunc,
        handlerFunc: mouseEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };
  var _emscripten_set_mousedown_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);

  var _emscripten_set_mousemove_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread);

  var _emscripten_set_mouseup_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread);

  
  
  var registerUiEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      if (!JSEvents.uiEvent) JSEvents.uiEvent = _malloc(36);
  
      target = findEventTarget(target);
  
      var uiEventHandlerFunc = (e = event) => {
        if (e.target != target) {
          // Never take ui events such as scroll via a 'bubbled' route, but always from the direct element that
          // was targeted. Otherwise e.g. if app logs a message in response to a page scroll, the Emscripten log
          // message box could cause to scroll, generating a new (bubbled) scroll message, causing a new log print,
          // causing a new scroll, etc..
          return;
        }
        var b = document.body; // Take document.body to a variable, Closure compiler does not outline access to it on its own.
        if (!b) {
          // During a page unload 'body' can be null, with "Cannot read property 'clientWidth' of null" being thrown
          return;
        }
        var uiEvent = JSEvents.uiEvent;
        HEAP32[((uiEvent)>>2)] = e.detail;
        HEAP32[(((uiEvent)+(4))>>2)] = b.clientWidth;
        HEAP32[(((uiEvent)+(8))>>2)] = b.clientHeight;
        HEAP32[(((uiEvent)+(12))>>2)] = innerWidth;
        HEAP32[(((uiEvent)+(16))>>2)] = innerHeight;
        HEAP32[(((uiEvent)+(20))>>2)] = outerWidth;
        HEAP32[(((uiEvent)+(24))>>2)] = outerHeight;
        HEAP32[(((uiEvent)+(28))>>2)] = pageXOffset;
        HEAP32[(((uiEvent)+(32))>>2)] = pageYOffset;
        if (((a1, a2, a3) => dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]))(eventTypeId, uiEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        eventTypeString,
        callbackfunc,
        handlerFunc: uiEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };
  var _emscripten_set_resize_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, "resize", targetThread);

  
  
  
  var registerTouchEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      if (!JSEvents.touchEvent) JSEvents.touchEvent = _malloc(1696);
  
      target = findEventTarget(target);
  
      var touchEventHandlerFunc = (e) => {
        assert(e);
        var t, touches = {}, et = e.touches;
        // To ease marshalling different kinds of touches that browser reports (all touches are listed in e.touches,
        // only changed touches in e.changedTouches, and touches on target at a.targetTouches), mark a boolean in
        // each Touch object so that we can later loop only once over all touches we see to marshall over to Wasm.
  
        for (var i = 0; i < et.length; ++i) {
          t = et[i];
          // Browser might recycle the generated Touch objects between each frame (Firefox on Android), so reset any
          // changed/target states we may have set from previous frame.
          t.isChanged = t.onTarget = 0;
          touches[t.identifier] = t;
        }
        // Mark which touches are part of the changedTouches list.
        for (var i = 0; i < e.changedTouches.length; ++i) {
          t = e.changedTouches[i];
          t.isChanged = 1;
          touches[t.identifier] = t;
        }
        // Mark which touches are part of the targetTouches list.
        for (var i = 0; i < e.targetTouches.length; ++i) {
          touches[e.targetTouches[i].identifier].onTarget = 1;
        }
  
        var touchEvent = JSEvents.touchEvent;
        HEAPF64[((touchEvent)>>3)] = e.timeStamp;
        var idx =((touchEvent)>>2);// Pre-shift the ptr to index to HEAP32 to save code size
        HEAP32[idx + 3] = e.ctrlKey;
        HEAP32[idx + 4] = e.shiftKey;
        HEAP32[idx + 5] = e.altKey;
        HEAP32[idx + 6] = e.metaKey;
        idx += 7; // Advance to the start of the touch array.
        var targetRect = getBoundingClientRect(target);
        var numTouches = 0;
        for (var i in touches) {
          t = touches[i];
          HEAP32[idx + 0] = t.identifier;
          HEAP32[idx + 1] = t.screenX;
          HEAP32[idx + 2] = t.screenY;
          HEAP32[idx + 3] = t.clientX;
          HEAP32[idx + 4] = t.clientY;
          HEAP32[idx + 5] = t.pageX;
          HEAP32[idx + 6] = t.pageY;
          HEAP32[idx + 7] = t.isChanged;
          HEAP32[idx + 8] = t.onTarget;
          HEAP32[idx + 9] = t.clientX - targetRect.left;
          HEAP32[idx + 10] = t.clientY - targetRect.top;
  
          idx += 13;
  
          if (++numTouches > 31) {
            break;
          }
        }
        HEAP32[(((touchEvent)+(8))>>2)] = numTouches;
  
        if (((a1, a2, a3) => dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]))(eventTypeId, touchEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        allowsDeferredCalls: eventTypeString == 'touchstart' || eventTypeString == 'touchend',
        eventTypeString,
        callbackfunc,
        handlerFunc: touchEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };
  var _emscripten_set_touchcancel_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 25, "touchcancel", targetThread);

  var _emscripten_set_touchend_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 23, "touchend", targetThread);

  var _emscripten_set_touchmove_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 24, "touchmove", targetThread);

  var _emscripten_set_touchstart_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 22, "touchstart", targetThread);

  
  
  
  
  var registerWheelEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      if (!JSEvents.wheelEvent) JSEvents.wheelEvent = _malloc(104);
  
      // The DOM Level 3 events spec event 'wheel'
      var wheelHandlerFunc = (e = event) => {
        var wheelEvent = JSEvents.wheelEvent;
        fillMouseEventData(wheelEvent, e, target);
        HEAPF64[(((wheelEvent)+(72))>>3)] = e["deltaX"];
        HEAPF64[(((wheelEvent)+(80))>>3)] = e["deltaY"];
        HEAPF64[(((wheelEvent)+(88))>>3)] = e["deltaZ"];
        HEAP32[(((wheelEvent)+(96))>>2)] = e["deltaMode"];
        if (((a1, a2, a3) => dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]))(eventTypeId, wheelEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        allowsDeferredCalls: true,
        eventTypeString,
        callbackfunc,
        handlerFunc: wheelHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };
  
  var _emscripten_set_wheel_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => {
      target = findEventTarget(target);
      if (!target) return -4;
      if (typeof target.onwheel != 'undefined') {
        return registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread);
      } else {
        return -1;
      }
    };

  var _emscripten_set_main_loop_timing = (mode, value) => {
      Browser.mainLoop.timingMode = mode;
      Browser.mainLoop.timingValue = value;
  
      if (!Browser.mainLoop.func) {
        err('emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up.');
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (!Browser.mainLoop.running) {
        
        Browser.mainLoop.running = true;
      }
      if (mode == 0) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
          var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now())|0;
          setTimeout(Browser.mainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else if (mode == 1) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      } else if (mode == 2) {
        if (typeof Browser.setImmediate == 'undefined') {
          if (typeof setImmediate == 'undefined') {
            // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
            var setImmediates = [];
            var emscriptenMainLoopMessageId = 'setimmediate';
            /** @param {Event} event */
            var Browser_setImmediate_messageHandler = (event) => {
              // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
              // so check for both cases.
              if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {
                event.stopPropagation();
                setImmediates.shift()();
              }
            };
            addEventListener("message", Browser_setImmediate_messageHandler, true);
            Browser.setImmediate = /** @type{function(function(): ?, ...?): number} */(function Browser_emulated_setImmediate(func) {
              setImmediates.push(func);
              if (ENVIRONMENT_IS_WORKER) {
                if (Module['setImmediates'] === undefined) Module['setImmediates'] = [];
                Module['setImmediates'].push(func);
                postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js
              } else postMessage(emscriptenMainLoopMessageId, "*"); // On the main thread, can just send the message to itself.
            });
          } else {
            Browser.setImmediate = setImmediate;
          }
        }
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
          Browser.setImmediate(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'immediate';
      }
      return 0;
    };
  
  var _emscripten_get_now;
      // Modern environment where performance.now() is supported:
      // N.B. a shorter form "_emscripten_get_now = performance.now;" is
      // unfortunately not allowed even in current browsers (e.g. FF Nightly 75).
      _emscripten_get_now = () => performance.now();
  ;
  
  
    /**
     * @param {number=} arg
     * @param {boolean=} noSetTiming
     */
  var setMainLoop = (browserIterationFunc, fps, simulateInfiniteLoop, arg, noSetTiming) => {
      assert(!Browser.mainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');
  
      Browser.mainLoop.func = browserIterationFunc;
      Browser.mainLoop.arg = arg;
  
      // Closure compiler bug(?): Closure does not see that the assignment
      //   var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop
      // is a value copy of a number (even with the JSDoc @type annotation)
      // but optimizeis the code as if the assignment was a reference assignment,
      // which results in Browser.mainLoop.pause() not working. Hence use a
      // workaround to make Closure believe this is a value copy that should occur:
      // (TODO: Minimize this down to a small test case and report - was unable
      // to reproduce in a small written test case)
      /** @type{number} */
      var thisMainLoopId = (() => Browser.mainLoop.currentlyRunningMainloop)();
      function checkIsRunning() {
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) {
          
          return false;
        }
        return true;
      }
  
      // We create the loop runner here but it is not actually running until
      // _emscripten_set_main_loop_timing is called (which might happen a
      // later time).  This member signifies that the current runner has not
      // yet been started so that we can call runtimeKeepalivePush when it
      // gets it timing set for the first time.
      Browser.mainLoop.running = false;
      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          Browser.mainLoop.updateStatus();
  
          // catches pause/resume main loop from blocker execution
          if (!checkIsRunning()) return;
  
          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (!checkIsRunning()) return;
  
        // Implement very basic swap interval control
        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
        if (Browser.mainLoop.timingMode == 1 && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          Browser.mainLoop.scheduler();
          return;
        } else if (Browser.mainLoop.timingMode == 0) {
          Browser.mainLoop.tickStartTime = _emscripten_get_now();
        }
  
        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.
        GL.newRenderingFrameStarted();
  
        if (Browser.mainLoop.method === 'timeout' && Module.ctx) {
          warnOnce('Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!');
          Browser.mainLoop.method = ''; // just warn once per call to set main loop
        }
  
        Browser.mainLoop.runIter(browserIterationFunc);
  
        checkStackCookie();
  
        // catch pauses from the main loop itself
        if (!checkIsRunning()) return;
  
        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof SDL == 'object') SDL.audio?.queueNewAudioData?.();
  
        Browser.mainLoop.scheduler();
      }
  
      if (!noSetTiming) {
        if (fps && fps > 0) {
          _emscripten_set_main_loop_timing(0, 1000.0 / fps);
        } else {
          // Do rAF by rendering each frame (no decimating)
          _emscripten_set_main_loop_timing(1, 1);
        }
  
        Browser.mainLoop.scheduler();
      }
  
      if (simulateInfiniteLoop) {
        throw 'unwind';
      }
    };
  
  var handleException = (e) => {
      // Certain exception types we do not treat as errors since they are used for
      // internal control flow.
      // 1. ExitStatus, which is thrown by exit()
      // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
      //    that wish to return to JS event loop.
      if (e instanceof ExitStatus || e == 'unwind') {
        return EXITSTATUS;
      }
      checkStackCookie();
      if (e instanceof WebAssembly.RuntimeError) {
        if (_emscripten_stack_get_current() <= 0) {
          err('Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)');
        }
      }
      quit_(1, e);
    };
  
  
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  
  var _proc_exit = (code) => {
      EXITSTATUS = code;
      if (!keepRuntimeAlive()) {
        Module['onExit']?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    };
  
  /** @suppress {duplicate } */
  /** @param {boolean|number=} implicit */
  var exitJS = (status, implicit) => {
      EXITSTATUS = status;
  
      checkUnflushedContent();
  
      // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down
      if (keepRuntimeAlive() && !implicit) {
        var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;
        err(msg);
      }
  
      _proc_exit(status);
    };
  var _exit = exitJS;
  
  
  var maybeExit = () => {
      if (!keepRuntimeAlive()) {
        try {
          _exit(EXITSTATUS);
        } catch (e) {
          handleException(e);
        }
      }
    };
  var callUserCallback = (func) => {
      if (ABORT) {
        err('user callback triggered after runtime exited or application aborted.  Ignoring.');
        return;
      }
      try {
        func();
        maybeExit();
      } catch (e) {
        handleException(e);
      }
    };
  
  /** @param {number=} timeout */
  var safeSetTimeout = (func, timeout) => {
      
      return setTimeout(() => {
        
        callUserCallback(func);
      }, timeout);
    };
  
  
  
  
  var Browser = {
  mainLoop:{
  running:false,
  scheduler:null,
  method:"",
  currentlyRunningMainloop:0,
  func:null,
  arg:0,
  timingMode:0,
  timingValue:0,
  currentFrameNumber:0,
  queue:[],
  pause() {
          Browser.mainLoop.scheduler = null;
          // Incrementing this signals the previous main loop that it's now become old, and it must return.
          Browser.mainLoop.currentlyRunningMainloop++;
        },
  resume() {
          Browser.mainLoop.currentlyRunningMainloop++;
          var timingMode = Browser.mainLoop.timingMode;
          var timingValue = Browser.mainLoop.timingValue;
          var func = Browser.mainLoop.func;
          Browser.mainLoop.func = null;
          // do not set timing and call scheduler, we will do it on the next lines
          setMainLoop(func, 0, false, Browser.mainLoop.arg, true);
          _emscripten_set_main_loop_timing(timingMode, timingValue);
          Browser.mainLoop.scheduler();
        },
  updateStatus() {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        },
  runIter(func) {
          if (ABORT) return;
          if (Module['preMainLoop']) {
            var preRet = Module['preMainLoop']();
            if (preRet === false) {
              return; // |return false| skips a frame
            }
          }
          callUserCallback(func);
          Module['postMainLoop']?.();
        },
  },
  isFullscreen:false,
  pointerLock:false,
  moduleContextCreatedCallbacks:[],
  workers:[],
  init() {
        if (Browser.initted) return;
        Browser.initted = true;
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
          if (b.size !== byteArray.length) { // Safari bug #118630
            // Safari's Blob can only take an ArrayBuffer
            b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
          }
          var url = URL.createObjectURL(b);
          assert(typeof url == 'string', 'createObjectURL must return a url as a string');
          var img = new Image();
          img.onload = () => {
            assert(img.complete, `Image ${name} could not be decoded`);
            var canvas = /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            preloadedImages[name] = canvas;
            URL.revokeObjectURL(url);
            onload?.(byteArray);
          };
          img.onerror = (event) => {
            err(`Image ${url} could not be decoded`);
            onerror?.();
          };
          img.src = url;
        };
        preloadPlugins.push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            preloadedAudios[name] = audio;
            onload?.(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            preloadedAudios[name] = new Audio(); // empty shim
            onerror?.();
          }
          var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
          var url = URL.createObjectURL(b); // XXX we never revoke this!
          assert(typeof url == 'string', 'createObjectURL must return a url as a string');
          var audio = new Audio();
          audio.addEventListener('canplaythrough', () => finish(audio), false); // use addEventListener due to chromium bug 124926
          audio.onerror = function audio_onerror(event) {
            if (done) return;
            err(`warning: browser could not fully decode audio ${name}, trying slower base64 approach`);
            function encode64(data) {
              var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
              var PAD = '=';
              var ret = '';
              var leftchar = 0;
              var leftbits = 0;
              for (var i = 0; i < data.length; i++) {
                leftchar = (leftchar << 8) | data[i];
                leftbits += 8;
                while (leftbits >= 6) {
                  var curr = (leftchar >> (leftbits-6)) & 0x3f;
                  leftbits -= 6;
                  ret += BASE[curr];
                }
              }
              if (leftbits == 2) {
                ret += BASE[(leftchar&3) << 4];
                ret += PAD + PAD;
              } else if (leftbits == 4) {
                ret += BASE[(leftchar&0xf) << 2];
                ret += PAD;
              }
              return ret;
            }
            audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
            finish(audio); // we don't wait for confirmation this worked - but it's worth trying
          };
          audio.src = url;
          // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
          safeSetTimeout(() => {
            finish(audio); // try to use it even though it is not necessarily ready to play
          }, 10000);
        };
        preloadPlugins.push(audioPlugin);
  
        // Canvas event setup
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === Module['canvas'] ||
                                document['mozPointerLockElement'] === Module['canvas'] ||
                                document['webkitPointerLockElement'] === Module['canvas'] ||
                                document['msPointerLockElement'] === Module['canvas'];
        }
        var canvas = Module['canvas'];
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;
  
          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      (() => {});
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   (() => {}); // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);
  
          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", (ev) => {
              if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
                Module['canvas'].requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },
  createContext(/** @type {HTMLCanvasElement} */ canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.
  
        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false,
            majorVersion: 1,
          };
  
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
  
          // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
          // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
          // Browser.createContext() should not even be emitted.
          if (typeof GL != 'undefined') {
            contextHandle = GL.createContext(canvas, contextAttributes);
            if (contextHandle) {
              ctx = GL.getContext(contextHandle).GLctx;
            }
          }
        } else {
          ctx = canvas.getContext('2d');
        }
  
        if (!ctx) return null;
  
        if (setInModule) {
          if (!useWebGL) assert(typeof GLctx == 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');
  
          Module.ctx = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach((callback) => callback());
          Browser.init();
        }
        return ctx;
      },
  destroyContext(canvas, useWebGL, setInModule) {},
  fullscreenHandlersInstalled:false,
  lockPointer:undefined,
  resizeCanvas:undefined,
  requestFullscreen(lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer == 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas == 'undefined') Browser.resizeCanvas = false;
  
        var canvas = Module['canvas'];
        function fullscreenChange() {
          Browser.isFullscreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||
               document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.exitFullscreen = Browser.exitFullscreen;
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullscreen = true;
            if (Browser.resizeCanvas) {
              Browser.setFullscreenCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          } else {
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
  
            if (Browser.resizeCanvas) {
              Browser.setWindowedCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          }
          Module['onFullScreen']?.(Browser.isFullscreen);
          Module['onFullscreen']?.(Browser.isFullscreen);
        }
  
        if (!Browser.fullscreenHandlersInstalled) {
          Browser.fullscreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullscreenChange, false);
          document.addEventListener('mozfullscreenchange', fullscreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
          document.addEventListener('MSFullscreenChange', fullscreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullscreen'] ? () => canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) : null) ||
                                           (canvasContainer['webkitRequestFullScreen'] ? () => canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) : null);
  
        canvasContainer.requestFullscreen();
      },
  requestFullScreen() {
        abort('Module.requestFullScreen has been replaced by Module.requestFullscreen (without a capital S)');
      },
  exitFullscreen() {
        // This is workaround for chrome. Trying to exit from fullscreen
        // not in fullscreen state will cause "TypeError: Document not active"
        // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
        if (!Browser.isFullscreen) {
          return false;
        }
  
        var CFS = document['exitFullscreen'] ||
                  document['cancelFullScreen'] ||
                  document['mozCancelFullScreen'] ||
                  document['msExitFullscreen'] ||
                  document['webkitCancelFullScreen'] ||
            (() => {});
        CFS.apply(document, []);
        return true;
      },
  nextRAF:0,
  fakeRequestAnimationFrame(func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            Browser.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func, delay);
      },
  requestAnimationFrame(func) {
        if (typeof requestAnimationFrame == 'function') {
          requestAnimationFrame(func);
          return;
        }
        var RAF = Browser.fakeRequestAnimationFrame;
        RAF(func);
      },
  safeSetTimeout(func, timeout) {
        // Legacy function, this is used by the SDL2 port so we need to keep it
        // around at least until that is updated.
        // See https://github.com/libsdl-org/SDL/pull/6304
        return safeSetTimeout(func, timeout);
      },
  safeRequestAnimationFrame(func) {
        
        return Browser.requestAnimationFrame(() => {
          
          callUserCallback(func);
        });
      },
  getMimetype(name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },
  getUserMedia(func) {
        window.getUserMedia ||= navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        window.getUserMedia(func);
      },
  getMovementX(event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },
  getMovementY(event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },
  getMouseWheelDelta(event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll':
            // 3 lines make up a step
            delta = event.detail / 3;
            break;
          case 'mousewheel':
            // 120 units make up a step
            delta = event.wheelDelta / 120;
            break;
          case 'wheel':
            delta = event.deltaY
            switch (event.deltaMode) {
              case 0:
                // DOM_DELTA_PIXEL: 100 pixels make up a step
                delta /= 100;
                break;
              case 1:
                // DOM_DELTA_LINE: 3 lines make up a step
                delta /= 3;
                break;
              case 2:
                // DOM_DELTA_PAGE: A page makes up 80 steps
                delta *= 80;
                break;
              default:
                throw 'unrecognized mouse wheel delta mode: ' + event.deltaMode;
            }
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },
  mouseX:0,
  mouseY:0,
  mouseMovementX:0,
  mouseMovementY:0,
  touches:{
  },
  lastTouches:{
  },
  calculateMouseCoords(pageX, pageY) {
        // Calculate the movement based on the changes
        // in the coordinates.
        var rect = Module["canvas"].getBoundingClientRect();
        var cw = Module["canvas"].width;
        var ch = Module["canvas"].height;
  
        // Neither .scrollX or .pageXOffset are defined in a spec, but
        // we prefer .scrollX because it is currently in a spec draft.
        // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
        var scrollX = ((typeof window.scrollX != 'undefined') ? window.scrollX : window.pageXOffset);
        var scrollY = ((typeof window.scrollY != 'undefined') ? window.scrollY : window.pageYOffset);
        // If this assert lands, it's likely because the browser doesn't support scrollX or pageXOffset
        // and we have no viable fallback.
        assert((typeof scrollX != 'undefined') && (typeof scrollY != 'undefined'), 'Unable to retrieve scroll position, mouse positions likely broken.');
        var adjustedX = pageX - (scrollX + rect.left);
        var adjustedY = pageY - (scrollY + rect.top);
  
        // the canvas might be CSS-scaled compared to its backbuffer;
        // SDL-using content will want mouse coordinates in terms
        // of backbuffer units.
        adjustedX = adjustedX * (cw / rect.width);
        adjustedY = adjustedY * (ch / rect.height);
  
        return { x: adjustedX, y: adjustedY };
      },
  setMouseCoords(pageX, pageY) {
        const {x, y} = Browser.calculateMouseCoords(pageX, pageY);
        Browser.mouseMovementX = x - Browser.mouseX;
        Browser.mouseMovementY = y - Browser.mouseY;
        Browser.mouseX = x;
        Browser.mouseY = y;
      },
  calculateMouseEvent(event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
  
          // check if SDL is available
          if (typeof SDL != "undefined") {
            Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
            Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
            // just add the mouse delta to the current absolut mouse position
            // FIXME: ideally this should be clamped against the canvas size and zero
            Browser.mouseX += Browser.mouseMovementX;
            Browser.mouseY += Browser.mouseMovementY;
          }
        } else {
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL
  
            }
            var coords = Browser.calculateMouseCoords(touch.pageX, touch.pageY);
  
            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              var last = Browser.touches[touch.identifier];
              last ||= coords;
              Browser.lastTouches[touch.identifier] = last;
              Browser.touches[touch.identifier] = coords;
            }
            return;
          }
  
          Browser.setMouseCoords(event.pageX, event.pageY);
        }
      },
  resizeListeners:[],
  updateResizeListeners() {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach((listener) => listener(canvas.width, canvas.height));
      },
  setCanvasSize(width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },
  windowedWidth:0,
  windowedHeight:0,
  setFullscreenCanvasSize() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)] = flags;
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },
  setWindowedCanvasSize() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)] = flags;
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },
  updateCanvasDimensions(canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||
             document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      },
  };
  
  var _emscripten_set_window_title = (title) => document.title = UTF8ToString(title);

  var _emscripten_sleep = (ms) => {
      // emscripten_sleep() does not return a value, but we still need a |return|
      // here for stack switching support (ASYNCIFY=2). In that mode this function
      // returns a Promise instead of nothing, and that Promise is what tells the
      // wasm VM to pause the stack.
      return Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
    };
  _emscripten_sleep.isAsync = true;

  var webgl_enable_ANGLE_instanced_arrays = (ctx) => {
      // Extension available in WebGL 1 from Firefox 26 and Google Chrome 30 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('ANGLE_instanced_arrays');
      if (ext) {
        ctx['vertexAttribDivisor'] = (index, divisor) => ext['vertexAttribDivisorANGLE'](index, divisor);
        ctx['drawArraysInstanced'] = (mode, first, count, primcount) => ext['drawArraysInstancedANGLE'](mode, first, count, primcount);
        ctx['drawElementsInstanced'] = (mode, count, type, indices, primcount) => ext['drawElementsInstancedANGLE'](mode, count, type, indices, primcount);
        return 1;
      }
    };
  
  var webgl_enable_OES_vertex_array_object = (ctx) => {
      // Extension available in WebGL 1 from Firefox 25 and WebKit 536.28/desktop Safari 6.0.3 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('OES_vertex_array_object');
      if (ext) {
        ctx['createVertexArray'] = () => ext['createVertexArrayOES']();
        ctx['deleteVertexArray'] = (vao) => ext['deleteVertexArrayOES'](vao);
        ctx['bindVertexArray'] = (vao) => ext['bindVertexArrayOES'](vao);
        ctx['isVertexArray'] = (vao) => ext['isVertexArrayOES'](vao);
        return 1;
      }
    };
  
  var webgl_enable_WEBGL_draw_buffers = (ctx) => {
      // Extension available in WebGL 1 from Firefox 28 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('WEBGL_draw_buffers');
      if (ext) {
        ctx['drawBuffers'] = (n, bufs) => ext['drawBuffersWEBGL'](n, bufs);
        return 1;
      }
    };
  
  var webgl_enable_WEBGL_multi_draw = (ctx) => {
      // Closure is expected to be allowed to minify the '.multiDrawWebgl' property, so not accessing it quoted.
      return !!(ctx.multiDrawWebgl = ctx.getExtension('WEBGL_multi_draw'));
    };
  
  var getEmscriptenSupportedExtensions = function(ctx) {
      // Restrict the list of advertised extensions to those that we actually
      // support.
      var supportedExtensions = [
        // WebGL 1 extensions
        'ANGLE_instanced_arrays',
        'EXT_blend_minmax',
        'EXT_disjoint_timer_query',
        'EXT_frag_depth',
        'EXT_shader_texture_lod',
        'EXT_sRGB',
        'OES_element_index_uint',
        'OES_fbo_render_mipmap',
        'OES_standard_derivatives',
        'OES_texture_float',
        'OES_texture_half_float',
        'OES_texture_half_float_linear',
        'OES_vertex_array_object',
        'WEBGL_color_buffer_float',
        'WEBGL_depth_texture',
        'WEBGL_draw_buffers',
        // WebGL 1 and WebGL 2 extensions
        'EXT_color_buffer_half_float',
        'EXT_float_blend',
        'EXT_texture_compression_bptc',
        'EXT_texture_compression_rgtc',
        'EXT_texture_filter_anisotropic',
        'KHR_parallel_shader_compile',
        'OES_texture_float_linear',
        'WEBGL_compressed_texture_s3tc',
        'WEBGL_compressed_texture_s3tc_srgb',
        'WEBGL_debug_renderer_info',
        'WEBGL_debug_shaders',
        'WEBGL_lose_context',
        'WEBGL_multi_draw',
      ];
      // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
      return (ctx.getSupportedExtensions() || []).filter(ext => supportedExtensions.includes(ext));
    };
  
  
  var GL = {
  counter:1,
  buffers:[],
  programs:[],
  framebuffers:[],
  renderbuffers:[],
  textures:[],
  shaders:[],
  vaos:[],
  contexts:[],
  offscreenCanvases:{
  },
  queries:[],
  byteSizeByTypeRoot:5120,
  byteSizeByType:[1,1,2,2,4,4,4,2,3,4,8],
  stringCache:{
  },
  unpackAlignment:4,
  recordError:function recordError(errorCode) {
        if (!GL.lastError) {
          GL.lastError = errorCode;
        }
      },
  getNewId:(table) => {
        var ret = GL.counter++;
        for (var i = table.length; i < ret; i++) {
          table[i] = null;
        }
        return ret;
      },
  MAX_TEMP_BUFFER_SIZE:2097152,
  numTempVertexBuffersPerSize:64,
  log2ceilLookup:(i) => 32 - Math.clz32(i === 0 ? 0 : i - 1),
  generateTempBuffers:(quads, context) => {
        var largestIndex = GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);
        context.tempVertexBufferCounters1 = [];
        context.tempVertexBufferCounters2 = [];
        context.tempVertexBufferCounters1.length = context.tempVertexBufferCounters2.length = largestIndex+1;
        context.tempVertexBuffers1 = [];
        context.tempVertexBuffers2 = [];
        context.tempVertexBuffers1.length = context.tempVertexBuffers2.length = largestIndex+1;
        context.tempIndexBuffers = [];
        context.tempIndexBuffers.length = largestIndex+1;
        for (var i = 0; i <= largestIndex; ++i) {
          context.tempIndexBuffers[i] = null; // Created on-demand
          context.tempVertexBufferCounters1[i] = context.tempVertexBufferCounters2[i] = 0;
          var ringbufferLength = GL.numTempVertexBuffersPerSize;
          context.tempVertexBuffers1[i] = [];
          context.tempVertexBuffers2[i] = [];
          var ringbuffer1 = context.tempVertexBuffers1[i];
          var ringbuffer2 = context.tempVertexBuffers2[i];
          ringbuffer1.length = ringbuffer2.length = ringbufferLength;
          for (var j = 0; j < ringbufferLength; ++j) {
            ringbuffer1[j] = ringbuffer2[j] = null; // Created on-demand
          }
        }
  
        if (quads) {
          // GL_QUAD indexes can be precalculated
          context.tempQuadIndexBuffer = GLctx.createBuffer();
          context.GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, context.tempQuadIndexBuffer);
          var numIndexes = GL.MAX_TEMP_BUFFER_SIZE >> 1;
          var quadIndexes = new Uint16Array(numIndexes);
          var i = 0, v = 0;
          while (1) {
            quadIndexes[i++] = v;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+1;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+2;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+2;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+3;
            if (i >= numIndexes) break;
            v += 4;
          }
          context.GLctx.bufferData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, quadIndexes, 0x88E4 /*GL_STATIC_DRAW*/);
          context.GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, null);
        }
      },
  getTempVertexBuffer:function getTempVertexBuffer(sizeBytes) {
        var idx = GL.log2ceilLookup(sizeBytes);
        var ringbuffer = GL.currentContext.tempVertexBuffers1[idx];
        var nextFreeBufferIndex = GL.currentContext.tempVertexBufferCounters1[idx];
        GL.currentContext.tempVertexBufferCounters1[idx] = (GL.currentContext.tempVertexBufferCounters1[idx]+1) & (GL.numTempVertexBuffersPerSize-1);
        var vbo = ringbuffer[nextFreeBufferIndex];
        if (vbo) {
          return vbo;
        }
        var prevVBO = GLctx.getParameter(0x8894 /*GL_ARRAY_BUFFER_BINDING*/);
        ringbuffer[nextFreeBufferIndex] = GLctx.createBuffer();
        GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, ringbuffer[nextFreeBufferIndex]);
        GLctx.bufferData(0x8892 /*GL_ARRAY_BUFFER*/, 1 << idx, 0x88E8 /*GL_DYNAMIC_DRAW*/);
        GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, prevVBO);
        return ringbuffer[nextFreeBufferIndex];
      },
  getTempIndexBuffer:function getTempIndexBuffer(sizeBytes) {
        var idx = GL.log2ceilLookup(sizeBytes);
        var ibo = GL.currentContext.tempIndexBuffers[idx];
        if (ibo) {
          return ibo;
        }
        var prevIBO = GLctx.getParameter(0x8895 /*ELEMENT_ARRAY_BUFFER_BINDING*/);
        GL.currentContext.tempIndexBuffers[idx] = GLctx.createBuffer();
        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, GL.currentContext.tempIndexBuffers[idx]);
        GLctx.bufferData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, 1 << idx, 0x88E8 /*GL_DYNAMIC_DRAW*/);
        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, prevIBO);
        return GL.currentContext.tempIndexBuffers[idx];
      },
  newRenderingFrameStarted:function newRenderingFrameStarted() {
        if (!GL.currentContext) {
          return;
        }
        var vb = GL.currentContext.tempVertexBuffers1;
        GL.currentContext.tempVertexBuffers1 = GL.currentContext.tempVertexBuffers2;
        GL.currentContext.tempVertexBuffers2 = vb;
        vb = GL.currentContext.tempVertexBufferCounters1;
        GL.currentContext.tempVertexBufferCounters1 = GL.currentContext.tempVertexBufferCounters2;
        GL.currentContext.tempVertexBufferCounters2 = vb;
        var largestIndex = GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);
        for (var i = 0; i <= largestIndex; ++i) {
          GL.currentContext.tempVertexBufferCounters1[i] = 0;
        }
      },
  getSource:(shader, count, string, length) => {
        var source = '';
        for (var i = 0; i < count; ++i) {
          var len = length ? HEAP32[(((length)+(i*4))>>2)] : -1;
          source += UTF8ToString(HEAP32[(((string)+(i*4))>>2)], len < 0 ? undefined : len);
        }
        // Let's see if we need to enable the standard derivatives extension
        var type = GLctx.getShaderParameter(GL.shaders[shader], 0x8B4F /* GL_SHADER_TYPE */);
        if (type == 0x8B30 /* GL_FRAGMENT_SHADER */) {
          if (GLEmulation.findToken(source, "dFdx") ||
              GLEmulation.findToken(source, "dFdy") ||
              GLEmulation.findToken(source, "fwidth")) {
            source = "#extension GL_OES_standard_derivatives : enable\n" + source;
            var extension = GLctx.getExtension("OES_standard_derivatives");
          }
        }
        return source;
      },
  createContext:(/** @type {HTMLCanvasElement} */ canvas, webGLContextAttributes) => {
  
        // BUG: Workaround Safari WebGL issue: After successfully acquiring WebGL
        // context on a canvas, calling .getContext() will always return that
        // context independent of which 'webgl' or 'webgl2'
        // context version was passed. See:
        //   https://bugs.webkit.org/show_bug.cgi?id=222758
        // and:
        //   https://github.com/emscripten-core/emscripten/issues/13295.
        // TODO: Once the bug is fixed and shipped in Safari, adjust the Safari
        // version field in above check.
        if (!canvas.getContextSafariWebGL2Fixed) {
          canvas.getContextSafariWebGL2Fixed = canvas.getContext;
          /** @type {function(this:HTMLCanvasElement, string, (Object|null)=): (Object|null)} */
          function fixedGetContext(ver, attrs) {
            var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
            return ((ver == 'webgl') == (gl instanceof WebGLRenderingContext)) ? gl : null;
          }
          canvas.getContext = fixedGetContext;
        }
  
        var ctx =
          (canvas.getContext("webgl", webGLContextAttributes)
            // https://caniuse.com/#feat=webgl
            );
  
        if (!ctx) return 0;
  
        var handle = GL.registerContext(ctx, webGLContextAttributes);
  
        return handle;
      },
  registerContext:(ctx, webGLContextAttributes) => {
        // without pthreads a context is just an integer ID
        var handle = GL.getNewId(GL.contexts);
  
        var context = {
          handle,
          attributes: webGLContextAttributes,
          version: webGLContextAttributes.majorVersion,
          GLctx: ctx
        };
  
        // Store the created context object so that we can access the context
        // given a canvas without having to pass the parameters again.
        if (ctx.canvas) ctx.canvas.GLctxObject = context;
        GL.contexts[handle] = context;
        if (typeof webGLContextAttributes.enableExtensionsByDefault == 'undefined' || webGLContextAttributes.enableExtensionsByDefault) {
          GL.initExtensions(context);
        }
  
        return handle;
      },
  makeContextCurrent:(contextHandle) => {
  
        // Active Emscripten GL layer context object.
        GL.currentContext = GL.contexts[contextHandle];
        // Active WebGL context object.
        Module.ctx = GLctx = GL.currentContext?.GLctx;
        return !(contextHandle && !GLctx);
      },
  getContext:(contextHandle) => {
        return GL.contexts[contextHandle];
      },
  deleteContext:(contextHandle) => {
        if (GL.currentContext === GL.contexts[contextHandle]) {
          GL.currentContext = null;
        }
        if (typeof JSEvents == 'object') {
          // Release all JS event handlers on the DOM element that the GL context is
          // associated with since the context is now deleted.
          JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
        }
        // Make sure the canvas object no longer refers to the context object so
        // there are no GC surprises.
        if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) {
          GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined;
        }
        GL.contexts[contextHandle] = null;
      },
  initExtensions:(context) => {
        // If this function is called without a specific context object, init the
        // extensions of the currently active context.
        context ||= GL.currentContext;
  
        if (context.initExtensionsDone) return;
        context.initExtensionsDone = true;
  
        var GLctx = context.GLctx;
  
        // Detect the presence of a few extensions manually, ction GL interop
        // layer itself will need to know if they exist.
        context.compressionExt = GLctx.getExtension('WEBGL_compressed_texture_s3tc');
        context.anisotropicExt = GLctx.getExtension('EXT_texture_filter_anisotropic');
  
        // Extensions that are only available in WebGL 1 (the calls will be no-ops
        // if called on a WebGL 2 context active)
        webgl_enable_ANGLE_instanced_arrays(GLctx);
        webgl_enable_OES_vertex_array_object(GLctx);
        webgl_enable_WEBGL_draw_buffers(GLctx);
  
        {
          GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query");
        }
  
        webgl_enable_WEBGL_multi_draw(GLctx);
  
        getEmscriptenSupportedExtensions(GLctx).forEach((ext) => {
          // WEBGL_lose_context, WEBGL_debug_renderer_info and WEBGL_debug_shaders
          // are not enabled by default.
          if (!ext.includes('lose_context') && !ext.includes('debug')) {
            // Call .getExtension() to enable that extension permanently.
            GLctx.getExtension(ext);
          }
        });
      },
  };
  
  /** @suppress {duplicate } */
  var _emscripten_webgl_do_commit_frame = () => {
      if (!GL.currentContext || !GL.currentContext.GLctx) {
        return -3;
      }
  
      if (!GL.currentContext.attributes.explicitSwapControl) {
        return -3;
      }
      // We would do GL.currentContext.GLctx.commit(); here, but the current implementation
      // in browsers has removed it - swap is implicit, so this function is a no-op for now
      // (until/unless the spec changes).
      return 0;
    };
  var _emscripten_webgl_commit_frame = _emscripten_webgl_do_commit_frame;

  
  
  var emscripten_webgl_power_preferences = ['default', 'low-power', 'high-performance'];
  
  
  
  /** @suppress {duplicate } */
  var _emscripten_webgl_do_create_context = (target, attributes) => {
      assert(attributes);
      var a = attributes >> 2;
      var powerPreference = HEAP32[a + (24>>2)];
      var contextAttributes = {
        'alpha': !!HEAP32[a + (0>>2)],
        'depth': !!HEAP32[a + (4>>2)],
        'stencil': !!HEAP32[a + (8>>2)],
        'antialias': !!HEAP32[a + (12>>2)],
        'premultipliedAlpha': !!HEAP32[a + (16>>2)],
        'preserveDrawingBuffer': !!HEAP32[a + (20>>2)],
        'powerPreference': emscripten_webgl_power_preferences[powerPreference],
        'failIfMajorPerformanceCaveat': !!HEAP32[a + (28>>2)],
        // The following are not predefined WebGL context attributes in the WebGL specification, so the property names can be minified by Closure.
        majorVersion: HEAP32[a + (32>>2)],
        minorVersion: HEAP32[a + (36>>2)],
        enableExtensionsByDefault: HEAP32[a + (40>>2)],
        explicitSwapControl: HEAP32[a + (44>>2)],
        proxyContextToMainThread: HEAP32[a + (48>>2)],
        renderViaOffscreenBackBuffer: HEAP32[a + (52>>2)]
      };
  
      var canvas = findCanvasEventTarget(target);
  
      if (!canvas) {
        return 0;
      }
  
      if (contextAttributes.explicitSwapControl) {
        return 0;
      }
  
      var contextHandle = GL.createContext(canvas, contextAttributes);
      return contextHandle;
    };
  var _emscripten_webgl_create_context = _emscripten_webgl_do_create_context;

  
  var _emscripten_webgl_destroy_context = (contextHandle) => {
      if (GL.currentContext == contextHandle) GL.currentContext = 0;
      GL.deleteContext(contextHandle);
    };

  var _emscripten_webgl_init_context_attributes = (attributes) => {
      assert(attributes);
      var a = attributes >> 2;
      for (var i = 0; i < (56>>2); ++i) {
        HEAP32[a+i] = 0;
      }
  
      HEAP32[a + (0>>2)] =
      HEAP32[a + (4>>2)] =
      HEAP32[a + (12>>2)] =
      HEAP32[a + (16>>2)] =
      HEAP32[a + (32>>2)] =
      HEAP32[a + (40>>2)] = 1;
  
    };

  var _emscripten_webgl_make_context_current = (contextHandle) => {
      var success = GL.makeContextCurrent(contextHandle);
      return success ? 0 : -5;
    };

  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }

  /** @param {number=} offset */
  var doReadv = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break; // nothing more to read
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    };
  
  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }

  
  var convertI32PairToI53Checked = (lo, hi) => {
      assert(lo == (lo >>> 0) || lo == (lo|0)); // lo should either be a i32 or a u32
      assert(hi === (hi|0));                    // hi should be a i32
      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;
    };
  function _fd_seek(fd,offset_low, offset_high,whence,newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);;
  
    
  try {
  
      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble = stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  ;
  }

  /** @param {number=} offset */
  var doWritev = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    };
  
  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }

  
  
  
  function _glEnable(x0) { GLctx.enable(x0) }
  
  function _glDisable(x0) { GLctx.disable(x0) }
  
  function _glIsEnabled(x0) { return GLctx.isEnabled(x0) }
  
  var readI53FromI64 = (ptr) => {
      return HEAPU32[((ptr)>>2)] + HEAP32[(((ptr)+(4))>>2)] * 4294967296;
    };
  
  var readI53FromU64 = (ptr) => {
      return HEAPU32[((ptr)>>2)] + HEAPU32[(((ptr)+(4))>>2)] * 4294967296;
    };
  var writeI53ToI64 = (ptr, num) => {
      HEAPU32[((ptr)>>2)] = num;
      var lower = HEAPU32[((ptr)>>2)];
      HEAPU32[(((ptr)+(4))>>2)] = (num - lower)/4294967296;
      var deserialized = (num >= 0) ? readI53FromU64(ptr) : readI53FromI64(ptr);
      var offset = ((ptr)>>2);
      if (deserialized != num) warnOnce(`writeI53ToI64() out of range: serialized JS Number ${num} to Wasm heap as bytes lo=${ptrToString(HEAPU32[offset])}, hi=${ptrToString(HEAPU32[offset+1])}, which deserializes back to ${deserialized} instead!`);
    };
  
  var emscriptenWebGLGet = (name_, p, type) => {
      // Guard against user passing a null pointer.
      // Note that GLES2 spec does not say anything about how passing a null
      // pointer should be treated.  Testing on desktop core GL 3, the application
      // crashes on glGetIntegerv to a null pointer, but better to report an error
      // instead of doing anything random.
      if (!p) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var ret = undefined;
      switch (name_) { // Handle a few trivial GLES values
        case 0x8DFA: // GL_SHADER_COMPILER
          ret = 1;
          break;
        case 0x8DF8: // GL_SHADER_BINARY_FORMATS
          if (type != 0 && type != 1) {
            GL.recordError(0x500); // GL_INVALID_ENUM
          }
          // Do not write anything to the out pointer, since no binary formats are
          // supported.
          return;
        case 0x8DF9: // GL_NUM_SHADER_BINARY_FORMATS
          ret = 0;
          break;
        case 0x86A2: // GL_NUM_COMPRESSED_TEXTURE_FORMATS
          // WebGL doesn't have GL_NUM_COMPRESSED_TEXTURE_FORMATS (it's obsolete
          // since GL_COMPRESSED_TEXTURE_FORMATS returns a JS array that can be
          // queried for length), so implement it ourselves to allow C++ GLES2
          // code get the length.
          var formats = GLctx.getParameter(0x86A3 /*GL_COMPRESSED_TEXTURE_FORMATS*/);
          ret = formats ? formats.length : 0;
          break;
  
      }
  
      if (ret === undefined) {
        var result = GLctx.getParameter(name_);
        switch (typeof result) {
          case "number":
            ret = result;
            break;
          case "boolean":
            ret = result ? 1 : 0;
            break;
          case "string":
            GL.recordError(0x500); // GL_INVALID_ENUM
            return;
          case "object":
            if (result === null) {
              // null is a valid result for some (e.g., which buffer is bound -
              // perhaps nothing is bound), but otherwise can mean an invalid
              // name_, which we need to report as an error
              switch (name_) {
                case 0x8894: // ARRAY_BUFFER_BINDING
                case 0x8B8D: // CURRENT_PROGRAM
                case 0x8895: // ELEMENT_ARRAY_BUFFER_BINDING
                case 0x8CA6: // FRAMEBUFFER_BINDING or DRAW_FRAMEBUFFER_BINDING
                case 0x8CA7: // RENDERBUFFER_BINDING
                case 0x8069: // TEXTURE_BINDING_2D
                case 0x85B5: // WebGL 2 GL_VERTEX_ARRAY_BINDING, or WebGL 1 extension OES_vertex_array_object GL_VERTEX_ARRAY_BINDING_OES
                case 0x8514: { // TEXTURE_BINDING_CUBE_MAP
                  ret = 0;
                  break;
                }
                default: {
                  GL.recordError(0x500); // GL_INVALID_ENUM
                  return;
                }
              }
            } else if (result instanceof Float32Array ||
                       result instanceof Uint32Array ||
                       result instanceof Int32Array ||
                       result instanceof Array) {
              for (var i = 0; i < result.length; ++i) {
                switch (type) {
                  case 0: HEAP32[(((p)+(i*4))>>2)] = result[i]; break;
                  case 2: HEAPF32[(((p)+(i*4))>>2)] = result[i]; break;
                  case 4: HEAP8[(((p)+(i))>>0)] = result[i] ? 1 : 0; break;
                }
              }
              return;
            } else {
              try {
                ret = result.name | 0;
              } catch(e) {
                GL.recordError(0x500); // GL_INVALID_ENUM
                err(`GL_INVALID_ENUM in glGet${type}v: Unknown object returned from WebGL getParameter(${name_})! (error: ${e})`);
                return;
              }
            }
            break;
          default:
            GL.recordError(0x500); // GL_INVALID_ENUM
            err(`GL_INVALID_ENUM in glGet${type}v: Native code calling glGet${type}v(${name_}) and it returns ${result} of type ${typeof(result)}!`);
            return;
        }
      }
  
      switch (type) {
        case 1: writeI53ToI64(p, ret); break;
        case 0: HEAP32[((p)>>2)] = ret; break;
        case 2:   HEAPF32[((p)>>2)] = ret; break;
        case 4: HEAP8[((p)>>0)] = ret ? 1 : 0; break;
      }
    };
  
  var _glGetBooleanv = (name_, p) => emscriptenWebGLGet(name_, p, 4);
  
  
  var _glGetIntegerv = (name_, p) => emscriptenWebGLGet(name_, p, 0);
  
  
  
  var stringToNewUTF8 = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret) stringToUTF8(str, ret, size);
      return ret;
    };
  
  
  var webglGetExtensions = function $webglGetExtensions() {
      var exts = getEmscriptenSupportedExtensions(GLctx);
      exts = exts.concat(exts.map((e) => "GL_" + e));
      return exts;
    };
  
  var _glGetString = (name_) => {
      var ret = GL.stringCache[name_];
      if (!ret) {
        switch (name_) {
          case 0x1F03 /* GL_EXTENSIONS */:
            ret = stringToNewUTF8(webglGetExtensions().join(' '));
            break;
          case 0x1F00 /* GL_VENDOR */:
          case 0x1F01 /* GL_RENDERER */:
          case 0x9245 /* UNMASKED_VENDOR_WEBGL */:
          case 0x9246 /* UNMASKED_RENDERER_WEBGL */:
            var s = GLctx.getParameter(name_);
            if (!s) {
              GL.recordError(0x500/*GL_INVALID_ENUM*/);
            }
            ret = s ? stringToNewUTF8(s) : 0;
            break;
  
          case 0x1F02 /* GL_VERSION */:
            var glVersion = GLctx.getParameter(0x1F02 /*GL_VERSION*/);
            // return GLES version string corresponding to the version of the WebGL context
            {
              glVersion = `OpenGL ES 2.0 (${glVersion})`;
            }
            ret = stringToNewUTF8(glVersion);
            break;
          case 0x8B8C /* GL_SHADING_LANGUAGE_VERSION */:
            var glslVersion = GLctx.getParameter(0x8B8C /*GL_SHADING_LANGUAGE_VERSION*/);
            // extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'
            var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
            var ver_num = glslVersion.match(ver_re);
            if (ver_num !== null) {
              if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + '0'; // ensure minor version has 2 digits
              glslVersion = `OpenGL ES GLSL ES ${ver_num[1]} (${glslVersion})`;
            }
            ret = stringToNewUTF8(glslVersion);
            break;
          default:
            GL.recordError(0x500/*GL_INVALID_ENUM*/);
            // fall through
        }
        GL.stringCache[name_] = ret;
      }
      return ret;
    };
  
  var _glCreateShader = (shaderType) => {
      var id = GL.getNewId(GL.shaders);
      GL.shaders[id] = GLctx.createShader(shaderType);
  
      return id;
    };
  
  var _glShaderSource = (shader, count, string, length) => {
      var source = GL.getSource(shader, count, string, length);
  
      GLctx.shaderSource(GL.shaders[shader], source);
    };
  
  var _glCompileShader = (shader) => {
      GLctx.compileShader(GL.shaders[shader]);
    };
  
  var _glAttachShader = (program, shader) => {
      GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
    };
  
  var _glDetachShader = (program, shader) => {
      GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
    };
  
  var _glUseProgram = (program) => {
      program = GL.programs[program];
      GLctx.useProgram(program);
      // Record the currently active program so that we can access the uniform
      // mapping table of that program.
      GLctx.currentProgram = program;
    };
  
  var _glDeleteProgram = (id) => {
      if (!id) return;
      var program = GL.programs[id];
      if (!program) {
        // glDeleteProgram actually signals an error when deleting a nonexisting
        // object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteProgram(program);
      program.name = 0;
      GL.programs[id] = null;
    };
  
  
  var _glBindAttribLocation = (program, index, name) => {
      GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name));
    };
  
  var _glLinkProgram = (program) => {
      program = GL.programs[program];
      GLctx.linkProgram(program);
      // Invalidate earlier computed uniform->ID mappings, those have now become stale
      program.uniformLocsById = 0; // Mark as null-like so that glGetUniformLocation() knows to populate this again.
      program.uniformSizeAndIdsByName = {};
  
    };
  
  var _glBindBuffer = (target, buffer) => {
      if (target == 0x8892 /*GL_ARRAY_BUFFER*/) {
        GLctx.currentArrayBufferBinding = buffer;
        GLImmediate.lastArrayBuffer = buffer;
      } else if (target == 0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/) {
        GLctx.currentElementArrayBufferBinding = buffer;
      }
  
      GLctx.bindBuffer(target, GL.buffers[buffer]);
    };
  
  
  var _glGetFloatv = (name_, p) => emscriptenWebGLGet(name_, p, 2);
  
  function _glHint(x0, x1) { GLctx.hint(x0, x1) }
  
  var _glEnableVertexAttribArray = (index) => {
      GLctx.enableVertexAttribArray(index);
    };
  
  var _glDisableVertexAttribArray = (index) => {
      GLctx.disableVertexAttribArray(index);
    };
  
  var _glVertexAttribPointer = (index, size, type, normalized, stride, ptr) => {
      GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);
    };
  
  function _glActiveTexture(x0) { GLctx.activeTexture(x0) }
  
  
  
  var GLEmulation = {
  fogStart:0,
  fogEnd:1,
  fogDensity:1,
  fogColor:null,
  fogMode:2048,
  fogEnabled:false,
  MAX_CLIP_PLANES:6,
  clipPlaneEnabled:[false,false,false,false,false,false],
  clipPlaneEquation:[],
  lightingEnabled:false,
  lightModelAmbient:null,
  lightModelLocalViewer:false,
  lightModelTwoSide:false,
  materialAmbient:null,
  materialDiffuse:null,
  materialSpecular:null,
  materialShininess:null,
  materialEmission:null,
  MAX_LIGHTS:8,
  lightEnabled:[false,false,false,false,false,false,false,false],
  lightAmbient:[],
  lightDiffuse:[],
  lightSpecular:[],
  lightPosition:[],
  alphaTestEnabled:false,
  alphaTestFunc:519,
  alphaTestRef:0,
  pointSize:1,
  vaos:[],
  currentVao:null,
  enabledVertexAttribArrays:{
  },
  hasRunInit:false,
  findToken(source, token) {
        function isIdentChar(ch) {
          if (ch >= 48 && ch <= 57) // 0-9
            return true;
          if (ch >= 65 && ch <= 90) // A-Z
            return true;
          if (ch >= 97 && ch <= 122) // a-z
            return true;
          return false;
        }
        var i = -1;
        do {
          i = source.indexOf(token, i + 1);
          if (i < 0) {
            break;
          }
          if (i > 0 && isIdentChar(source[i - 1])) {
            continue;
          }
          i += token.length;
          if (i < source.length - 1 && isIdentChar(source[i + 1])) {
            continue;
          }
          return true;
        } while (true);
        return false;
      },
  init() {
        // Do not activate immediate/emulation code (e.g. replace glDrawElements) when in FULL_ES2 mode.
        // We do not need full emulation, we instead emulate client-side arrays etc. in FULL_ES2 code in
        // a straightforward manner, and avoid not having a bound buffer be ambiguous between es2 emulation
        // code and legacy gl emulation code.
  
        if (GLEmulation.hasRunInit) {
          return;
        }
        GLEmulation.hasRunInit = true;
  
        GLEmulation.fogColor = new Float32Array(4);
  
        for (var clipPlaneId = 0; clipPlaneId < GLEmulation.MAX_CLIP_PLANES; clipPlaneId++) {
          GLEmulation.clipPlaneEquation[clipPlaneId] = new Float32Array(4);
        }
  
        // set defaults for GL_LIGHTING
        GLEmulation.lightModelAmbient = new Float32Array([0.2, 0.2, 0.2, 1.0]);
        GLEmulation.materialAmbient = new Float32Array([0.2, 0.2, 0.2, 1.0]);
        GLEmulation.materialDiffuse = new Float32Array([0.8, 0.8, 0.8, 1.0]);
        GLEmulation.materialSpecular = new Float32Array([0.0, 0.0, 0.0, 1.0]);
        GLEmulation.materialShininess = new Float32Array([0.0]);
        GLEmulation.materialEmission = new Float32Array([0.0, 0.0, 0.0, 1.0]);
  
        for (var lightId = 0; lightId < GLEmulation.MAX_LIGHTS; lightId++) {
          GLEmulation.lightAmbient[lightId] = new Float32Array([0.0, 0.0, 0.0, 1.0]);
          GLEmulation.lightDiffuse[lightId] = lightId ? new Float32Array([0.0, 0.0, 0.0, 1.0]) : new Float32Array([1.0, 1.0, 1.0, 1.0]);
          GLEmulation.lightSpecular[lightId] = lightId ? new Float32Array([0.0, 0.0, 0.0, 1.0]) : new Float32Array([1.0, 1.0, 1.0, 1.0]);
          GLEmulation.lightPosition[lightId] = new Float32Array([0.0, 0.0, 1.0, 0.0]);
        }
  
        // Add some emulation workarounds
        err('WARNING: using emscripten GL emulation. This is a collection of limited workarounds, do not expect it to work.');
  
        // XXX some of the capabilities we don't support may lead to incorrect rendering, if we do not emulate them in shaders
        var validCapabilities = {
          0xB44: 1, // GL_CULL_FACE
          0xBE2: 1, // GL_BLEND
          0xBD0: 1, // GL_DITHER,
          0xB90: 1, // GL_STENCIL_TEST
          0xB71: 1, // GL_DEPTH_TEST
          0xC11: 1, // GL_SCISSOR_TEST
          0x8037: 1, // GL_POLYGON_OFFSET_FILL
          0x809E: 1, // GL_SAMPLE_ALPHA_TO_COVERAGE
          0x80A0: 1  // GL_SAMPLE_COVERAGE
        };
  
        var glEnable = _glEnable;
        _glEnable = _emscripten_glEnable = (cap) => {
          // Clean up the renderer on any change to the rendering state. The optimization of
          // skipping renderer setup is aimed at the case of multiple glDraw* right after each other
          GLImmediate.lastRenderer?.cleanup();
          if (cap == 0xB60 /* GL_FOG */) {
            if (GLEmulation.fogEnabled != true) {
              GLImmediate.currentRenderer = null; // Fog parameter is part of the FFP shader state, we must re-lookup the renderer to use.
              GLEmulation.fogEnabled = true;
            }
            return;
          } else if ((cap >= 0x3000) && (cap < 0x3006)  /* GL_CLIP_PLANE0 to GL_CLIP_PLANE5 */) {
            var clipPlaneId = cap - 0x3000;
            if (GLEmulation.clipPlaneEnabled[clipPlaneId] != true) {
              GLImmediate.currentRenderer = null; // clip plane parameter is part of the FFP shader state, we must re-lookup the renderer to use.
              GLEmulation.clipPlaneEnabled[clipPlaneId] = true;
            }
            return;
          } else if ((cap >= 0x4000) && (cap < 0x4008)  /* GL_LIGHT0 to GL_LIGHT7 */) {
            var lightId = cap - 0x4000;
            if (GLEmulation.lightEnabled[lightId] != true) {
              GLImmediate.currentRenderer = null; // light parameter is part of the FFP shader state, we must re-lookup the renderer to use.
              GLEmulation.lightEnabled[lightId] = true;
            }
            return;
          } else if (cap == 0xB50 /* GL_LIGHTING */) {
            if (GLEmulation.lightingEnabled != true) {
              GLImmediate.currentRenderer = null; // light parameter is part of the FFP shader state, we must re-lookup the renderer to use.
              GLEmulation.lightingEnabled = true;
            }
            return;
          } else if (cap == 0xBC0 /* GL_ALPHA_TEST */) {
            if (GLEmulation.alphaTestEnabled != true) {
              GLImmediate.currentRenderer = null; // alpha testing is part of the FFP shader state, we must re-lookup the renderer to use.
              GLEmulation.alphaTestEnabled = true;
            }
            return;
          } else if (cap == 0xDE1 /* GL_TEXTURE_2D */) {
            // XXX not according to spec, and not in desktop GL, but works in some GLES1.x apparently, so support
            // it by forwarding to glEnableClientState
            /* Actually, let's not, for now. (This sounds exceedingly broken)
             * This is in gl_ps_workaround2.c.
            _glEnableClientState(cap);
            */
            return;
          } else if (!(cap in validCapabilities)) {
            return;
          }
          glEnable(cap);
        };
  
        var glDisable = _glDisable;
        _glDisable = _emscripten_glDisable = (cap) => {
          GLImmediate.lastRenderer?.cleanup();
          if (cap == 0xB60 /* GL_FOG */) {
            if (GLEmulation.fogEnabled != false) {
              GLImmediate.currentRenderer = null; // Fog parameter is part of the FFP shader state, we must re-lookup the renderer to use.
              GLEmulation.fogEnabled = false;
            }
            return;
          } else if ((cap >= 0x3000) && (cap < 0x3006)  /* GL_CLIP_PLANE0 to GL_CLIP_PLANE5 */) {
            var clipPlaneId = cap - 0x3000;
            if (GLEmulation.clipPlaneEnabled[clipPlaneId] != false) {
              GLImmediate.currentRenderer = null; // clip plane parameter is part of the FFP shader state, we must re-lookup the renderer to use.
              GLEmulation.clipPlaneEnabled[clipPlaneId] = false;
            }
            return;
          } else if ((cap >= 0x4000) && (cap < 0x4008)  /* GL_LIGHT0 to GL_LIGHT7 */) {
            var lightId = cap - 0x4000;
            if (GLEmulation.lightEnabled[lightId] != false) {
              GLImmediate.currentRenderer = null; // light parameter is part of the FFP shader state, we must re-lookup the renderer to use.
              GLEmulation.lightEnabled[lightId] = false;
            }
            return;
          } else if (cap == 0xB50 /* GL_LIGHTING */) {
            if (GLEmulation.lightingEnabled != false) {
              GLImmediate.currentRenderer = null; // light parameter is part of the FFP shader state, we must re-lookup the renderer to use.
              GLEmulation.lightingEnabled = false;
            }
            return;
          } else if (cap == 0xBC0 /* GL_ALPHA_TEST */) {
            if (GLEmulation.alphaTestEnabled != false) {
              GLImmediate.currentRenderer = null; // alpha testing is part of the FFP shader state, we must re-lookup the renderer to use.
              GLEmulation.alphaTestEnabled = false;
            }
            return;
          } else if (cap == 0xDE1 /* GL_TEXTURE_2D */) {
            // XXX not according to spec, and not in desktop GL, but works in some GLES1.x apparently, so support
            // it by forwarding to glDisableClientState
            /* Actually, let's not, for now. (This sounds exceedingly broken)
             * This is in gl_ps_workaround2.c.
            _glDisableClientState(cap);
            */
            return;
          } else if (!(cap in validCapabilities)) {
            return;
          }
          glDisable(cap);
        };
  
        _glIsEnabled = _emscripten_glIsEnabled = (cap) => {
          if (cap == 0xB60 /* GL_FOG */) {
            return GLEmulation.fogEnabled ? 1 : 0;
          } else if ((cap >= 0x3000) && (cap < 0x3006)  /* GL_CLIP_PLANE0 to GL_CLIP_PLANE5 */) {
            var clipPlaneId = cap - 0x3000;
            return GLEmulation.clipPlaneEnabled[clipPlaneId] ? 1 : 0;
          } else if ((cap >= 0x4000) && (cap < 0x4008)  /* GL_LIGHT0 to GL_LIGHT7 */) {
            var lightId = cap - 0x4000;
            return GLEmulation.lightEnabled[lightId] ? 1 : 0;
          } else if (cap == 0xB50 /* GL_LIGHTING */) {
            return GLEmulation.lightingEnabled ? 1 : 0;
          } else if (cap == 0xBC0 /* GL_ALPHA_TEST */) {
            return GLEmulation.alphaTestEnabled ? 1 : 0;
          } else if (!(cap in validCapabilities)) {
            return 0;
          }
          return GLctx.isEnabled(cap);
        };
  
        var glGetBooleanv = _glGetBooleanv;
        _glGetBooleanv = _emscripten_glGetBooleanv = (pname, p) => {
          var attrib = GLEmulation.getAttributeFromCapability(pname);
          if (attrib !== null) {
            var result = GLImmediate.enabledClientAttributes[attrib];
            HEAP8[((p)>>0)] = result === true ? 1 : 0;
            return;
          }
          glGetBooleanv(pname, p);
        };
  
        var glGetIntegerv = _glGetIntegerv;
        _glGetIntegerv = _emscripten_glGetIntegerv = (pname, params) => {
          switch (pname) {
            case 0x84E2: pname = GLctx.MAX_TEXTURE_IMAGE_UNITS /* fake it */; break; // GL_MAX_TEXTURE_UNITS
            case 0x8B4A: { // GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB
              var result = GLctx.getParameter(GLctx.MAX_VERTEX_UNIFORM_VECTORS);
              HEAP32[((params)>>2)] = result*4; // GLES gives num of 4-element vectors, GL wants individual components, so multiply
              return;
            }
            case 0x8B49: { // GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB
              var result = GLctx.getParameter(GLctx.MAX_FRAGMENT_UNIFORM_VECTORS);
              HEAP32[((params)>>2)] = result*4; // GLES gives num of 4-element vectors, GL wants individual components, so multiply
              return;
            }
            case 0x8B4B: { // GL_MAX_VARYING_FLOATS_ARB
              var result = GLctx.getParameter(GLctx.MAX_VARYING_VECTORS);
              HEAP32[((params)>>2)] = result*4; // GLES gives num of 4-element vectors, GL wants individual components, so multiply
              return;
            }
            case 0x8871: pname = GLctx.MAX_COMBINED_TEXTURE_IMAGE_UNITS /* close enough */; break; // GL_MAX_TEXTURE_COORDS
            case 0x807A: { // GL_VERTEX_ARRAY_SIZE
              var attribute = GLImmediate.clientAttributes[GLImmediate.VERTEX];
              HEAP32[((params)>>2)] = attribute ? attribute.size : 0;
              return;
            }
            case 0x807B: { // GL_VERTEX_ARRAY_TYPE
              var attribute = GLImmediate.clientAttributes[GLImmediate.VERTEX];
              HEAP32[((params)>>2)] = attribute ? attribute.type : 0;
              return;
            }
            case 0x807C: { // GL_VERTEX_ARRAY_STRIDE
              var attribute = GLImmediate.clientAttributes[GLImmediate.VERTEX];
              HEAP32[((params)>>2)] = attribute ? attribute.stride : 0;
              return;
            }
            case 0x8081: { // GL_COLOR_ARRAY_SIZE
              var attribute = GLImmediate.clientAttributes[GLImmediate.COLOR];
              HEAP32[((params)>>2)] = attribute ? attribute.size : 0;
              return;
            }
            case 0x8082: { // GL_COLOR_ARRAY_TYPE
              var attribute = GLImmediate.clientAttributes[GLImmediate.COLOR];
              HEAP32[((params)>>2)] = attribute ? attribute.type : 0;
              return;
            }
            case 0x8083: { // GL_COLOR_ARRAY_STRIDE
              var attribute = GLImmediate.clientAttributes[GLImmediate.COLOR];
              HEAP32[((params)>>2)] = attribute ? attribute.stride : 0;
              return;
            }
            case 0x8088: { // GL_TEXTURE_COORD_ARRAY_SIZE
              var attribute = GLImmediate.clientAttributes[GLImmediate.TEXTURE0 + GLImmediate.clientActiveTexture];
              HEAP32[((params)>>2)] = attribute ? attribute.size : 0;
              return;
            }
            case 0x8089: { // GL_TEXTURE_COORD_ARRAY_TYPE
              var attribute = GLImmediate.clientAttributes[GLImmediate.TEXTURE0 + GLImmediate.clientActiveTexture];
              HEAP32[((params)>>2)] = attribute ? attribute.type : 0;
              return;
            }
            case 0x808A: { // GL_TEXTURE_COORD_ARRAY_STRIDE
              var attribute = GLImmediate.clientAttributes[GLImmediate.TEXTURE0 + GLImmediate.clientActiveTexture];
              HEAP32[((params)>>2)] = attribute ? attribute.stride : 0;
              return;
            }
            case 0x0D32: { // GL_MAX_CLIP_PLANES
              HEAP32[((params)>>2)] = GLEmulation.MAX_CLIP_PLANES; // all implementations need to support atleast 6
              return;
            }
            case 0x0BA0: { // GL_MATRIX_MODE
              HEAP32[((params)>>2)] = GLImmediate.currentMatrix + 0x1700;
              return;
            }
            case 0x0BC1: { // GL_ALPHA_TEST_FUNC
              HEAP32[((params)>>2)] = GLEmulation.alphaTestFunc;
              return;
            }
          }
          glGetIntegerv(pname, params);
        };
  
        var glGetString = _glGetString;
        _glGetString = _emscripten_glGetString = (name_) => {
          if (GL.stringCache[name_]) return GL.stringCache[name_];
          switch (name_) {
            case 0x1F03 /* GL_EXTENSIONS */: // Add various extensions that we can support
              var ret = stringToNewUTF8(getEmscriptenSupportedExtensions(GLctx).join(' ') +
                     ' GL_EXT_texture_env_combine GL_ARB_texture_env_crossbar GL_ATI_texture_env_combine3 GL_NV_texture_env_combine4 GL_EXT_texture_env_dot3 GL_ARB_multitexture GL_ARB_vertex_buffer_object GL_EXT_framebuffer_object GL_ARB_vertex_program GL_ARB_fragment_program GL_ARB_shading_language_100 GL_ARB_shader_objects GL_ARB_vertex_shader GL_ARB_fragment_shader GL_ARB_texture_cube_map GL_EXT_draw_range_elements' +
                     (GL.currentContext.compressionExt ? ' GL_ARB_texture_compression GL_EXT_texture_compression_s3tc' : '') +
                     (GL.currentContext.anisotropicExt ? ' GL_EXT_texture_filter_anisotropic' : '')
              );
              return GL.stringCache[name_] = ret;
          }
          return glGetString(name_);
        };
  
        // Do some automatic rewriting to work around GLSL differences. Note that this must be done in
        // tandem with the rest of the program, by itself it cannot suffice.
        // Note that we need to remember shader types for this rewriting, saving sources makes it easier to debug.
        GL.shaderInfos = {};
        var glCreateShader = _glCreateShader;
        _glCreateShader = _emscripten_glCreateShader = (shaderType) => {
          var id = glCreateShader(shaderType);
          GL.shaderInfos[id] = {
            type: shaderType,
            ftransform: false
          };
          return id;
        };
  
        function ensurePrecision(source) {
          if (!/precision +(low|medium|high)p +float *;/.test(source)) {
            source = '#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n' + source;
          }
          return source;
        }
  
        var glShaderSource = _glShaderSource;
        _glShaderSource = _emscripten_glShaderSource = (shader, count, string, length) => {
          var source = GL.getSource(shader, count, string, length);
          // XXX We add attributes and uniforms to shaders. The program can ask for the # of them, and see the
          // ones we generated, potentially confusing it? Perhaps we should hide them.
          if (GL.shaderInfos[shader].type == GLctx.VERTEX_SHADER) {
            // Replace ftransform() with explicit project/modelview transforms, and add position and matrix info.
            var has_pm = source.search(/u_projection/) >= 0;
            var has_mm = source.search(/u_modelView/) >= 0;
            var has_pv = source.search(/a_position/) >= 0;
            var need_pm = 0, need_mm = 0, need_pv = 0;
            var old = source;
            source = source.replace(/ftransform\(\)/g, '(u_projection * u_modelView * a_position)');
            if (old != source) need_pm = need_mm = need_pv = 1;
            old = source;
            source = source.replace(/gl_ProjectionMatrix/g, 'u_projection');
            if (old != source) need_pm = 1;
            old = source;
            source = source.replace(/gl_ModelViewMatrixTranspose\[2\]/g, 'vec4(u_modelView[0][2], u_modelView[1][2], u_modelView[2][2], u_modelView[3][2])'); // XXX extremely inefficient
            if (old != source) need_mm = 1;
            old = source;
            source = source.replace(/gl_ModelViewMatrix/g, 'u_modelView');
            if (old != source) need_mm = 1;
            old = source;
            source = source.replace(/gl_Vertex/g, 'a_position');
            if (old != source) need_pv = 1;
            old = source;
            source = source.replace(/gl_ModelViewProjectionMatrix/g, '(u_projection * u_modelView)');
            if (old != source) need_pm = need_mm = 1;
            if (need_pv && !has_pv) source = 'attribute vec4 a_position; \n' + source;
            if (need_mm && !has_mm) source = 'uniform mat4 u_modelView; \n' + source;
            if (need_pm && !has_pm) source = 'uniform mat4 u_projection; \n' + source;
            GL.shaderInfos[shader].ftransform = need_pm || need_mm || need_pv; // we will need to provide the fixed function stuff as attributes and uniforms
            for (var i = 0; i < GLImmediate.MAX_TEXTURES; i++) {
              // XXX To handle both regular texture mapping and cube mapping, we use vec4 for tex coordinates.
              old = source;
              var need_vtc = source.search(`v_texCoord${i}`) == -1;
              source = source.replace(new RegExp(`gl_TexCoord\\[${i}\\]`, 'g'), `v_texCoord${i}`)
                             .replace(new RegExp(`gl_MultiTexCoord${i}`, 'g'), `a_texCoord${i}`);
              if (source != old) {
                source = `attribute vec4 a_texCoord${i}; \n${source}`;
                if (need_vtc) {
                  source = `varying vec4 v_texCoord${i};   \n${source}`;
                }
              }
  
              old = source;
              source = source.replace(new RegExp(`gl_TextureMatrix\\[${i}\\]`, 'g'), `u_textureMatrix${i}`);
              if (source != old) {
                source = `uniform mat4 u_textureMatrix${i}; \n${source}`;
              }
            }
            if (source.includes('gl_FrontColor')) {
              source = 'varying vec4 v_color; \n' +
                       source.replace(/gl_FrontColor/g, 'v_color');
            }
            if (source.includes('gl_Color')) {
              source = 'attribute vec4 a_color; \n' +
                       source.replace(/gl_Color/g, 'a_color');
            }
            if (source.includes('gl_Normal')) {
              source = 'attribute vec3 a_normal; \n' +
                       source.replace(/gl_Normal/g, 'a_normal');
            }
            // fog
            if (source.includes('gl_FogFragCoord')) {
              source = 'varying float v_fogFragCoord;   \n' +
                       source.replace(/gl_FogFragCoord/g, 'v_fogFragCoord');
            }
          } else { // Fragment shader
            for (i = 0; i < GLImmediate.MAX_TEXTURES; i++) {
              old = source;
              source = source.replace(new RegExp(`gl_TexCoord\\[${i}\\]`, 'g'), `v_texCoord${i}`);
              if (source != old) {
                source = 'varying vec4 v_texCoord' + i + ';   \n' + source;
              }
            }
            if (source.includes('gl_Color')) {
              source = 'varying vec4 v_color; \n' + source.replace(/gl_Color/g, 'v_color');
            }
            if (source.includes('gl_Fog.color')) {
              source = 'uniform vec4 u_fogColor;   \n' +
                       source.replace(/gl_Fog.color/g, 'u_fogColor');
            }
            if (source.includes('gl_Fog.end')) {
              source = 'uniform float u_fogEnd;   \n' +
                       source.replace(/gl_Fog.end/g, 'u_fogEnd');
            }
            if (source.includes('gl_Fog.scale')) {
              source = 'uniform float u_fogScale;   \n' +
                       source.replace(/gl_Fog.scale/g, 'u_fogScale');
            }
            if (source.includes('gl_Fog.density')) {
              source = 'uniform float u_fogDensity;   \n' +
                       source.replace(/gl_Fog.density/g, 'u_fogDensity');
            }
            if (source.includes('gl_FogFragCoord')) {
              source = 'varying float v_fogFragCoord;   \n' +
                       source.replace(/gl_FogFragCoord/g, 'v_fogFragCoord');
            }
            source = ensurePrecision(source);
          }
          GLctx.shaderSource(GL.shaders[shader], source);
        };
  
        var glCompileShader = _glCompileShader;
        _glCompileShader = _emscripten_glCompileShader = (shader) => {
          GLctx.compileShader(GL.shaders[shader]);
        };
  
        GL.programShaders = {};
        var glAttachShader = _glAttachShader;
        _glAttachShader = _emscripten_glAttachShader = (program, shader) => {
          GL.programShaders[program] ||= [];
          GL.programShaders[program].push(shader);
          glAttachShader(program, shader);
        };
  
        var glDetachShader = _glDetachShader;
        _glDetachShader = _emscripten_glDetachShader = (program, shader) => {
          var programShader = GL.programShaders[program];
          if (!programShader) {
            err(`WARNING: _glDetachShader received invalid program: ${program}`);
            return;
          }
          var index = programShader.indexOf(shader);
          programShader.splice(index, 1);
          glDetachShader(program, shader);
        };
  
        var glUseProgram = _glUseProgram;
        _glUseProgram = _emscripten_glUseProgram = (program) => {
          if (GL.currProgram != program) {
            GLImmediate.currentRenderer = null; // This changes the FFP emulation shader program, need to recompute that.
            GL.currProgram = program;
            GLImmediate.fixedFunctionProgram = 0;
            glUseProgram(program);
          }
        }
  
        var glDeleteProgram = _glDeleteProgram;
        _glDeleteProgram = _emscripten_glDeleteProgram = (program) => {
          glDeleteProgram(program);
          if (program == GL.currProgram) {
            GLImmediate.currentRenderer = null; // This changes the FFP emulation shader program, need to recompute that.
            GL.currProgram = 0;
          }
        };
  
        // If attribute 0 was not bound, bind it to 0 for WebGL performance reasons. Track if 0 is free for that.
        var zeroUsedPrograms = {};
        var glBindAttribLocation = _glBindAttribLocation;
        _glBindAttribLocation = _emscripten_glBindAttribLocation = (program, index, name) => {
          if (index == 0) zeroUsedPrograms[program] = true;
          glBindAttribLocation(program, index, name);
        };
  
        var glLinkProgram = _glLinkProgram;
        _glLinkProgram = _emscripten_glLinkProgram = (program) => {
          if (!(program in zeroUsedPrograms)) {
            GLctx.bindAttribLocation(GL.programs[program], 0, 'a_position');
          }
          glLinkProgram(program);
        };
  
        var glBindBuffer = _glBindBuffer;
        _glBindBuffer = _emscripten_glBindBuffer = (target, buffer) => {
          glBindBuffer(target, buffer);
          if (target == GLctx.ARRAY_BUFFER) {
            if (GLEmulation.currentVao) {
              assert(GLEmulation.currentVao.arrayBuffer == buffer || GLEmulation.currentVao.arrayBuffer == 0 || buffer == 0, 'TODO: support for multiple array buffers in vao');
              GLEmulation.currentVao.arrayBuffer = buffer;
            }
          } else if (target == GLctx.ELEMENT_ARRAY_BUFFER) {
            if (GLEmulation.currentVao) GLEmulation.currentVao.elementArrayBuffer = buffer;
          }
        };
  
        var glGetFloatv = _glGetFloatv;
        _glGetFloatv = _emscripten_glGetFloatv = (pname, params) => {
          if (pname == 0xBA6) { // GL_MODELVIEW_MATRIX
            HEAPF32.set(GLImmediate.matrix[0/*m*/], params >> 2);
          } else if (pname == 0xBA7) { // GL_PROJECTION_MATRIX
            HEAPF32.set(GLImmediate.matrix[1/*p*/], params >> 2);
          } else if (pname == 0xBA8) { // GL_TEXTURE_MATRIX
            HEAPF32.set(GLImmediate.matrix[2/*t*/ + GLImmediate.clientActiveTexture], params >> 2);
          } else if (pname == 0xB66) { // GL_FOG_COLOR
            HEAPF32.set(GLEmulation.fogColor, params >> 2);
          } else if (pname == 0xB63) { // GL_FOG_START
            HEAPF32[((params)>>2)] = GLEmulation.fogStart;
          } else if (pname == 0xB64) { // GL_FOG_END
            HEAPF32[((params)>>2)] = GLEmulation.fogEnd;
          } else if (pname == 0xB62) { // GL_FOG_DENSITY
            HEAPF32[((params)>>2)] = GLEmulation.fogDensity;
          } else if (pname == 0xB65) { // GL_FOG_MODE
            HEAPF32[((params)>>2)] = GLEmulation.fogMode;
          } else if (pname == 0xB53) { // GL_LIGHT_MODEL_AMBIENT
            HEAPF32[((params)>>2)] = GLEmulation.lightModelAmbient[0];
            HEAPF32[(((params)+(4))>>2)] = GLEmulation.lightModelAmbient[1];
            HEAPF32[(((params)+(8))>>2)] = GLEmulation.lightModelAmbient[2];
            HEAPF32[(((params)+(12))>>2)] = GLEmulation.lightModelAmbient[3];
          } else if (pname == 0xBC2) { // GL_ALPHA_TEST_REF
            HEAPF32[((params)>>2)] = GLEmulation.alphaTestRef;
          } else {
            glGetFloatv(pname, params);
          }
        };
  
        var glHint = _glHint;
        _glHint = _emscripten_glHint = (target, mode) => {
          if (target == 0x84EF) { // GL_TEXTURE_COMPRESSION_HINT
            return;
          }
          glHint(target, mode);
        };
  
        var glEnableVertexAttribArray = _glEnableVertexAttribArray;
        _glEnableVertexAttribArray = _emscripten_glEnableVertexAttribArray = (index) => {
          glEnableVertexAttribArray(index);
          GLEmulation.enabledVertexAttribArrays[index] = 1;
          if (GLEmulation.currentVao) GLEmulation.currentVao.enabledVertexAttribArrays[index] = 1;
        };
  
        var glDisableVertexAttribArray = _glDisableVertexAttribArray;
        _glDisableVertexAttribArray = _emscripten_glDisableVertexAttribArray = (index) => {
          glDisableVertexAttribArray(index);
          delete GLEmulation.enabledVertexAttribArrays[index];
          if (GLEmulation.currentVao) delete GLEmulation.currentVao.enabledVertexAttribArrays[index];
        };
  
        var glVertexAttribPointer = _glVertexAttribPointer;
        _glVertexAttribPointer = _emscripten_glVertexAttribPointer = (index, size, type, normalized, stride, pointer) => {
          glVertexAttribPointer(index, size, type, normalized, stride, pointer);
          if (GLEmulation.currentVao) { // TODO: avoid object creation here? likely not hot though
            GLEmulation.currentVao.vertexAttribPointers[index] = [index, size, type, normalized, stride, pointer];
          }
        };
      },
  getAttributeFromCapability(cap) {
        var attrib = null;
        switch (cap) {
          case 0xDE1: // GL_TEXTURE_2D - XXX not according to spec, and not in desktop GL, but works in some GLES1.x apparently, so support it
            abort("GL_TEXTURE_2D is not a spec-defined capability for gl{Enable,Disable}ClientState.");
            // Fall through:
          case 0x8078: // GL_TEXTURE_COORD_ARRAY
            attrib = GLImmediate.TEXTURE0 + GLImmediate.clientActiveTexture; break;
          case 0x8074: // GL_VERTEX_ARRAY
            attrib = GLImmediate.VERTEX; break;
          case 0x8075: // GL_NORMAL_ARRAY
            attrib = GLImmediate.NORMAL; break;
          case 0x8076: // GL_COLOR_ARRAY
            attrib = GLImmediate.COLOR; break;
        }
        return attrib;
      },
  };
  var GLImmediate = {
  MapTreeLib:null,
  spawnMapTreeLib:() => {
        /**
         * A naive implementation of a map backed by an array, and accessed by
         * naive iteration along the array. (hashmap with only one bucket)
         * @constructor
         */
        function CNaiveListMap() {
          var list = [];
  
          this.insert = function CNaiveListMap_insert(key, val) {
            if (this.contains(key|0)) return false;
            list.push([key, val]);
            return true;
          };
  
          var __contains_i;
          this.contains = function CNaiveListMap_contains(key) {
            for (__contains_i = 0; __contains_i < list.length; ++__contains_i) {
              if (list[__contains_i][0] === key) return true;
            }
            return false;
          };
  
          var __get_i;
          this.get = function CNaiveListMap_get(key) {
            for (__get_i = 0; __get_i < list.length; ++__get_i) {
              if (list[__get_i][0] === key) return list[__get_i][1];
            }
            return undefined;
          };
        };
  
        /**
         * A tree of map nodes.
         * Uses `KeyView`s to allow descending the tree without garbage.
         * Example: {
         *   // Create our map object.
         *   var map = new ObjTreeMap();
         *
         *   // Grab the static keyView for the map.
         *   var keyView = map.GetStaticKeyView();
         *
         *   // Let's make a map for:
         *   // root: <undefined>
         *   //   1: <undefined>
         *   //     2: <undefined>
         *   //       5: "Three, sir!"
         *   //       3: "Three!"
         *
         *   // Note how we can chain together `Reset` and `Next` to
         *   // easily descend based on multiple key fragments.
         *   keyView.Reset().Next(1).Next(2).Next(5).Set("Three, sir!");
         *   keyView.Reset().Next(1).Next(2).Next(3).Set("Three!");
         * }
         * @constructor
         */
        function CMapTree() {
          /** @constructor */
          function CNLNode() {
            var map = new CNaiveListMap();
  
            this.child = function CNLNode_child(keyFrag) {
              if (!map.contains(keyFrag|0)) {
                map.insert(keyFrag|0, new CNLNode());
              }
              return map.get(keyFrag|0);
            };
  
            this.value = undefined;
            this.get = function CNLNode_get() {
              return this.value;
            };
  
            this.set = function CNLNode_set(val) {
              this.value = val;
            };
          }
  
          /** @constructor */
          function CKeyView(root) {
            var cur;
  
            this.reset = function CKeyView_reset() {
              cur = root;
              return this;
            };
            this.reset();
  
            this.next = function CKeyView_next(keyFrag) {
              cur = cur.child(keyFrag);
              return this;
            };
  
            this.get = function CKeyView_get() {
              return cur.get();
            };
  
            this.set = function CKeyView_set(val) {
              cur.set(val);
            };
          };
  
          var root;
          var staticKeyView;
  
          this.createKeyView = function CNLNode_createKeyView() {
            return new CKeyView(root);
          }
  
          this.clear = function CNLNode_clear() {
            root = new CNLNode();
            staticKeyView = this.createKeyView();
          };
          this.clear();
  
          this.getStaticKeyView = function CNLNode_getStaticKeyView() {
            staticKeyView.reset();
            return staticKeyView;
          };
        };
  
        // Exports:
        return {
          create: () => new CMapTree(),
        };
      },
  TexEnvJIT:null,
  spawnTexEnvJIT:() => {
        // GL defs:
        var GL_TEXTURE0 = 0x84C0;
        var GL_TEXTURE_1D = 0xDE0;
        var GL_TEXTURE_2D = 0xDE1;
        var GL_TEXTURE_3D = 0x806f;
        var GL_TEXTURE_CUBE_MAP = 0x8513;
        var GL_TEXTURE_ENV = 0x2300;
        var GL_TEXTURE_ENV_MODE = 0x2200;
        var GL_TEXTURE_ENV_COLOR = 0x2201;
        var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
        var GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
        var GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
        var GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
        var GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
        var GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
  
        var GL_SRC0_RGB = 0x8580;
        var GL_SRC1_RGB = 0x8581;
        var GL_SRC2_RGB = 0x8582;
  
        var GL_SRC0_ALPHA = 0x8588;
        var GL_SRC1_ALPHA = 0x8589;
        var GL_SRC2_ALPHA = 0x858A;
  
        var GL_OPERAND0_RGB = 0x8590;
        var GL_OPERAND1_RGB = 0x8591;
        var GL_OPERAND2_RGB = 0x8592;
  
        var GL_OPERAND0_ALPHA = 0x8598;
        var GL_OPERAND1_ALPHA = 0x8599;
        var GL_OPERAND2_ALPHA = 0x859A;
  
        var GL_COMBINE_RGB = 0x8571;
        var GL_COMBINE_ALPHA = 0x8572;
  
        var GL_RGB_SCALE = 0x8573;
        var GL_ALPHA_SCALE = 0xD1C;
  
        // env.mode
        var GL_ADD      = 0x104;
        var GL_BLEND    = 0xBE2;
        var GL_REPLACE  = 0x1E01;
        var GL_MODULATE = 0x2100;
        var GL_DECAL    = 0x2101;
        var GL_COMBINE  = 0x8570;
  
        // env.color/alphaCombiner
        //var GL_ADD         = 0x104;
        //var GL_REPLACE     = 0x1E01;
        //var GL_MODULATE    = 0x2100;
        var GL_SUBTRACT    = 0x84E7;
        var GL_INTERPOLATE = 0x8575;
  
        // env.color/alphaSrc
        var GL_TEXTURE       = 0x1702;
        var GL_CONSTANT      = 0x8576;
        var GL_PRIMARY_COLOR = 0x8577;
        var GL_PREVIOUS      = 0x8578;
  
        // env.color/alphaOp
        var GL_SRC_COLOR           = 0x300;
        var GL_ONE_MINUS_SRC_COLOR = 0x301;
        var GL_SRC_ALPHA           = 0x302;
        var GL_ONE_MINUS_SRC_ALPHA = 0x303;
  
        var GL_RGB  = 0x1907;
        var GL_RGBA = 0x1908;
  
        // Our defs:
        var TEXENVJIT_NAMESPACE_PREFIX = "tej_";
        // Not actually constant, as they can be changed between JIT passes:
        var TEX_UNIT_UNIFORM_PREFIX = "uTexUnit";
        var TEX_COORD_VARYING_PREFIX = "vTexCoord";
        var PRIM_COLOR_VARYING = "vPrimColor";
        var TEX_MATRIX_UNIFORM_PREFIX = "uTexMatrix";
  
        // Static vars:
        var s_texUnits = null; //[];
        var s_activeTexture = 0;
  
        var s_requiredTexUnitsForPass = [];
  
        // Static funcs:
        function abort(info) {
          assert(false, "[TexEnvJIT] ABORT: " + info);
        }
  
        function abort_noSupport(info) {
          abort("No support: " + info);
        }
  
        function abort_sanity(info) {
          abort("Sanity failure: " + info);
        }
  
        function genTexUnitSampleExpr(texUnitID) {
          var texUnit = s_texUnits[texUnitID];
          var texType = texUnit.getTexType();
  
          var func = null;
          switch (texType) {
            case GL_TEXTURE_1D:
              func = "texture2D";
              break;
            case GL_TEXTURE_2D:
              func = "texture2D";
              break;
            case GL_TEXTURE_3D:
              return abort_noSupport("No support for 3D textures.");
            case GL_TEXTURE_CUBE_MAP:
              func = "textureCube";
              break;
            default:
              return abort_sanity("Unknown texType: " + ptrToString(texType));
          }
  
          var texCoordExpr = TEX_COORD_VARYING_PREFIX + texUnitID;
          if (TEX_MATRIX_UNIFORM_PREFIX != null) {
            texCoordExpr = "(" + TEX_MATRIX_UNIFORM_PREFIX + texUnitID + " * " + texCoordExpr + ")";
          }
          return func + "(" + TEX_UNIT_UNIFORM_PREFIX + texUnitID + ", " + texCoordExpr + ".xy)";
        }
  
        function getTypeFromCombineOp(op) {
          switch (op) {
            case GL_SRC_COLOR:
            case GL_ONE_MINUS_SRC_COLOR:
              return "vec3";
            case GL_SRC_ALPHA:
            case GL_ONE_MINUS_SRC_ALPHA:
              return "float";
          }
  
          return abort_noSupport("Unsupported combiner op: " + ptrToString(op));
        }
  
        function getCurTexUnit() {
          return s_texUnits[s_activeTexture];
        }
  
        function genCombinerSourceExpr(texUnitID, constantExpr, previousVar,
                                       src, op)
        {
          var srcExpr = null;
          switch (src) {
            case GL_TEXTURE:
              srcExpr = genTexUnitSampleExpr(texUnitID);
              break;
            case GL_CONSTANT:
              srcExpr = constantExpr;
              break;
            case GL_PRIMARY_COLOR:
              srcExpr = PRIM_COLOR_VARYING;
              break;
            case GL_PREVIOUS:
              srcExpr = previousVar;
              break;
            default:
                return abort_noSupport("Unsupported combiner src: " + ptrToString(src));
          }
  
          var expr = null;
          switch (op) {
            case GL_SRC_COLOR:
              expr = srcExpr + ".rgb";
              break;
            case GL_ONE_MINUS_SRC_COLOR:
              expr = "(vec3(1.0) - " + srcExpr + ".rgb)";
              break;
            case GL_SRC_ALPHA:
              expr = srcExpr + ".a";
              break;
            case GL_ONE_MINUS_SRC_ALPHA:
              expr = "(1.0 - " + srcExpr + ".a)";
              break;
            default:
              return abort_noSupport("Unsupported combiner op: " + ptrToString(op));
          }
  
          return expr;
        }
  
        function valToFloatLiteral(val) {
          if (val == Math.round(val)) return val + '.0';
          return val;
        }
  
        // Classes:
        /** @constructor */
        function CTexEnv() {
          this.mode = GL_MODULATE;
          this.colorCombiner = GL_MODULATE;
          this.alphaCombiner = GL_MODULATE;
          this.colorScale = 1;
          this.alphaScale = 1;
          this.envColor = [0, 0, 0, 0];
  
          this.colorSrc = [
            GL_TEXTURE,
            GL_PREVIOUS,
            GL_CONSTANT
          ];
          this.alphaSrc = [
            GL_TEXTURE,
            GL_PREVIOUS,
            GL_CONSTANT
          ];
          this.colorOp = [
            GL_SRC_COLOR,
            GL_SRC_COLOR,
            GL_SRC_ALPHA
          ];
          this.alphaOp = [
            GL_SRC_ALPHA,
            GL_SRC_ALPHA,
            GL_SRC_ALPHA
          ];
  
          // Map GLenums to small values to efficiently pack the enums to bits for tighter access.
          this.traverseKey = {
            // mode
            0x1E01 /* GL_REPLACE */: 0,
            0x2100 /* GL_MODULATE */: 1,
            0x104 /* GL_ADD */: 2,
            0xBE2 /* GL_BLEND */: 3,
            0x2101 /* GL_DECAL */: 4,
            0x8570 /* GL_COMBINE */: 5,
  
            // additional color and alpha combiners
            0x84E7 /* GL_SUBTRACT */: 3,
            0x8575 /* GL_INTERPOLATE */: 4,
  
            // color and alpha src
            0x1702 /* GL_TEXTURE */: 0,
            0x8576 /* GL_CONSTANT */: 1,
            0x8577 /* GL_PRIMARY_COLOR */: 2,
            0x8578 /* GL_PREVIOUS */: 3,
  
            // color and alpha op
            0x300 /* GL_SRC_COLOR */: 0,
            0x301 /* GL_ONE_MINUS_SRC_COLOR */: 1,
            0x302 /* GL_SRC_ALPHA */: 2,
            0x303 /* GL_ONE_MINUS_SRC_ALPHA */: 3
          };
  
          // The tuple (key0,key1,key2) uniquely identifies the state of the variables in CTexEnv.
          // -1 on key0 denotes 'the whole cached key is dirty'
          this.key0 = -1;
          this.key1 = 0;
          this.key2 = 0;
  
          this.computeKey0 = function() {
            var k = this.traverseKey;
            var key = k[this.mode] * 1638400; // 6 distinct values.
            key += k[this.colorCombiner] * 327680; // 5 distinct values.
            key += k[this.alphaCombiner] * 65536; // 5 distinct values.
            // The above three fields have 6*5*5=150 distinct values -> 8 bits.
            key += (this.colorScale-1) * 16384; // 10 bits used.
            key += (this.alphaScale-1) * 4096; // 12 bits used.
            key += k[this.colorSrc[0]] * 1024; // 14
            key += k[this.colorSrc[1]] * 256; // 16
            key += k[this.colorSrc[2]] * 64; // 18
            key += k[this.alphaSrc[0]] * 16; // 20
            key += k[this.alphaSrc[1]] * 4; // 22
            key += k[this.alphaSrc[2]]; // 24 bits used total.
            return key;
          }
          this.computeKey1 = function() {
            var k = this.traverseKey;
            var key = k[this.colorOp[0]] * 4096;
            key += k[this.colorOp[1]] * 1024;
            key += k[this.colorOp[2]] * 256;
            key += k[this.alphaOp[0]] * 16;
            key += k[this.alphaOp[1]] * 4;
            key += k[this.alphaOp[2]];
            return key;
          }
          // TODO: remove this. The color should not be part of the key!
          this.computeKey2 = function() {
            return this.envColor[0] * 16777216 + this.envColor[1] * 65536 + this.envColor[2] * 256 + 1 + this.envColor[3];
          }
          this.recomputeKey = function() {
            this.key0 = this.computeKey0();
            this.key1 = this.computeKey1();
            this.key2 = this.computeKey2();
          }
          this.invalidateKey = function() {
            this.key0 = -1; // The key of this texture unit must be recomputed when rendering the next time.
            GLImmediate.currentRenderer = null; // The currently used renderer must be re-evaluated at next render.
          }
        }
  
        /** @constructor */
        function CTexUnit() {
          this.env = new CTexEnv();
          this.enabled_tex1D   = false;
          this.enabled_tex2D   = false;
          this.enabled_tex3D   = false;
          this.enabled_texCube = false;
          this.texTypesEnabled = 0; // A bitfield combination of the four flags above, used for fast access to operations.
  
          this.traverseState = function CTexUnit_traverseState(keyView) {
            if (this.texTypesEnabled) {
              if (this.env.key0 == -1) {
                this.env.recomputeKey();
              }
              keyView.next(this.texTypesEnabled | (this.env.key0 << 4));
              keyView.next(this.env.key1);
              keyView.next(this.env.key2);
            } else {
              // For correctness, must traverse a zero value, theoretically a subsequent integer key could collide with this value otherwise.
              keyView.next(0);
            }
          };
        };
  
        // Class impls:
        CTexUnit.prototype.enabled = function CTexUnit_enabled() {
          return this.texTypesEnabled;
        }
  
        CTexUnit.prototype.genPassLines = function CTexUnit_genPassLines(passOutputVar, passInputVar, texUnitID) {
          if (!this.enabled()) {
            return ["vec4 " + passOutputVar + " = " + passInputVar + ";"];
          }
          var lines = this.env.genPassLines(passOutputVar, passInputVar, texUnitID).join('\n');
  
          var texLoadLines = '';
          var texLoadRegex = /(texture.*?\(.*?\))/g;
          var loadCounter = 0;
          var load;
  
          // As an optimization, merge duplicate identical texture loads to one var.
          while (load = texLoadRegex.exec(lines)) {
            var texLoadExpr = load[1];
            var secondOccurrence = lines.slice(load.index+1).indexOf(texLoadExpr);
            if (secondOccurrence != -1) { // And also has a second occurrence of same load expression..
              // Create new var to store the common load.
              var prefix = TEXENVJIT_NAMESPACE_PREFIX + 'env' + texUnitID + "_";
              var texLoadVar = prefix + 'texload' + loadCounter++;
              var texLoadLine = 'vec4 ' + texLoadVar + ' = ' + texLoadExpr + ';\n';
              texLoadLines += texLoadLine + '\n'; // Store the generated texture load statements in a temp string to not confuse regex search in progress.
              lines = lines.split(texLoadExpr).join(texLoadVar);
              // Reset regex search, since we modified the string.
              texLoadRegex = /(texture.*\(.*\))/g;
            }
          }
          return [texLoadLines + lines];
        }
  
        CTexUnit.prototype.getTexType = function CTexUnit_getTexType() {
          if (this.enabled_texCube) {
            return GL_TEXTURE_CUBE_MAP;
          } else if (this.enabled_tex3D) {
            return GL_TEXTURE_3D;
          } else if (this.enabled_tex2D) {
            return GL_TEXTURE_2D;
          } else if (this.enabled_tex1D) {
            return GL_TEXTURE_1D;
          }
          return 0;
        }
  
        CTexEnv.prototype.genPassLines = function CTexEnv_genPassLines(passOutputVar, passInputVar, texUnitID) {
          switch (this.mode) {
            case GL_REPLACE: {
              /* RGB:
               * Cv = Cs
               * Av = Ap // Note how this is different, and that we'll
               *            need to track the bound texture internalFormat
               *            to get this right.
               *
               * RGBA:
               * Cv = Cs
               * Av = As
               */
              return [
                "vec4 " + passOutputVar + " = " + genTexUnitSampleExpr(texUnitID) + ";",
              ];
            }
            case GL_ADD: {
              /* RGBA:
               * Cv = Cp + Cs
               * Av = ApAs
               */
              var prefix = TEXENVJIT_NAMESPACE_PREFIX + 'env' + texUnitID + "_";
              var texVar = prefix + "tex";
              var colorVar = prefix + "color";
              var alphaVar = prefix + "alpha";
  
              return [
                "vec4 " + texVar + " = " + genTexUnitSampleExpr(texUnitID) + ";",
                "vec3 " + colorVar + " = " + passInputVar + ".rgb + " + texVar + ".rgb;",
                "float " + alphaVar + " = " + passInputVar + ".a * " + texVar + ".a;",
                "vec4 " + passOutputVar + " = vec4(" + colorVar + ", " + alphaVar + ");",
              ];
            }
            case GL_MODULATE: {
              /* RGBA:
               * Cv = CpCs
               * Av = ApAs
               */
              var line = [
                "vec4 " + passOutputVar,
                " = ",
                  passInputVar,
                  " * ",
                  genTexUnitSampleExpr(texUnitID),
                ";",
              ];
              return [line.join("")];
            }
            case GL_DECAL: {
              /* RGBA:
               * Cv = Cp(1 - As) + CsAs
               * Av = Ap
               */
              var prefix = TEXENVJIT_NAMESPACE_PREFIX + 'env' + texUnitID + "_";
              var texVar = prefix + "tex";
              var colorVar = prefix + "color";
              var alphaVar = prefix + "alpha";
  
              return [
                "vec4 " + texVar + " = " + genTexUnitSampleExpr(texUnitID) + ";",
                [
                  "vec3 " + colorVar + " = ",
                    passInputVar + ".rgb * (1.0 - " + texVar + ".a)",
                      " + ",
                    texVar + ".rgb * " + texVar + ".a",
                  ";"
                ].join(""),
                "float " + alphaVar + " = " + passInputVar + ".a;",
                "vec4 " + passOutputVar + " = vec4(" + colorVar + ", " + alphaVar + ");",
              ];
            }
            case GL_BLEND: {
              /* RGBA:
               * Cv = Cp(1 - Cs) + CcCs
               * Av = As
               */
              var prefix = TEXENVJIT_NAMESPACE_PREFIX + 'env' + texUnitID + "_";
              var texVar = prefix + "tex";
              var colorVar = prefix + "color";
              var alphaVar = prefix + "alpha";
  
              return [
                "vec4 " + texVar + " = " + genTexUnitSampleExpr(texUnitID) + ";",
                [
                  "vec3 " + colorVar + " = ",
                    passInputVar + ".rgb * (1.0 - " + texVar + ".rgb)",
                      " + ",
                    PRIM_COLOR_VARYING + ".rgb * " + texVar + ".rgb",
                  ";"
                ].join(""),
                "float " + alphaVar + " = " + texVar + ".a;",
                "vec4 " + passOutputVar + " = vec4(" + colorVar + ", " + alphaVar + ");",
              ];
            }
            case GL_COMBINE: {
              var prefix = TEXENVJIT_NAMESPACE_PREFIX + 'env' + texUnitID + "_";
              var colorVar = prefix + "color";
              var alphaVar = prefix + "alpha";
              var colorLines = this.genCombinerLines(true, colorVar,
                                                     passInputVar, texUnitID,
                                                     this.colorCombiner, this.colorSrc, this.colorOp);
              var alphaLines = this.genCombinerLines(false, alphaVar,
                                                     passInputVar, texUnitID,
                                                     this.alphaCombiner, this.alphaSrc, this.alphaOp);
  
              // Generate scale, but avoid generating an identity op that multiplies by one.
              var scaledColor = (this.colorScale == 1) ? colorVar : (colorVar + " * " + valToFloatLiteral(this.colorScale));
              var scaledAlpha = (this.alphaScale == 1) ? alphaVar : (alphaVar + " * " + valToFloatLiteral(this.alphaScale));
  
              var line = [
                "vec4 " + passOutputVar,
                " = ",
                  "vec4(",
                      scaledColor,
                      ", ",
                      scaledAlpha,
                  ")",
                ";",
              ].join("");
              return [].concat(colorLines, alphaLines, [line]);
            }
          }
  
          return abort_noSupport("Unsupported TexEnv mode: " + ptrToString(this.mode));
        }
  
        CTexEnv.prototype.genCombinerLines = function CTexEnv_getCombinerLines(isColor, outputVar,
                                                                               passInputVar, texUnitID,
                                                                               combiner, srcArr, opArr)
        {
          var argsNeeded = null;
          switch (combiner) {
            case GL_REPLACE:
              argsNeeded = 1;
              break;
  
            case GL_MODULATE:
            case GL_ADD:
            case GL_SUBTRACT:
              argsNeeded = 2;
              break;
  
            case GL_INTERPOLATE:
              argsNeeded = 3;
              break;
  
            default:
              return abort_noSupport("Unsupported combiner: " + ptrToString(combiner));
          }
  
          var constantExpr = [
            "vec4(",
              valToFloatLiteral(this.envColor[0]),
              ", ",
              valToFloatLiteral(this.envColor[1]),
              ", ",
              valToFloatLiteral(this.envColor[2]),
              ", ",
              valToFloatLiteral(this.envColor[3]),
            ")",
          ].join("");
          var src0Expr = (argsNeeded >= 1) ? genCombinerSourceExpr(texUnitID, constantExpr, passInputVar, srcArr[0], opArr[0])
                                           : null;
          var src1Expr = (argsNeeded >= 2) ? genCombinerSourceExpr(texUnitID, constantExpr, passInputVar, srcArr[1], opArr[1])
                                           : null;
          var src2Expr = (argsNeeded >= 3) ? genCombinerSourceExpr(texUnitID, constantExpr, passInputVar, srcArr[2], opArr[2])
                                           : null;
  
          var outputType = isColor ? "vec3" : "float";
          var lines = null;
          switch (combiner) {
            case GL_REPLACE: {
              var line = [
                outputType + " " + outputVar,
                " = ",
                  src0Expr,
                ";",
              ];
              lines = [line.join("")];
              break;
            }
            case GL_MODULATE: {
              var line = [
                outputType + " " + outputVar + " = ",
                  src0Expr + " * " + src1Expr,
                ";",
              ];
              lines = [line.join("")];
              break;
            }
            case GL_ADD: {
              var line = [
                outputType + " " + outputVar + " = ",
                  src0Expr + " + " + src1Expr,
                ";",
              ];
              lines = [line.join("")];
              break;
            }
            case GL_SUBTRACT: {
              var line = [
                outputType + " " + outputVar + " = ",
                  src0Expr + " - " + src1Expr,
                ";",
              ];
              lines = [line.join("")];
              break;
            }
            case GL_INTERPOLATE: {
              var prefix = TEXENVJIT_NAMESPACE_PREFIX + 'env' + texUnitID + "_";
              var arg2Var = prefix + "colorSrc2";
              var arg2Line = getTypeFromCombineOp(this.colorOp[2]) + " " + arg2Var + " = " + src2Expr + ";";
  
              var line = [
                outputType + " " + outputVar,
                " = ",
                  src0Expr + " * " + arg2Var,
                  " + ",
                  src1Expr + " * (1.0 - " + arg2Var + ")",
                ";",
              ];
              lines = [
                arg2Line,
                line.join(""),
              ];
              break;
            }
  
            default:
              return abort_sanity("Unmatched TexEnv.colorCombiner?");
          }
  
          return lines;
        }
  
        return {
          // Exports:
          init: (gl, specifiedMaxTextureImageUnits) => {
            var maxTexUnits = 0;
            if (specifiedMaxTextureImageUnits) {
              maxTexUnits = specifiedMaxTextureImageUnits;
            } else if (gl) {
              maxTexUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            }
            assert(maxTexUnits > 0);
            s_texUnits = [];
            for (var i = 0; i < maxTexUnits; i++) {
              s_texUnits.push(new CTexUnit());
            }
          },
  
          setGLSLVars: (uTexUnitPrefix, vTexCoordPrefix, vPrimColor, uTexMatrixPrefix) => {
            TEX_UNIT_UNIFORM_PREFIX   = uTexUnitPrefix;
            TEX_COORD_VARYING_PREFIX  = vTexCoordPrefix;
            PRIM_COLOR_VARYING        = vPrimColor;
            TEX_MATRIX_UNIFORM_PREFIX = uTexMatrixPrefix;
          },
  
          genAllPassLines: (resultDest, indentSize = 0) => {
            s_requiredTexUnitsForPass.length = 0; // Clear the list.
            var lines = [];
            var lastPassVar = PRIM_COLOR_VARYING;
            for (var i = 0; i < s_texUnits.length; i++) {
              if (!s_texUnits[i].enabled()) continue;
  
              s_requiredTexUnitsForPass.push(i);
  
              var prefix = TEXENVJIT_NAMESPACE_PREFIX + 'env' + i + "_";
              var passOutputVar = prefix + "result";
  
              var newLines = s_texUnits[i].genPassLines(passOutputVar, lastPassVar, i);
              lines = lines.concat(newLines, [""]);
  
              lastPassVar = passOutputVar;
            }
            lines.push(resultDest + " = " + lastPassVar + ";");
  
            var indent = "";
            for (var i = 0; i < indentSize; i++) indent += " ";
  
            var output = indent + lines.join("\n" + indent);
  
            return output;
          },
  
          getUsedTexUnitList: () => s_requiredTexUnitsForPass,
  
          getActiveTexture: () => s_activeTexture,
  
          traverseState: (keyView) => {
            for (var i = 0; i < s_texUnits.length; i++) {
              s_texUnits[i].traverseState(keyView);
            }
          },
  
          getTexUnitType: (texUnitID) => {
            assert(texUnitID >= 0 &&
                   texUnitID < s_texUnits.length);
            return s_texUnits[texUnitID].getTexType();
          },
  
          // Hooks:
          hook_activeTexture: (texture) => {
            s_activeTexture = texture - GL_TEXTURE0;
            // Check if the current matrix mode is GL_TEXTURE.
            if (GLImmediate.currentMatrix >= 2) {
              // Switch to the corresponding texture matrix stack.
              GLImmediate.currentMatrix = 2 + s_activeTexture;
            }
          },
  
          hook_enable: (cap) => {
            var cur = getCurTexUnit();
            switch (cap) {
              case GL_TEXTURE_1D:
                if (!cur.enabled_tex1D) {
                  GLImmediate.currentRenderer = null; // Renderer state changed, and must be recreated or looked up again.
                  cur.enabled_tex1D = true;
                  cur.texTypesEnabled |= 1;
                }
                break;
              case GL_TEXTURE_2D:
                if (!cur.enabled_tex2D) {
                  GLImmediate.currentRenderer = null;
                  cur.enabled_tex2D = true;
                  cur.texTypesEnabled |= 2;
                }
                break;
              case GL_TEXTURE_3D:
                if (!cur.enabled_tex3D) {
                  GLImmediate.currentRenderer = null;
                  cur.enabled_tex3D = true;
                  cur.texTypesEnabled |= 4;
                }
                break;
              case GL_TEXTURE_CUBE_MAP:
                if (!cur.enabled_texCube) {
                  GLImmediate.currentRenderer = null;
                  cur.enabled_texCube = true;
                  cur.texTypesEnabled |= 8;
                }
                break;
            }
          },
  
          hook_disable: (cap) => {
            var cur = getCurTexUnit();
            switch (cap) {
              case GL_TEXTURE_1D:
                if (cur.enabled_tex1D) {
                  GLImmediate.currentRenderer = null; // Renderer state changed, and must be recreated or looked up again.
                  cur.enabled_tex1D = false;
                  cur.texTypesEnabled &= ~1;
                }
                break;
              case GL_TEXTURE_2D:
                if (cur.enabled_tex2D) {
                  GLImmediate.currentRenderer = null;
                  cur.enabled_tex2D = false;
                  cur.texTypesEnabled &= ~2;
                }
                break;
              case GL_TEXTURE_3D:
                if (cur.enabled_tex3D) {
                  GLImmediate.currentRenderer = null;
                  cur.enabled_tex3D = false;
                  cur.texTypesEnabled &= ~4;
                }
                break;
              case GL_TEXTURE_CUBE_MAP:
                if (cur.enabled_texCube) {
                  GLImmediate.currentRenderer = null;
                  cur.enabled_texCube = false;
                  cur.texTypesEnabled &= ~8;
                }
                break;
            }
          },
  
          hook_texEnvf(target, pname, param) {
            if (target != GL_TEXTURE_ENV)
              return;
  
            var env = getCurTexUnit().env;
            switch (pname) {
              case GL_RGB_SCALE:
                if (env.colorScale != param) {
                  env.invalidateKey(); // We changed FFP emulation renderer state.
                  env.colorScale = param;
                }
                break;
              case GL_ALPHA_SCALE:
                if (env.alphaScale != param) {
                  env.invalidateKey();
                  env.alphaScale = param;
                }
                break;
  
              default:
                err('WARNING: Unhandled `pname` in call to `glTexEnvf`.');
            }
          },
  
          hook_texEnvi(target, pname, param) {
            if (target != GL_TEXTURE_ENV)
              return;
  
            var env = getCurTexUnit().env;
            switch (pname) {
              case GL_TEXTURE_ENV_MODE:
                if (env.mode != param) {
                  env.invalidateKey(); // We changed FFP emulation renderer state.
                  env.mode = param;
                }
                break;
  
              case GL_COMBINE_RGB:
                if (env.colorCombiner != param) {
                  env.invalidateKey();
                  env.colorCombiner = param;
                }
                break;
              case GL_COMBINE_ALPHA:
                if (env.alphaCombiner != param) {
                  env.invalidateKey();
                  env.alphaCombiner = param;
                }
                break;
  
              case GL_SRC0_RGB:
                if (env.colorSrc[0] != param) {
                  env.invalidateKey();
                  env.colorSrc[0] = param;
                }
                break;
              case GL_SRC1_RGB:
                if (env.colorSrc[1] != param) {
                  env.invalidateKey();
                  env.colorSrc[1] = param;
                }
                break;
              case GL_SRC2_RGB:
                if (env.colorSrc[2] != param) {
                  env.invalidateKey();
                  env.colorSrc[2] = param;
                }
                break;
  
              case GL_SRC0_ALPHA:
                if (env.alphaSrc[0] != param) {
                  env.invalidateKey();
                  env.alphaSrc[0] = param;
                }
                break;
              case GL_SRC1_ALPHA:
                if (env.alphaSrc[1] != param) {
                  env.invalidateKey();
                  env.alphaSrc[1] = param;
                }
                break;
              case GL_SRC2_ALPHA:
                if (env.alphaSrc[2] != param) {
                  env.invalidateKey();
                  env.alphaSrc[2] = param;
                }
                break;
  
              case GL_OPERAND0_RGB:
                if (env.colorOp[0] != param) {
                  env.invalidateKey();
                  env.colorOp[0] = param;
                }
                break;
              case GL_OPERAND1_RGB:
                if (env.colorOp[1] != param) {
                  env.invalidateKey();
                  env.colorOp[1] = param;
                }
                break;
              case GL_OPERAND2_RGB:
                if (env.colorOp[2] != param) {
                  env.invalidateKey();
                  env.colorOp[2] = param;
                }
                break;
  
              case GL_OPERAND0_ALPHA:
                if (env.alphaOp[0] != param) {
                  env.invalidateKey();
                  env.alphaOp[0] = param;
                }
                break;
              case GL_OPERAND1_ALPHA:
                if (env.alphaOp[1] != param) {
                  env.invalidateKey();
                  env.alphaOp[1] = param;
                }
                break;
              case GL_OPERAND2_ALPHA:
                if (env.alphaOp[2] != param) {
                  env.invalidateKey();
                  env.alphaOp[2] = param;
                }
                break;
  
              case GL_RGB_SCALE:
                if (env.colorScale != param) {
                  env.invalidateKey();
                  env.colorScale = param;
                }
                break;
              case GL_ALPHA_SCALE:
                if (env.alphaScale != param) {
                  env.invalidateKey();
                  env.alphaScale = param;
                }
                break;
  
              default:
                err('WARNING: Unhandled `pname` in call to `glTexEnvi`.');
            }
          },
  
          hook_texEnvfv(target, pname, params) {
            if (target != GL_TEXTURE_ENV) return;
  
            var env = getCurTexUnit().env;
            switch (pname) {
              case GL_TEXTURE_ENV_COLOR: {
                for (var i = 0; i < 4; i++) {
                  var param = HEAPF32[(((params)+(i*4))>>2)];
                  if (env.envColor[i] != param) {
                    env.invalidateKey(); // We changed FFP emulation renderer state.
                    env.envColor[i] = param;
                  }
                }
                break
              }
              default:
                err('WARNING: Unhandled `pname` in call to `glTexEnvfv`.');
            }
          },
  
          hook_getTexEnviv(target, pname, param) {
            if (target != GL_TEXTURE_ENV)
              return;
  
            var env = getCurTexUnit().env;
            switch (pname) {
              case GL_TEXTURE_ENV_MODE:
                HEAP32[((param)>>2)] = env.mode;
                return;
  
              case GL_TEXTURE_ENV_COLOR:
                HEAP32[((param)>>2)] = Math.max(Math.min(env.envColor[0]*255, 255, -255));
                HEAP32[(((param)+(1))>>2)] = Math.max(Math.min(env.envColor[1]*255, 255, -255));
                HEAP32[(((param)+(2))>>2)] = Math.max(Math.min(env.envColor[2]*255, 255, -255));
                HEAP32[(((param)+(3))>>2)] = Math.max(Math.min(env.envColor[3]*255, 255, -255));
                return;
  
              case GL_COMBINE_RGB:
                HEAP32[((param)>>2)] = env.colorCombiner;
                return;
  
              case GL_COMBINE_ALPHA:
                HEAP32[((param)>>2)] = env.alphaCombiner;
                return;
  
              case GL_SRC0_RGB:
                HEAP32[((param)>>2)] = env.colorSrc[0];
                return;
  
              case GL_SRC1_RGB:
                HEAP32[((param)>>2)] = env.colorSrc[1];
                return;
  
              case GL_SRC2_RGB:
                HEAP32[((param)>>2)] = env.colorSrc[2];
                return;
  
              case GL_SRC0_ALPHA:
                HEAP32[((param)>>2)] = env.alphaSrc[0];
                return;
  
              case GL_SRC1_ALPHA:
                HEAP32[((param)>>2)] = env.alphaSrc[1];
                return;
  
              case GL_SRC2_ALPHA:
                HEAP32[((param)>>2)] = env.alphaSrc[2];
                return;
  
              case GL_OPERAND0_RGB:
                HEAP32[((param)>>2)] = env.colorOp[0];
                return;
  
              case GL_OPERAND1_RGB:
                HEAP32[((param)>>2)] = env.colorOp[1];
                return;
  
              case GL_OPERAND2_RGB:
                HEAP32[((param)>>2)] = env.colorOp[2];
                return;
  
              case GL_OPERAND0_ALPHA:
                HEAP32[((param)>>2)] = env.alphaOp[0];
                return;
  
              case GL_OPERAND1_ALPHA:
                HEAP32[((param)>>2)] = env.alphaOp[1];
                return;
  
              case GL_OPERAND2_ALPHA:
                HEAP32[((param)>>2)] = env.alphaOp[2];
                return;
  
              case GL_RGB_SCALE:
                HEAP32[((param)>>2)] = env.colorScale;
                return;
  
              case GL_ALPHA_SCALE:
                HEAP32[((param)>>2)] = env.alphaScale;
                return;
  
              default:
                err('WARNING: Unhandled `pname` in call to `glGetTexEnvi`.');
            }
          },
  
          hook_getTexEnvfv: (target, pname, param) => {
            if (target != GL_TEXTURE_ENV)
              return;
  
            var env = getCurTexUnit().env;
            switch (pname) {
              case GL_TEXTURE_ENV_COLOR:
                HEAPF32[((param)>>2)] = env.envColor[0];
                HEAPF32[(((param)+(4))>>2)] = env.envColor[1];
                HEAPF32[(((param)+(8))>>2)] = env.envColor[2];
                HEAPF32[(((param)+(12))>>2)] = env.envColor[3];
                return;
            }
          }
        };
      },
  vertexData:null,
  vertexDataU8:null,
  tempData:null,
  indexData:null,
  vertexCounter:0,
  mode:-1,
  rendererCache:null,
  rendererComponents:[],
  rendererComponentPointer:0,
  lastRenderer:null,
  lastArrayBuffer:null,
  lastProgram:null,
  lastStride:-1,
  matrix:[],
  matrixStack:[],
  currentMatrix:0,
  tempMatrix:null,
  matricesModified:false,
  useTextureMatrix:false,
  VERTEX:0,
  NORMAL:1,
  COLOR:2,
  TEXTURE0:3,
  NUM_ATTRIBUTES:-1,
  MAX_TEXTURES:-1,
  totalEnabledClientAttributes:0,
  enabledClientAttributes:[0,0],
  clientAttributes:[],
  liveClientAttributes:[],
  currentRenderer:null,
  modifiedClientAttributes:false,
  clientActiveTexture:0,
  clientColor:null,
  usedTexUnitList:[],
  fixedFunctionProgram:null,
  setClientAttribute(name, size, type, stride, pointer) {
        var attrib = GLImmediate.clientAttributes[name];
        if (!attrib) {
          for (var i = 0; i <= name; i++) { // keep flat
            GLImmediate.clientAttributes[i] ||= {
              name,
              size,
              type,
              stride,
              pointer,
              offset: 0
            };
          }
        } else {
          attrib.name = name;
          attrib.size = size;
          attrib.type = type;
          attrib.stride = stride;
          attrib.pointer = pointer;
          attrib.offset = 0;
        }
        GLImmediate.modifiedClientAttributes = true;
      },
  addRendererComponent(name, size, type) {
        if (!GLImmediate.rendererComponents[name]) {
          GLImmediate.rendererComponents[name] = 1;
          if (GLImmediate.enabledClientAttributes[name]) {
            out("Warning: glTexCoord used after EnableClientState for TEXTURE_COORD_ARRAY for TEXTURE0. Disabling TEXTURE_COORD_ARRAY...");
          }
          GLImmediate.enabledClientAttributes[name] = true;
          GLImmediate.setClientAttribute(name, size, type, 0, GLImmediate.rendererComponentPointer);
          GLImmediate.rendererComponentPointer += size * GL.byteSizeByType[type - GL.byteSizeByTypeRoot];
        } else {
          GLImmediate.rendererComponents[name]++;
        }
      },
  disableBeginEndClientAttributes() {
        for (var i = 0; i < GLImmediate.NUM_ATTRIBUTES; i++) {
          if (GLImmediate.rendererComponents[i]) GLImmediate.enabledClientAttributes[i] = false;
        }
      },
  getRenderer() {
        // If no FFP state has changed that would have forced to re-evaluate which FFP emulation shader to use,
        // we have the currently used renderer in cache, and can immediately return that.
        if (GLImmediate.currentRenderer) {
          return GLImmediate.currentRenderer;
        }
        // return a renderer object given the liveClientAttributes
        // we maintain a cache of renderers, optimized to not generate garbage
        var attributes = GLImmediate.liveClientAttributes;
        var cacheMap = GLImmediate.rendererCache;
        var keyView = cacheMap.getStaticKeyView().reset();
  
        // By attrib state:
        var enabledAttributesKey = 0;
        for (var i = 0; i < attributes.length; i++) {
          enabledAttributesKey |= 1 << attributes[i].name;
        }
  
        // To prevent using more than 31 bits add another level to the maptree
        // and reset the enabledAttributesKey for the next glemulation state bits
        keyView.next(enabledAttributesKey);
        enabledAttributesKey = 0;
  
        // By fog state:
        var fogParam = 0;
        if (GLEmulation.fogEnabled) {
          switch (GLEmulation.fogMode) {
            case 0x801: // GL_EXP2
              fogParam = 1;
              break;
            case 0x2601: // GL_LINEAR
              fogParam = 2;
              break;
            default: // default to GL_EXP
              fogParam = 3;
              break;
          }
        }
        enabledAttributesKey = (enabledAttributesKey << 2) | fogParam;
  
        // By clip plane mode
        for (var clipPlaneId = 0; clipPlaneId < GLEmulation.MAX_CLIP_PLANES; clipPlaneId++) {
          enabledAttributesKey = (enabledAttributesKey << 1) | GLEmulation.clipPlaneEnabled[clipPlaneId];
        }
  
        // By lighting mode and enabled lights
        enabledAttributesKey = (enabledAttributesKey << 1) | GLEmulation.lightingEnabled;
        for (var lightId = 0; lightId < GLEmulation.MAX_LIGHTS; lightId++) {
          enabledAttributesKey = (enabledAttributesKey << 1) | (GLEmulation.lightingEnabled ? GLEmulation.lightEnabled[lightId] : 0);
        }
  
        // By alpha testing mode
        enabledAttributesKey = (enabledAttributesKey << 3) | (GLEmulation.alphaTestEnabled ? (GLEmulation.alphaTestFunc - 0x200) : 0x7);
  
        // By drawing mode:
        enabledAttributesKey = (enabledAttributesKey << 1) | (GLImmediate.mode == GLctx.POINTS ? 1 : 0);
  
        keyView.next(enabledAttributesKey);
  
        // By cur program:
        keyView.next(GL.currProgram);
        if (!GL.currProgram) {
          GLImmediate.TexEnvJIT.traverseState(keyView);
        }
  
        // If we don't already have it, create it.
        var renderer = keyView.get();
        if (!renderer) {
          renderer = GLImmediate.createRenderer();
          GLImmediate.currentRenderer = renderer;
          keyView.set(renderer);
          return renderer;
        }
        GLImmediate.currentRenderer = renderer; // Cache the currently used renderer, so later lookups without state changes can get this fast.
        return renderer;
      },
  createRenderer(renderer) {
        var useCurrProgram = !!GL.currProgram;
        var hasTextures = false;
        for (var i = 0; i < GLImmediate.MAX_TEXTURES; i++) {
          var texAttribName = GLImmediate.TEXTURE0 + i;
          if (!GLImmediate.enabledClientAttributes[texAttribName])
            continue;
  
          if (!useCurrProgram) {
            if (GLImmediate.TexEnvJIT.getTexUnitType(i) == 0) {
               warnOnce("GL_TEXTURE" + i + " coords are supplied, but that texture unit is disabled in the fixed-function pipeline.");
            }
          }
  
          hasTextures = true;
        }
  
        /** @constructor */
        function Renderer() {
          this.init = function() {
            // For fixed-function shader generation.
            var uTexUnitPrefix = 'u_texUnit';
            var aTexCoordPrefix = 'a_texCoord';
            var vTexCoordPrefix = 'v_texCoord';
            var vPrimColor = 'v_color';
            var uTexMatrixPrefix = GLImmediate.useTextureMatrix ? 'u_textureMatrix' : null;
  
            if (useCurrProgram) {
              if (GL.shaderInfos[GL.programShaders[GL.currProgram][0]].type == GLctx.VERTEX_SHADER) {
                this.vertexShader = GL.shaders[GL.programShaders[GL.currProgram][0]];
                this.fragmentShader = GL.shaders[GL.programShaders[GL.currProgram][1]];
              } else {
                this.vertexShader = GL.shaders[GL.programShaders[GL.currProgram][1]];
                this.fragmentShader = GL.shaders[GL.programShaders[GL.currProgram][0]];
              }
              this.program = GL.programs[GL.currProgram];
              this.usedTexUnitList = [];
            } else {
              // IMPORTANT NOTE: If you parameterize the shader source based on any runtime values
              // in order to create the least expensive shader possible based on the features being
              // used, you should also update the code in the beginning of getRenderer to make sure
              // that you cache the renderer based on the said parameters.
              if (GLEmulation.fogEnabled) {
                switch (GLEmulation.fogMode) {
                  case 0x801: // GL_EXP2
                    // fog = exp(-(gl_Fog.density * gl_FogFragCoord)^2)
                    var fogFormula = '  float fog = exp(-u_fogDensity * u_fogDensity * ecDistance * ecDistance); \n';
                    break;
                  case 0x2601: // GL_LINEAR
                    // fog = (gl_Fog.end - gl_FogFragCoord) * gl_fog.scale
                    var fogFormula = '  float fog = (u_fogEnd - ecDistance) * u_fogScale; \n';
                    break;
                  default: // default to GL_EXP
                    // fog = exp(-gl_Fog.density * gl_FogFragCoord)
                    var fogFormula = '  float fog = exp(-u_fogDensity * ecDistance); \n';
                    break;
                }
              }
  
              GLImmediate.TexEnvJIT.setGLSLVars(uTexUnitPrefix, vTexCoordPrefix, vPrimColor, uTexMatrixPrefix);
              var fsTexEnvPass = GLImmediate.TexEnvJIT.genAllPassLines('gl_FragColor', 2);
  
              var texUnitAttribList = '';
              var texUnitVaryingList = '';
              var texUnitUniformList = '';
              var vsTexCoordInits = '';
              this.usedTexUnitList = GLImmediate.TexEnvJIT.getUsedTexUnitList();
              for (var i = 0; i < this.usedTexUnitList.length; i++) {
                var texUnit = this.usedTexUnitList[i];
                texUnitAttribList += 'attribute vec4 ' + aTexCoordPrefix + texUnit + ';\n';
                texUnitVaryingList += 'varying vec4 ' + vTexCoordPrefix + texUnit + ';\n';
                texUnitUniformList += 'uniform sampler2D ' + uTexUnitPrefix + texUnit + ';\n';
                vsTexCoordInits += '  ' + vTexCoordPrefix + texUnit + ' = ' + aTexCoordPrefix + texUnit + ';\n';
  
                if (GLImmediate.useTextureMatrix) {
                  texUnitUniformList += 'uniform mat4 ' + uTexMatrixPrefix + texUnit + ';\n';
                }
              }
  
              var vsFogVaryingInit = null;
              if (GLEmulation.fogEnabled) {
                vsFogVaryingInit = '  v_fogFragCoord = abs(ecPosition.z);\n';
              }
  
              var vsPointSizeDefs = null;
              var vsPointSizeInit = null;
              if (GLImmediate.mode == GLctx.POINTS) {
                vsPointSizeDefs = 'uniform float u_pointSize;\n';
                vsPointSizeInit = '  gl_PointSize = u_pointSize;\n';
              }
  
              var vsClipPlaneDefs = '';
              var vsClipPlaneInit = '';
              var fsClipPlaneDefs = '';
              var fsClipPlanePass = '';
              for (var clipPlaneId = 0; clipPlaneId < GLEmulation.MAX_CLIP_PLANES; clipPlaneId++) {
                if (GLEmulation.clipPlaneEnabled[clipPlaneId]) {
                  vsClipPlaneDefs += 'uniform vec4 u_clipPlaneEquation' + clipPlaneId + ';';
                  vsClipPlaneDefs += 'varying float v_clipDistance' + clipPlaneId + ';';
                  vsClipPlaneInit += '  v_clipDistance' + clipPlaneId + ' = dot(ecPosition, u_clipPlaneEquation' + clipPlaneId + ');';
                  fsClipPlaneDefs += 'varying float v_clipDistance' + clipPlaneId + ';';
                  fsClipPlanePass += '  if (v_clipDistance' + clipPlaneId + ' < 0.0) discard;';
                }
              }
  
              var vsLightingDefs = '';
              var vsLightingPass = '';
              if (GLEmulation.lightingEnabled) {
                vsLightingDefs += 'attribute vec3 a_normal;';
                vsLightingDefs += 'uniform mat3 u_normalMatrix;';
                vsLightingDefs += 'uniform vec4 u_lightModelAmbient;';
                vsLightingDefs += 'uniform vec4 u_materialAmbient;';
                vsLightingDefs += 'uniform vec4 u_materialDiffuse;';
                vsLightingDefs += 'uniform vec4 u_materialSpecular;';
                vsLightingDefs += 'uniform float u_materialShininess;';
                vsLightingDefs += 'uniform vec4 u_materialEmission;';
  
                vsLightingPass += '  vec3 ecNormal = normalize(u_normalMatrix * a_normal);';
                vsLightingPass += '  v_color.w = u_materialDiffuse.w;';
                vsLightingPass += '  v_color.xyz = u_materialEmission.xyz;';
                vsLightingPass += '  v_color.xyz += u_lightModelAmbient.xyz * u_materialAmbient.xyz;';
  
                for (var lightId = 0; lightId < GLEmulation.MAX_LIGHTS; lightId++) {
                  if (GLEmulation.lightEnabled[lightId]) {
                    vsLightingDefs += 'uniform vec4 u_lightAmbient' + lightId + ';';
                    vsLightingDefs += 'uniform vec4 u_lightDiffuse' + lightId + ';';
                    vsLightingDefs += 'uniform vec4 u_lightSpecular' + lightId + ';';
                    vsLightingDefs += 'uniform vec4 u_lightPosition' + lightId + ';';
  
                    vsLightingPass += '  {';
                    vsLightingPass += '    vec3 lightDirection = normalize(u_lightPosition' + lightId + ').xyz;';
                    vsLightingPass += '    vec3 halfVector = normalize(lightDirection + vec3(0,0,1));';
                    vsLightingPass += '    vec3 ambient = u_lightAmbient' + lightId + '.xyz * u_materialAmbient.xyz;';
                    vsLightingPass += '    float diffuseI = max(dot(ecNormal, lightDirection), 0.0);';
                    vsLightingPass += '    float specularI = max(dot(ecNormal, halfVector), 0.0);';
                    vsLightingPass += '    vec3 diffuse = diffuseI * u_lightDiffuse' + lightId + '.xyz * u_materialDiffuse.xyz;';
                    vsLightingPass += '    specularI = (diffuseI > 0.0 && specularI > 0.0) ? exp(u_materialShininess * log(specularI)) : 0.0;';
                    vsLightingPass += '    vec3 specular = specularI * u_lightSpecular' + lightId + '.xyz * u_materialSpecular.xyz;';
                    vsLightingPass += '    v_color.xyz += ambient + diffuse + specular;';
                    vsLightingPass += '  }';
                  }
                }
                vsLightingPass += '  v_color = clamp(v_color, 0.0, 1.0);';
              }
  
              var vsSource = [
                'attribute vec4 a_position;',
                'attribute vec4 a_color;',
                'varying vec4 v_color;',
                texUnitAttribList,
                texUnitVaryingList,
                (GLEmulation.fogEnabled ? 'varying float v_fogFragCoord;' : null),
                'uniform mat4 u_modelView;',
                'uniform mat4 u_projection;',
                vsPointSizeDefs,
                vsClipPlaneDefs,
                vsLightingDefs,
                'void main()',
                '{',
                '  vec4 ecPosition = u_modelView * a_position;', // eye-coordinate position
                '  gl_Position = u_projection * ecPosition;',
                '  v_color = a_color;',
                vsTexCoordInits,
                vsFogVaryingInit,
                vsPointSizeInit,
                vsClipPlaneInit,
                vsLightingPass,
                '}',
                ''
              ].join('\n').replace(/\n\n+/g, '\n');
  
              this.vertexShader = GLctx.createShader(GLctx.VERTEX_SHADER);
              GLctx.shaderSource(this.vertexShader, vsSource);
              GLctx.compileShader(this.vertexShader);
  
              var fogHeaderIfNeeded = null;
              if (GLEmulation.fogEnabled) {
                fogHeaderIfNeeded = [
                  '',
                  'varying float v_fogFragCoord; ',
                  'uniform vec4 u_fogColor;      ',
                  'uniform float u_fogEnd;       ',
                  'uniform float u_fogScale;     ',
                  'uniform float u_fogDensity;   ',
                  'float ffog(in float ecDistance) { ',
                  fogFormula,
                  '  fog = clamp(fog, 0.0, 1.0); ',
                  '  return fog;                 ',
                  '}',
                  '',
                ].join("\n");
              }
  
              var fogPass = null;
              if (GLEmulation.fogEnabled) {
                fogPass = 'gl_FragColor = vec4(mix(u_fogColor.rgb, gl_FragColor.rgb, ffog(v_fogFragCoord)), gl_FragColor.a);\n';
              }
  
              var fsAlphaTestDefs = '';
              var fsAlphaTestPass = '';
              if (GLEmulation.alphaTestEnabled) {
                fsAlphaTestDefs = 'uniform float u_alphaTestRef;';
                switch (GLEmulation.alphaTestFunc) {
                  case 0x200: // GL_NEVER
                    fsAlphaTestPass = 'discard;';
                    break;
                  case 0x201: // GL_LESS
                    fsAlphaTestPass = 'if (!(gl_FragColor.a < u_alphaTestRef)) { discard; }';
                    break;
                  case 0x202: // GL_EQUAL
                    fsAlphaTestPass = 'if (!(gl_FragColor.a == u_alphaTestRef)) { discard; }';
                    break;
                  case 0x203: // GL_LEQUAL
                    fsAlphaTestPass = 'if (!(gl_FragColor.a <= u_alphaTestRef)) { discard; }';
                    break;
                  case 0x204: // GL_GREATER
                    fsAlphaTestPass = 'if (!(gl_FragColor.a > u_alphaTestRef)) { discard; }';
                    break;
                  case 0x205: // GL_NOTEQUAL
                    fsAlphaTestPass = 'if (!(gl_FragColor.a != u_alphaTestRef)) { discard; }';
                    break;
                  case 0x206: // GL_GEQUAL
                    fsAlphaTestPass = 'if (!(gl_FragColor.a >= u_alphaTestRef)) { discard; }';
                    break;
                  case 0x207: // GL_ALWAYS
                    fsAlphaTestPass = '';
                    break;
                }
              }
  
              var fsSource = [
                'precision mediump float;',
                texUnitVaryingList,
                texUnitUniformList,
                'varying vec4 v_color;',
                fogHeaderIfNeeded,
                fsClipPlaneDefs,
                fsAlphaTestDefs,
                'void main()',
                '{',
                fsClipPlanePass,
                fsTexEnvPass,
                fogPass,
                fsAlphaTestPass,
                '}',
                ''
              ].join("\n").replace(/\n\n+/g, '\n');
  
              this.fragmentShader = GLctx.createShader(GLctx.FRAGMENT_SHADER);
              GLctx.shaderSource(this.fragmentShader, fsSource);
              GLctx.compileShader(this.fragmentShader);
  
              this.program = GLctx.createProgram();
              GLctx.attachShader(this.program, this.vertexShader);
              GLctx.attachShader(this.program, this.fragmentShader);
  
              // As optimization, bind all attributes to prespecified locations, so that the FFP emulation
              // code can submit attributes to any generated FFP shader without having to examine each shader in turn.
              // These prespecified locations are only assumed if GL_FFP_ONLY is specified, since user could also create their
              // own shaders that didn't have attributes in the same locations.
              GLctx.bindAttribLocation(this.program, GLImmediate.VERTEX, 'a_position');
              GLctx.bindAttribLocation(this.program, GLImmediate.COLOR, 'a_color');
              GLctx.bindAttribLocation(this.program, GLImmediate.NORMAL, 'a_normal');
              var maxVertexAttribs = GLctx.getParameter(GLctx.MAX_VERTEX_ATTRIBS);
              for (var i = 0; i < GLImmediate.MAX_TEXTURES && GLImmediate.TEXTURE0 + i < maxVertexAttribs; i++) {
                GLctx.bindAttribLocation(this.program, GLImmediate.TEXTURE0 + i, 'a_texCoord'+i);
                GLctx.bindAttribLocation(this.program, GLImmediate.TEXTURE0 + i, aTexCoordPrefix+i);
              }
              GLctx.linkProgram(this.program);
            }
  
            // Stores an array that remembers which matrix uniforms are up-to-date in this FFP renderer, so they don't need to be resubmitted
            // each time we render with this program.
            this.textureMatrixVersion = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
  
            this.positionLocation = GLctx.getAttribLocation(this.program, 'a_position');
  
            this.texCoordLocations = [];
  
            for (var i = 0; i < GLImmediate.MAX_TEXTURES; i++) {
              if (!GLImmediate.enabledClientAttributes[GLImmediate.TEXTURE0 + i]) {
                this.texCoordLocations[i] = -1;
                continue;
              }
  
              if (useCurrProgram) {
                this.texCoordLocations[i] = GLctx.getAttribLocation(this.program, `a_texCoord${i}`);
              } else {
                this.texCoordLocations[i] = GLctx.getAttribLocation(this.program, aTexCoordPrefix + i);
              }
            }
            this.colorLocation = GLctx.getAttribLocation(this.program, 'a_color');
            if (!useCurrProgram) {
              // Temporarily switch to the program so we can set our sampler uniforms early.
              var prevBoundProg = GLctx.getParameter(GLctx.CURRENT_PROGRAM);
              GLctx.useProgram(this.program);
              {
                for (var i = 0; i < this.usedTexUnitList.length; i++) {
                  var texUnitID = this.usedTexUnitList[i];
                  var texSamplerLoc = GLctx.getUniformLocation(this.program, uTexUnitPrefix + texUnitID);
                  GLctx.uniform1i(texSamplerLoc, texUnitID);
                }
              }
              // The default color attribute value is not the same as the default for all other attribute streams (0,0,0,1) but (1,1,1,1),
              // so explicitly set it right at start.
              GLctx.vertexAttrib4fv(this.colorLocation, [1,1,1,1]);
              GLctx.useProgram(prevBoundProg);
            }
  
            this.textureMatrixLocations = [];
            for (var i = 0; i < GLImmediate.MAX_TEXTURES; i++) {
              this.textureMatrixLocations[i] = GLctx.getUniformLocation(this.program, `u_textureMatrix${i}`);
            }
            this.normalLocation = GLctx.getAttribLocation(this.program, 'a_normal');
  
            this.modelViewLocation = GLctx.getUniformLocation(this.program, 'u_modelView');
            this.projectionLocation = GLctx.getUniformLocation(this.program, 'u_projection');
            this.normalMatrixLocation = GLctx.getUniformLocation(this.program, 'u_normalMatrix');
  
            this.hasTextures = hasTextures;
            this.hasNormal = GLImmediate.enabledClientAttributes[GLImmediate.NORMAL] &&
                             GLImmediate.clientAttributes[GLImmediate.NORMAL].size > 0 &&
                             this.normalLocation >= 0;
            this.hasColor = (this.colorLocation === 0) || this.colorLocation > 0;
  
            this.floatType = GLctx.FLOAT; // minor optimization
  
            this.fogColorLocation = GLctx.getUniformLocation(this.program, 'u_fogColor');
            this.fogEndLocation = GLctx.getUniformLocation(this.program, 'u_fogEnd');
            this.fogScaleLocation = GLctx.getUniformLocation(this.program, 'u_fogScale');
            this.fogDensityLocation = GLctx.getUniformLocation(this.program, 'u_fogDensity');
            this.hasFog = !!(this.fogColorLocation || this.fogEndLocation ||
                             this.fogScaleLocation || this.fogDensityLocation);
  
            this.pointSizeLocation = GLctx.getUniformLocation(this.program, 'u_pointSize');
  
            this.hasClipPlane = false;
            this.clipPlaneEquationLocation = [];
            for (var clipPlaneId = 0; clipPlaneId < GLEmulation.MAX_CLIP_PLANES; clipPlaneId++) {
              this.clipPlaneEquationLocation[clipPlaneId] = GLctx.getUniformLocation(this.program, `u_clipPlaneEquation${clipPlaneId}`);
              this.hasClipPlane = (this.hasClipPlane || this.clipPlaneEquationLocation[clipPlaneId]);
            }
  
            this.hasLighting = GLEmulation.lightingEnabled;
            this.lightModelAmbientLocation = GLctx.getUniformLocation(this.program, 'u_lightModelAmbient');
            this.materialAmbientLocation = GLctx.getUniformLocation(this.program, 'u_materialAmbient');
            this.materialDiffuseLocation = GLctx.getUniformLocation(this.program, 'u_materialDiffuse');
            this.materialSpecularLocation = GLctx.getUniformLocation(this.program, 'u_materialSpecular');
            this.materialShininessLocation = GLctx.getUniformLocation(this.program, 'u_materialShininess');
            this.materialEmissionLocation = GLctx.getUniformLocation(this.program, 'u_materialEmission');
            this.lightAmbientLocation = []
            this.lightDiffuseLocation = []
            this.lightSpecularLocation = []
            this.lightPositionLocation = []
            for (var lightId = 0; lightId < GLEmulation.MAX_LIGHTS; lightId++) {
              this.lightAmbientLocation[lightId] = GLctx.getUniformLocation(this.program, `u_lightAmbient${lightId}`);
              this.lightDiffuseLocation[lightId] = GLctx.getUniformLocation(this.program, `u_lightDiffuse${lightId}`);
              this.lightSpecularLocation[lightId] = GLctx.getUniformLocation(this.program, `u_lightSpecular${lightId}`);
              this.lightPositionLocation[lightId] = GLctx.getUniformLocation(this.program, `u_lightPosition${lightId}`);
            }
  
            this.hasAlphaTest = GLEmulation.alphaTestEnabled;
            this.alphaTestRefLocation = GLctx.getUniformLocation(this.program, 'u_alphaTestRef');
  
          };
  
          this.prepare = function() {
            // Calculate the array buffer
            var arrayBuffer;
            if (!GLctx.currentArrayBufferBinding) {
              var start = GLImmediate.firstVertex*GLImmediate.stride;
              var end = GLImmediate.lastVertex*GLImmediate.stride;
              assert(end <= GL.MAX_TEMP_BUFFER_SIZE, 'too much vertex data');
              arrayBuffer = GL.getTempVertexBuffer(end);
              // TODO: consider using the last buffer we bound, if it was larger. downside is larger buffer, but we might avoid rebinding and preparing
            } else {
              arrayBuffer = GLctx.currentArrayBufferBinding;
            }
  
            if (!GLctx.currentArrayBufferBinding) {
              // Bind the array buffer and upload data after cleaning up the previous renderer
  
              if (arrayBuffer != GLImmediate.lastArrayBuffer) {
                GLctx.bindBuffer(GLctx.ARRAY_BUFFER, arrayBuffer);
                GLImmediate.lastArrayBuffer = arrayBuffer;
              }
  
              GLctx.bufferSubData(GLctx.ARRAY_BUFFER, start, GLImmediate.vertexData.subarray(start >> 2, end >> 2));
            }
  
            if (!GL.currProgram) {
              if (GLImmediate.fixedFunctionProgram != this.program) {
                GLctx.useProgram(this.program);
                GLImmediate.fixedFunctionProgram = this.program;
              }
            }
  
            if (this.modelViewLocation && this.modelViewMatrixVersion != GLImmediate.matrixVersion[0/*m*/]) {
              this.modelViewMatrixVersion = GLImmediate.matrixVersion[0/*m*/];
              GLctx.uniformMatrix4fv(this.modelViewLocation, false, GLImmediate.matrix[0/*m*/]);
  
              // set normal matrix to the upper 3x3 of the inverse transposed current modelview matrix
              if (GLEmulation.lightEnabled) {
                var tmpMVinv = GLImmediate.matrixLib.mat4.create(GLImmediate.matrix[0]);
                GLImmediate.matrixLib.mat4.inverse(tmpMVinv);
                GLImmediate.matrixLib.mat4.transpose(tmpMVinv);
                GLctx.uniformMatrix3fv(this.normalMatrixLocation, false, GLImmediate.matrixLib.mat4.toMat3(tmpMVinv));
              }
            }
            if (this.projectionLocation && this.projectionMatrixVersion != GLImmediate.matrixVersion[1/*p*/]) {
              this.projectionMatrixVersion = GLImmediate.matrixVersion[1/*p*/];
              GLctx.uniformMatrix4fv(this.projectionLocation, false, GLImmediate.matrix[1/*p*/]);
            }
  
            var clientAttributes = GLImmediate.clientAttributes;
            var posAttr = clientAttributes[GLImmediate.VERTEX];
  
            GLctx.vertexAttribPointer(this.positionLocation, posAttr.size, posAttr.type, false, GLImmediate.stride, posAttr.offset);
            GLctx.enableVertexAttribArray(this.positionLocation);
            if (this.hasNormal) {
              var normalAttr = clientAttributes[GLImmediate.NORMAL];
              GLctx.vertexAttribPointer(this.normalLocation, normalAttr.size, normalAttr.type, true, GLImmediate.stride, normalAttr.offset);
              GLctx.enableVertexAttribArray(this.normalLocation);
            }
            if (this.hasTextures) {
              for (var i = 0; i < GLImmediate.MAX_TEXTURES; i++) {
                var attribLoc = this.texCoordLocations[i];
                if (attribLoc === undefined || attribLoc < 0) continue;
                var texAttr = clientAttributes[GLImmediate.TEXTURE0+i];
  
                if (texAttr.size) {
                  GLctx.vertexAttribPointer(attribLoc, texAttr.size, texAttr.type, false, GLImmediate.stride, texAttr.offset);
                  GLctx.enableVertexAttribArray(attribLoc);
                } else {
                  // These two might be dangerous, but let's try them.
                  GLctx.vertexAttrib4f(attribLoc, 0, 0, 0, 1);
                  GLctx.disableVertexAttribArray(attribLoc);
                }
                var t = 2/*t*/+i;
                if (this.textureMatrixLocations[i] && this.textureMatrixVersion[t] != GLImmediate.matrixVersion[t]) { // XXX might we need this even without the condition we are currently in?
                  this.textureMatrixVersion[t] = GLImmediate.matrixVersion[t];
                  GLctx.uniformMatrix4fv(this.textureMatrixLocations[i], false, GLImmediate.matrix[t]);
                }
              }
            }
            if (GLImmediate.enabledClientAttributes[GLImmediate.COLOR]) {
              var colorAttr = clientAttributes[GLImmediate.COLOR];
              GLctx.vertexAttribPointer(this.colorLocation, colorAttr.size, colorAttr.type, true, GLImmediate.stride, colorAttr.offset);
              GLctx.enableVertexAttribArray(this.colorLocation);
            }
            else if (this.hasColor) {
              GLctx.disableVertexAttribArray(this.colorLocation);
              GLctx.vertexAttrib4fv(this.colorLocation, GLImmediate.clientColor);
            }
            if (this.hasFog) {
              if (this.fogColorLocation) GLctx.uniform4fv(this.fogColorLocation, GLEmulation.fogColor);
              if (this.fogEndLocation) GLctx.uniform1f(this.fogEndLocation, GLEmulation.fogEnd);
              if (this.fogScaleLocation) GLctx.uniform1f(this.fogScaleLocation, 1/(GLEmulation.fogEnd - GLEmulation.fogStart));
              if (this.fogDensityLocation) GLctx.uniform1f(this.fogDensityLocation, GLEmulation.fogDensity);
            }
  
            if (this.hasClipPlane) {
              for (var clipPlaneId = 0; clipPlaneId < GLEmulation.MAX_CLIP_PLANES; clipPlaneId++) {
                if (this.clipPlaneEquationLocation[clipPlaneId]) GLctx.uniform4fv(this.clipPlaneEquationLocation[clipPlaneId], GLEmulation.clipPlaneEquation[clipPlaneId]);
              }
            }
  
            if (this.hasLighting) {
              if (this.lightModelAmbientLocation) GLctx.uniform4fv(this.lightModelAmbientLocation, GLEmulation.lightModelAmbient);
              if (this.materialAmbientLocation) GLctx.uniform4fv(this.materialAmbientLocation, GLEmulation.materialAmbient);
              if (this.materialDiffuseLocation) GLctx.uniform4fv(this.materialDiffuseLocation, GLEmulation.materialDiffuse);
              if (this.materialSpecularLocation) GLctx.uniform4fv(this.materialSpecularLocation, GLEmulation.materialSpecular);
              if (this.materialShininessLocation) GLctx.uniform1f(this.materialShininessLocation, GLEmulation.materialShininess[0]);
              if (this.materialEmissionLocation) GLctx.uniform4fv(this.materialEmissionLocation, GLEmulation.materialEmission);
              for (var lightId = 0; lightId < GLEmulation.MAX_LIGHTS; lightId++) {
                if (this.lightAmbientLocation[lightId]) GLctx.uniform4fv(this.lightAmbientLocation[lightId], GLEmulation.lightAmbient[lightId]);
                if (this.lightDiffuseLocation[lightId]) GLctx.uniform4fv(this.lightDiffuseLocation[lightId], GLEmulation.lightDiffuse[lightId]);
                if (this.lightSpecularLocation[lightId]) GLctx.uniform4fv(this.lightSpecularLocation[lightId], GLEmulation.lightSpecular[lightId]);
                if (this.lightPositionLocation[lightId]) GLctx.uniform4fv(this.lightPositionLocation[lightId], GLEmulation.lightPosition[lightId]);
              }
            }
  
            if (this.hasAlphaTest) {
              if (this.alphaTestRefLocation) GLctx.uniform1f(this.alphaTestRefLocation, GLEmulation.alphaTestRef);
            }
  
            if (GLImmediate.mode == GLctx.POINTS) {
              if (this.pointSizeLocation) {
                GLctx.uniform1f(this.pointSizeLocation, GLEmulation.pointSize);
              }
            }
          };
  
          this.cleanup = function() {
            GLctx.disableVertexAttribArray(this.positionLocation);
            if (this.hasTextures) {
              for (var i = 0; i < GLImmediate.MAX_TEXTURES; i++) {
                if (GLImmediate.enabledClientAttributes[GLImmediate.TEXTURE0+i] && this.texCoordLocations[i] >= 0) {
                  GLctx.disableVertexAttribArray(this.texCoordLocations[i]);
                }
              }
            }
            if (this.hasColor) {
              GLctx.disableVertexAttribArray(this.colorLocation);
            }
            if (this.hasNormal) {
              GLctx.disableVertexAttribArray(this.normalLocation);
            }
            if (!GL.currProgram) {
              GLctx.useProgram(null);
              GLImmediate.fixedFunctionProgram = 0;
            }
            if (!GLctx.currentArrayBufferBinding) {
              GLctx.bindBuffer(GLctx.ARRAY_BUFFER, null);
              GLImmediate.lastArrayBuffer = null;
            }
  
            GLImmediate.matricesModified = true;
          }
  
          this.init();
        }
        return new Renderer();
      },
  setupFuncs() {
        // TexEnv stuff needs to be prepared early, so do it here.
        // init() is too late for -O2, since it freezes the GL functions
        // by that point.
        GLImmediate.MapTreeLib = GLImmediate.spawnMapTreeLib();
        GLImmediate.spawnMapTreeLib = null;
  
        GLImmediate.TexEnvJIT = GLImmediate.spawnTexEnvJIT();
        GLImmediate.spawnTexEnvJIT = null;
  
        GLImmediate.setupHooks();
      },
  setupHooks() {
        if (!GLEmulation.hasRunInit) {
          GLEmulation.init();
        }
  
        var glActiveTexture = _glActiveTexture;
        _glActiveTexture = _emscripten_glActiveTexture = (texture) => {
          GLImmediate.TexEnvJIT.hook_activeTexture(texture);
          glActiveTexture(texture);
        };
  
        var glEnable = _glEnable;
        _glEnable = _emscripten_glEnable = (cap) => {
          GLImmediate.TexEnvJIT.hook_enable(cap);
          glEnable(cap);
        };
  
        var glDisable = _glDisable;
        _glDisable = _emscripten_glDisable = (cap) => {
          GLImmediate.TexEnvJIT.hook_disable(cap);
          glDisable(cap);
        };
  
        var glTexEnvf = (typeof _glTexEnvf != 'undefined') ? _glTexEnvf : () => {};
        /** @suppress {checkTypes} */
        _glTexEnvf = _emscripten_glTexEnvf = (target, pname, param) => {
          GLImmediate.TexEnvJIT.hook_texEnvf(target, pname, param);
          // Don't call old func, since we are the implementor.
          //glTexEnvf(target, pname, param);
        };
  
        var glTexEnvi = (typeof _glTexEnvi != 'undefined') ? _glTexEnvi : () => {};
        /** @suppress {checkTypes} */
        _glTexEnvi = _emscripten_glTexEnvi = (target, pname, param) => {
          GLImmediate.TexEnvJIT.hook_texEnvi(target, pname, param);
          // Don't call old func, since we are the implementor.
          //glTexEnvi(target, pname, param);
        };
  
        var glTexEnvfv = (typeof _glTexEnvfv != 'undefined') ? _glTexEnvfv : () => {};
        /** @suppress {checkTypes} */
        _glTexEnvfv = _emscripten_glTexEnvfv = (target, pname, param) => {
          GLImmediate.TexEnvJIT.hook_texEnvfv(target, pname, param);
          // Don't call old func, since we are the implementor.
          //glTexEnvfv(target, pname, param);
        };
  
        _glGetTexEnviv = (target, pname, param) => {
          GLImmediate.TexEnvJIT.hook_getTexEnviv(target, pname, param);
        };
  
        _glGetTexEnvfv = (target, pname, param) => {
          GLImmediate.TexEnvJIT.hook_getTexEnvfv(target, pname, param);
        };
  
        var glGetIntegerv = _glGetIntegerv;
        _glGetIntegerv = _emscripten_glGetIntegerv = (pname, params) => {
          switch (pname) {
            case 0x8B8D: { // GL_CURRENT_PROGRAM
              // Just query directly so we're working with WebGL objects.
              var cur = GLctx.getParameter(GLctx.CURRENT_PROGRAM);
              if (cur == GLImmediate.fixedFunctionProgram) {
                // Pretend we're not using a program.
                HEAP32[((params)>>2)] = 0;
                return;
              }
              break;
            }
          }
          glGetIntegerv(pname, params);
        };
      },
  initted:false,
  init() {
        err('WARNING: using emscripten GL immediate mode emulation. This is very limited in what it supports');
        GLImmediate.initted = true;
  
        if (!Module.useWebGL) return; // a 2D canvas may be currently used TODO: make sure we are actually called in that case
  
        // User can override the maximum number of texture units that we emulate. Using fewer texture units increases runtime performance
        // slightly, so it is advantageous to choose as small value as needed.
        // Limit to a maximum of 28 to not overflow the state bits used for renderer caching (31 bits = 3 attributes + 28 texture units).
        GLImmediate.MAX_TEXTURES = Math.min(Module['GL_MAX_TEXTURE_IMAGE_UNITS'] || GLctx.getParameter(GLctx.MAX_TEXTURE_IMAGE_UNITS), 28);
  
        GLImmediate.TexEnvJIT.init(GLctx, GLImmediate.MAX_TEXTURES);
  
        GLImmediate.NUM_ATTRIBUTES = 3 /*pos+normal+color attributes*/ + GLImmediate.MAX_TEXTURES;
        GLImmediate.clientAttributes = [];
        GLEmulation.enabledClientAttribIndices = [];
        for (var i = 0; i < GLImmediate.NUM_ATTRIBUTES; i++) {
          GLImmediate.clientAttributes.push({});
          GLEmulation.enabledClientAttribIndices.push(false);
        }
  
        // Initialize matrix library
        // When user sets a matrix, increment a 'version number' on the new data, and when rendering, submit
        // the matrices to the shader program only if they have an old version of the data.
        GLImmediate.matrix = [];
        GLImmediate.matrixStack = [];
        GLImmediate.matrixVersion = [];
        for (var i = 0; i < 2 + GLImmediate.MAX_TEXTURES; i++) { // Modelview, Projection, plus one matrix for each texture coordinate.
          GLImmediate.matrixStack.push([]);
          GLImmediate.matrixVersion.push(0);
          GLImmediate.matrix.push(GLImmediate.matrixLib.mat4.create());
          GLImmediate.matrixLib.mat4.identity(GLImmediate.matrix[i]);
        }
  
        // Renderer cache
        GLImmediate.rendererCache = GLImmediate.MapTreeLib.create();
  
        // Buffers for data
        GLImmediate.tempData = new Float32Array(GL.MAX_TEMP_BUFFER_SIZE >> 2);
        GLImmediate.indexData = new Uint16Array(GL.MAX_TEMP_BUFFER_SIZE >> 1);
  
        GLImmediate.vertexDataU8 = new Uint8Array(GLImmediate.tempData.buffer);
  
        GL.generateTempBuffers(true, GL.currentContext);
  
        GLImmediate.clientColor = new Float32Array([1, 1, 1, 1]);
      },
  prepareClientAttributes(count, beginEnd) {
        // If no client attributes were modified since we were last called, do nothing. Note that this
        // does not work for glBegin/End, where we generate renderer components dynamically and then
        // disable them ourselves, but it does help with glDrawElements/Arrays.
        if (!GLImmediate.modifiedClientAttributes) {
          GLImmediate.vertexCounter = (GLImmediate.stride * count) / 4; // XXX assuming float
          return;
        }
        GLImmediate.modifiedClientAttributes = false;
  
        // The role of prepareClientAttributes is to examine the set of client-side vertex attribute buffers
        // that user code has submitted, and to prepare them to be uploaded to a VBO in GPU memory
        // (since WebGL does not support client-side rendering, i.e. rendering from vertex data in CPU memory)
        // User can submit vertex data generally in three different configurations:
        // 1. Fully planar: all attributes are in their own separate tightly-packed arrays in CPU memory.
        // 2. Fully interleaved: all attributes share a single array where data is interleaved something like (pos,uv,normal), (pos,uv,normal), ...
        // 3. Complex hybrid: Multiple separate arrays that either are sparsely strided, and/or partially interleave vertex attributes.
  
        // For simplicity, we support the case (2) as the fast case. For (1) and (3), we do a memory copy of the
        // vertex data here to prepare a relayouted buffer that is of the structure in case (2). The reason
        // for this is that it allows the emulation code to get away with using just one VBO buffer for rendering,
        // and not have to maintain multiple ones. Therefore cases (1) and (3) will be very slow, and case (2) is fast.
  
        // Detect which case we are in by using a quick heuristic by examining the strides of the buffers. If all the buffers have identical
        // stride, we assume we have case (2), otherwise we have something more complex.
        var clientStartPointer = 0x7FFFFFFF;
        var bytes = 0; // Total number of bytes taken up by a single vertex.
        var minStride = 0x7FFFFFFF;
        var maxStride = 0;
        var attributes = GLImmediate.liveClientAttributes;
        attributes.length = 0;
        for (var i = 0; i < 3+GLImmediate.MAX_TEXTURES; i++) {
          if (GLImmediate.enabledClientAttributes[i]) {
            var attr = GLImmediate.clientAttributes[i];
            attributes.push(attr);
            clientStartPointer = Math.min(clientStartPointer, attr.pointer);
            attr.sizeBytes = attr.size * GL.byteSizeByType[attr.type - GL.byteSizeByTypeRoot];
            bytes += attr.sizeBytes;
            minStride = Math.min(minStride, attr.stride);
            maxStride = Math.max(maxStride, attr.stride);
          }
        }
  
        if ((minStride != maxStride || maxStride < bytes) && !beginEnd) {
          // We are in cases (1) or (3): slow path, shuffle the data around into a single interleaved vertex buffer.
          // The immediate-mode glBegin()/glEnd() vertex submission gets automatically generated in appropriate layout,
          // so never need to come down this path if that was used.
          GLImmediate.restrideBuffer ||= _malloc(GL.MAX_TEMP_BUFFER_SIZE);
          var start = GLImmediate.restrideBuffer;
          bytes = 0;
          // calculate restrided offsets and total size
          for (var i = 0; i < attributes.length; i++) {
            var attr = attributes[i];
            var size = attr.sizeBytes;
            if (size % 4 != 0) size += 4 - (size % 4); // align everything
            attr.offset = bytes;
            bytes += size;
          }
          // copy out the data (we need to know the stride for that, and define attr.pointer)
          for (var i = 0; i < attributes.length; i++) {
            var attr = attributes[i];
            var srcStride = Math.max(attr.sizeBytes, attr.stride);
            if ((srcStride & 3) == 0 && (attr.sizeBytes & 3) == 0) {
              var size4 = attr.sizeBytes>>2;
              var srcStride4 = Math.max(attr.sizeBytes, attr.stride)>>2;
              for (var j = 0; j < count; j++) {
                for (var k = 0; k < size4; k++) { // copy in chunks of 4 bytes, our alignment makes this possible
                  HEAP32[((start + attr.offset + bytes*j)>>2) + k] = HEAP32[(attr.pointer>>2) + j*srcStride4 + k];
                }
              }
            } else {
              for (var j = 0; j < count; j++) {
                for (var k = 0; k < attr.sizeBytes; k++) { // source data was not aligned to multiples of 4, must copy byte by byte.
                  HEAP8[start + attr.offset + bytes*j + k] = HEAP8[attr.pointer + j*srcStride + k];
                }
              }
            }
            attr.pointer = start + attr.offset;
          }
          GLImmediate.stride = bytes;
          GLImmediate.vertexPointer = start;
        } else {
          // case (2): fast path, all data is interleaved to a single vertex array so we can get away with a single VBO upload.
          if (GLctx.currentArrayBufferBinding) {
            GLImmediate.vertexPointer = 0;
          } else {
            GLImmediate.vertexPointer = clientStartPointer;
          }
          for (var i = 0; i < attributes.length; i++) {
            var attr = attributes[i];
            attr.offset = attr.pointer - GLImmediate.vertexPointer; // Compute what will be the offset of this attribute in the VBO after we upload.
          }
          GLImmediate.stride = Math.max(maxStride, bytes);
        }
        if (!beginEnd) {
          GLImmediate.vertexCounter = (GLImmediate.stride * count) / 4; // XXX assuming float
        }
      },
  flush(numProvidedIndexes, startIndex = 0, ptr = 0) {
        assert(numProvidedIndexes >= 0 || !numProvidedIndexes);
        var renderer = GLImmediate.getRenderer();
  
        // Generate index data in a format suitable for GLES 2.0/WebGL
        var numVertexes = 4 * GLImmediate.vertexCounter / GLImmediate.stride;
        if (!numVertexes) return;
        assert(numVertexes % 1 == 0, "`numVertexes` must be an integer.");
        var emulatedElementArrayBuffer = false;
        var numIndexes = 0;
        if (numProvidedIndexes) {
          numIndexes = numProvidedIndexes;
          if (!GLctx.currentArrayBufferBinding && GLImmediate.firstVertex > GLImmediate.lastVertex) {
            // Figure out the first and last vertex from the index data
            // If we are going to upload array buffer data, we need to find which range to
            // upload based on the indices. If they are in a buffer on the GPU, that is very
            // inconvenient! So if you do not have an array buffer, you should also not have
            // an element array buffer. But best is to use both buffers!
            assert(!GLctx.currentElementArrayBufferBinding);
            for (var i = 0; i < numProvidedIndexes; i++) {
              var currIndex = HEAPU16[(((ptr)+(i*2))>>1)];
              GLImmediate.firstVertex = Math.min(GLImmediate.firstVertex, currIndex);
              GLImmediate.lastVertex = Math.max(GLImmediate.lastVertex, currIndex+1);
            }
          }
          if (!GLctx.currentElementArrayBufferBinding) {
            // If no element array buffer is bound, then indices is a literal pointer to clientside data
            assert(numProvidedIndexes << 1 <= GL.MAX_TEMP_BUFFER_SIZE, 'too many immediate mode indexes (a)');
            var indexBuffer = GL.getTempIndexBuffer(numProvidedIndexes << 1);
            GLctx.bindBuffer(GLctx.ELEMENT_ARRAY_BUFFER, indexBuffer);
            GLctx.bufferSubData(GLctx.ELEMENT_ARRAY_BUFFER, 0, HEAPU16.subarray((ptr)>>1, (ptr + (numProvidedIndexes << 1))>>1));
            ptr = 0;
            emulatedElementArrayBuffer = true;
          }
        } else if (GLImmediate.mode > 6) { // above GL_TRIANGLE_FAN are the non-GL ES modes
          if (GLImmediate.mode != 7) throw 'unsupported immediate mode ' + GLImmediate.mode; // GL_QUADS
          // GLImmediate.firstVertex is the first vertex we want. Quad indexes are in the pattern
          // 0 1 2, 0 2 3, 4 5 6, 4 6 7, so we need to look at index firstVertex * 1.5 to see it.
          // Then since indexes are 2 bytes each, that means 3
          assert(GLImmediate.firstVertex % 4 == 0);
          ptr = GLImmediate.firstVertex*3;
          var numQuads = numVertexes / 4;
          numIndexes = numQuads * 6; // 0 1 2, 0 2 3 pattern
          assert(ptr + (numIndexes << 1) <= GL.MAX_TEMP_BUFFER_SIZE, 'too many immediate mode indexes (b)');
          GLctx.bindBuffer(GLctx.ELEMENT_ARRAY_BUFFER, GL.currentContext.tempQuadIndexBuffer);
          emulatedElementArrayBuffer = true;
          GLImmediate.mode = GLctx.TRIANGLES;
        }
  
        renderer.prepare();
  
        if (numIndexes) {
          GLctx.drawElements(GLImmediate.mode, numIndexes, GLctx.UNSIGNED_SHORT, ptr);
        } else {
          GLctx.drawArrays(GLImmediate.mode, startIndex, numVertexes);
        }
  
        if (emulatedElementArrayBuffer) {
          GLctx.bindBuffer(GLctx.ELEMENT_ARRAY_BUFFER, GL.buffers[GLctx.currentElementArrayBufferBinding] || null);
        }
  
        renderer.cleanup();
      },
  };
  GLImmediate.matrixLib = (function() {
  
  /**
   * @fileoverview gl-matrix - High performance matrix and vector operations for WebGL
   * @author Brandon Jones
   * @version 1.2.4
   */
  
  // Modifed for emscripten:
  // - Global scoping etc.
  // - Disabled some non-closure-compatible javadoc comments.
  
  /*
   * Copyright (c) 2011 Brandon Jones
   *
   * This software is provided 'as-is', without any express or implied
   * warranty. In no event will the authors be held liable for any damages
   * arising from the use of this software.
   *
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   *
   *    1. The origin of this software must not be misrepresented; you must not
   *    claim that you wrote the original software. If you use this software
   *    in a product, an acknowledgment in the product documentation would be
   *    appreciated but is not required.
   *
   *    2. Altered source versions must be plainly marked as such, and must not
   *    be misrepresented as being the original software.
   *
   *    3. This notice may not be removed or altered from any source
   *    distribution.
   */
  
  
  /**
   * @class 3 Dimensional Vector
   * @name vec3
   */
  var vec3 = {};
  
  /**
   * @class 3x3 Matrix
   * @name mat3
   */
  var mat3 = {};
  
  /**
   * @class 4x4 Matrix
   * @name mat4
   */
  var mat4 = {};
  
  /**
   * @class Quaternion
   * @name quat4
   */
  var quat4 = {};
  
  var MatrixArray = Float32Array;
  
  /*
   * vec3
   */
  
  /**
   * Creates a new instance of a vec3 using the default array type
   * Any javascript array-like objects containing at least 3 numeric elements can serve as a vec3
   *
   * _param {vec3} [vec] vec3 containing values to initialize with
   *
   * _returns {vec3} New vec3
   */
  vec3.create = function (vec) {
      var dest = new MatrixArray(3);
  
      if (vec) {
          dest[0] = vec[0];
          dest[1] = vec[1];
          dest[2] = vec[2];
      } else {
          dest[0] = dest[1] = dest[2] = 0;
      }
  
      return dest;
  };
  
  /**
   * Copies the values of one vec3 to another
   *
   * _param {vec3} vec vec3 containing values to copy
   * _param {vec3} dest vec3 receiving copied values
   *
   * _returns {vec3} dest
   */
  vec3.set = function (vec, dest) {
      dest[0] = vec[0];
      dest[1] = vec[1];
      dest[2] = vec[2];
  
      return dest;
  };
  
  /**
   * Performs a vector addition
   *
   * _param {vec3} vec First operand
   * _param {vec3} vec2 Second operand
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  vec3.add = function (vec, vec2, dest) {
      if (!dest || vec === dest) {
          vec[0] += vec2[0];
          vec[1] += vec2[1];
          vec[2] += vec2[2];
          return vec;
      }
  
      dest[0] = vec[0] + vec2[0];
      dest[1] = vec[1] + vec2[1];
      dest[2] = vec[2] + vec2[2];
      return dest;
  };
  
  /**
   * Performs a vector subtraction
   *
   * _param {vec3} vec First operand
   * _param {vec3} vec2 Second operand
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  vec3.subtract = function (vec, vec2, dest) {
      if (!dest || vec === dest) {
          vec[0] -= vec2[0];
          vec[1] -= vec2[1];
          vec[2] -= vec2[2];
          return vec;
      }
  
      dest[0] = vec[0] - vec2[0];
      dest[1] = vec[1] - vec2[1];
      dest[2] = vec[2] - vec2[2];
      return dest;
  };
  
  /**
   * Performs a vector multiplication
   *
   * _param {vec3} vec First operand
   * _param {vec3} vec2 Second operand
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  vec3.multiply = function (vec, vec2, dest) {
      if (!dest || vec === dest) {
          vec[0] *= vec2[0];
          vec[1] *= vec2[1];
          vec[2] *= vec2[2];
          return vec;
      }
  
      dest[0] = vec[0] * vec2[0];
      dest[1] = vec[1] * vec2[1];
      dest[2] = vec[2] * vec2[2];
      return dest;
  };
  
  /**
   * Negates the components of a vec3
   *
   * _param {vec3} vec vec3 to negate
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  vec3.negate = function (vec, dest) {
      if (!dest) { dest = vec; }
  
      dest[0] = -vec[0];
      dest[1] = -vec[1];
      dest[2] = -vec[2];
      return dest;
  };
  
  /**
   * Multiplies the components of a vec3 by a scalar value
   *
   * _param {vec3} vec vec3 to scale
   * _param {number} val Value to scale by
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  vec3.scale = function (vec, val, dest) {
      if (!dest || vec === dest) {
          vec[0] *= val;
          vec[1] *= val;
          vec[2] *= val;
          return vec;
      }
  
      dest[0] = vec[0] * val;
      dest[1] = vec[1] * val;
      dest[2] = vec[2] * val;
      return dest;
  };
  
  /**
   * Generates a unit vector of the same direction as the provided vec3
   * If vector length is 0, returns [0, 0, 0]
   *
   * _param {vec3} vec vec3 to normalize
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  vec3.normalize = function (vec, dest) {
      if (!dest) { dest = vec; }
  
      var x = vec[0], y = vec[1], z = vec[2],
          len = Math.sqrt(x * x + y * y + z * z);
  
      if (!len) {
          dest[0] = 0;
          dest[1] = 0;
          dest[2] = 0;
          return dest;
      } else if (len === 1) {
          dest[0] = x;
          dest[1] = y;
          dest[2] = z;
          return dest;
      }
  
      len = 1 / len;
      dest[0] = x * len;
      dest[1] = y * len;
      dest[2] = z * len;
      return dest;
  };
  
  /**
   * Generates the cross product of two vec3s
   *
   * _param {vec3} vec First operand
   * _param {vec3} vec2 Second operand
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  vec3.cross = function (vec, vec2, dest) {
      if (!dest) { dest = vec; }
  
      var x = vec[0], y = vec[1], z = vec[2],
          x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];
  
      dest[0] = y * z2 - z * y2;
      dest[1] = z * x2 - x * z2;
      dest[2] = x * y2 - y * x2;
      return dest;
  };
  
  /**
   * Caclulates the length of a vec3
   *
   * _param {vec3} vec vec3 to calculate length of
   *
   * _returns {number} Length of vec
   */
  vec3.length = function (vec) {
      var x = vec[0], y = vec[1], z = vec[2];
      return Math.sqrt(x * x + y * y + z * z);
  };
  
  /**
   * Caclulates the dot product of two vec3s
   *
   * _param {vec3} vec First operand
   * _param {vec3} vec2 Second operand
   *
   * _returns {number} Dot product of vec and vec2
   */
  vec3.dot = function (vec, vec2) {
      return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
  };
  
  /**
   * Generates a unit vector pointing from one vector to another
   *
   * _param {vec3} vec Origin vec3
   * _param {vec3} vec2 vec3 to point to
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  vec3.direction = function (vec, vec2, dest) {
      if (!dest) { dest = vec; }
  
      var x = vec[0] - vec2[0],
          y = vec[1] - vec2[1],
          z = vec[2] - vec2[2],
          len = Math.sqrt(x * x + y * y + z * z);
  
      if (!len) {
          dest[0] = 0;
          dest[1] = 0;
          dest[2] = 0;
          return dest;
      }
  
      len = 1 / len;
      dest[0] = x * len;
      dest[1] = y * len;
      dest[2] = z * len;
      return dest;
  };
  
  /**
   * Performs a linear interpolation between two vec3
   *
   * _param {vec3} vec First vector
   * _param {vec3} vec2 Second vector
   * _param {number} lerp Interpolation amount between the two inputs
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  vec3.lerp = function (vec, vec2, lerp, dest) {
      if (!dest) { dest = vec; }
  
      dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
      dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
      dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);
  
      return dest;
  };
  
  /**
   * Calculates the euclidian distance between two vec3
   *
   * Params:
   * _param {vec3} vec First vector
   * _param {vec3} vec2 Second vector
   *
   * _returns {number} Distance between vec and vec2
   */
  vec3.dist = function (vec, vec2) {
      var x = vec2[0] - vec[0],
          y = vec2[1] - vec[1],
          z = vec2[2] - vec[2];
  
      return Math.sqrt(x*x + y*y + z*z);
  };
  
  /**
   * Projects the specified vec3 from screen space into object space
   * Based on the <a href="http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup">Mesa gluUnProject implementation</a>
   *
   * _param {vec3} vec Screen-space vector to project
   * _param {mat4} view View matrix
   * _param {mat4} proj Projection matrix
   * _param {vec4} viewport Viewport as given to gl.viewport [x, y, width, height]
   * _param {vec3} [dest] vec3 receiving unprojected result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  vec3.unproject = function (vec, view, proj, viewport, dest) {
      if (!dest) { dest = vec; }
  
      var m = mat4.create();
      var v = new MatrixArray(4);
  
      v[0] = (vec[0] - viewport[0]) * 2.0 / viewport[2] - 1.0;
      v[1] = (vec[1] - viewport[1]) * 2.0 / viewport[3] - 1.0;
      v[2] = 2.0 * vec[2] - 1.0;
      v[3] = 1.0;
  
      mat4.multiply(proj, view, m);
      if(!mat4.inverse(m)) { return null; }
  
      mat4.multiplyVec4(m, v);
      if(v[3] === 0.0) { return null; }
  
      dest[0] = v[0] / v[3];
      dest[1] = v[1] / v[3];
      dest[2] = v[2] / v[3];
  
      return dest;
  };
  
  /**
   * Returns a string representation of a vector
   *
   * _param {vec3} vec Vector to represent as a string
   *
   * _returns {string} String representation of vec
   */
  vec3.str = function (vec) {
      return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';
  };
  
  /*
   * mat3
   */
  
  /**
   * Creates a new instance of a mat3 using the default array type
   * Any javascript array-like object containing at least 9 numeric elements can serve as a mat3
   *
   * _param {mat3} [mat] mat3 containing values to initialize with
   *
   * _returns {mat3} New mat3
   *
   * @param {Object=} mat
   */
  mat3.create = function (mat) {
      var dest = new MatrixArray(9);
  
      if (mat) {
          dest[0] = mat[0];
          dest[1] = mat[1];
          dest[2] = mat[2];
          dest[3] = mat[3];
          dest[4] = mat[4];
          dest[5] = mat[5];
          dest[6] = mat[6];
          dest[7] = mat[7];
          dest[8] = mat[8];
      }
  
      return dest;
  };
  
  /**
   * Copies the values of one mat3 to another
   *
   * _param {mat3} mat mat3 containing values to copy
   * _param {mat3} dest mat3 receiving copied values
   *
   * _returns {mat3} dest
   */
  mat3.set = function (mat, dest) {
      dest[0] = mat[0];
      dest[1] = mat[1];
      dest[2] = mat[2];
      dest[3] = mat[3];
      dest[4] = mat[4];
      dest[5] = mat[5];
      dest[6] = mat[6];
      dest[7] = mat[7];
      dest[8] = mat[8];
      return dest;
  };
  
  /**
   * Sets a mat3 to an identity matrix
   *
   * _param {mat3} dest mat3 to set
   *
   * _returns dest if specified, otherwise a new mat3
   */
  mat3.identity = function (dest) {
      if (!dest) { dest = mat3.create(); }
      dest[0] = 1;
      dest[1] = 0;
      dest[2] = 0;
      dest[3] = 0;
      dest[4] = 1;
      dest[5] = 0;
      dest[6] = 0;
      dest[7] = 0;
      dest[8] = 1;
      return dest;
  };
  
  /**
   * Transposes a mat3 (flips the values over the diagonal)
   *
   * Params:
   * _param {mat3} mat mat3 to transpose
   * _param {mat3} [dest] mat3 receiving transposed values. If not specified result is written to mat
   */
  mat3.transpose = function (mat, dest) {
      // If we are transposing ourselves we can skip a few steps but have to cache some values
      if (!dest || mat === dest) {
          var a01 = mat[1], a02 = mat[2],
              a12 = mat[5];
  
          mat[1] = mat[3];
          mat[2] = mat[6];
          mat[3] = a01;
          mat[5] = mat[7];
          mat[6] = a02;
          mat[7] = a12;
          return mat;
      }
  
      dest[0] = mat[0];
      dest[1] = mat[3];
      dest[2] = mat[6];
      dest[3] = mat[1];
      dest[4] = mat[4];
      dest[5] = mat[7];
      dest[6] = mat[2];
      dest[7] = mat[5];
      dest[8] = mat[8];
      return dest;
  };
  
  /**
   * Copies the elements of a mat3 into the upper 3x3 elements of a mat4
   *
   * _param {mat3} mat mat3 containing values to copy
   * _param {mat4} [dest] mat4 receiving copied values
   *
   * _returns {mat4} dest if specified, a new mat4 otherwise
   */
  mat3.toMat4 = function (mat, dest) {
      if (!dest) { dest = mat4.create(); }
  
      dest[15] = 1;
      dest[14] = 0;
      dest[13] = 0;
      dest[12] = 0;
  
      dest[11] = 0;
      dest[10] = mat[8];
      dest[9] = mat[7];
      dest[8] = mat[6];
  
      dest[7] = 0;
      dest[6] = mat[5];
      dest[5] = mat[4];
      dest[4] = mat[3];
  
      dest[3] = 0;
      dest[2] = mat[2];
      dest[1] = mat[1];
      dest[0] = mat[0];
  
      return dest;
  };
  
  /**
   * Returns a string representation of a mat3
   *
   * _param {mat3} mat mat3 to represent as a string
   *
   * _param {string} String representation of mat
   */
  mat3.str = function (mat) {
      return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] +
          ', ' + mat[3] + ', ' + mat[4] + ', ' + mat[5] +
          ', ' + mat[6] + ', ' + mat[7] + ', ' + mat[8] + ']';
  };
  
  /*
   * mat4
   */
  
  /**
   * Creates a new instance of a mat4 using the default array type
   * Any javascript array-like object containing at least 16 numeric elements can serve as a mat4
   *
   * _param {mat4} [mat] mat4 containing values to initialize with
   *
   * _returns {mat4} New mat4
   *
   * @param {Object=} mat
   */
  mat4.create = function (mat) {
      var dest = new MatrixArray(16);
  
      if (mat) {
          dest[0] = mat[0];
          dest[1] = mat[1];
          dest[2] = mat[2];
          dest[3] = mat[3];
          dest[4] = mat[4];
          dest[5] = mat[5];
          dest[6] = mat[6];
          dest[7] = mat[7];
          dest[8] = mat[8];
          dest[9] = mat[9];
          dest[10] = mat[10];
          dest[11] = mat[11];
          dest[12] = mat[12];
          dest[13] = mat[13];
          dest[14] = mat[14];
          dest[15] = mat[15];
      }
  
      return dest;
  };
  
  /**
   * Copies the values of one mat4 to another
   *
   * _param {mat4} mat mat4 containing values to copy
   * _param {mat4} dest mat4 receiving copied values
   *
   * _returns {mat4} dest
   */
  mat4.set = function (mat, dest) {
      dest[0] = mat[0];
      dest[1] = mat[1];
      dest[2] = mat[2];
      dest[3] = mat[3];
      dest[4] = mat[4];
      dest[5] = mat[5];
      dest[6] = mat[6];
      dest[7] = mat[7];
      dest[8] = mat[8];
      dest[9] = mat[9];
      dest[10] = mat[10];
      dest[11] = mat[11];
      dest[12] = mat[12];
      dest[13] = mat[13];
      dest[14] = mat[14];
      dest[15] = mat[15];
      return dest;
  };
  
  /**
   * Sets a mat4 to an identity matrix
   *
   * _param {mat4} dest mat4 to set
   *
   * _returns {mat4} dest
   */
  mat4.identity = function (dest) {
      if (!dest) { dest = mat4.create(); }
      dest[0] = 1;
      dest[1] = 0;
      dest[2] = 0;
      dest[3] = 0;
      dest[4] = 0;
      dest[5] = 1;
      dest[6] = 0;
      dest[7] = 0;
      dest[8] = 0;
      dest[9] = 0;
      dest[10] = 1;
      dest[11] = 0;
      dest[12] = 0;
      dest[13] = 0;
      dest[14] = 0;
      dest[15] = 1;
      return dest;
  };
  
  /**
   * Transposes a mat4 (flips the values over the diagonal)
   *
   * _param {mat4} mat mat4 to transpose
   * _param {mat4} [dest] mat4 receiving transposed values. If not specified result is written to mat
   */
  mat4.transpose = function (mat, dest) {
      // If we are transposing ourselves we can skip a few steps but have to cache some values
      if (!dest || mat === dest) {
          var a01 = mat[1], a02 = mat[2], a03 = mat[3],
              a12 = mat[6], a13 = mat[7],
              a23 = mat[11];
  
          mat[1] = mat[4];
          mat[2] = mat[8];
          mat[3] = mat[12];
          mat[4] = a01;
          mat[6] = mat[9];
          mat[7] = mat[13];
          mat[8] = a02;
          mat[9] = a12;
          mat[11] = mat[14];
          mat[12] = a03;
          mat[13] = a13;
          mat[14] = a23;
          return mat;
      }
  
      dest[0] = mat[0];
      dest[1] = mat[4];
      dest[2] = mat[8];
      dest[3] = mat[12];
      dest[4] = mat[1];
      dest[5] = mat[5];
      dest[6] = mat[9];
      dest[7] = mat[13];
      dest[8] = mat[2];
      dest[9] = mat[6];
      dest[10] = mat[10];
      dest[11] = mat[14];
      dest[12] = mat[3];
      dest[13] = mat[7];
      dest[14] = mat[11];
      dest[15] = mat[15];
      return dest;
  };
  
  /**
   * Calculates the determinant of a mat4
   *
   * _param {mat4} mat mat4 to calculate determinant of
   *
   * _returns {number} determinant of mat
   */
  mat4.determinant = function (mat) {
      // Cache the matrix values (makes for huge speed increases!)
      var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
          a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
          a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
          a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
  
      return (a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
              a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
              a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
              a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
              a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
              a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33);
  };
  
  /**
   * Calculates the inverse matrix of a mat4
   *
   * _param {mat4} mat mat4 to calculate inverse of
   * _param {mat4} [dest] mat4 receiving inverse matrix. If not specified result is written to mat, null if matrix cannot be inverted
   *
   * @param {Object=} dest
   */
  mat4.inverse = function (mat, dest) {
      if (!dest) { dest = mat; }
  
      // Cache the matrix values (makes for huge speed increases!)
      var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
          a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
          a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
          a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],
  
          b00 = a00 * a11 - a01 * a10,
          b01 = a00 * a12 - a02 * a10,
          b02 = a00 * a13 - a03 * a10,
          b03 = a01 * a12 - a02 * a11,
          b04 = a01 * a13 - a03 * a11,
          b05 = a02 * a13 - a03 * a12,
          b06 = a20 * a31 - a21 * a30,
          b07 = a20 * a32 - a22 * a30,
          b08 = a20 * a33 - a23 * a30,
          b09 = a21 * a32 - a22 * a31,
          b10 = a21 * a33 - a23 * a31,
          b11 = a22 * a33 - a23 * a32,
  
          d = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06),
          invDet;
  
          // Calculate the determinant
          if (!d) { return null; }
          invDet = 1 / d;
  
      dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
      dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
      dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
      dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
      dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
      dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
      dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
      dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
      dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
      dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
      dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
      dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
      dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
      dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
      dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
      dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
  
      return dest;
  };
  
  /**
   * Copies the upper 3x3 elements of a mat4 into another mat4
   *
   * _param {mat4} mat mat4 containing values to copy
   * _param {mat4} [dest] mat4 receiving copied values
   *
   * _returns {mat4} dest is specified, a new mat4 otherwise
   */
  mat4.toRotationMat = function (mat, dest) {
      if (!dest) { dest = mat4.create(); }
  
      dest[0] = mat[0];
      dest[1] = mat[1];
      dest[2] = mat[2];
      dest[3] = mat[3];
      dest[4] = mat[4];
      dest[5] = mat[5];
      dest[6] = mat[6];
      dest[7] = mat[7];
      dest[8] = mat[8];
      dest[9] = mat[9];
      dest[10] = mat[10];
      dest[11] = mat[11];
      dest[12] = 0;
      dest[13] = 0;
      dest[14] = 0;
      dest[15] = 1;
  
      return dest;
  };
  
  /**
   * Copies the upper 3x3 elements of a mat4 into a mat3
   *
   * _param {mat4} mat mat4 containing values to copy
   * _param {mat3} [dest] mat3 receiving copied values
   *
   * _returns {mat3} dest is specified, a new mat3 otherwise
   */
  mat4.toMat3 = function (mat, dest) {
      if (!dest) { dest = mat3.create(); }
  
      dest[0] = mat[0];
      dest[1] = mat[1];
      dest[2] = mat[2];
      dest[3] = mat[4];
      dest[4] = mat[5];
      dest[5] = mat[6];
      dest[6] = mat[8];
      dest[7] = mat[9];
      dest[8] = mat[10];
  
      return dest;
  };
  
  /**
   * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
   * The resulting matrix is useful for calculating transformed normals
   *
   * Params:
   * _param {mat4} mat mat4 containing values to invert and copy
   * _param {mat3} [dest] mat3 receiving values
   *
   * _returns {mat3} dest is specified, a new mat3 otherwise, null if the matrix cannot be inverted
   */
  mat4.toInverseMat3 = function (mat, dest) {
      // Cache the matrix values (makes for huge speed increases!)
      var a00 = mat[0], a01 = mat[1], a02 = mat[2],
          a10 = mat[4], a11 = mat[5], a12 = mat[6],
          a20 = mat[8], a21 = mat[9], a22 = mat[10],
  
          b01 = a22 * a11 - a12 * a21,
          b11 = -a22 * a10 + a12 * a20,
          b21 = a21 * a10 - a11 * a20,
  
          d = a00 * b01 + a01 * b11 + a02 * b21,
          id;
  
      if (!d) { return null; }
      id = 1 / d;
  
      if (!dest) { dest = mat3.create(); }
  
      dest[0] = b01 * id;
      dest[1] = (-a22 * a01 + a02 * a21) * id;
      dest[2] = (a12 * a01 - a02 * a11) * id;
      dest[3] = b11 * id;
      dest[4] = (a22 * a00 - a02 * a20) * id;
      dest[5] = (-a12 * a00 + a02 * a10) * id;
      dest[6] = b21 * id;
      dest[7] = (-a21 * a00 + a01 * a20) * id;
      dest[8] = (a11 * a00 - a01 * a10) * id;
  
      return dest;
  };
  
  /**
   * Performs a matrix multiplication
   *
   * _param {mat4} mat First operand
   * _param {mat4} mat2 Second operand
   * _param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   */
  mat4.multiply = function (mat, mat2, dest) {
      if (!dest) { dest = mat; }
  
      // Cache the matrix values (makes for huge speed increases!)
      var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
          a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
          a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
          a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],
  
          b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3],
          b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7],
          b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11],
          b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];
  
      dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
      dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
      dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
      dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
      dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
      dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
      dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
      dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
      dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
      dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
      dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
      dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
      dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
      dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
      dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
      dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
  
      return dest;
  };
  
  /**
   * Transforms a vec3 with the given matrix
   * 4th vector component is implicitly '1'
   *
   * _param {mat4} mat mat4 to transform the vector with
   * _param {vec3} vec vec3 to transform
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec3} dest if specified, vec otherwise
   */
  mat4.multiplyVec3 = function (mat, vec, dest) {
      if (!dest) { dest = vec; }
  
      var x = vec[0], y = vec[1], z = vec[2];
  
      dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
      dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
      dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
  
      return dest;
  };
  
  /**
   * Transforms a vec4 with the given matrix
   *
   * _param {mat4} mat mat4 to transform the vector with
   * _param {vec4} vec vec4 to transform
   * _param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
   *
   * _returns {vec4} dest if specified, vec otherwise
   *
   * @param {Object=} dest
   */
  mat4.multiplyVec4 = function (mat, vec, dest) {
      if (!dest) { dest = vec; }
  
      var x = vec[0], y = vec[1], z = vec[2], w = vec[3];
  
      dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
      dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
      dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
      dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;
  
      return dest;
  };
  
  /**
   * Translates a matrix by the given vector
   *
   * _param {mat4} mat mat4 to translate
   * _param {vec3} vec vec3 specifying the translation
   * _param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   */
  mat4.translate = function (mat, vec, dest) {
      var x = vec[0], y = vec[1], z = vec[2],
          a00, a01, a02, a03,
          a10, a11, a12, a13,
          a20, a21, a22, a23;
  
      if (!dest || mat === dest) {
          mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
          mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
          mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
          mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
          return mat;
      }
  
      a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
      a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
      a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];
  
      dest[0] = a00; dest[1] = a01; dest[2] = a02; dest[3] = a03;
      dest[4] = a10; dest[5] = a11; dest[6] = a12; dest[7] = a13;
      dest[8] = a20; dest[9] = a21; dest[10] = a22; dest[11] = a23;
  
      dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
      dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
      dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
      dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
      return dest;
  };
  
  /**
   * Scales a matrix by the given vector
   *
   * _param {mat4} mat mat4 to scale
   * _param {vec3} vec vec3 specifying the scale for each axis
   * _param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   */
  mat4.scale = function (mat, vec, dest) {
      var x = vec[0], y = vec[1], z = vec[2];
  
      if (!dest || mat === dest) {
          mat[0] *= x;
          mat[1] *= x;
          mat[2] *= x;
          mat[3] *= x;
          mat[4] *= y;
          mat[5] *= y;
          mat[6] *= y;
          mat[7] *= y;
          mat[8] *= z;
          mat[9] *= z;
          mat[10] *= z;
          mat[11] *= z;
          return mat;
      }
  
      dest[0] = mat[0] * x;
      dest[1] = mat[1] * x;
      dest[2] = mat[2] * x;
      dest[3] = mat[3] * x;
      dest[4] = mat[4] * y;
      dest[5] = mat[5] * y;
      dest[6] = mat[6] * y;
      dest[7] = mat[7] * y;
      dest[8] = mat[8] * z;
      dest[9] = mat[9] * z;
      dest[10] = mat[10] * z;
      dest[11] = mat[11] * z;
      dest[12] = mat[12];
      dest[13] = mat[13];
      dest[14] = mat[14];
      dest[15] = mat[15];
      return dest;
  };
  
  /**
   * Rotates a matrix by the given angle around the specified axis
   * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
   *
   * _param {mat4} mat mat4 to rotate
   * _param {number} angle Angle (in radians) to rotate
   * _param {vec3} axis vec3 representing the axis to rotate around
   * _param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   */
  mat4.rotate = function (mat, angle, axis, dest) {
      var x = axis[0], y = axis[1], z = axis[2],
          len = Math.sqrt(x * x + y * y + z * z),
          s, c, t,
          a00, a01, a02, a03,
          a10, a11, a12, a13,
          a20, a21, a22, a23,
          b00, b01, b02,
          b10, b11, b12,
          b20, b21, b22;
  
      if (!len) { return null; }
      if (len !== 1) {
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
      }
  
      s = Math.sin(angle);
      c = Math.cos(angle);
      t = 1 - c;
  
      a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
      a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
      a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];
  
      // Construct the elements of the rotation matrix
      b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
      b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
      b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;
  
      if (!dest) {
          dest = mat;
      } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
          dest[12] = mat[12];
          dest[13] = mat[13];
          dest[14] = mat[14];
          dest[15] = mat[15];
      }
  
      // Perform rotation-specific matrix multiplication
      dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
      dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
      dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
      dest[3] = a03 * b00 + a13 * b01 + a23 * b02;
  
      dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
      dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
      dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
      dest[7] = a03 * b10 + a13 * b11 + a23 * b12;
  
      dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
      dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
      dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
      dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
      return dest;
  };
  
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * _param {mat4} mat mat4 to rotate
   * _param {number} angle Angle (in radians) to rotate
   * _param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   */
  mat4.rotateX = function (mat, angle, dest) {
      var s = Math.sin(angle),
          c = Math.cos(angle),
          a10 = mat[4],
          a11 = mat[5],
          a12 = mat[6],
          a13 = mat[7],
          a20 = mat[8],
          a21 = mat[9],
          a22 = mat[10],
          a23 = mat[11];
  
      if (!dest) {
          dest = mat;
      } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
          dest[0] = mat[0];
          dest[1] = mat[1];
          dest[2] = mat[2];
          dest[3] = mat[3];
  
          dest[12] = mat[12];
          dest[13] = mat[13];
          dest[14] = mat[14];
          dest[15] = mat[15];
      }
  
      // Perform axis-specific matrix multiplication
      dest[4] = a10 * c + a20 * s;
      dest[5] = a11 * c + a21 * s;
      dest[6] = a12 * c + a22 * s;
      dest[7] = a13 * c + a23 * s;
  
      dest[8] = a10 * -s + a20 * c;
      dest[9] = a11 * -s + a21 * c;
      dest[10] = a12 * -s + a22 * c;
      dest[11] = a13 * -s + a23 * c;
      return dest;
  };
  
  /**
   * Rotates a matrix by the given angle around the Y axis
   *
   * _param {mat4} mat mat4 to rotate
   * _param {number} angle Angle (in radians) to rotate
   * _param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   */
  mat4.rotateY = function (mat, angle, dest) {
      var s = Math.sin(angle),
          c = Math.cos(angle),
          a00 = mat[0],
          a01 = mat[1],
          a02 = mat[2],
          a03 = mat[3],
          a20 = mat[8],
          a21 = mat[9],
          a22 = mat[10],
          a23 = mat[11];
  
      if (!dest) {
          dest = mat;
      } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
          dest[4] = mat[4];
          dest[5] = mat[5];
          dest[6] = mat[6];
          dest[7] = mat[7];
  
          dest[12] = mat[12];
          dest[13] = mat[13];
          dest[14] = mat[14];
          dest[15] = mat[15];
      }
  
      // Perform axis-specific matrix multiplication
      dest[0] = a00 * c + a20 * -s;
      dest[1] = a01 * c + a21 * -s;
      dest[2] = a02 * c + a22 * -s;
      dest[3] = a03 * c + a23 * -s;
  
      dest[8] = a00 * s + a20 * c;
      dest[9] = a01 * s + a21 * c;
      dest[10] = a02 * s + a22 * c;
      dest[11] = a03 * s + a23 * c;
      return dest;
  };
  
  /**
   * Rotates a matrix by the given angle around the Z axis
   *
   * _param {mat4} mat mat4 to rotate
   * _param {number} angle Angle (in radians) to rotate
   * _param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   */
  mat4.rotateZ = function (mat, angle, dest) {
      var s = Math.sin(angle),
          c = Math.cos(angle),
          a00 = mat[0],
          a01 = mat[1],
          a02 = mat[2],
          a03 = mat[3],
          a10 = mat[4],
          a11 = mat[5],
          a12 = mat[6],
          a13 = mat[7];
  
      if (!dest) {
          dest = mat;
      } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
          dest[8] = mat[8];
          dest[9] = mat[9];
          dest[10] = mat[10];
          dest[11] = mat[11];
  
          dest[12] = mat[12];
          dest[13] = mat[13];
          dest[14] = mat[14];
          dest[15] = mat[15];
      }
  
      // Perform axis-specific matrix multiplication
      dest[0] = a00 * c + a10 * s;
      dest[1] = a01 * c + a11 * s;
      dest[2] = a02 * c + a12 * s;
      dest[3] = a03 * c + a13 * s;
  
      dest[4] = a00 * -s + a10 * c;
      dest[5] = a01 * -s + a11 * c;
      dest[6] = a02 * -s + a12 * c;
      dest[7] = a03 * -s + a13 * c;
  
      return dest;
  };
  
  /**
   * Generates a frustum matrix with the given bounds
   *
   * _param {number} left Left bound of the frustum
   * _param {number} right Right bound of the frustum
   * _param {number} bottom Bottom bound of the frustum
   * _param {number} top Top bound of the frustum
   * _param {number} near Near bound of the frustum
   * _param {number} far Far bound of the frustum
   * _param {mat4} [dest] mat4 frustum matrix will be written into
   *
   * _returns {mat4} dest if specified, a new mat4 otherwise
   */
  mat4.frustum = function (left, right, bottom, top, near, far, dest) {
      if (!dest) { dest = mat4.create(); }
      var rl = (right - left),
          tb = (top - bottom),
          fn = (far - near);
      dest[0] = (near * 2) / rl;
      dest[1] = 0;
      dest[2] = 0;
      dest[3] = 0;
      dest[4] = 0;
      dest[5] = (near * 2) / tb;
      dest[6] = 0;
      dest[7] = 0;
      dest[8] = (right + left) / rl;
      dest[9] = (top + bottom) / tb;
      dest[10] = -(far + near) / fn;
      dest[11] = -1;
      dest[12] = 0;
      dest[13] = 0;
      dest[14] = -(far * near * 2) / fn;
      dest[15] = 0;
      return dest;
  };
  
  /**
   * Generates a perspective projection matrix with the given bounds
   *
   * _param {number} fovy Vertical field of view
   * _param {number} aspect Aspect ratio. typically viewport width/height
   * _param {number} near Near bound of the frustum
   * _param {number} far Far bound of the frustum
   * _param {mat4} [dest] mat4 frustum matrix will be written into
   *
   * _returns {mat4} dest if specified, a new mat4 otherwise
   */
  mat4.perspective = function (fovy, aspect, near, far, dest) {
      var top = near * Math.tan(fovy * Math.PI / 360.0),
          right = top * aspect;
      return mat4.frustum(-right, right, -top, top, near, far, dest);
  };
  
  /**
   * Generates a orthogonal projection matrix with the given bounds
   *
   * _param {number} left Left bound of the frustum
   * _param {number} right Right bound of the frustum
   * _param {number} bottom Bottom bound of the frustum
   * _param {number} top Top bound of the frustum
   * _param {number} near Near bound of the frustum
   * _param {number} far Far bound of the frustum
   * _param {mat4} [dest] mat4 frustum matrix will be written into
   *
   * _returns {mat4} dest if specified, a new mat4 otherwise
   */
  mat4.ortho = function (left, right, bottom, top, near, far, dest) {
      if (!dest) { dest = mat4.create(); }
      var rl = (right - left),
          tb = (top - bottom),
          fn = (far - near);
      dest[0] = 2 / rl;
      dest[1] = 0;
      dest[2] = 0;
      dest[3] = 0;
      dest[4] = 0;
      dest[5] = 2 / tb;
      dest[6] = 0;
      dest[7] = 0;
      dest[8] = 0;
      dest[9] = 0;
      dest[10] = -2 / fn;
      dest[11] = 0;
      dest[12] = -(left + right) / rl;
      dest[13] = -(top + bottom) / tb;
      dest[14] = -(far + near) / fn;
      dest[15] = 1;
      return dest;
  };
  
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis
   *
   * _param {vec3} eye Position of the viewer
   * _param {vec3} center Point the viewer is looking at
   * _param {vec3} up vec3 pointing "up"
   * _param {mat4} [dest] mat4 frustum matrix will be written into
   *
   * _returns {mat4} dest if specified, a new mat4 otherwise
   */
  mat4.lookAt = function (eye, center, up, dest) {
      if (!dest) { dest = mat4.create(); }
  
      var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
          eyex = eye[0],
          eyey = eye[1],
          eyez = eye[2],
          upx = up[0],
          upy = up[1],
          upz = up[2],
          centerx = center[0],
          centery = center[1],
          centerz = center[2];
  
      if (eyex === centerx && eyey === centery && eyez === centerz) {
          return mat4.identity(dest);
      }
  
      //vec3.direction(eye, center, z);
      z0 = eyex - centerx;
      z1 = eyey - centery;
      z2 = eyez - centerz;
  
      // normalize (no check needed for 0 because of early return)
      len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
      z0 *= len;
      z1 *= len;
      z2 *= len;
  
      //vec3.normalize(vec3.cross(up, z, x));
      x0 = upy * z2 - upz * z1;
      x1 = upz * z0 - upx * z2;
      x2 = upx * z1 - upy * z0;
      len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
      if (!len) {
          x0 = 0;
          x1 = 0;
          x2 = 0;
      } else {
          len = 1 / len;
          x0 *= len;
          x1 *= len;
          x2 *= len;
      }
  
      //vec3.normalize(vec3.cross(z, x, y));
      y0 = z1 * x2 - z2 * x1;
      y1 = z2 * x0 - z0 * x2;
      y2 = z0 * x1 - z1 * x0;
  
      len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
      if (!len) {
          y0 = 0;
          y1 = 0;
          y2 = 0;
      } else {
          len = 1 / len;
          y0 *= len;
          y1 *= len;
          y2 *= len;
      }
  
      dest[0] = x0;
      dest[1] = y0;
      dest[2] = z0;
      dest[3] = 0;
      dest[4] = x1;
      dest[5] = y1;
      dest[6] = z1;
      dest[7] = 0;
      dest[8] = x2;
      dest[9] = y2;
      dest[10] = z2;
      dest[11] = 0;
      dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
      dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
      dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
      dest[15] = 1;
  
      return dest;
  };
  
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     var quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * _param {quat4} quat Rotation quaternion
   * _param {vec3} vec Translation vector
   * _param {mat4} [dest] mat4 receiving operation result. If not specified result is written to a new mat4
   *
   * _returns {mat4} dest if specified, a new mat4 otherwise
   */
  mat4.fromRotationTranslation = function (quat, vec, dest) {
      if (!dest) { dest = mat4.create(); }
  
      // Quaternion math
      var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
          x2 = x + x,
          y2 = y + y,
          z2 = z + z,
  
          xx = x * x2,
          xy = x * y2,
          xz = x * z2,
          yy = y * y2,
          yz = y * z2,
          zz = z * z2,
          wx = w * x2,
          wy = w * y2,
          wz = w * z2;
  
      dest[0] = 1 - (yy + zz);
      dest[1] = xy + wz;
      dest[2] = xz - wy;
      dest[3] = 0;
      dest[4] = xy - wz;
      dest[5] = 1 - (xx + zz);
      dest[6] = yz + wx;
      dest[7] = 0;
      dest[8] = xz + wy;
      dest[9] = yz - wx;
      dest[10] = 1 - (xx + yy);
      dest[11] = 0;
      dest[12] = vec[0];
      dest[13] = vec[1];
      dest[14] = vec[2];
      dest[15] = 1;
  
      return dest;
  };
  
  /**
   * Returns a string representation of a mat4
   *
   * _param {mat4} mat mat4 to represent as a string
   *
   * _returns {string} String representation of mat
   */
  mat4.str = function (mat) {
      return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] +
          ', ' + mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] +
          ', ' + mat[8] + ', ' + mat[9] + ', ' + mat[10] + ', ' + mat[11] +
          ', ' + mat[12] + ', ' + mat[13] + ', ' + mat[14] + ', ' + mat[15] + ']';
  };
  
  /*
   * quat4
   */
  
  /**
   * Creates a new instance of a quat4 using the default array type
   * Any javascript array containing at least 4 numeric elements can serve as a quat4
   *
   * _param {quat4} [quat] quat4 containing values to initialize with
   *
   * _returns {quat4} New quat4
   */
  quat4.create = function (quat) {
      var dest = new MatrixArray(4);
  
      if (quat) {
          dest[0] = quat[0];
          dest[1] = quat[1];
          dest[2] = quat[2];
          dest[3] = quat[3];
      }
  
      return dest;
  };
  
  /**
   * Copies the values of one quat4 to another
   *
   * _param {quat4} quat quat4 containing values to copy
   * _param {quat4} dest quat4 receiving copied values
   *
   * _returns {quat4} dest
   */
  quat4.set = function (quat, dest) {
      dest[0] = quat[0];
      dest[1] = quat[1];
      dest[2] = quat[2];
      dest[3] = quat[3];
  
      return dest;
  };
  
  /**
   * Calculates the W component of a quat4 from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   *
   * _param {quat4} quat quat4 to calculate W component of
   * _param {quat4} [dest] quat4 receiving calculated values. If not specified result is written to quat
   *
   * _returns {quat4} dest if specified, quat otherwise
   */
  quat4.calculateW = function (quat, dest) {
      var x = quat[0], y = quat[1], z = quat[2];
  
      if (!dest || quat === dest) {
          quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
          return quat;
      }
      dest[0] = x;
      dest[1] = y;
      dest[2] = z;
      dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
      return dest;
  };
  
  /**
   * Calculates the dot product of two quaternions
   *
   * _param {quat4} quat First operand
   * _param {quat4} quat2 Second operand
   *
   * @return {number} Dot product of quat and quat2
   */
  quat4.dot = function(quat, quat2){
      return quat[0]*quat2[0] + quat[1]*quat2[1] + quat[2]*quat2[2] + quat[3]*quat2[3];
  };
  
  /**
   * Calculates the inverse of a quat4
   *
   * _param {quat4} quat quat4 to calculate inverse of
   * _param {quat4} [dest] quat4 receiving inverse values. If not specified result is written to quat
   *
   * _returns {quat4} dest if specified, quat otherwise
   */
  quat4.inverse = function(quat, dest) {
      var q0 = quat[0], q1 = quat[1], q2 = quat[2], q3 = quat[3],
          dot = q0*q0 + q1*q1 + q2*q2 + q3*q3,
          invDot = dot ? 1.0/dot : 0;
  
      // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
  
      if(!dest || quat === dest) {
          quat[0] *= -invDot;
          quat[1] *= -invDot;
          quat[2] *= -invDot;
          quat[3] *= invDot;
          return quat;
      }
      dest[0] = -quat[0]*invDot;
      dest[1] = -quat[1]*invDot;
      dest[2] = -quat[2]*invDot;
      dest[3] = quat[3]*invDot;
      return dest;
  };
  
  
  /**
   * Calculates the conjugate of a quat4
   * If the quaternion is normalized, this function is faster than quat4.inverse and produces the same result.
   *
   * _param {quat4} quat quat4 to calculate conjugate of
   * _param {quat4} [dest] quat4 receiving conjugate values. If not specified result is written to quat
   *
   * _returns {quat4} dest if specified, quat otherwise
   */
  quat4.conjugate = function (quat, dest) {
      if (!dest || quat === dest) {
          quat[0] *= -1;
          quat[1] *= -1;
          quat[2] *= -1;
          return quat;
      }
      dest[0] = -quat[0];
      dest[1] = -quat[1];
      dest[2] = -quat[2];
      dest[3] = quat[3];
      return dest;
  };
  
  /**
   * Calculates the length of a quat4
   *
   * Params:
   * _param {quat4} quat quat4 to calculate length of
   *
   * _returns Length of quat
   */
  quat4.length = function (quat) {
      var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
      return Math.sqrt(x * x + y * y + z * z + w * w);
  };
  
  /**
   * Generates a unit quaternion of the same direction as the provided quat4
   * If quaternion length is 0, returns [0, 0, 0, 0]
   *
   * _param {quat4} quat quat4 to normalize
   * _param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
   *
   * _returns {quat4} dest if specified, quat otherwise
   */
  quat4.normalize = function (quat, dest) {
      if (!dest) { dest = quat; }
  
      var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
          len = Math.sqrt(x * x + y * y + z * z + w * w);
      if (len === 0) {
          dest[0] = 0;
          dest[1] = 0;
          dest[2] = 0;
          dest[3] = 0;
          return dest;
      }
      len = 1 / len;
      dest[0] = x * len;
      dest[1] = y * len;
      dest[2] = z * len;
      dest[3] = w * len;
  
      return dest;
  };
  
  /**
   * Performs quaternion addition
   *
   * _param {quat4} quat First operand
   * _param {quat4} quat2 Second operand
   * _param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
   *
   * _returns {quat4} dest if specified, quat otherwise
   */
  quat4.add = function (quat, quat2, dest) {
      if(!dest || quat === dest) {
          quat[0] += quat2[0];
          quat[1] += quat2[1];
          quat[2] += quat2[2];
          quat[3] += quat2[3];
          return quat;
      }
      dest[0] = quat[0]+quat2[0];
      dest[1] = quat[1]+quat2[1];
      dest[2] = quat[2]+quat2[2];
      dest[3] = quat[3]+quat2[3];
      return dest;
  };
  
  /**
   * Performs a quaternion multiplication
   *
   * _param {quat4} quat First operand
   * _param {quat4} quat2 Second operand
   * _param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
   *
   * _returns {quat4} dest if specified, quat otherwise
   */
  quat4.multiply = function (quat, quat2, dest) {
      if (!dest) { dest = quat; }
  
      var qax = quat[0], qay = quat[1], qaz = quat[2], qaw = quat[3],
          qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];
  
      dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
  
      return dest;
  };
  
  /**
   * Transforms a vec3 with the given quaternion
   *
   * _param {quat4} quat quat4 to transform the vector with
   * _param {vec3} vec vec3 to transform
   * _param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * _returns dest if specified, vec otherwise
   */
  quat4.multiplyVec3 = function (quat, vec, dest) {
      if (!dest) { dest = vec; }
  
      var x = vec[0], y = vec[1], z = vec[2],
          qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3],
  
          // calculate quat * vec
          ix = qw * x + qy * z - qz * y,
          iy = qw * y + qz * x - qx * z,
          iz = qw * z + qx * y - qy * x,
          iw = -qx * x - qy * y - qz * z;
  
      // calculate result * inverse quat
      dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  
      return dest;
  };
  
  /**
   * Multiplies the components of a quaternion by a scalar value
   *
   * _param {quat4} quat to scale
   * _param {number} val Value to scale by
   * _param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
   *
   * _returns {quat4} dest if specified, quat otherwise
   */
  quat4.scale = function (quat, val, dest) {
      if(!dest || quat === dest) {
          quat[0] *= val;
          quat[1] *= val;
          quat[2] *= val;
          quat[3] *= val;
          return quat;
      }
      dest[0] = quat[0]*val;
      dest[1] = quat[1]*val;
      dest[2] = quat[2]*val;
      dest[3] = quat[3]*val;
      return dest;
  };
  
  /**
   * Calculates a 3x3 matrix from the given quat4
   *
   * _param {quat4} quat quat4 to create matrix from
   * _param {mat3} [dest] mat3 receiving operation result
   *
   * _returns {mat3} dest if specified, a new mat3 otherwise
   */
  quat4.toMat3 = function (quat, dest) {
      if (!dest) { dest = mat3.create(); }
  
      var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
          x2 = x + x,
          y2 = y + y,
          z2 = z + z,
  
          xx = x * x2,
          xy = x * y2,
          xz = x * z2,
          yy = y * y2,
          yz = y * z2,
          zz = z * z2,
          wx = w * x2,
          wy = w * y2,
          wz = w * z2;
  
      dest[0] = 1 - (yy + zz);
      dest[1] = xy + wz;
      dest[2] = xz - wy;
  
      dest[3] = xy - wz;
      dest[4] = 1 - (xx + zz);
      dest[5] = yz + wx;
  
      dest[6] = xz + wy;
      dest[7] = yz - wx;
      dest[8] = 1 - (xx + yy);
  
      return dest;
  };
  
  /**
   * Calculates a 4x4 matrix from the given quat4
   *
   * _param {quat4} quat quat4 to create matrix from
   * _param {mat4} [dest] mat4 receiving operation result
   *
   * _returns {mat4} dest if specified, a new mat4 otherwise
   */
  quat4.toMat4 = function (quat, dest) {
      if (!dest) { dest = mat4.create(); }
  
      var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
          x2 = x + x,
          y2 = y + y,
          z2 = z + z,
  
          xx = x * x2,
          xy = x * y2,
          xz = x * z2,
          yy = y * y2,
          yz = y * z2,
          zz = z * z2,
          wx = w * x2,
          wy = w * y2,
          wz = w * z2;
  
      dest[0] = 1 - (yy + zz);
      dest[1] = xy + wz;
      dest[2] = xz - wy;
      dest[3] = 0;
  
      dest[4] = xy - wz;
      dest[5] = 1 - (xx + zz);
      dest[6] = yz + wx;
      dest[7] = 0;
  
      dest[8] = xz + wy;
      dest[9] = yz - wx;
      dest[10] = 1 - (xx + yy);
      dest[11] = 0;
  
      dest[12] = 0;
      dest[13] = 0;
      dest[14] = 0;
      dest[15] = 1;
  
      return dest;
  };
  
  /**
   * Performs a spherical linear interpolation between two quat4
   *
   * _param {quat4} quat First quaternion
   * _param {quat4} quat2 Second quaternion
   * _param {number} slerp Interpolation amount between the two inputs
   * _param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
   *
   * _returns {quat4} dest if specified, quat otherwise
   */
  quat4.slerp = function (quat, quat2, slerp, dest) {
      if (!dest) { dest = quat; }
  
      var cosHalfTheta = quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3],
          halfTheta,
          sinHalfTheta,
          ratioA,
          ratioB;
  
      if (Math.abs(cosHalfTheta) >= 1.0) {
          if (dest !== quat) {
              dest[0] = quat[0];
              dest[1] = quat[1];
              dest[2] = quat[2];
              dest[3] = quat[3];
          }
          return dest;
      }
  
      halfTheta = Math.acos(cosHalfTheta);
      sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
  
      if (Math.abs(sinHalfTheta) < 0.001) {
          dest[0] = (quat[0] * 0.5 + quat2[0] * 0.5);
          dest[1] = (quat[1] * 0.5 + quat2[1] * 0.5);
          dest[2] = (quat[2] * 0.5 + quat2[2] * 0.5);
          dest[3] = (quat[3] * 0.5 + quat2[3] * 0.5);
          return dest;
      }
  
      ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
      ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;
  
      dest[0] = (quat[0] * ratioA + quat2[0] * ratioB);
      dest[1] = (quat[1] * ratioA + quat2[1] * ratioB);
      dest[2] = (quat[2] * ratioA + quat2[2] * ratioB);
      dest[3] = (quat[3] * ratioA + quat2[3] * ratioB);
  
      return dest;
  };
  
  /**
   * Returns a string representation of a quaternion
   *
   * _param {quat4} quat quat4 to represent as a string
   *
   * _returns {string} String representation of quat
   */
  quat4.str = function (quat) {
      return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']';
  };
  
  
  return {
    vec3: vec3,
    mat3: mat3,
    mat4: mat4,
    quat4: quat4
  };
  
  })();
  
  ;
  
  var GLImmediateSetup = {
  };
  var _glBegin = (mode) => {
      // Push the old state:
      GLImmediate.enabledClientAttributes_preBegin = GLImmediate.enabledClientAttributes;
      GLImmediate.enabledClientAttributes = [];
  
      GLImmediate.clientAttributes_preBegin = GLImmediate.clientAttributes;
      GLImmediate.clientAttributes = []
      for (var i = 0; i < GLImmediate.clientAttributes_preBegin.length; i++) {
        GLImmediate.clientAttributes.push({});
      }
  
      GLImmediate.mode = mode;
      GLImmediate.vertexCounter = 0;
      var components = GLImmediate.rendererComponents = [];
      for (var i = 0; i < GLImmediate.NUM_ATTRIBUTES; i++) {
        components[i] = 0;
      }
      GLImmediate.rendererComponentPointer = 0;
      GLImmediate.vertexData = GLImmediate.tempData;
    };

  var _glBindTexture = (target, texture) => {
      GLctx.bindTexture(target, GL.textures[texture]);
    };

  function _glClear(x0) { GLctx.clear(x0) }

  var _glColor4f = (r, g, b, a) => {
      r = Math.max(Math.min(r, 1), 0);
      g = Math.max(Math.min(g, 1), 0);
      b = Math.max(Math.min(b, 1), 0);
      a = Math.max(Math.min(a, 1), 0);
  
      // TODO: make ub the default, not f, save a few mathops
      if (GLImmediate.mode >= 0) {
        var start = GLImmediate.vertexCounter << 2;
        GLImmediate.vertexDataU8[start + 0] = r * 255;
        GLImmediate.vertexDataU8[start + 1] = g * 255;
        GLImmediate.vertexDataU8[start + 2] = b * 255;
        GLImmediate.vertexDataU8[start + 3] = a * 255;
        GLImmediate.vertexCounter++;
        GLImmediate.addRendererComponent(GLImmediate.COLOR, 4, GLctx.UNSIGNED_BYTE);
      } else {
        GLImmediate.clientColor[0] = r;
        GLImmediate.clientColor[1] = g;
        GLImmediate.clientColor[2] = b;
        GLImmediate.clientColor[3] = a;
      }
    };
  var _glColor3f = (r, g, b) => {
      _glColor4f(r, g, b, 1);
    };

  var _glDeleteTextures = (n, textures) => {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((textures)+(i*4))>>2)];
        var texture = GL.textures[id];
        // GL spec: "glDeleteTextures silently ignores 0s and names that do not
        // correspond to existing textures".
        if (!texture) continue;
        GLctx.deleteTexture(texture);
        texture.name = 0;
        GL.textures[id] = null;
      }
    };


  var _glEnd = () => {
      GLImmediate.prepareClientAttributes(GLImmediate.rendererComponents[GLImmediate.VERTEX], true);
      GLImmediate.firstVertex = 0;
      GLImmediate.lastVertex = GLImmediate.vertexCounter / (GLImmediate.stride >> 2);
      GLImmediate.flush();
      GLImmediate.disableBeginEndClientAttributes();
      GLImmediate.mode = -1;
  
      // Pop the old state:
      GLImmediate.enabledClientAttributes = GLImmediate.enabledClientAttributes_preBegin;
      GLImmediate.clientAttributes = GLImmediate.clientAttributes_preBegin;
      GLImmediate.currentRenderer = null; // The set of active client attributes changed, we must re-lookup the renderer to use.
      GLImmediate.modifiedClientAttributes = true;
    };

  var __glGenObject = (n, buffers, createFunction, objectTable
      ) => {
      for (var i = 0; i < n; i++) {
        var buffer = GLctx[createFunction]();
        var id = buffer && GL.getNewId(objectTable);
        if (buffer) {
          buffer.name = id;
          objectTable[id] = buffer;
        } else {
          GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        }
        HEAP32[(((buffers)+(i*4))>>2)] = id;
      }
    };
  
  var _glGenTextures = (n, textures) => {
      __glGenObject(n, textures, 'createTexture', GL.textures
        );
    };

  /** @suppress {duplicate } */
  var _glTexCoord2i = (u, v) => {
      assert(GLImmediate.mode >= 0); // must be in begin/end
      GLImmediate.vertexData[GLImmediate.vertexCounter++] = u;
      GLImmediate.vertexData[GLImmediate.vertexCounter++] = v;
      GLImmediate.addRendererComponent(GLImmediate.TEXTURE0, 2, GLctx.FLOAT);
    };
  var _glTexCoord2f = _glTexCoord2i;

  var computeUnpackAlignedImageSize = (width, height, sizePerPixel, alignment) => {
      function roundedToNextMultipleOf(x, y) {
        return (x + y - 1) & -y;
      }
      var plainRowSize = width * sizePerPixel;
      var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
      return height * alignedRowSize;
    };
  
  var colorChannelsInGlTextureFormat = (format) => {
      // Micro-optimizations for size: map format to size by subtracting smallest
      // enum value (0x1902) from all values first.  Also omit the most common
      // size value (1) from the list, which is assumed by formats not on the
      // list.
      var colorChannels = {
        // 0x1902 /* GL_DEPTH_COMPONENT */ - 0x1902: 1,
        // 0x1906 /* GL_ALPHA */ - 0x1902: 1,
        5: 3,
        6: 4,
        // 0x1909 /* GL_LUMINANCE */ - 0x1902: 1,
        8: 2,
        29502: 3,
        29504: 4,
      };
      return colorChannels[format - 0x1902]||1;
    };
  
  var heapObjectForWebGLType = (type) => {
      // Micro-optimization for size: Subtract lowest GL enum number (0x1400/* GL_BYTE */) from type to compare
      // smaller values for the heap, for shorter generated code size.
      // Also the type HEAPU16 is not tested for explicitly, but any unrecognized type will return out HEAPU16.
      // (since most types are HEAPU16)
      type -= 0x1400;
  
      if (type == 1) return HEAPU8;
  
      if (type == 4) return HEAP32;
  
      if (type == 6) return HEAPF32;
  
      if (type == 5
        || type == 28922
        )
        return HEAPU32;
  
      return HEAPU16;
    };
  
  var heapAccessShiftForWebGLHeap = (heap) => 31 - Math.clz32(heap.BYTES_PER_ELEMENT);
  
  var emscriptenWebGLGetTexPixelData = (type, format, width, height, pixels, internalFormat) => {
      var heap = heapObjectForWebGLType(type);
      var shift = heapAccessShiftForWebGLHeap(heap);
      var byteSize = 1<<shift;
      var sizePerPixel = colorChannelsInGlTextureFormat(format) * byteSize;
      var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
      return heap.subarray(pixels >> shift, pixels + bytes >> shift);
    };
  
  var _glTexImage2D = (target, level, internalFormat, width, height, border, format, type, pixels) => {
      GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
    };

  function _glTexParameteri(x0, x1, x2) { GLctx.texParameteri(x0, x1, x2) }

  var _glVertex2f = (x, y) => {
      assert(GLImmediate.mode >= 0); // must be in begin/end
      GLImmediate.vertexData[GLImmediate.vertexCounter++] = x;
      GLImmediate.vertexData[GLImmediate.vertexCounter++] = y;
      GLImmediate.vertexData[GLImmediate.vertexCounter++] = 0;
      GLImmediate.vertexData[GLImmediate.vertexCounter++] = 1;
      assert(GLImmediate.vertexCounter << 2 < GL.MAX_TEMP_BUFFER_SIZE);
      GLImmediate.addRendererComponent(GLImmediate.VERTEX, 4, GLctx.FLOAT);
    };

  function _glViewport(x0, x1, x2, x3) { GLctx.viewport(x0, x1, x2, x3) }




  var runAndAbortIfError = (func) => {
      try {
        return func();
      } catch (e) {
        abort(e);
      }
    };
  
  
  var sigToWasmTypes = (sig) => {
      assert(!sig.includes('j'), 'i64 not permitted in function signatures when WASM_BIGINT is disabled');
      var typeNames = {
        'i': 'i32',
        'j': 'i64',
        'f': 'f32',
        'd': 'f64',
        'e': 'externref',
        'p': 'i32',
      };
      var type = {
        parameters: [],
        results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
      };
      for (var i = 1; i < sig.length; ++i) {
        assert(sig[i] in typeNames, 'invalid signature char: ' + sig[i]);
        type.parameters.push(typeNames[sig[i]]);
      }
      return type;
    };
  
  var runtimeKeepalivePush = () => {
      runtimeKeepaliveCounter += 1;
    };
  
  var runtimeKeepalivePop = () => {
      assert(runtimeKeepaliveCounter > 0);
      runtimeKeepaliveCounter -= 1;
    };
  
  
  var Asyncify = {
  instrumentWasmImports(imports) {
        var importPattern = /^(invoke_.*|__asyncjs__.*)$/;
  
        for (let [x, original] of Object.entries(imports)) {
          let sig = original.sig;
          if (typeof original == 'function') {
            let isAsyncifyImport = original.isAsync || importPattern.test(x);
            imports[x] = function() {
              var originalAsyncifyState = Asyncify.state;
              try {
                return original.apply(null, arguments);
              } finally {
                // Only asyncify-declared imports are allowed to change the
                // state.
                // Changing the state from normal to disabled is allowed (in any
                // function) as that is what shutdown does (and we don't have an
                // explicit list of shutdown imports).
                var changedToDisabled =
                      originalAsyncifyState === Asyncify.State.Normal &&
                      Asyncify.state        === Asyncify.State.Disabled;
                // invoke_* functions are allowed to change the state if we do
                // not ignore indirect calls.
                var ignoredInvoke = x.startsWith('invoke_') &&
                                    true;
                if (Asyncify.state !== originalAsyncifyState &&
                    !isAsyncifyImport &&
                    !changedToDisabled &&
                    !ignoredInvoke) {
                  throw new Error(`import ${x} was not in ASYNCIFY_IMPORTS, but changed the state`);
                }
              }
            };
          }
        }
      },
  instrumentWasmExports(exports) {
        var ret = {};
        for (let [x, original] of Object.entries(exports)) {
          if (typeof original == 'function') {
            ret[x] = function() {
              Asyncify.exportCallStack.push(x);
              try {
                return original.apply(null, arguments);
              } finally {
                if (!ABORT) {
                  var y = Asyncify.exportCallStack.pop();
                  assert(y === x);
                  Asyncify.maybeStopUnwind();
                }
              }
            };
          } else {
            ret[x] = original;
          }
        }
        return ret;
      },
  State:{
  Normal:0,
  Unwinding:1,
  Rewinding:2,
  Disabled:3,
  },
  state:0,
  StackSize:4096,
  currData:null,
  handleSleepReturnValue:0,
  exportCallStack:[],
  callStackNameToId:{
  },
  callStackIdToName:{
  },
  callStackId:0,
  asyncPromiseHandlers:null,
  sleepCallbacks:[],
  getCallStackId(funcName) {
        var id = Asyncify.callStackNameToId[funcName];
        if (id === undefined) {
          id = Asyncify.callStackId++;
          Asyncify.callStackNameToId[funcName] = id;
          Asyncify.callStackIdToName[id] = funcName;
        }
        return id;
      },
  maybeStopUnwind() {
        if (Asyncify.currData &&
            Asyncify.state === Asyncify.State.Unwinding &&
            Asyncify.exportCallStack.length === 0) {
          // We just finished unwinding.
          // Be sure to set the state before calling any other functions to avoid
          // possible infinite recursion here (For example in debug pthread builds
          // the dbg() function itself can call back into WebAssembly to get the
          // current pthread_self() pointer).
          Asyncify.state = Asyncify.State.Normal;
          
          // Keep the runtime alive so that a re-wind can be done later.
          runAndAbortIfError(_asyncify_stop_unwind);
          if (typeof Fibers != 'undefined') {
            Fibers.trampoline();
          }
        }
      },
  whenDone() {
        assert(Asyncify.currData, 'Tried to wait for an async operation when none is in progress.');
        assert(!Asyncify.asyncPromiseHandlers, 'Cannot have multiple async operations in flight at once');
        return new Promise((resolve, reject) => {
          Asyncify.asyncPromiseHandlers = { resolve, reject };
        });
      },
  allocateData() {
        // An asyncify data structure has three fields:
        //  0  current stack pos
        //  4  max stack pos
        //  8  id of function at bottom of the call stack (callStackIdToName[id] == name of js function)
        //
        // The Asyncify ABI only interprets the first two fields, the rest is for the runtime.
        // We also embed a stack in the same memory region here, right next to the structure.
        // This struct is also defined as asyncify_data_t in emscripten/fiber.h
        var ptr = _malloc(12 + Asyncify.StackSize);
        Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
        Asyncify.setDataRewindFunc(ptr);
        return ptr;
      },
  setDataHeader(ptr, stack, stackSize) {
        HEAPU32[((ptr)>>2)] = stack;
        HEAPU32[(((ptr)+(4))>>2)] = stack + stackSize;
      },
  setDataRewindFunc(ptr) {
        var bottomOfCallStack = Asyncify.exportCallStack[0];
        var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
        HEAP32[(((ptr)+(8))>>2)] = rewindId;
      },
  getDataRewindFunc(ptr) {
        var id = HEAP32[(((ptr)+(8))>>2)];
        var name = Asyncify.callStackIdToName[id];
        var func = wasmExports[name];
        return func;
      },
  doRewind(ptr) {
        var start = Asyncify.getDataRewindFunc(ptr);
        // Once we have rewound and the stack we no longer need to artificially
        // keep the runtime alive.
        
        return start();
      },
  handleSleep(startAsync) {
        assert(Asyncify.state !== Asyncify.State.Disabled, 'Asyncify cannot be done during or after the runtime exits');
        if (ABORT) return;
        if (Asyncify.state === Asyncify.State.Normal) {
          // Prepare to sleep. Call startAsync, and see what happens:
          // if the code decided to call our callback synchronously,
          // then no async operation was in fact begun, and we don't
          // need to do anything.
          var reachedCallback = false;
          var reachedAfterCallback = false;
          startAsync((handleSleepReturnValue = 0) => {
            assert(!handleSleepReturnValue || typeof handleSleepReturnValue == 'number' || typeof handleSleepReturnValue == 'boolean'); // old emterpretify API supported other stuff
            if (ABORT) return;
            Asyncify.handleSleepReturnValue = handleSleepReturnValue;
            reachedCallback = true;
            if (!reachedAfterCallback) {
              // We are happening synchronously, so no need for async.
              return;
            }
            // This async operation did not happen synchronously, so we did
            // unwind. In that case there can be no compiled code on the stack,
            // as it might break later operations (we can rewind ok now, but if
            // we unwind again, we would unwind through the extra compiled code
            // too).
            assert(!Asyncify.exportCallStack.length, 'Waking up (starting to rewind) must be done from JS, without compiled code on the stack.');
            Asyncify.state = Asyncify.State.Rewinding;
            runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
            if (typeof Browser != 'undefined' && Browser.mainLoop.func) {
              Browser.mainLoop.resume();
            }
            var asyncWasmReturnValue, isError = false;
            try {
              asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
            } catch (err) {
              asyncWasmReturnValue = err;
              isError = true;
            }
            // Track whether the return value was handled by any promise handlers.
            var handled = false;
            if (!Asyncify.currData) {
              // All asynchronous execution has finished.
              // `asyncWasmReturnValue` now contains the final
              // return value of the exported async WASM function.
              //
              // Note: `asyncWasmReturnValue` is distinct from
              // `Asyncify.handleSleepReturnValue`.
              // `Asyncify.handleSleepReturnValue` contains the return
              // value of the last C function to have executed
              // `Asyncify.handleSleep()`, where as `asyncWasmReturnValue`
              // contains the return value of the exported WASM function
              // that may have called C functions that
              // call `Asyncify.handleSleep()`.
              var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
              if (asyncPromiseHandlers) {
                Asyncify.asyncPromiseHandlers = null;
                (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
                handled = true;
              }
            }
            if (isError && !handled) {
              // If there was an error and it was not handled by now, we have no choice but to
              // rethrow that error into the global scope where it can be caught only by
              // `onerror` or `onunhandledpromiserejection`.
              throw asyncWasmReturnValue;
            }
          });
          reachedAfterCallback = true;
          if (!reachedCallback) {
            // A true async operation was begun; start a sleep.
            Asyncify.state = Asyncify.State.Unwinding;
            // TODO: reuse, don't alloc/free every sleep
            Asyncify.currData = Asyncify.allocateData();
            if (typeof Browser != 'undefined' && Browser.mainLoop.func) {
              Browser.mainLoop.pause();
            }
            runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
          }
        } else if (Asyncify.state === Asyncify.State.Rewinding) {
          // Stop a resume.
          Asyncify.state = Asyncify.State.Normal;
          runAndAbortIfError(_asyncify_stop_rewind);
          _free(Asyncify.currData);
          Asyncify.currData = null;
          // Call all sleep callbacks now that the sleep-resume is all done.
          Asyncify.sleepCallbacks.forEach(callUserCallback);
        } else {
          abort(`invalid state: ${Asyncify.state}`);
        }
        return Asyncify.handleSleepReturnValue;
      },
  handleAsync(startAsync) {
        return Asyncify.handleSleep((wakeUp) => {
          // TODO: add error handling as a second param when handleSleep implements it.
          startAsync().then(wakeUp);
        });
      },
  };





  var FS_unlink = (path) => FS.unlink(path);

  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_unlink"] = FS.unlink;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createDevice"] = FS.createDevice;;

      // exports
      Module["requestFullscreen"] = Browser.requestFullscreen;
      Module["requestFullScreen"] = Browser.requestFullScreen;
      Module["requestAnimationFrame"] = Browser.requestAnimationFrame;
      Module["setCanvasSize"] = Browser.setCanvasSize;
      Module["pauseMainLoop"] = Browser.mainLoop.pause;
      Module["resumeMainLoop"] = Browser.mainLoop.resume;
      Module["getUserMedia"] = Browser.getUserMedia;
      Module["createContext"] = Browser.createContext;
      var preloadedImages = {};
      var preloadedAudios = {};;
var GLctx;;
GLImmediate.setupFuncs(); Browser.moduleContextCreatedCallbacks.push(() => GLImmediate.init());;
/**@suppress {duplicate, undefinedVars}*/var _emscripten_glDrawArrays;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glDrawElements;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glActiveTexture;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glEnable;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glDisable;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glTexEnvf;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glTexEnvi;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glTexEnvfv;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glGetIntegerv;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glIsEnabled;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glGetBooleanv;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glGetString;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glCreateShader;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glShaderSource;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glCompileShader;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glAttachShader;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glDetachShader;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glUseProgram;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glDeleteProgram;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glBindAttribLocation;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glLinkProgram;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glBindBuffer;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glGetFloatv;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glHint;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glEnableVertexAttribArray;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glDisableVertexAttribArray;/**@suppress {duplicate, undefinedVars}*/var _emscripten_glVertexAttribPointer;/**@suppress {duplicate, undefinedVars}*/var _glTexEnvf;/**@suppress {duplicate, undefinedVars}*/var _glTexEnvi;/**@suppress {duplicate, undefinedVars}*/var _glTexEnvfv;/**@suppress {duplicate, undefinedVars}*/var _glGetTexEnviv;/**@suppress {duplicate, undefinedVars}*/var _glGetTexEnvfv;GLEmulation.init();;
function checkIncomingModuleAPI() {
  ignoredModuleProp('fetchSettings');
}
var wasmImports = {
  /** @export */
  __syscall_fcntl64: ___syscall_fcntl64,
  /** @export */
  __syscall_ioctl: ___syscall_ioctl,
  /** @export */
  __syscall_mkdirat: ___syscall_mkdirat,
  /** @export */
  __syscall_openat: ___syscall_openat,
  /** @export */
  emscripten_asm_const_int: _emscripten_asm_const_int,
  /** @export */
  emscripten_get_gamepad_status: _emscripten_get_gamepad_status,
  /** @export */
  emscripten_get_num_gamepads: _emscripten_get_num_gamepads,
  /** @export */
  emscripten_memcpy_js: _emscripten_memcpy_js,
  /** @export */
  emscripten_resize_heap: _emscripten_resize_heap,
  /** @export */
  emscripten_set_canvas_element_size: _emscripten_set_canvas_element_size,
  /** @export */
  emscripten_set_focusin_callback_on_thread: _emscripten_set_focusin_callback_on_thread,
  /** @export */
  emscripten_set_focusout_callback_on_thread: _emscripten_set_focusout_callback_on_thread,
  /** @export */
  emscripten_set_fullscreenchange_callback_on_thread: _emscripten_set_fullscreenchange_callback_on_thread,
  /** @export */
  emscripten_set_gamepadconnected_callback_on_thread: _emscripten_set_gamepadconnected_callback_on_thread,
  /** @export */
  emscripten_set_gamepaddisconnected_callback_on_thread: _emscripten_set_gamepaddisconnected_callback_on_thread,
  /** @export */
  emscripten_set_keydown_callback_on_thread: _emscripten_set_keydown_callback_on_thread,
  /** @export */
  emscripten_set_keyup_callback_on_thread: _emscripten_set_keyup_callback_on_thread,
  /** @export */
  emscripten_set_mousedown_callback_on_thread: _emscripten_set_mousedown_callback_on_thread,
  /** @export */
  emscripten_set_mousemove_callback_on_thread: _emscripten_set_mousemove_callback_on_thread,
  /** @export */
  emscripten_set_mouseup_callback_on_thread: _emscripten_set_mouseup_callback_on_thread,
  /** @export */
  emscripten_set_resize_callback_on_thread: _emscripten_set_resize_callback_on_thread,
  /** @export */
  emscripten_set_touchcancel_callback_on_thread: _emscripten_set_touchcancel_callback_on_thread,
  /** @export */
  emscripten_set_touchend_callback_on_thread: _emscripten_set_touchend_callback_on_thread,
  /** @export */
  emscripten_set_touchmove_callback_on_thread: _emscripten_set_touchmove_callback_on_thread,
  /** @export */
  emscripten_set_touchstart_callback_on_thread: _emscripten_set_touchstart_callback_on_thread,
  /** @export */
  emscripten_set_wheel_callback_on_thread: _emscripten_set_wheel_callback_on_thread,
  /** @export */
  emscripten_set_window_title: _emscripten_set_window_title,
  /** @export */
  emscripten_sleep: _emscripten_sleep,
  /** @export */
  emscripten_webgl_commit_frame: _emscripten_webgl_commit_frame,
  /** @export */
  emscripten_webgl_create_context: _emscripten_webgl_create_context,
  /** @export */
  emscripten_webgl_destroy_context: _emscripten_webgl_destroy_context,
  /** @export */
  emscripten_webgl_init_context_attributes: _emscripten_webgl_init_context_attributes,
  /** @export */
  emscripten_webgl_make_context_current: _emscripten_webgl_make_context_current,
  /** @export */
  fd_close: _fd_close,
  /** @export */
  fd_read: _fd_read,
  /** @export */
  fd_seek: _fd_seek,
  /** @export */
  fd_write: _fd_write,
  /** @export */
  glBegin: _glBegin,
  /** @export */
  glBindTexture: _glBindTexture,
  /** @export */
  glClear: _glClear,
  /** @export */
  glColor3f: _glColor3f,
  /** @export */
  glDeleteTextures: _glDeleteTextures,
  /** @export */
  glEnable: _glEnable,
  /** @export */
  glEnd: _glEnd,
  /** @export */
  glGenTextures: _glGenTextures,
  /** @export */
  glTexCoord2f: _glTexCoord2f,
  /** @export */
  glTexImage2D: _glTexImage2D,
  /** @export */
  glTexParameteri: _glTexParameteri,
  /** @export */
  glVertex2f: _glVertex2f,
  /** @export */
  glViewport: _glViewport
};
Asyncify.instrumentWasmImports(wasmImports);
var wasmExports = createWasm();
var ___wasm_call_ctors = createExportWrapper('__wasm_call_ctors');
var _Emscripten_onDrop = Module['_Emscripten_onDrop'] = createExportWrapper('Emscripten_onDrop');
var _RGFW_makeSetValue = Module['_RGFW_makeSetValue'] = createExportWrapper('RGFW_makeSetValue');
var _RGFW_mkdir = Module['_RGFW_mkdir'] = createExportWrapper('RGFW_mkdir');
var _RGFW_writeFile = Module['_RGFW_writeFile'] = createExportWrapper('RGFW_writeFile');
var _malloc = createExportWrapper('malloc');
var _free = createExportWrapper('free');
var _main = Module['_main'] = createExportWrapper('main');
var _fflush = createExportWrapper('fflush');
var _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports['emscripten_stack_init'])();
var _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'])();
var _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'])();
var _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'])();
var stackSave = createExportWrapper('stackSave');
var stackRestore = createExportWrapper('stackRestore');
var stackAlloc = createExportWrapper('stackAlloc');
var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();
var dynCall_iiii = Module['dynCall_iiii'] = createExportWrapper('dynCall_iiii');
var dynCall_vii = Module['dynCall_vii'] = createExportWrapper('dynCall_vii');
var dynCall_viii = Module['dynCall_viii'] = createExportWrapper('dynCall_viii');
var dynCall_viiiii = Module['dynCall_viiiii'] = createExportWrapper('dynCall_viiiii');
var dynCall_viidi = Module['dynCall_viidi'] = createExportWrapper('dynCall_viidi');
var dynCall_jiji = Module['dynCall_jiji'] = createExportWrapper('dynCall_jiji');
var dynCall_ii = Module['dynCall_ii'] = createExportWrapper('dynCall_ii');
var _asyncify_start_unwind = createExportWrapper('asyncify_start_unwind');
var _asyncify_stop_unwind = createExportWrapper('asyncify_stop_unwind');
var _asyncify_start_rewind = createExportWrapper('asyncify_start_rewind');
var _asyncify_stop_rewind = createExportWrapper('asyncify_stop_rewind');


// include: postamble.js
// === Auto-generated postamble setup entry stuff ===

Module['addRunDependency'] = addRunDependency;
Module['removeRunDependency'] = removeRunDependency;
Module['FS_createPath'] = FS.createPath;
Module['FS_createLazyFile'] = FS.createLazyFile;
Module['FS_createDevice'] = FS.createDevice;
Module['stringToNewUTF8'] = stringToNewUTF8;
Module['FS_createPreloadedFile'] = FS.createPreloadedFile;
Module['FS_createDataFile'] = FS.createDataFile;
Module['FS_unlink'] = FS.unlink;
var missingLibrarySymbols = [
  'writeI53ToI64Clamped',
  'writeI53ToI64Signaling',
  'writeI53ToU64Clamped',
  'writeI53ToU64Signaling',
  'convertI32PairToI53',
  'convertU32PairToI53',
  'growMemory',
  'isLeapYear',
  'ydayFromDate',
  'arraySum',
  'addDays',
  'inetPton4',
  'inetNtop4',
  'inetPton6',
  'inetNtop6',
  'readSockaddr',
  'writeSockaddr',
  'getCallstack',
  'emscriptenLog',
  'convertPCtoSourceLocation',
  'runMainThreadEmAsm',
  'jstoi_q',
  'getExecutableName',
  'listenOnce',
  'autoResumeAudioContext',
  'dynCallLegacy',
  'getDynCaller',
  'dynCall',
  'asmjsMangle',
  'HandleAllocator',
  'getNativeTypeSize',
  'STACK_SIZE',
  'STACK_ALIGN',
  'POINTER_SIZE',
  'ASSERTIONS',
  'getCFunc',
  'ccall',
  'cwrap',
  'uleb128Encode',
  'generateFuncType',
  'convertJsFunctionToWasm',
  'getEmptyTableSlot',
  'updateTableMap',
  'getFunctionAddress',
  'addFunction',
  'removeFunction',
  'reallyNegative',
  'unSign',
  'strLen',
  'reSign',
  'formatString',
  'intArrayToString',
  'AsciiToString',
  'stringToAscii',
  'UTF16ToString',
  'stringToUTF16',
  'lengthBytesUTF16',
  'UTF32ToString',
  'stringToUTF32',
  'lengthBytesUTF32',
  'stringToUTF8OnStack',
  'writeArrayToMemory',
  'fillDeviceOrientationEventData',
  'registerDeviceOrientationEventCallback',
  'fillDeviceMotionEventData',
  'registerDeviceMotionEventCallback',
  'screenOrientation',
  'fillOrientationChangeEventData',
  'registerOrientationChangeEventCallback',
  'JSEvents_requestFullscreen',
  'JSEvents_resizeCanvasForFullscreen',
  'registerRestoreOldStyle',
  'hideEverythingExceptGivenElement',
  'restoreHiddenElements',
  'setLetterbox',
  'softFullscreenResizeWebGLRenderTarget',
  'doRequestFullscreen',
  'fillPointerlockChangeEventData',
  'registerPointerlockChangeEventCallback',
  'registerPointerlockErrorEventCallback',
  'requestPointerLock',
  'fillVisibilityChangeEventData',
  'registerVisibilityChangeEventCallback',
  'registerBeforeUnloadEventCallback',
  'fillBatteryEventData',
  'battery',
  'registerBatteryEventCallback',
  'setCanvasElementSize',
  'getCanvasElementSize',
  'jsStackTrace',
  'stackTrace',
  'getEnvStrings',
  'checkWasiClock',
  'wasiRightsToMuslOFlags',
  'wasiOFlagsToMuslOFlags',
  'createDyncallWrapper',
  'setImmediateWrapped',
  'clearImmediateWrapped',
  'polyfillSetImmediate',
  'getPromise',
  'makePromise',
  'idsToPromises',
  'makePromiseCallback',
  'ExceptionInfo',
  'findMatchingCatch',
  'Browser_asyncPrepareDataCounter',
  'getSocketFromFD',
  'getSocketAddress',
  'FS_mkdirTree',
  '_setNetworkCallback',
  'emscriptenWebGLGetUniform',
  'webglGetUniformLocation',
  'webglPrepareUniformLocationsBeforeFirstUse',
  'webglGetLeftBracePos',
  'emscriptenWebGLGetVertexAttrib',
  '__glGetActiveAttribOrUniform',
  'writeGLArray',
  'registerWebGlEventCallback',
  'SDL_unicode',
  'SDL_ttfContext',
  'SDL_audio',
  'emulGlGenVertexArrays',
  'emulGlDeleteVertexArrays',
  'emulGlIsVertexArray',
  'emulGlBindVertexArray',
  'ALLOC_NORMAL',
  'ALLOC_STACK',
  'allocate',
  'writeStringToMemory',
  'writeAsciiToMemory',
  'setErrNo',
];
missingLibrarySymbols.forEach(missingLibrarySymbol)

var unexportedSymbols = [
  'run',
  'addOnPreRun',
  'addOnInit',
  'addOnPreMain',
  'addOnExit',
  'addOnPostRun',
  'FS_createFolder',
  'FS_createLink',
  'FS_readFile',
  'out',
  'err',
  'callMain',
  'abort',
  'wasmMemory',
  'wasmExports',
  'stackAlloc',
  'stackSave',
  'stackRestore',
  'getTempRet0',
  'setTempRet0',
  'writeStackCookie',
  'checkStackCookie',
  'writeI53ToI64',
  'readI53FromI64',
  'readI53FromU64',
  'convertI32PairToI53Checked',
  'ptrToString',
  'zeroMemory',
  'exitJS',
  'getHeapMax',
  'abortOnCannotGrowMemory',
  'ENV',
  'MONTH_DAYS_REGULAR',
  'MONTH_DAYS_LEAP',
  'MONTH_DAYS_REGULAR_CUMULATIVE',
  'MONTH_DAYS_LEAP_CUMULATIVE',
  'ERRNO_CODES',
  'ERRNO_MESSAGES',
  'DNS',
  'Protocols',
  'Sockets',
  'initRandomFill',
  'randomFill',
  'timers',
  'warnOnce',
  'UNWIND_CACHE',
  'readEmAsmArgsArray',
  'readEmAsmArgs',
  'runEmAsmFunction',
  'jstoi_s',
  'handleException',
  'keepRuntimeAlive',
  'runtimeKeepalivePush',
  'runtimeKeepalivePop',
  'callUserCallback',
  'maybeExit',
  'asyncLoad',
  'alignMemory',
  'mmapAlloc',
  'wasmTable',
  'noExitRuntime',
  'sigToWasmTypes',
  'freeTableIndexes',
  'functionsInTableMap',
  'setValue',
  'getValue',
  'PATH',
  'PATH_FS',
  'UTF8Decoder',
  'UTF8ArrayToString',
  'UTF8ToString',
  'stringToUTF8Array',
  'stringToUTF8',
  'lengthBytesUTF8',
  'intArrayFromString',
  'UTF16Decoder',
  'JSEvents',
  'registerKeyEventCallback',
  'specialHTMLTargets',
  'maybeCStringToJsString',
  'findEventTarget',
  'findCanvasEventTarget',
  'getBoundingClientRect',
  'fillMouseEventData',
  'registerMouseEventCallback',
  'registerWheelEventCallback',
  'registerUiEventCallback',
  'registerFocusEventCallback',
  'fillFullscreenChangeEventData',
  'registerFullscreenChangeEventCallback',
  'currentFullscreenStrategy',
  'restoreOldWindowedStyle',
  'registerTouchEventCallback',
  'fillGamepadEventData',
  'registerGamepadEventCallback',
  'demangle',
  'demangleAll',
  'ExitStatus',
  'doReadv',
  'doWritev',
  'safeSetTimeout',
  'promiseMap',
  'uncaughtExceptionCount',
  'exceptionLast',
  'exceptionCaught',
  'Browser',
  'setMainLoop',
  'wget',
  'SYSCALLS',
  'preloadPlugins',
  'FS_modeStringToFlags',
  'FS_getMode',
  'FS_stdin_getChar_buffer',
  'FS_stdin_getChar',
  'FS',
  'MEMFS',
  'TTY',
  'PIPEFS',
  'SOCKFS',
  'tempFixedLengthArray',
  'miniTempWebGLFloatBuffers',
  'miniTempWebGLIntBuffers',
  'heapObjectForWebGLType',
  'heapAccessShiftForWebGLHeap',
  'webgl_enable_ANGLE_instanced_arrays',
  'webgl_enable_OES_vertex_array_object',
  'webgl_enable_WEBGL_draw_buffers',
  'webgl_enable_WEBGL_multi_draw',
  'GL',
  'emscriptenWebGLGet',
  'computeUnpackAlignedImageSize',
  'colorChannelsInGlTextureFormat',
  'emscriptenWebGLGetTexPixelData',
  '__glGenObject',
  'emscripten_webgl_power_preferences',
  'AL',
  'GLUT',
  'EGL',
  'GLEW',
  'IDBStore',
  'runAndAbortIfError',
  'Asyncify',
  'Fibers',
  'SDL',
  'SDL_gfx',
  'GLEmulation',
  'GLImmediate',
  'GLImmediateSetup',
  'allocateUTF8',
  'allocateUTF8OnStack',
];
unexportedSymbols.forEach(unexportedRuntimeSymbol);



var calledRun;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain() {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  var entryFunction = _main;

  var argc = 0;
  var argv = 0;

  try {

    var ret = entryFunction(argc, argv);

    // if we're not running an evented main loop, it's time to exit
    exitJS(ret, /* implicit = */ true);
    return ret;
  }
  catch (e) {
    return handleException(e);
  }
}

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  _emscripten_stack_init();
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  writeStackCookie();
}

function run() {

  if (runDependencies > 0) {
    return;
  }

    stackCheckInit();

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (shouldRunNow) callMain();

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  }
  try { // it doesn't matter if it fails
    _fflush(0);
    // also flush in the JS FS layer
    ['stdout', 'stderr'].forEach(function(name) {
      var info = FS.analyzePath('/dev/' + name);
      if (!info) return;
      var stream = info.object;
      var rdev = stream.rdev;
      var tty = TTY.ttys[rdev];
      if (tty?.output?.length) {
        has = true;
      }
    });
  } catch(e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');
  }
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;

run();


// end include: postamble.js
 asm   `` `` `` ` ```  `| ` ` `~~`||`}} `}`	 `}}} `} `}}}} `|||`|`|||`||` `| `~~`~2env(emscripten_webgl_init_context_attributes envemscripten_webgl_create_context env%emscripten_webgl_make_context_current envemscripten_asm_const_int  env"emscripten_set_canvas_element_size  envemscripten_set_window_title env)emscripten_set_keydown_callback_on_thread env'emscripten_set_keyup_callback_on_thread env(emscripten_set_resize_callback_on_thread env2emscripten_set_fullscreenchange_callback_on_thread env+emscripten_set_mousemove_callback_on_thread env,emscripten_set_touchstart_callback_on_thread env*emscripten_set_touchend_callback_on_thread env+emscripten_set_touchmove_callback_on_thread env-emscripten_set_touchcancel_callback_on_thread env+emscripten_set_mousedown_callback_on_thread env)emscripten_set_mouseup_callback_on_thread env'emscripten_set_wheel_callback_on_thread env)emscripten_set_focusin_callback_on_thread env*emscripten_set_focusout_callback_on_thread env2emscripten_set_gamepadconnected_callback_on_thread env5emscripten_set_gamepaddisconnected_callback_on_thread env
glViewport envemscripten_get_num_gamepads envemscripten_get_gamepad_status envglEnable envglGenTextures envglBindTexture envglTexParameteri envglTexImage2D envglClear envglBegin envglTexCoord2f env	glColor3f env
glVertex2f envglEnd 	envglDeleteTextures envemscripten_webgl_commit_frame envemscripten_sleep env emscripten_webgl_destroy_context envemscripten_memcpy_js env__syscall_openat env__syscall_fcntl64  env__syscall_ioctl  wasi_snapshot_preview1fd_write wasi_snapshot_preview1fd_read wasi_snapshot_preview1fd_close env__syscall_mkdirat  envemscripten_resize_heap wasi_snapshot_preview1fd_seek 	
                	     	 			p/AA A A  A AA A !memory __wasm_call_ctors 2Emscripten_onDrop IRGFW_makeSetValue J
RGFW_mkdir KRGFW_writeFile Lmalloc free main o__indirect_function_table fflush {emscripten_stack_init emscripten_stack_get_free emscripten_stack_get_base emscripten_stack_get_end 	stackSave stackRestore 
stackAlloc emscripten_stack_get_current __start_em_asm__stop_em_asmdynCall_iiii dynCall_vii dynCall_viii dynCall_viiiii dynCall_viidi dynCall_jiji 
dynCall_ii asyncify_start_unwind asyncify_stop_unwind asyncify_start_rewind asyncify_stop_rewind asyncify_get_state 	" A9;<=@DFEGABC>?H354867
#! #  G@ #!# !A!  k!   6&#!# !A!  k!   6  : #!# !A!  k!   6;#!# !A!  k!   6  6  6  :   : 4#!# !A !  k!   6  :   9  : -#!# !A!  k!   6  6  6~#AF@##( Adj6 #( ! ( ! (! (! (! (! (! (!@@#AF@##( A|j6 #( ( !#A F@# !L L!A! !M !N M Nk!O O! !P P$  !Q  !R Q R6 !S !T S T6 !U !V U V6A ! !W W(!X X!A! !Y !Z Y Zl![ [!	A!
 
!\ 	!] \ ]j!^ ^!A! !_ !` _ `6 !a a(!b b! !c !d c dl!e e! 
!f !g f gj!h h! !i i(!j j! !k k),! ! !l ! l 7 A! !m !n m nj!o o!A4! !p !q p qj!r r! !s s) ! ! !t ! t 7  !u u(!v v! !w w($!x x! !y y:!z z! !{ {(!| |! !} !~ } ~l! ! 
! !  j! ! ! !  :  ! (! ! ! !  l! ! 
! !  j! ! ! !  :  ! (! ! ! !  j! ! ! !  6 ! (! !   ! ($! !! !! :! !"A!# #! "!  j! !$ $! -  ! !% %! !  q! !& ! (! !' '! ($! !( (! :! !) #! )!  j! !* *! -  ! !+ &! !  t! !,A!- +! -!  q! !. .! ,!  r! !/ *! /!  :   ! (! !0 0! ($! !1 1! :! !2 #! 2!  j! !3 3! -  ! !4 4! !  r! !5 2! 5!  : A !6 6! (! !7A !8 8! (! !9 ! (! !: :! ($! !; ;! :! !<A != =! (! !>A!?A!@ >! @!  l! !A ?! A!  j! !BA !CA!DA!E C! E!  q! !FA!G D! G!  q! !H 9! <! B! F! H! 7!#A F A Fr@       #AF@A #A F@A!IA!J ! J!  j! !K K! $  I!    !#(  6 ##( Aj6 #( !  6   6  6  6  6  6  6##( Aj6 A #!# !A!  k!   6 (!A! ! !  K!A!	  	q!
@@ 
E A !  6 (! - !A!  q!  6 (! ~#AF@##( Adj6 #( ! ( ! (! (! (! (! (! (!@@#AF@##( A|j6 #( ( !#A F@# !M M!A! !N !O N Ok!P P! !Q Q$  !R  !S R S6 !T !U T U6 !V !W V W6A ! !X X(!Y Y!A! !Z ![ Z [l!\ \!	A!
 
!] 	!^ ] ^j!_ _!A! !` !a ` a6 !b b(!c c! !d !e d el!f f! 
!g !h g hj!i i! !j j(!k k! !l l),! ! !m ! m 7 A! !n !o n oj!p p!A4! !q !r q rj!s s! !t t) ! ! !u ! u 7  !v v(!w w! !x x($!y y! !z z:!{ {! !| |(!} }! !~ ! ~ l! ! 
! !  j! ! ! !  :  ! (! ! ! !  l! ! 
! !  j! ! ! !  :  ! (! !A! ! !  j! !  !  !  6 ! (! !! !! ($! !" "! :! !#A!$ $! #!  j! !% %! -  ! !& &! !  q! !' ! (! !( (! ($! !) )! :! !* $! *!  j! !+ +! -  ! !, '! !  t! !-A!. ,! .!  q! !/ /! -!  r! !0 +! 0!  :   ! (! !1 1! ($! !2 2! :! !3 $! 3!  j! !4 4! -  ! !5A~!6 5! 6!  q! !7 3! 7!  : A !8 8! (! !9A !: :! (! !; ! (! !< <! ($! != =! :! !>A !? ?! (! !@A!AA!B @! B!  l! !C A! C!  j! !DA !EA!F E! F!  q! !GA!H E! H!  q! !I ;! >! D! G! I! 9!#A F A Fr@       #AF@A #A F@A!JA!K ! K!  j! !L L! $  J!    !#(  6 ##( Aj6 #( !  6   6  6  6  6  6  6##( Aj6 A l~#AF@##( Apj6 #( !m m( ! m(!a m(!b m(!c@@#AF@##( A|j6 #( ( !l#A F@# !$ $!A0! !% !& % &k!' '! !( ($  !)  !* ) *6, !+ !, + ,6( !- !. - .6$A ! !/ /(!0 0!A!A!	 !1 	!2 1 2l!3 3!
 !4 
!5 4 5j!6 6!A
! !7 !8 7 86A ! !9 9(!: :!A! !; !< ; <j!= =!A ! !> !? > ?6A ! !@ @(!A A!A ! !B B(!C C!A ! !D !E D E6A ! !F !G F G6 !H H((!I I! !J J(!K K! !L !M L M6 !N N((!O O! !P P(!Q Q! !R !S R S6 A! !T !U T Uj!V V!A! !W !X W Xj!Y Y! !Z ![ Z [j!\ \!   !] ]) !q q!o !^ o!r ^ r7  !_ _)!s s!p !` p!t ` t7  !a !b !c#A F lA Fr@ a b c #AF@A #A F@A!!A0!" !d "!e d ej!f f!# #!g g$  !!h h   !k#(  k6 ##( Aj6 #( !n n 6  n a6 n b6 n c6##( Aj6 A 	~#AF@##( Apj6 #( ! ( ! (! (! (!@@#AF@##( A|j6 #( ( !#A F@# !/ /!A0! !0 !1 0 1k!2 2! !3 3$  !4  !5 4 56, !6 !7 6 76( !8 !9 8 96$A ! !: :(!; ;!A!A!	 !< 	!= < =l!> >!
 !? 
!@ ? @j!A A!A
! !B !C B C6A ! !D D(!E E!A! !F !G F Gj!H H!A ! !I !J I J6A ! !K K(!L L!A! !M !N M Nj!O O!A ! !P !Q P Q6A ! !R !S R S6 !T T((!U U! !V V(!W W! !X !Y X Y6 !Z Z((![ [! !\ \(!] ]! !^ !_ ^ _6  !` `)! ! !a ! a 7 A! !b !c b cj!d d!A! !e !f e fj!g g! !h !i h ij!j j!   !k k) ! ! !l ! l 7 A !! !!m m(!n n!"A !# #!o o(!p p!$A !% %!q q(!r r!&A!' &!s '!t s tj!u u!(A!) (!v )!w v wj!x x!* *!y y) ! ! !z )!{ z {j!| |!+ +!} ! } 7  (!~ ~) ! ! ! !  7  $! ! "!#A F A Fr@    #AF@A #A F@A!,A0!- ! -!  j! !. .! $  ,!    !#(  6 ##( Aj6 #( !  6   6  6  6##( Aj6 A Q#AF@##( Apj6 #( !R R( ! R(!F R(!G R(!H@@#AF@##( A|j6 #( ( !Q#A F@# ! !A! !  !!   !k!" "! !# #$  !$  !% $ %6 !& !' & '6 !( !) ( )6A ! !* *(!+ +!A!A!	 !, 	!- , -l!. .!
 !/ 
!0 / 0j!1 1!A! !2 !3 2 36A ! !4 4(!5 5!A! !6 !7 6 7j!8 8!A ! !9 !: 9 :6A ! !; ;(!< <!A! != !> = >: A ! !? ?(!@ @!A ! !A A(!B B!A!A! !C !D C Dq!E E! !F !G !H#A F QA Fr@ F G H #AF@A #A F@A!A! !I !J I Jj!K K! !L L$  !M M   !P#(  P6 ##( Aj6 #( !S S 6  S F6 S G6 S H6##( Aj6 A Q#AF@##( Apj6 #( !R R( ! R(!F R(!G R(!H@@#AF@##( A|j6 #( ( !Q#A F@# ! !A! !  !!   !k!" "! !# #$  !$  !% $ %6 !& !' & '6 !( !) ( )6A ! !* *(!+ +!A!A!	 !, 	!- , -l!. .!
 !/ 
!0 / 0j!1 1!A! !2 !3 2 36A ! !4 4(!5 5!A! !6 !7 6 7j!8 8!A ! !9 !: 9 :6A ! !; ;(!< <!A ! != !> = >: A ! !? ?(!@ @!A ! !A A(!B B!A !A! !C !D C Dq!E E! !F !G !H#A F QA Fr@ F G H #AF@A #A F@A!A! !I !J I Jj!K K! !L L$  !M M   !P#(  P6 ##( Aj6 #( !S S 6  S F6 S G6 S H6##( Aj6 A 	~#AF@##( Apj6 #( ! ( ! (! (! (!@@#AF@##( A|j6 #( ( !#A F@# !@ @!A0! !A !B A Bk!C C! !D D$  !E  !F E F6, !G !H G H6( !I !J I J6$A ! !K K(!L L!A!A!	 !M 	!N M Nl!O O!
 !P 
!Q P Qj!R R!A! !S !T S T6A ! !U U(!V V! !W W(!X X!A! !Y !Z Y Zq![ [!@@ !\ \E!] ]  !^ ^((!_ _! !` `(,!a a! !b !c b c6 !d d((!e e! !f f(0!g g! !h !i h i6 A ! !j j(!k k!A!A! !l !m l ml!n n! !o !p o pj!q q!A! !r !s r sj!t t! !u u)! ! !v ! v 7 A ! !w w(!x x!A! A!! !y !!z y zl!{ {!"  !| "!} | }j!~ ~!#A!$ #! $!  j! !% ! ((! !& &! (4! !' ! '!  6 ! ((! !( (! (8! !) ! )!  6 ! )! ! %! !  7 A !* *! (! !+A!, +! ,!  j! !-A !. .! -!  6A !/ /! (! !0A !1 1! (! !2A !3 3! (! !4A!5A!6 4! 6!  l! !7 5! 7!  j! !8A!9 8! 9!  j! !: :! ) ! ! ! !  7A!; ! ;!  j! !< 2! <! 0!#A F A Fr@    #AF@A #A F@A!=A0!> ! >!  j! !? ?! $  =!    !#(  6 ##( Aj6 #( !  6   6  6  6##( Aj6 A ~|#AF@##( Adj6 #( ! ( ! (! (! +! (! (!@@#AF@##( A|j6 #( ( !#A F@# !O O!A ! !P !Q P Qk!R R! !S S$  !T  !U T U6 !V !W V W6 !X !Y X Y6A ! !Z Z(![ [!A! !\ !] \ ]l!^ ^!	A!
 
!_ 	!` _ `j!a a!A! !b !c b c6 !d d(!e e! !f !g f gl!h h! 
!i !j i jj!k k! !l l(!m m! !n n(4!o o! !p !q p q6 !r r(!s s! !t t(8!u u! !v !w v w6 !x x)! ! !y ! y 7 !z z(!{ {! !| |/(!} }!A! !~ ! ~ j! ! ! (! ! ! !  l! ! 
! !  j! ! ! !  :  ! (! ! ! !  l! ! 
! !  j! !B ! ! !  7 ! (! ! ! !  l! ! 
! !  j! !   ! - ! !!A!" "! !!  j! !# #! -  ! !$ $! !  q! !% %! !  t! !&A!' $! '!  q! !( (! &!  r! !) #! )!  :   ! (! !* *! !  l! !+ 
! +!  j! !, ,! - ! !- "! -!  j! !. .! -  ! !/ /! !  r! !0 -! 0!  : A !1 1! (! !2A !3 3! (! !4A !5 5! (! !6A!7A!8 6! 8!  l! !9 7! 9!  j! !: :! - ! !;A !< <! (! !=A!>A!? =! ?!  l! !@ >! @!  j! !A A! +! !A!BA!C ;! C!  q! !DA!E B! E!  q! !F 4! D! ! F! 2!#A F A Fr@     
 #AF@A #A F@A !G G! (! !HA!I H! I!  j! !JA !K K! J!  6A!LA !M ! M!  j! !N N! $  L!    !#(  6 ##( Aj6 #( !  6   6  6  9  6  6##( Aj6 A ~|#AF@##( Adj6 #( ! ( ! (! (! +! (! (!@@#AF@##( A|j6 #( ( !#A F@# !P P!A ! !Q !R Q Rk!S S! !T T$  !U  !V U V6 !W !X W X6 !Y !Z Y Z6A ! ![ [(!\ \!A! !] !^ ] ^l!_ _!	A!
 
!` 	!a ` aj!b b!A! !c !d c d6 !e e(!f f! !g !h g hl!i i! 
!j !k j kj!l l! !m m(!n n! !o o(4!p p! !q !r q r6 !s s(!t t! !u u(8!v v! !w !x w x6 !y y)! ! !z ! z 7 !{ {(!| |! !} }/(!~ ~!A! ! !  j! ! ! (! ! ! !  l! ! 
! !  j! ! ! !  :  ! (! ! ! !  l! ! 
! !  j! !B ! ! !  7 ! (! ! ! !  l! ! 
! !  j! !   ! - ! !!A!" "! !!  j! !# #! -  ! !$ $! !  q! !% %! !  t! !&A!' $! '!  q! !( (! &!  r! !) #! )!  :   ! (! !* *! !  l! !+ 
! +!  j! !, ,! - ! !- "! -!  j! !. .! -  ! !/A~!0 /! 0!  q! !1 -! 1!  : A !2 2! (! !3A !4 4! (! !5A !6 6! (! !7A!8A!9 7! 9!  l! !: 8! :!  j! !; ;! - ! !<A != =! (! !>A!?A!@ >! @!  l! !A ?! A!  j! !B B! +! !A !CA!D <! D!  q! !EA!F C! F!  q! !G 5! E! ! G! 3!#A F A Fr@     
 #AF@A #A F@A !H H! (! !IA!J I! J!  j! !KA !L L! K!  6A!MA !N ! N!  j! !O O! $  M!    !#(  6 ##( Aj6 #( !  6   6  6  9  6  6##( Aj6 A ~|#AF@##( Adj6 #( ! ( ! (! (! +! (! (!@@#AF@##( A|j6 #( ( !#A F@# !Q Q!A ! !R !S R Sk!T T! !U U$  !V  !W V W6 !X !Y X Y6 !Z ![ Z [6A ! !\ \(!] ]!A! !^ !_ ^ _l!` `!	A!
 
!a 	!b a bj!c c!A! !d !e d e6 !f f(!g g! !h !i h il!j j! 
!k !l k lj!m m! !n n(!o o! !p p(4!q q! !r !s r s6 !t t(!u u! !v v(8!w w! !x !y x y6 !z z)! ! !{ ! { 7 !| |(!} }! !~ ~+P! !D        ! ! !  c! !A! ! !  r! ! ! (! ! ! !  l! ! 
! !  j! ! ! !  :  ! (! ! ! +P! ! ! (! ! ! !  l! ! 
! !  j! ! ! !  9 ! (! ! ! !  l! !  
!  !  j! !! !! - ! !"A!# #! "!  j! !$ $! -  ! !%A!& %! &!  q! !' '! &!  t! !(A!) %! )!  q! !* *! (!  r! !+ $! +!  :   ! (! !, ,! !  l! !- 
! -!  j! !. .! - ! !/ #! /!  j! !0 0! -  ! !1 1! &!  r! !2 /! 2!  : A !3 3! (! !4A !5 5! (! !6A !7 7! (! !8A!9A!: 8! :!  l! !; 9! ;!  j! !< <! - ! !=A !> >! (! !?A!@A!A ?! A!  l! !B @! B!  j! !C C! +! !A!DA!E =! E!  q! !FA!G D! G!  q! !H 6! F! ! H! 4!#A F A Fr@     
 #AF@A #A F@A !I I! (! !JA!K J! K!  j! !LA !M M! L!  6A!NA !O ! O!  j! !P P! $  N!    !#(  6 ##( Aj6 #( !  6   6  6  9  6  6##( Aj6 A ~|#AF@##( AXj6 #( ! ( ! (! (! (! (! (! +! ( ! ($!@@#AF@##( A|j6 #( ( !#A F@# !o o!A ! !p !q p qk!r r! !s s$  !t  !u t u6 !v !w v w6 !x !y x y6A ! !z !{ z {6@@#A F@ !| |(!} }! !~ ~(! ! ! (! !	 ! !
 	! ! 
! !  I! !A! ! !  q! ! ! E! A ! ! (! !A! ! !  l! !A! ! !  j! !A! ! !  6 ! (! ! ! !  l! ! ! !  j! ! ! (! ! ! (! !A4! ! !  l! ! ! !  j! !A ! ! !  j! ! ! ( ! !  !  !  6 ! (! !! ! (! !" "! !  l! !# !! #!  j! !$A !% $! %!  j! !& &! ( ! !' ! '!  6 ! )! ! ! !  7 ! (! !( (! !  l! !) ! )!  j! !*A!+ *! +!  :  ! (! !, ,! !  l! !- ! -!  j! !.B ! .! !  7 ! (! !/ /! !  l! !0 ! 0!  j! !1 1! - ! !2A!3 3! 2!  j! !4 4! -  ! !5 5! +!  q! !6 6! +!  t! !7A!8 5! 8!  q! !9 9! 7!  r! !: 4! :!  :   ! (! !; ;! !  l! !< ! <!  j! != =! - ! !> 3! >!  j! !? ?! -  ! !@ @! +!  r! !A >! A!  : A !B B! (! !CA !D D! (! !EA !F F! (! !GA!HA!I G! I!  l! !J H! J!  j! !KA!L K! L!  j! !M M! ) ! ! ! !  7  E! ! C!#A F A Fr@    #AF@A #A F@A !N N! (! !OA !P P! (! !QA !R R! (! !SA!TA!U S! U!  l! !V T! V!  j! !W W! - ! !XA !Y Y! (! !ZA![A!\ Z! \!  l! !] [! ]!  j! !^ ^! +! !A!_A!` X! `!  q! !aA!b _! b!  q! !c Q! a! ! c! O!#A F AFr@     
 #AF@A#A F@A !d d! (! !eA!f e! f!  j! !gA !h h! g!  6 ! (! !iA!j i! j!  j! !k ! k!  6#A F@A!lA !m ! m!  j! !n n! $  l!    !#(  6 ##( Aj6 #( !  6   6  6  6  6  6  9  6   6$##( A(j6 A ~#AF@##( Apj6 #( ! ( ! (! (! (!@@#AF@##( A|j6 #( ( !#A F@# !E E!A ! !F !G F Gk!H H! !I I$  !J  !K J K6 !L !M L M6 !N !O N O6A ! !P !Q P Q6@@#A F@ !R R(!S S! !T T(!U U! !V V(!W W!	 !X X!
 	!Y Y! 
!Z ![ Z [I!\ \!A! !] !^ ] ^q!_ _! !` `E!a aA ! !b b(!c c!A!A! !d !e d el!f f! !g !h g hj!i i!A! !j !k j k6A ! !l l(!m m!A!A! !n !o n ol!p p! !q !r q rj!s s!A! !t !u t uj!v v! !w w(!x x!A! !y !z y zj!{ {!  !| |(!} }!!A4!" !!~ "! ~ l! !#  ! #!  j! !$ $! ($! !% ! %!  6 ! (! !&A!' &! '!  j! !( ! (! !)A4!* )! *!  l! !+ (! +!  j! !, ,! ((! !- ! -!  6 ! )! ! ! !  7 A !. .! (! !/A !0 0! (! !1A !2 2! (! !3A!4A!5 3! 5!  l! !6 4! 6!  j! !7A!8 7! 8!  j! !9 9! ) ! ! ! !  7  1! ! /!#A F A Fr@    #AF@A #A F@A !: :! (! !;A!< ;! <!  j! !=A !> >! =!  6 ! (! !?A!@ ?! @!  j! !A ! A!  6#A F@A!BA !C ! C!  j! !D D! $  B!    !#(  6 ##( Aj6 #( !  6   6  6  6##( Aj6 A ~|#AF@##( Adj6 #( ! ( ! (! (! +! (! (!@@#AF@##( A|j6 #( ( !#A F@# !d d!A ! !e !f e fk!g g! !h h$  !i  !j i j6 !k !l k l6 !m !n m n6A ! !o !p o p6@@#A F@ !q q(!r r! !s s(!t t! !u u(!v v!	 !w w!
 	!x x! 
!y !z y zI!{ {!A! !| !} | }q!~ ~! ! E! A ! ! (! !A! ! !  l! !A! ! !  j! !A! ! !  6 ! (! ! ! !  l! ! ! !  j! ! ! (! ! ! (! !A4! ! !  l! ! ! !  j! !A ! ! !  j! ! ! ( ! !  !  !  6 ! (! !! ! (! !" "! !  l! !# !! #!  j! !$A !% $! %!  j! !& &! ( ! !' ! '!  6 ! )! ! ! !  7 ! (! !( (! !  l! !) ! )!  j! !*A!+ *! +!  :  ! (! !, ,! !  l! !- ! -!  j! !.B ! .! !  7 ! (! !/ /! !  l! !0 ! 0!  j! !1 1! - ! !2A!3 3! 2!  j! !4 4! -  ! !5 5! +!  q! !6 6! +!  t! !7A!8 5! 8!  q! !9 9! 7!  r! !: 4! :!  :   ! (! !; ;! !  l! !< ! <!  j! != =! - ! !> 3! >!  j! !? ?! -  ! !@A~!A @! A!  q! !B >! B!  : A !C C! (! !DA !E E! (! !FA !G G! (! !HA!IA!J H! J!  l! !K I! K!  j! !L L! - ! !MA !N N! (! !OA!PA!Q O! Q!  l! !R P! R!  j! !S S! +! !A !TA!U M! U!  q! !VA!W T! W!  q! !X F! V! ! X! D!#A F A Fr@     
 #AF@A #A F@A !Y Y! (! !ZA![ Z! [!  j! !\A !] ]! \!  6 ! (! !^A!_ ^! _!  j! !` ! `!  6#A F@A!aA !b ! b!  j! !c c! $  a!    !#(  6 ##( Aj6 #( !  6   6  6  9  6  6##( Aj6 A 3#!# !A!  k!   6  6  6A! #!# !A!  k!   6  6  6  (! (
!A! !	 !
 	 
N!A!  q!@@ E A !  6 (! (
! (! (
!A !A!  t!  j!  6 A!  6 (! b#AF@##( Alj6 #( !a a( ! a(!P a(!Q a(!R a(!S@@#AF@##( A|j6 #( ( !`#A F@# !$ $!A! !% !& % &k!' '! !( ($  !)  !* ) *6A ! !+ +(!, ,! !- -(!. .!A ! !/ !0 / 0q!1 1!@#A F@@ !2 2  !3 3(!4 4!	A !
 
!5 5(!6 6!A!A! !7 !8 7 8l!9 9! !: !; : ;j!< <! != 	!> = >6A ! !? ?(!@ @!A ! !A A(!B B!A ! !C C(!D D!A!A! !E !F E Fl!G G! !H !I H Ij!J J!A! !K !L K Lj!M M! !N N(!O O! !P !Q !R !S#A F `A Fr@ P Q R S #AF@A #A F@A ! !T T(!U U!A! !V !W V Wj!X X! A !! !!Y  !Z Y Z6#A F@A!" ![ "!\ [ \j!] ]!# #!^ ^$  !_#(  _6 ##( Aj6 #( !b b 6  b P6 b Q6 b R6 b S6##( Aj6 #!# !A!  k!   6  6A ! (!A!A!  l!	  	j!
A! 
 6A ! (!A!A!  l!  j!A!  j! (!A!  l!  j!  6 (! (!  6 S	#!# !A!  k! $    6 (!A!  !	# G@  	A!  j! $ J#AF@##( A`j6 #( !K K( ! K(!; K(!< K(!= K(!> K(!? K(!B K(!C@@#AF@##( A|j6 #( ( !I#A F@# ! !A! ! !  k! ! ! $  !  !  6 ! !  6 !  !!   !6 !" "(!# #!A! !$ !% $ %!& &! !' !( ' (6  !) )( !* *!	A !
 	!+ +! 
!, ,! !- !. - .F!/ /!A! !0 !1 0 1q!2 2!@#A F@@ !3 3E!4 4  !5 5(!6 6! !7 7(!8 8! !9 9( !: :!A! !; !< != !>#A F IA Fr@ ; < = >!J#AF@A  J!?#A F@ ? !@ @( !A A! !B#A F IAFr@ Bz!J#AF@A J!C#A F@ C#A F@A! !D !E D Ej!F F! !G G$  !H#(  H6 ##( Aj6 #( !L L 6  L ;6 L <6 L =6 L >6 L ?6 L B6 L C6##( A j6 ~#!# !A!  k! $    6|  ;z /z!A!  j! ) !A!	  	j!
 
 j!  7  ) !  7A!  q!A!  j!  N!# G@  !  6tA!  6<A!  6@A!  6<A ! (!  6DA ! (!  6HA!  6LA !  6PA ! (!@@  A !  6pA ! (!  6pA !  6XA !   (!!@@ ! A!" "!#A !$ $(!% %!# #!&  &6\A !' '(!(  (6`A!)  )6dA!*  *6hA<!+  +j!, ,!- - # G@ A!.A<!/  /j!0 0!1 . 1!# G@  !2 (t!3 3 26  (t!4 4( !5 5!# G@  A!6  668 (8!7A !8  8: 7A7!9  9j!: :!;A !< 7 ; <!# G@   (!= (!>A!? ? = >!# G@   (|!@ @# G@ A!AA !BA!C A B B C A!# G@  A!DA !EA!F D E E F D!# G@  A!GA !HA!I G H H I G!# G@  A!JA !KA!LA!M J K K L M	!# G@  A!NA !OA!PA!Q N O O P Q
!# G@  A!RA !SA!TA!U R S S T U!# G@  A!VA !WA!XA!Y V W W X Y!# G@  A!ZA ![A!\A!] Z [ [ \ ]!# G@  A!^A !_A	!`A!a ^ _ _ ` a!# G@  A!bA !cA
!dA!e b c c d e!# G@  A!fA !gA!hA!i f g g h i!# G@  A!jA !kA!lA!m j k k l m!# G@  A!nA !oA!p n o o p n!# G@  A!qA !rA!s q r r s q!# G@  A !tA!uA!vA!w t u v w!# G@  A !xA!yA!zA!{ x y z {!# G@   /z!|A!} | }q!~A ! ~ q!@ E  (t! (!A !  r!  6A!  60 (0!A !  : /A/!  j! !A !   !# G@   (t! O# G@  (! (!A !    # G@  (t!A !  6 /z!A!  q!A !  q!@ E  (t!A !A!  t!  u!  P# G@  /z!A!  q!A!  q!@ E  (t!A$!  j! ! Q# G@  )$!  7A!  j!  R# G@  (t!A!  j! $  ?~#!?# !A0!  k! $   ;.A! !@# ?G@  @!  6(A !  j! !	 	Q# ?G@  /.!
A! 
 q!A!  q!@ E A !  6A !  6 ( !  6 ($!  6 )!A   A7 A!   j!A!  j!  j! ) !B  B7  /.!A!  q!A!  q!@ E  ( !  (!  k!A!    v!!  !6  ($!"  (!# " #k!$A!% $ %v!&  &6  (!'  '6  (!(  (6 ) !C   C7 A!)   )j!*  )j!+ +) !D * D7  ((!,A!- , -j!.  ) !E . E7 A!/ . /j!0   /j!1 1) !F 0 F7  ((!2A!3 2 3:  ((!4A !5 4 56A !6A !7 7 6;W ((!8A !9 8 96 ((!:A !; : ;:  ((!<A0!=  =j!> >$  <~#!# !A!  k! $    6A ! (!@  A ! (!  A!  j!	 	!
 
Q# G@  )!A !  7A ! (!A ! (!  l!A!  t! !# G@  ! (!  6A!  j! $ #!# !A!  k! $    6  :  - !A !A!  q!A!	  	q!
  
G!A!  q!@@ E  (! S# G@ A!  6 (!A !  : A!  j! !A !   !# G@  A!  j! $ 9#!T!# G@  !   6 U!# G@  !   6\
#!
# !A!  k! $    6 ( ! (!A!   !# 
G@  A!  j!	 	$ X
#!
# !A!  k! $    6 (!A !A!  q!  m# 
G@ A!  j!	 	$ v#!# ! A!   k! $ A!  6 (!A !  : A!  j! !A !	   	!# G@  !
A!  j! $  
v#!# ! A!   k! $ A!  6 (!A !  : A!  j! !A !	   	!# G@  !
A!  j! $  

~
|#!# !A!  k! $    6A ! - W!A!  q!@  W# G@ A !  6@@ (!	!# G@  !
 	! 
!  H!A !A!  q! !@ E  (!A! ! !  H! ! !A!  q!@ E  (!A !A!  t!  j! ( !@@   (! A !!  !j!" "!#   #!# G@  !$@ $E A !%  %6T@ (T!& (d!' &!( '!) ( )H!*A !+A!, * ,q!- +!.@ -E  (T!/A!0 /!1 0!2 1 2H!3 3!. .!4A!5 4 5q!6@ 6E A !7 7)!A !8  8j!9 9 7  7)!A !:  :j!; ; 7  7)!A8!<  <j!= = 7  7)!A0!>  >j!? ? 7  7)!A(!@  @j!A A 7  7)!A !B  Bj!C C 7  7)!  7 7)!  7 (T!DA!E  Ej!F F!GA!H D Ht!I G Ij!J J( !K  K6 (!LA !MA!N L Nt!O M Oj!P (!Q P Qj!R R-  !SA!T S Tq!UA !V  Vj!W W!XA!Y X Yj!Z (T![A!\ [ \t!] Z ]j!^ ^( !_ U!` _!a ` aG!bA!c b cq!d@ dE  (!eA!f e f6 (!g (!h h g; (T!iA!j  jj!k k!lA!m i mt!n l nj!o o( !p (!q q p:  (!rA!s r sj!t  t6A !u  uj!v v!wA!x w xj!y (T!zA!{ z {t!| y |j!} }( !~ (!A !A!  t!  j! (!  j!  ~:   (T!A!  j!  6TA !  6@ (! (`! ! !  H!A !A!  q! !@ E  (!A! ! !  H! ! !A!  q!@ E  (`! (!  :  (!A!  j!A!  j! (!A!  t!  j! ( ! !A !  j! !A!  j! (!A!  t!  j! + !  b!A!  q!@@   (!A!  j!A!  j! (!A!  t!  j! (! !A !  j! !A!  j! (!A!  j!A!  t!  j! + !  b!A!  q! EA !  j! !A!  j! (!A!  t!  j! + ! !D      A!  c! E!@@   ! !Ax! ! ! (!A!  j!A!  j! (!A!  t!  j!  6 A !  j! !A!  j! (!A!  j!A!  t!  j! + ! !D      A!  c! E!@@   ! !Ax! ! ! (!A!  j!A!  j! (!A!  t!  j!  6 (!A!  6 (! (!  ; (!A!  j!  6 (!A!  j!  6 (!A!  j!  6A ! (!@  A !  6 (! )!A ! - W!A!  q!A!A!  l!  j!  7 (! )!A ! - W!A!  q!A!A!  l!  j!  7 (! - !A ! - W!A!  q!A!A!  l!  j!  :  (!A!  j!A ! - W!A!  q!A!A!  l!  j!A!   u!# G@  A ! (!A!  j!A !  6A ! (!@@ E A ! - W!A!  j!A !  : WA !A !  : W (!A!  j!  6 (!A!  j! $  #!# ! A!   k!A !  6A !  6@@ (! (! ! !  I!	A!
 	 
q! E (!A!  j! -  !A}!  q!  :  (!A!  j!  6  }2~#!# !A!  k! $   8  Y# G@  * ! !  8 *! !  8C  ?!  8A!  j! A8!   j!	 	) !A!
  
j!  j!  7 A0!   j! ) !A!  j!  j!  7 A(!   j! ) !A!  j!  j!  7 A !   j! ) !A!  j!  j!  7 A!   j! ) !A!  j!  j!    7 A!!   !j!" ") !A!#  #j!$ $ !j!% % 7 A!&   &j!' ') !A!(  (j!) ) &j!* * 7   ) !  7  &j!+A!,  ,j!- - &j!. .( !/ + /6  )!  7 A!0  0j!1A!2  2j!3 1 3 Z# G@  )!   7 A8!4   4j!5A!6  6j!7 7 4j!8 8) ! 5 7 A0!9   9j!:A!;  ;j!< < 9j!= =) ! : 7 A(!>   >j!?A!@  @j!A A >j!B B) ! ? 7 A !C   Cj!DA!E  Ej!F F Cj!G G) ! D 7 A!H   Hj!IA!J  Jj!K K Hj!L L) ! I 7 A!M   Mj!NA!O  Oj!P P Mj!Q Q) ! N 7 A!R   Rj!SA!T  Tj!U U Rj!V V) ! S 7  *!A!W  Wj!X XA8!Y   Yj!Z Z) !A ![  [j!\ \ Yj!] ] 7 A0!^   ^j!_ _) !A !`  `j!a a ^j!b b 7 A(!c   cj!d d) !A !e  ej!f f cj!g g 7 A !h   hj!i i) !A !j  jj!k k hj!l l 7 A!m   mj!n n) !A !o  oj!p p mj!q q 7 A!r   rj!s s) !A !t  tj!u u rj!v v 7 A!w   wj!x x) !A !y  yj!z z wj!{ { 7   ) !  7PC  ?!A!|  |j!}A !~  ~j! }     [# G@  )!   7 A8!   j!A!  j!  j! ) !  7 A0!   j!A!  j!  j! ) !  7 A(!   j!A!  j!  j! ) !  7 A !   j!A!  j!  j! ) !  7 A!   j!A!  j!  j! ) !  7 A!   j!A!  j!  j! ) !  7 A!   j!A!  j!  j! ) !  7 A!  j! A8!   j! ) !A!  j!  j!  7 A0!   j! ) !A!  j!  j!  7 A(!   j! ) !A!  j!  j!  7 A !   j! ) !A!  j!  j!  7 A!   j! ) !A!  j!  j!  7 A!   j! ) !A!  j!  j!  7 A!   j! ) !A!  j!  j!  7   ) !  7  j! ( !A!  j!  j!  6  ) !  7A!  j!A!  j!A!  j!   Z# G@  )!   7 A8!   j!A!  j!  j! ) !  7 A0!   j!A!  j!  j! ) !  7 A(!   j!A!  j!  j! ) !  7 A !   j!A!  j!  j! ) !  7 A!   j!A!  j!  j! ) !  7 A!   j!A!  j!  j! ) !  7 A!   j!A!  j!  j! ) !  7 A!  j! $ 	~#!'B !   7 A8!
   
j!  7 A0!   j!  7 A(!   j!  7 A !   j!  7 A!   j!  7 A!   j!  7 A!   j!  7 A8!   j!A ! )!  7 A0!   j! )!  7 A(!   j! )!  7 A !   j!  )!   7 A!!   !j!" )! " 7 A!#   #j!$ )! $ 7 A!%   %j!& )! & 7  )!	   	7 }#!# !A !  k! $ C  ?!  8 A ! !  8A ! !  8A ! !  8A !	 	!  8C  ?!  8A !
 
!  8A ! !  8A ! !  8 A ! !  8$C  ?!  8(A ! !  8, * !  80 *!    84 *!!  !88C  ?!"  "8< !    \# G@ A !  j! $ 
 ~}#!%# !A !  k! $   8l  8h  8d  8` *h!& *h!' *d!( *d!) ( )!* & '!+ + *!, *`!- *`!. - .!/ / ,!0  08\ *\!1C  ?!2 1 2\!	A!
 	 
q!@ E  *\!3A ! !4 3 4\!A!  q! E  *\!5 5!6C  ?!7 7 6!8  88X *X!9 *h!: : 9!;  ;8h *X!< *d!= = <!>  >8d *X!? *`!@ @ ?!A  A8` *l!B B!CC   O!D C D]! E!@@   B! !Ax! ! ! ]!# %G@  !E  E8T *l!F F!GC   O!H G H]! E!@@   F! !Ax! ! ! ^!# %G@  !I  I8P *P!JC  ?!K K J!L  L8L *h!M *h!N M N!O *L!P *P!Q O P!R R Q!S  S8  *d!T *h!U T U!V *L!W *`!X *T!Y X Y!Z V W![ [ Z!\  \8 *`!] *h!^ ] ^!_ *L!` *d!a *T!b a b!c c!d _ `!e e d!f  f8A ! !g  g8 *h!h *d!i h i!j *L!k *`!l *T!m l m!n n!o j k!p p o!q  q8 *d!r *d!s r s!t *L!u *P!v t u!w w v!x  x8 *`!y *d!z y z!{ *L!| *h!} *T!~ } ~! { |!  !  8A ! !  8 *h! *`!  ! *L! *d! *T!  !  !  !  8  *d! *`!  ! *L! *h! *T!  ! !  !  !  8$ *`! *`!  ! *L! *P!  !  !  8(A ! !  8,A ! !  80A !   !  84A !! !!  88C  ?!  8< !"    "\# %G@ A !#  #j!$ $$ }#!# !A!  k!  6  6 (! * ! (! * ! (! *! (!	 	*!  !  !  ! (!
 
*! (! * !  !  ! (! *! (! *0!  !  !   8  (! * ! (! *! (! *! (! *!  !  !  ! (! *! (! *$!  !  ! (! *! (! *4!  !  !   8 (! * ! (! *! (! *! (! *!  !  !  ! (! *! (! *(!  !  ! (! *! (! *8!  !  !   8 (! * ! (! *! (!   *! (!! !*!  !  !  ! (!" "*! (!# #*,!  !  ! (!$ $*! (!% %*<!  !  !   8 (!& &*! (!' '* ! (!( (*! (!) )*!  !  !  ! (!* **! (!+ +* !  !  ! (!, ,*! (!- -*0!  !  !   8 (!. .*! (!/ /*! (!0 0*! (!1 1*!  !  !  ! (!2 2*! (!3 3*$!  !  ! (!4 4*! (!5 5*4!  !  !   8 (!6 6*! (!7 7*! (!8 8*! (!9 9*!  !  !  ! (!: :*! (!; ;*(!  !  ! (!< <*! (!= =*8!  !  !   8 (!> >*! (!? ?*! (!@ @*! (!A A*!  !  !  ! (!B B*! (!C C*,!  !  ! (!D D*! (!E E*<!  !  !   8 (!F F* ! (!G G* ! (!H H*$! (!I I*!  !  !  ! (!J J*(! (!K K* !  !  ! (!L L*,! (!M M*0!  !  !   8  (!N N* ! (!O O*! (!P P*$! (!Q Q*!  !  !  ! (!R R*(! (!S S*$!  !  ! (!T T*,! (!U U*4!  !  !   8$ (!V V* ! (!W W*! (!X X*$! (!Y Y*!  !  !  ! (!Z Z*(! (![ [*(!  !  ! (!\ \*,! (!] ]*8!  !  !   8( (!^ ^* ! (!_ _*! (!` `*$! (!a a*!  !  !  ! (!b b*(! (!c c*,!  !  ! (!d d*,! (!e e*<!  !  !   8, (!f f*0! (!g g* ! (!h h*4! (!i i*!  !  !  ! (!j j*8! (!k k* !  !  ! (!l l*<! (!m m*0!  !  !   80 (!n n*0! (!o o*! (!p p*4! (!q q*!  !  !  ! (!r r*8! (!s s*$!  !  ! (!t t*<! (!u u*4!  !  !   84 (!v v*0! (!w w*! (!x x*4! (!y y*!  !  !  ! (!z z*8! (!{ {*(!  !  ! (!| |*<! (!} }*8!  !  !   88 (!~ ~*0! (! *! (! *4! (! *!  !  !  ! (! *8! (! *,!  !  ! (! *<! (! *<!  !  !   8<9}|#!9# !A!  k! $    6A ! *!:A ! !; : ;\!A!  q!@ E A !	  	6@@ (!
A! 
! !  I!A!  q! E (! !>D-DT!	@!? > ?!@D     f@!A @ A!B B!D# 9G@  D!C C!< (!A!A!  t!  j!  <8  (!A!  j!  6  @@ (!A ! ! !  H!A!  q!   E (!!A!" ! "j!#  #6   (!$A!% $!& %!' & 'N!(A!) ( )q!*@ *E  (!+A!, + ,m!-A!. - .l!/ (!0 0 /k!1  16 (!2A!3A!4 2 4t!5 3 5j!6 6* !=A!7  7j!8 8$  =9}|#!9# !A!  k! $    6A ! *W!:A ! !; : ;[!A!  q!@ E A !	  	6@@ (!
A! 
! !  I!A!  q! E (! !>D-DT!	@!? > ?!@D     f@!A @ A!B Bt!D# 9G@  D!C C!< (!A !A!  t!  j!  <8  (!A!  j!  6  @@ (!A ! ! !  H!A!  q!   E (!!A!" ! "j!#  #6   (!$A!% $!& %!' & 'N!(A!) ( )q!*@ *E  (!+A!, + ,m!-A!. - .l!/ (!0 0 /k!1  16 (!2A !3A!4 2 4t!5 3 5j!6 6* !=A!7  7j!8 8$  =m~G}#AF@##( Axj6 #( ! ( ! (!@@#AF@##( A|j6 #( ( !#A F@# ! ! A!  ! !  k! ! ! $ A ! ! !  6A ! ! !  6A ! ! !  6A! ! !  6A! ! !  6AA!A!	 ! 	!  j! !
 
! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7  ! )! ! ! !  7A!A!A! ! !  j! ! ! ! !   M! ! ! !  6A! ! !  j! ! ! ! ! Q ! )! ! ! !  7A! ! !  j! ! ! ` ! (! ! ! (! ! ! !  6 ! (! ! ! (! ! ! !  6 ! )! ! ! !  7A! ! !  j! ! ! aA ! ! ! ! ! !  8A!  !  !  : @@#A F@ ! - ! !!A !"A!# !! #!  q! !$A!% "! %!  q! !& $! &!  G! !'A!( '! (!  q! !) )! E! @@ ! (! !* *! V! !+A !, +! !- ,! !. -! .!  G! !/A!0 /! 0!  q! !1 1! E!  ! (! !2 2! (! !3A!4 3! !5 4! !6 5! 6!  F! !7A!8 7! 8!  q! !9@@ 9!   ! (! !:A!;A!< ;! <!  q! != :! =!  b! !>A!? >! ?!  q! !@ @! E! A !A ! A!  :  ! (! !B B! (! !CA
!D C! !E D! !F E! F!  F! !GA!H G! H!  q! !I@ I! E!   ! (! !J J! (! !K ! K!  6 ! (! !L L! (! !M ! M!  6 ! )! ! ! !  7A!N ! N!  j! !O O! a   ! (! !P P! (! !QA !R ! R!  : A !S ! S!  : A!T ! T!  : A!U ! U!  : A!V ! V!  j! !W W! !X Q! X!  cA !Y Y! (! !ZA![ ! [!  j! !\ \! Z!  6  Y! )! ! ! !  7A !] ]! (! !^A!_ ! _!  j! !` `! ^!  6  ]! )! ! ! !  7A !a a! (! !bA!c ! c!  j! !d d! b!  6  a! )! ! ! !  7C  C! ! !  8C  C! ! !  8C  ?! ! !  8 ! *! !A!e ! e!  j! !f f! A!gA!h ! h!  j! !i i! g!  j! !jA!k ! k!  j! !l l! g!  j! !m m! ( ! !n j! n!  6  ! )! ! ! !  7A!o ! o!  j! !pA!q ! q!  j! !r p! r! !   XA8!sA!t ! t!  j! !u u! s!  j! !vA!w ! w!  j! !x x! s!  j! !y y! ) ! ! v! !  7 A0!zA!{ ! {!  j! !| |! z!  j! !}A!~ ! ~!  j! ! ! z!  j! ! ! ) ! ! }! !  7 A(!A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A !A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A!A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A!A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A!A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7  ! )! ! ! !  7A! ! !  j! ! ! d ! (! ! ! (! !A! ! !  j! ! ! ! ! )! ! ! !  7 A! ! !  j! !A! ! !  j! ! ! !  j! ! ! ( ! ! ! !  6 A! ! !  j! ! ! )! ! ! !  7 A! ! !  j! !A! ! !  j! ! ! !  j! ! ! ( ! ! ! !  6 A! ! !  j! ! ! )! ! ! !  7 A! ! !  j! !A! ! !  j! ! ! !  j! ! ! ( ! ! ! !  6 A! ! !  j! ! ! !A ! ! !  : A! ! !  : A ! ! !  : A! ! !  : A! ! !  j! ! ! ! ! ! !   eC  zC! ! !  8C  zC! ! !  8C  ?! ! !  8 ! *! !A! ! !  j! ! ! A!A ! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ( ! ! ! !  6  ! )! ! ! !  7XA! ! !  j! !A ! ! !  j! ! ! ! !   XA8!A ! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A0!A ! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A(!A ! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A !A ! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A!A ! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A!A ! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A!A ! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7  ! )! ! ! !  7hA ! ! !  j! ! ! d ! (! ! ! (! !C  C! ! !  8C  C! ! !  8C  HC! ! !  8C  HC! ! !  8A ! ! !  : A! ! !  : A ! ! !  : A! ! !  : A! ! !  j! ! ! !A!A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7  ! )! ! ! !  7A! ! !  j! ! ! ! !   fC  HC! ! !  8C  D! ! !  8C  ?! ! !  8 ! *! !A! ! !  j! ! ! A!A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ( ! ! ! !  6  ! )! ! ! !  7A! ! !  j! !A! ! !  j! ! ! ! !   XA8!A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A0!A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A(!A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7 A !A! ! !  j! ! ! !  j! !A! ! !  j! ! ! !  j! ! ! ) ! ! !	 ! 	 7 A!A! !	 !	 	 	j!	 	! !	 !	 	 	j!	 	!A! !	 !	 	 	j!	 	! !	 !	 	 	j!	 	! !	 	) ! ! !	 ! 	 7 A!A! !	 !	 	 	j!	 	! !	 !	 	 	j!	 	!A! !	 !	 	 	j!	 	! !	 !	 	 	j!	 	! !	 	) ! ! !	 ! 	 7 A!A! !	 !	 	 	j!	 	! !	 !	 	 	j!	 	!A! !	 !	 	 	j!	 	! !	 !	 	 	j!	 	! !	 	) ! ! !	 ! 	 7  !	 	)! ! !	 ! 	 7A! !	 !	 	 	j!	 	! !	 	d !	 	(!	 	! !	 	(!	 	!C  HC! !	 ! 	 8C  D! !	 ! 	 8C  B! !	 ! 	 8C  B! !	 ! 	 8A ! !	 !	 	 	: A! !	 !	 	 	: A ! !	 !	 	 	: A! !	 !	 	 	: A! !	 !	 	 	j!	 	! !	 	!A!A! !	 !	 	 	j!	 	! !	 !	 	 	j!	 	!A! !	 !	 	 	j!	 	! !	 !	 	 	j!	 	! !	 	) ! ! !	 ! 	 7  !	 	)! ! !	 ! 	 7A!A! !	 !	 	 	j!	 	! !	 !	 !	 !	 	 	 	 	gC  C! !	 ! 	 8C  D! !	 ! 	 8C  ?! !	 ! 	 8 !	 	*! !A! !	 !	 	 	j!	 	! !	 	A!A! !	 !	 	 	j!	 	! !	 !	 	 	j!	 	!A! !	 !	 	 	j!	 	! !	 !	 	 	j!	 	! !	 	( !	 	! !	 !	 	 	6  !	 	)! ! !	 ! 	 7A! !	 !	 	 	j!	 	!A! !	 !	 	 	j!	 	! !	 !	 ! 	 	 XA8!A! !	 !	 	 	j!
 
! !
 !
 
 
j!
 
!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
! !
 
) ! ! !
 ! 
 7 A0!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
! !
 
) ! ! !
 ! 
 7 A(!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
! !
 
) ! ! !
 ! 
 7 A !A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
! !
 
) ! ! !
 ! 
 7 A!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
! !
 
) ! ! !
 ! 
 7 A!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
! !
 
) ! ! !
 ! 
 7 A!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
! !
 
) ! ! !
 ! 
 7  !
 
)! ! !
 ! 
 7A! !
 !
 
 
j!
 
! !
 
d !
 
(!
 
! !
 
(!
 
!C  C! !
 ! 
 8C  D! !
 ! 
 8C  B! !
 ! 
 8C  B! !
 ! 
 8A ! !
 !
 
 
: A! !
 !
 
 
: A ! !
 !
 
 
: A! !
 !
 
 
: A! !
 !
 
 
j!
 
! !
 
!A!A! !
 !
 
 
j!
 
! !
 !
 
 
j!
 
!A! ! !  j! ! ! !  j! ! ! ) ! ! ! !  7  ! )! ! ! !  7A$!A! ! !  j! ! ! ! ! !    g ! *! !C  ?! ! !  ! ! ! !  8 ! (! ! !#A F A Fr@ h#AF@A #A F@#A F@ ! (! ! ! i ! (! !A! ! !  j! ! ! $  !    !#(  6 ##( Aj6 #( !  6   6##( Aj6 A ~#!  ) !A !  7~#!  ) !A!  7%#!&# !A!  k!   6  :  - !A!  j! -  !A!	  	q!
A! 
 q!A ! !@ E  (!A ! ! !  F!A!A!  q! !@   (! - !A!  q!A ! ! !  G! ! !   ! !!A!" ! "q!#A!$ # $q!% %`#!_# !A!  k! $    6|  6xA!A !A!  j!   u!`# _G@  ` (x!	 	-  !
A! 
 q! (x! - !A!  q! ! !  F!A!  q!@@ E  (x! -  !A!  q! (x! - !A!  q! ! !  F! A!!   !q!" "E  (x!# #-  !$A!% $ %q!& (x!' '- !(A!) ( )q!* &!+ *!, + ,F!-A!. - .q!/ /E  (|!0 (!1 (!2 1 2l!3A!4 3 4t!5A !6 5 6t!7A !8 0 8 7v!a# _G@  aA !9  96@ (!: (!; :!< ;!= < =I!>A!? > ?q!@ @EA !A  A6@@ (!B (!C B!D C!E D EI!FA!G F Gq!H HE (!IA!J I Jt!K (!L K Ll!M (!NA!O N Ot!P M Pj!Q  Q6  (|!R ( !S R Sj!T (x!U U(  !V T V6   (!WA!X W Xj!Y  Y6   (!ZA![ Z [j!\  \6  A!]  ]j!^ ^$ ~#!!  ) !A!	 	 7A !
 	 
j!A8!   j! ) !  7 A ! 	 j!A0!   j! ) !  7  	 j!A(!   j! ) !  7  	 j!A !   j! ) !  7  	 j!A!   j! ) !  7  	 j!A!   j! ) !  7  	 j!A!   j!   ) !  7 *~{}
|#!# !A!  k! $    6  6  6A!A !A!  j!	 	  u!# G@  A !
 
(!A!  j!  6  
)!  7A ! (!A!  j!  6  )!  7A !  6@@ (!A! ! !  I!A!  q! E *!C  !  [!A!  q!@@   *! (! (!A!  l!    j!! !* !  ^!"A!# " #q!$ $E (!% (!&A!' & 'l!( % (j!) )* !  8 *!C  !  [!*A!+ * +q!,@@ ,  *! (!- (!.A!/ . /l!0 - 0j!1 1* !  ^!2A!3 2 3q!4 4E (!5 (!6A!7 6 7l!8 5 8j!9 9*!  8 *!C  !  [!:A!; : ;q!<@@ <  *! (!= (!>A!? > ?l!@ = @j!A A* !  ]!BA!C B Cq!D DE (!E (!FA!G F Gl!H E Hj!I I* !  8 *!C  !  [!JA!K J Kq!L@@ L  *! (!M (!NA!O N Ol!P M Pj!Q Q* !  ]!RA!S R Sq!T TE (!U (!VA!W V Wl!X U Xj!Y Y*!  8 (!ZA![ Z [j!\  \6   *! *!  !C   @!  !  8 *! *!  !C   @!  !  8C  ?!  8 (!] ]* !  8 (!^ ^*!  8C  ?!  8 (!_ _*!  8 (!` `*!  8C  ?!  8 (!a a*!  8 (!b b*!  8C  ?!  8A!c  cj!dA !e d e6 B !  7A!f  fj!gA !h g h6 B !  7A !i i!  8A !j  j6@@ (!kA!l k!m l!n m nI!oA!p o pq!q qE (!r (!sA!t s tl!u r uj!v v* ! *!  !A!w s wt!xA!y  yj!z z xj!{ { 8  (!| (!} } tl!~ | ~j! *! *!  ! } wt!A!  j!  j!  8  (!  wt!A!  j!  j! * ! ! ! *! !  d!A!  q!@ E  (!A!  j! !A!  t!  j! * !  8 (!A!  t!A!  j!  j! * ! ! !A!  j!  j! * ! ! !  f!A!  q!@ E  (!A!  t!A!  j!  j! * ! ! ! *! !  d!A!  q! E  (!A!  j! !A!  t!  j! * !  8 *! (!A!  j! !A!  t!  j! * !  !  8  *! (!A!  j! !A!  t!  j! * !  !  8  (!A!  j!  6  A ! !  8@@ *! *!  ]!A!  q! E *! *!  ! !C   O!  ]! E!@@   ! !Ax! ! ! !A!  u!  s!  k!  6 *! *!  ! !C   O!  ]! E!@@   ! !Ax! ! ! !A!  u!  s!  k!  6 (! )!  7   j!# G@  !  6 (!A!  j! !A!  j! !A!  j!A!  j! ( !A!  j!  j!  6  ) !  7  j! ( !A!  j!  j!  6  ) !  7A!  j!A!  j!A!  j!    k# G@  *! *!  ! !C   O!  ]! E!@@   ! !Ax! ! ! !A!  u!  s!  k! ! *!  ! !C   O!  ]! E!@@   ! !Ax! ! !  6 *! *!  ! !C   O!  ]! E!@@   ! !Ax! ! ! !A!  u!  s!  k! ! *!  ! !C   O!  ]! E!@@   ! !Ax! ! !  6 (! )!  7(A(!  j!  j!# G@  !  6 (!A!  j! !A!  j!A!  j! !A!  j!A!  j! ( !A !  j!  j!  6  ) !  7@  j! ( !A0!  j!  j!  6  ) !  70A !  j!A0!  j!A!  j!    k# G@  *! *!  ! !C   O!  ]! E!@@   ! !Ax! ! ! !A!  u!  s!  k! ! *!  ! !C   O!  ]! E!@@   ! !Ax! ! !  6x *! *!  ! !C   O!  ]! E!@@   ! !Ax! ! ! !A!  u!  s!  k! ! *!  ! !C   O!  ]! E!@@   ! !Ax! ! !  6| (! )x!  7PA !  j!  j!# G@  !  6 (!A!  j! !A!  j!A!  j! !A!  j! ( !A !  j!  j!  6  ) !  7h  j! ( !A !  j!  j!  6  ) !  7XA !  j!A !  j!A!  j!    k# G@ A !  6t@@ (t!A! ! !  I!A!  q! E (t!A!  j! !A!  t!  j! * ! (t!A!  j! !A!  l!  j! * !  !  8  (t!A!  j! !A!  t!  j! * ! (t!A!  j! !A!  l!  j! *!  !  8 (t!A!  j!  6t   *!C  ?!  !  8  A!  j! $ /}~#!/# !A!  k! $    6  6A!A !A<!  j!	 	  u!0# /G@  0 * !2  288@@ *8!3 * !4 *!5 4 5!6 3 6]!
A! 
 q! E *!7  784@@ *4!8 *!9 *!: 9 :!; 8 ;]!A!  q! E *8!< * != < =!> >!?C   O!@ ? @]! E!@@   >! !Ax! ! !  6( *4!A *!B A B!C C!DC   O!E D E]! E!@@   C! !Ax! ! !  6, (! )(!O  O7A!  j!  j!1# /G@  1!  60 (!  *8!F  F8 *4!G  G8 C  ?!H  H8$A!!A!"  "j!# # !j!$A!%  %j!& & !j!' '( !( $ (6  )!P  P7A!)  )j!*A0!+  +j!,   * ,l# /G@  *4!IC  ?!J I J!K  K84   *8!LC  ?!M L M!N  N88  A!-  -j!. .$ b}~#!# !A!  k! $    6  6  6A!A !A!	  	j!
 
  u!# G@   *!  8 *!  8 *!  8| *! *!  `!A!  q!@ E  *!  8| *|! *!  !  8 *|! *!  !  8A!  j! ) !A !  j!  j!  7  ) !  7hA ! !  8d@@ *d! *|!  ]!A!  q! EA !  6`@@ (`! (! ! !  I!A!  q! E (`! (! A!! !  n!"  "l!# #!  8\ (`!$A!% $ %j!& (!' ! 'n!( & (l!) )!  8X * ! *\! !C   O!  ]!* *E!+@@ +  !, ,!-Ax!. .!- -!/ /^!# G@  ! *! !  !  !  8L *! *\! !C   O!  ]!0 0E!1@@ 1  !2 2!3Ax!4 4!3 3!5 5]!# G@  ! *!  !  !  8PC  ?!  8T * ! *X! !C   O!  ]!6 6E!7@@ 7  !8 8!9Ax!: :!9 9!; ;^!# G@  ! *! !  !  !  8@ *! *X! !C   O!  ]!< <E!=@@ =  !> >!?Ax!@ @!? ?!A A]!# G@  ! *!  !  !  8DC  ?!  8H *L! * ! *p!  !  ! !C   O!  ]!B BE!C@@ C  !D D!EAx!F F!E E!G G!HA!I H Iu!J H Js!K K Jk!L  L68 *D! *! *t!  !  ! !C   O!  ]!M ME!N@@ N  !O O!PAx!Q Q!P P!R R!SA!T S Tu!U S Us!V V Uk!W  W6< *L! * ! *p!C   @!  !  !  ! !C   O!  ]!X XE!Y@@ Y  !Z Z![Ax!\ \![ [!] ]!^A!_ ^ _u!` ^ `s!a a `k!b  b6, *P! *! *t!C  @!  !  !  ! !C   O!  ]!c cE!d@@ d  !e e!fAx!g g!f f!h h!iA!j i ju!k i ks!l l kk!m  m60 (!n ),!  7A!o  oj!p p nj!# G@  !q  q64 (!rA!sA !t  tj!u u sj!vA !w  wj!x x sj!y y( !z v z6  )L!  7 A!{  {j!| | sj!}A !~  ~j!  sj! ( ! } 6  )@!  7A !  j!A!  j!A4!  j! r   k# G@  (`!A!  j!  6`   *! *!  !  8 *! *!  !  8 *d!C  ?!  !  8d  A!  j! $ `}#AF@##( Axj6 #( ! ( ! (!@@#AF@##( A|j6 #( ( !#A F@# !2 2!A! !3 !4 3 4k!5 5! !6 6$  !7  !8 7 86 !9 9(!: :! !; ;(!< <!A! != !> = >q!? ?!@ !@ @ A! !A AA!	A!
 !B 
!C B Cj!D D! 	!E !F E F !G G(!H H! !I !J I JA!A ! !K !L !M K L MA ! !N !O !P N O PA !A ! !Q !R !S Q R SA ! !T !U !V T U VA ! !W W(!X X!A! !Y Y(!Z Z! ![ [(!\ \! !] ](!^ ^!A(!A2! !_ !` !a !b !c !d !e !f !g _ ` a b c d e f g !h h(!i i!A! !j !k j kj!l l! !m m( !n n! !o o! ! !p p(!q q! !r r! ! ! !  ! ! !s ! s 8 !t t(!u u! A!!  !v !!w v wj!x x!" "!y y( !z z!# #!{ {! ! !| |(!} }!$ $!~ ~! ! ! !  ! ! ! !  8 A!% %! A!& &!  ! * ! !A !' '! ! ! ! !   C  ?! ! ! !   !C  ! ! !  "A !( (! ! ! ! !   C  ?! ! ! !   !C  !C  ?! ! !  " ! *! ! ! * ! ! ! !   C  ?! ! ! !   !C  ?!C  ! ! !  " ! *! !A !) )! ! ! ! !   C  ?! ! ! !   !C  ?! ! !  " ! *! ! ! * ! ! ! !   C  ?! ! ! !   !C  ?!C  ! ! !  "A !* *! ! ! ! !   C  ?! ! ! !   !C  !C  ?! ! !  "#A!+A!, ! ,!  j! !- -! !. +! .!  $%! A !/ /!#A F A Fr@ &#AF@A #A F@A!0 ! 0!  j! !1 1! $  !#(  6 ##( Aj6 #( !  6   6##( Aj6 g
#!	# !A!  k! $    6 (! ( ! '!
# 	G@  
 (! # 	G@ A!  j! $ +}#!# !A!  k! $   6xA!A !A!  j!   u!# G@   (x!	 	-  !
  
:  (x! - !  : 	 (x! - !  : 
 (x! - !  :  (l!A ! ! !  F!A!  q!@@ E  ( !  6|  ( ! !A !  j! ( ! ! (p! !  !  ! (\! !  ! !C   O!  ]! E! @@    !! !!"Ax!# #!" "!$  $6\  (!% %!A !&  &j!' '( !( (!A !)  )j!* *( !+ +!  !  ! (`!, ,!  ! !C   O!  ]!- -E!.@@ .  !/ /!0Ax!1 1!0 0!2  26` (`!3 (p!4 3 4l!5A!6 5 6t!7 (\!8A!9 8 9t!: 7 :j!;  ;6 (!< (p!= (t!> = >l!?A!@ ? @t!A <!B A!C B CK!DA!E D Eq!F@ FE  ( !G  G6| (l!H (!I H Ij!J J-  !K  K:  (l!L (!M M Lj!NA!O N Oj!P P-  !Q  Q: 	 (l!R (!S S Rj!TA!U T Uj!V V-  !W  W: 
 (l!X (!Y Y Xj!ZA![ Z [j!\ \-  !]  ]:  (x!^ ^-  !_ _!C  C!  ! - !` `!  !C  O!  ]!aC    !  `!b a bq!c cE!d@@ d  !e e!fA !g g!f f!h  h:  (x!i i- !j j!  ! - 	!k k!  !C  O!  ]!lC    !  `!m l mq!n nE!o@@ o  !p p!qA !r r!q q!s  s: 	 (x!t t- !u u!  ! - 
!v v!  !C  O!  ]!wC    !  `!x w xq!y yE!z@@ z  !{ {!|A !} }!| |!~  ~: 
 (x! - ! !  ! - ! !  !C  O!  ]!C    !  `!  q! E!@@   ! !A ! ! !  :  ( !  6| (|!A!  j! $  9&}~|#!;# !A !  k! $    6\  6X * != * !> = >]!A!  q!	@ 	E A!
  
j! ( !A !  j!  
j!  6  ) !c  c7H ) !d  d7 A!  j!  j! ( !  6  )H!e  e7 A!  j!A !  j!  j! ( !  6  * !? * !@ ? @!A  A8D *!B *!C B C!D  D8@ *@!E E!h h!i i!F  F8< *D!G G!j j!k *@!H H!l l!m k mf!A!  q!@ E  *D!I I!n n!o o!J  J8< *<!K *D!L L K!M  M8D *<!N *@!O O N!P  P8@A ! !Q  Q88@@ *8!R *<!S R S]!A!  q!   E *8!T T!UC   O!V U V]!! !E!"@@ "  T!# #!$Ax!% %!$ $!&  &6,A !'  '60 (X!( ),!f  f7A!)  )j!* * (j!<# ;G@  <!+  +64 (\!, * !W  W8  *!X  X8$C  ?!Y  Y8(A!-A!.  .j!/ / -j!0A !1  1j!2 2 -j!3 3( !4 0 46  ) !g  g7A!5  5j!6A4!7  7j!8 , 6 8l# ;G@  *D!Z * ![ [ Z!\  \8  *@!] *!^ ^ ]!_  _8 *8!`C  ?!a ` a!b  b88  A !9  9j!: :$ 
~4}#!# !A!  k! $    6  6A!A !A !  j!	 	  u!# G@  A !
  
j! !A!  j!A !  j! A8!  j! ) !A!  j!  j!  7 A0!  j! ) !A!  j!  j!  7 A(!  j! ) !A!  j!  j!  7 A !    j!! !) !A!"  "j!# #  j!$ $ 7 A!%  %j!& &) !A!'  'j!( ( %j!) ) 7 A!*  *j!+ +) !A!,  ,j!- - *j!. . 7 A!/  /j!0 0) !A!1  1j!2 2 /j!3 3 7  ) !  7  /j!4 4( !5A!6  6j!7 7 /j!8 8 56  ) !  7A !9  9j!:A!;  ;j!<A!=  =j!> : < >n# G@  )`!  7 A!?  ?j!@A !A  Aj!B B ?j!C C( !D @ D6  * !A !E E!  ]!FA!G F Gq!H@@@ H  *!A !I I!  ]!JA!K J Kq!L L  * ! (l!M M!  ^!NA!O N Oq!P P  *! (p!Q Q!  ^!RA!S R Sq!T TE *!C  O!  ]!UC    !  `!V U Vq!W WE!X@@ X  !Y Y!ZA ![ [!Z Z!\ (l!] ] \l!^A!_ ^ _t!` * !C  O!  ]!aC    !  `!b a bq!c cE!d@@ d  !e e!fA !g g!f f!hA!i h it!j ` jj!k  k6\ (!l l- !mA!n m nq!oA!p o!q p!r q rG!sA!t s tq!u@ uE  (!v v- !wA!x w xn!y y!  8X (!z z-  !{ {! *X!C  ?!  ! (!| (\!} | }j!~ ~-  ! !  !  !  !C  O!  ]!C    !  `!  q! E!@@   ! !A ! ! ! z :   (! - ! ! *X!  ! (! (\!  j!A!  j! -  ! !  !  !  !C  O!  ]!C    !  `!  q! E!@@   ! !A ! ! !  :  (! - ! ! *X!  ! (! (\!  j!A!  j! -  ! !  !  !  !C  O!  ]!C    !  `!  q! E!@@   ! !A ! ! !  :  (! - ! ! *X!  ! (! (\!  j!A!  j! -  ! !  !  !  !C  O!  ]!C    !  `!  q! E!@@   ! !A ! ! ! (!  :  (! (\!  j! (! (  !  6  A!  j! $ #!# !A !  k! $    6  : A!  6 (!A !  : A !  : A!	  	j!
 
! - !A!  q!A!A!  l!  j!  6    !# G@  A !  j! $ '}#!* * ! * ! *! *!  !  !  !	 *!
 * ! 
 !  	! *0!  !   8  * ! *! *! *!  !  !  ! *! *$!  !  ! *4!  !   8 * ! *! *! *!    !!  !" " !!# *!$ *(!% $ %!& & #!' *8!( ' (!)   )8
#AF@##( A|j6 #( !
 
( !@@#AF@##( A|j6 #( ( !#A F A Fr@_!	#AF@A  	!#A F@ ! !    !#(  6 ##( Aj6 #( !  6 ##( Aj6 A |#!D      ?    "D      ?""D      ?      D>DwQlVDLUUUUU?  "   D8D!>DRO~   |#!# Ak"$  A}jAm"A  A J"Ahl j!@ AtAj( "	 Aj"
jA H  	 j!  
k!A !@@@ A N D        ! AtAj( ! Aj Atj 9  Aj! Aj" G  Ahj!A ! 	A  	A J! AH!@@@ E D        !  
j!A !D        !@   Atj+  Aj  kAtj+  ! Aj" G   Atj 9   F! Aj! E A/ k!A0 k! Agj! 	!@@  Atj+ !A ! !@ AH"
 @@@ D      p>"D      AcE  !Ax! Aj Atj!@@ "D      p "D      AcE  !Ax!  6   Aj"Atj+  ! Aj" G   !# G@  !@@  D      ?|!# G@  D       "D      AcE  !Ax!  !@@@@@ AH"  At AjjA|j" ( "  u" tk"6   u!  j!  At AjjA|j( Au! AHA! D      ?f A !A !A !@ 
 @ Aj Atj"
( !A!@@  A!  A ! 
  k6 A! Aj" G @  A!@@  A! At AjjA|j" (  q6  Aj! AG D      ? !A! E  D      ? !# G@  !@ D        b A ! !@  	L @ Aj Aj"Atj(  r!  	J  E  !@ Ahj! Aj Aj"Atj( E  A!@ "Aj! Aj 	 kAtj( E   j!@ Aj  j"Atj Aj" jAtAj( 9 A !D        !@ AH @   Atj+  Aj  kAtj+  ! Aj" G   Atj 9   H  !@@ A k!# G@  "D      pAfE  At!@@ D      p>"D      AcE  !Ax! Aj j!@@ D      p "D      AcE  !Ax!  6  Aj!@@ D      AcE  !Ax! ! Aj Atj 6 D      ? !# G@  !@ AL  !@  "Atj  Aj Atj( 9  Aj! D      p>!   AL  !@D        !A !@ 	  k" 	 H" A H @ AtAj+    jAtj+  !   G! Aj!   Aj Atj 9  A J! Aj!  @@@@@  D        !@ AH  Aj Atj+ ! !@ Aj Atj  Aj Aj"Atj"+ "  "9   9  AK! ! !   AF  Aj Atj+ ! !@ Aj Atj  Aj Aj"Atj"+ "  "9   9  AK! ! !  D        ! AF @  Aj Atj+ ! AJ! Aj!   +!   9  +!  9  9D        !@ A H @ "Aj!  Aj Atj+ !      9 D        !@ A H  !@ "Aj!  Aj Atj+ !      9  + !A!@ AH @  Aj Atj+ !  G! Aj!      9  9  +!  9  9 Aj$  Aq
~|#!# A0k"$ @@@@  "	B "Aq"AK  A?qA$F@ AK @ 	B S    D  @T!" D1cba"
9     
D1cba9A!   D  @T!?" D1cba="
9     
D1cba=9A!@ 	B S    D  @T!	" D1cba"
9     
D1cba9A!   D  @T!	@" D1cba="
9     
D1cba=9A~!@ AK @ AK  AF@ 	B S    D  0|" D"
9     
D9A!   D  0|@" D="
9     
D=9A}! AF@ 	B S    D  @T!" D1cba"
9     
D1cba9A!   D  @T!@" D1cba="
9     
D1cba=9A|! AK    Dm0_?D      8CD      8"
D  @T!" 
D1cba=""D-DT!c!@@ 
D      AcE  
!Ax!@@ E  Aj! 
D      "
D1cba=!   
D  @T!! D-DT!?dE  Aj! 
D      ?"
D1cba=!   
D  @T!!   " 9 @ Av"  B4AqkAH    
D  `a=" " 
Dsp.;    "" 9 @   B4AqkA2N  !   
D   .;" " 
DI %{9    "" 9      9@ AI      " 9    9A ! 	BB ! A !A!@ Aj Atj!@@  D      AcE   !Ax!  "
9    
D      pA! A! Aq!A !     9 A!@ "Aj! Aj Atj+ D        a  Aj  AvAwj AjAq!# G@  ! + ! @ 	BU    9   +9A  k!   9   +9 A0j$  |#!    "   D|Z:=D+Z  D}W>Da*D?!   !@     DIUUUUU      D      ?    DIUUUUU?|#!# Ak"$ @@  B Aq"AK D      ?! AI  D        p!# G@  !@ AI     !   r!# G@  ! +!  + !@@@@ Aq    p!# G@  !   As!# G@  !   p!	# G@  	!   As!
# G@  
! Aj$  #!@ AI     (# G@      j!@@   sAq @@  Aq   !@    !  !@  -  :   Aj! Aj"AqE  I @ A|q"A I   A@j"K @  ( 6   (6  (6  (6  (6  (6  (6  (6  ( 6   ($6$  ((6(  (,6,  (060  (464  (868  (<6< A j! A j" M   O@  ( 6  Aj! Aj" I  @ AO   !@ A|j"  O   !  !@  -  :    - :   - :   - :  Aj! Aj" M @  O @  -  :   Aj! Aj" G   ~#!@ E    :     j"Aj :   AI    :    :  A}j :   A~j :   AI    :  A|j :   A	I   A   kAq"j" AqAl"6    kA|q"j"A|j 6  A	I   6  6 Axj 6  Atj 6  AI   6  6  6  6 Apj 6  Alj 6  Ahj 6  Adj 6   AqAr"k"A I  B~!  j!@  7  7  7  7  A j! A`j"AK   
#!A#!#!7#AF@##( A\j6 #( !6 6( !  6(! 6(! 6(! 6(! 6(! 6(! 6(! 6( !1@@#AF@##( A|j6 #( ( !4#A F@@@  ! (L! A N!  A!  !	 	w!
 
E! !  !#A F 4A Fr@ {!5#AF@A  5!#A F@ !  !  ! (!#A F 4AFr@   !5#AF@A 5!#A F@ !@ !    ! x@  ! -  ! Aq!    ! y! !  ! (8! !@  ! (4! ! ! E!   ! !    68@ !! !E!" "  !# !$ # $64@ !% %( !&  !' & 'G!( (  !) !* ) *6   !+ +(`!, ,  !- - !. !/ . /r!0 0!1#A F@ 1!2 2   !3#(  36 ##( Aj6 #( !7 7  6  7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 16 ##( A$j6 A 
T~#AF@##( Aj6 #( !S S( !  S(! S(! S(! S(! S(! S(! S(! S( ! S($!3 S((!5 S(,!6 S(0!B S)4!U S(<!G S)@!V S(H!N@@#AF@##( A|j6 #( ( !Q@#A F@  ! A !@#A F@A (W! E! A (W!#A F QA Fr@ {!R#AF@A  R!#A F@ !@#A F@A (W!	 	E!
 
A (W!#A F QAFr@ {!R#AF@A R!#A F@ !  r! !@#A F@! ( ! !   ! E! @#A F@A !@  ! (L! A H!    ! w! !@#A F@  ! (!  ! (!  F!   !#A F QAFr@ {!R#AF@A R!#A F@ !  r!   !#A F@@ !! !E!" "   !# #x  !$ $(8!% %!   !& &#A F@ !' '#A F@@@  !( ((L!) )A N!* * A!  !+ +w!, ,E!- -!@@@#A F@  !. .(!/  !0 0(!1 / 1F!2 2  !3  !4 4($!5#A F QAFr@ 3A A  5  !R#AF@A R!6#A F@ 6  !7 7(!8 8A! !9 9E!: :@#A F@  !; ;(!< <! !=  !> >(!? ?! !@ = @F!A A  !B !C !D C Dk!E E!U  !F F((!G#A F QAFr@ B UA G !W#AF@A W!V#A F@ V#A F@A !  !H HA 6  !I IB 7  !J JB 7 !K K#A F@  !L Lx#A F@ !M M!N#A F@ N!O O   !P#(  P6 ##( Aj6 #( !T T  6  T 6 T 6 T 6 T 6 T 6 T 6 T 6 T 6  T 36$ T 56( T 66, T B60 T U74 T G6< T V7@ T N6H##( A j6 A #!  #! A #!A!@  A+!# G@     -  A G! Ar   A !# G@  "A r   A !# G@  " A r  -  " A F"Ar   A F"Ar   A F#~#!  (<  !# G@  #!
# A k"$    ("6  (!  6  6   k"6  j! Aj!A!@@@@@  (< AjA Aj,!# 
G@  !# 
G@  E  !@  ("F@ AJ  !   ("K"	Atj" (   A  	k"j6  AA 	j" (  k6   k! !  (<   	k" Aj,!# 
G@  !# 
G@  E  AG    (,"6   6     (0j6 !A !  A 6  B 7    ( A r6  AF   (k! A j$  #!# A k"$   6A !    (0"A Gk6  (,!  6  6A !@@@  (< AjA Aj-!# G@  !	# G@  	  ("A JA A !    (  r6  !  ("M     (,"6     kj6@  (0E    Aj6  jAj -  :   ! A j$  
#!  ,#!  (<!# G@  .!# G@  #!# A k"$ @@@@A ,  !# G@   }!# G@  A6 A	!# G@  "A ! A Av!# G@  @ A+!	# G@  	  AA -  A F6 @@ -  A F  ( !@  AA *!
# G@  
"Aq   Ar7  A Aj*!# G@    ( Ar"6  A6P A60   6<  Aj6,@ Aq   Aj7   A +!# G@    A
6P A6( A6$ A6  A6@A - W  A6L !# G@  ! A j$  #!# Ak"$ @@@A ,  !# G@   }!# G@  A6  ~!# G@  ! B7 A !A   Ar )!	# G@  	!
# G@  
" A H   !# G@  "  .!# G@  A ! Aj$  `#!    (H"Aj r6H@  ( "AqE    A r6 A  B 7    (,"6   6     (0j6A K#AF@##( Aj6 #( !L L( !  L(! L(! L(! L(! L(! L(! L(! L( ! L($! L((! L(,!+ L(0!, L(4!- L(8!/ L(<!0 L(@!G@@#AF@##( A|j6 #( ( !J@#A F@@ ! (! ! !  A ! !	 	!
 
 ! (! !@#A F@ ! ! (! ! !  k! !  O!  !  ! ! ! ($!#A F JA Fr@      !K#AF@A  K!#A F@ @@#A F@ ! (P! A H!  ! E!  ! !@@  !  !!   !j!" "! !# #Aj!$ $-  !% %A
F!& & !' 'Aj!( (! !) )E!* *   !+  !, !- !. .($!/#A F JAFr@ + , - /  !K#AF@A K!0#A F@ 0! !1 !2 1 2I!3 3 !4 !5 4 5k!6 6! !7 7(!8 8!#A F@  !9 9!A !#A F@ !: !; !< : ; <u!= = !> !? ?(!@ !A @ Aj!B > B6 !C !D C Dj!E E!#A F@ !F F!G#A F@ G!H H   !I#(  I6 ##( Aj6 #( !M M  6  M 6 M 6 M 6 M 6 M 6 M 6 M 6 M 6  M 6$ M 6( M +6, M ,60 M -64 M /68 M 06< M G6@##( A j6 A %#AF@##( ADj6 #( !' '( !  '(! '(! '(! '(! '(! '(! '(! '( ! '($! '((! '(,! '(0! '(4! '(8!"@@#AF@##( A|j6 #( ( !%#A F@ ! !  l! !@@#A F@ !	 	(L!
 
AJ!   ! ! !#A F %A Fr@   !&#AF@A  &!#A F@ ! #A F@ ! w! !  ! ! !#A F %AFr@   !&#AF@A &!#A F@ !  ! E!  ! x#A F@@  ! !  G!   ! ! A  !   ! !    n!! !!"#A F@ "!# #   !$#(  $6 ##( Aj6 #( !( (  6  ( 6 ( 6 ( 6 ( 6 ( 6 ( 6 ( 6 ( 6  ( 6$ ( 6( ( 6, ( 60 ( 64 ( "68##( A<j6 A W#!# Ak"$     Aq Aj!# G@  !# G@  ! )! Aj$ B  .#!A   /!# G@  !# G@  #!#!#! A #  G@ A #! A #  G@ H#!  !# G@  "( "68@ E    64   6 # G@   #!@@ AH   D      ! @ AO  Axj!  D      !  A AHApj! AxJ   D      `! @ ApM  Aj!  D      `!  Ah AhJAj!   AjB4|#!# Ak"$ @@  B Aq"AK  AI  D        A s!# G@  ! @ AI     !    r!# G@  ! +!  + !@@@@ Aq    As!# G@  !    p!# G@  !    As!	# G@  	!    p!
# G@  
!  Aj$   -#!   !# G@  " A   -   AqF#!@@ Aq"E @  AqE  Aq!@  -  "E  F  Aj" Aq @  ( "As AwjqAxq  Al!@  s"As AwjqAxq  (!  Aj!  As AwjqAxqE  Aq!@@  "-  "E Aj!   G      !# G@  j  #!  !@@  AqE @  -       k  !@ Aj"AqE -    @ "Aj! ( "As AwjqAxqE @ "Aj! -      k0#!@  A`I }!# G@  A   k6 A!   (#!@   A }!# G@    6 A#! ? At}#!A ("  AjAxq"j! @@@ E    M  !# G@  M  0!# G@  }!# G@  A06 AA   6 ##!# Ak"$ @@@@@@@@@@  AK @A (W"A  AjAq  AI"Av"v" AqE @@  AsAq j"At"A j"  A j( "("G A  A~ wq6W   6   6 Aj!   At"Ar6  j" (Ar6
 A (W"M@  E @@   tA t" A   krqh"At" A j"  A j( " ("G A  A~ wq"6W  6  6   Ar6   j" At" k"Ar6   j 6 @ E  AxqA j!A (W!@@ A Avt"q A   r6W ! (!  6  6  6  6  Aj! A  6WA  6W
A (W"	E 	hAtA j( "(Axq k! !@@@ ("   Aj( " E  (Axq k"   I"!    !  !   (!
@ (" F  (" A (WI   6   6	@ Aj"( "   (" E Aj!@ !  "Aj"( "   Aj! ("   A 6 A!  AK   Aj" Axq!A (W"E A !@ AI A! AK  A&  Avg" kvAq  AtkA>j!A  k!@@@@ AtA j( " A ! A !A !  A A Avk AFt!A !@@ (Axq k" O  ! !  A ! ! !    Aj( "   AvAqjAj( "F   !  At!  @   r A !A t" A   kr q" E  hAtA j( !   E@  (Axq k" I!@  ("   Aj( !   !    ! !    E  A (W kO  (!@ (" F  (" A (WI   6   6@ Aj"( "   (" E Aj!@ !  "Aj"( "   Aj! ("   A 6 @A (W"  I A (W!@@   k"AI   j" Ar6   j 6   Ar6   Ar6   j"   (Ar6A !A !A  6WA  6W Aj! @A (W" M A   k"6WA A (W"  j"6W  Ar6   Ar6  Aj! @@A (WE A (W!A B7WA B7WA  AjApqAs6WA A 6WA A 6WA !A !   A/j"j"A  k"q" MA ! @A (W"E A (W" j"
 M 
 K@@A - WAq @@@@@A (W"E A ! @@  ( " K    (j K  ("  A !# G@  "AF !@A (W" Aj" qE   k  jA   kqj!  M@A (W" E A (W" j" M   K !# G@  "  G  k q"!# G@  "  (   (jF !   AF@  A0jI   !  kA (W"jA  kq"!# G@  AF  j!  ! AGA A (WAr6W !# G@  !A !# G@  !  AF  AF   O   k" A(jMA A (W j" 6W@  A (WM A   6W@@A (W"E A ! @   ( "  ("jF  ("   @@A (W" E    OA  6WA ! A  6WA  6WA A6WA A (W6WA A 6W@  At"A j A j"6  A j 6   Aj" A G A  AXj" Ax kAq"k"6WA   j"6W  Ar6   jA(6A A (W6W  O  I  (Aq    j6A  Ax kAq" j"6WA A (W j"  k" 6W   Ar6  jA(6A A (W6WA !A !@ A (WO A  6W  j!A ! @@@@@  (  F  ("     - AqEA ! @@@  ( " K    (j" K  (!   A  AXj" Ax kAq"k"6WA   j"6W  Ar6   jA(6A A (W6W  A' kAqjAQj"    AjI"A6 AjA )W7  A )W7A  Aj6WA  6WA  6WA A 6W Aj! @  A6  Aj!  Aj!   I   F  (A~q6   k"Ar6  6 @ AK  AxqA j! @@A (W"A Avt"q A   r6W  !  (!   6  6   6  6A! @ AK  A& Avg" kvAq  AtkA>j!    6 B 7  AtA j!@@A (W"A  t"q A   r6W  6   6 A A  Avk  AFt!  ( !@ "(Axq F  Av!  At!   AqjAj"( "   6   6  6  6   6     ( j6   !# G@  !  ("  6  6 A 6  6   6A (W"  M A    k"6WA A (W"  j"6W  Ar6   Ar6  Aj! }!# G@  A06 A ! @ E @@  ("AtA j" ( G    6  A  A~ wq"6W AA ( Fj 6  E  6@ (" E    6   6 Aj( " E  Aj  6    6@@ AK    j" Ar6   j"   (Ar6  Ar6  j" Ar6  j 6 @ AK  AxqA j! @@A (W"A Avt"q A   r6W  !  (!   6  6   6  6A! @ AK  A& Avg" kvAq  AtkA>j!    6 B 7  AtA j!@@@ A  t"q A   r6W  6   6 A A  Avk  AFt!  ( !@ "(Axq F  Av!  At!   AqjAj"( "   6   6  6  6 ("  6  6 A 6  6   6 Aj! @ 
E @@  ("AtA j" ( G    6  A  	A~ wq6W 
AA 
( Fj 6  E  
6@ (" E    6   6 Aj( " E  Aj  6    6@@ AK    j" Ar6   j"   (Ar6  Ar6  j" Ar6  j 6 @ E  AxqA j!A (W! @@A Avt" q A   r6W ! (!   6   6   6   6A  6WA  6W Aj!  Aj$   #!
  Ax  kAqj" Ar6 Ax kAqj"  j"k!@@ A (WG A  6WA A (W j"6W  Ar6@ A (WG A  6WA A (W j"6W  Ar6  j 6 @ (" AqAG   Axq!@@  AK  ("  Av"AtA j"F@ ("  G A A (WA~ wq6W   F   6   6 (!	@@ (" F  (" A (WI   6   6@@ Aj"( "   (" E Aj!@ !  "Aj"( "   Aj! ("   A 6 A ! 	E @@  ("AtA j" ( G    6  A A (WA~ wq6W 	AA 	( Fj 6  E  	6@ (" E    6   6 Aj( " E  Aj  6    6  j!  j"(!    A~q6  Ar6  j 6 @ AK  AxqA j! @@A (W"A Avt"q A   r6W  !  (!   6  6   6  6A! @ AK  A& Avg" kvAq  AtkA>j!    6 B 7  AtA j!@@@A (W"A  t"q A   r6W  6   6 A A  Avk  AFt!  ( !@ "(Axq F  Av!  At!   AqjAj"( "   6   6  6  6 (" 6  6 A 6  6  6 Aj#!@  E   Axj"  A|j( "Axq" j!@ Aq  AqE  ( "k"A (W"I   j! @@@ A (WF @ AK  (" Av"AtA j"F@ (" G A A (WA~ wq6W  F  6  6 (!@ (" F  (" I  6  6@ Aj"( "  ("E Aj!@ ! "Aj"( "  Aj! ("  A 6  ("AqAGA   6W  A~q6   Ar6   6 A ! E @@  ("AtA j"( G   6  A A (WA~ wq6W AA ( Fj 6  E  6@ ("E   6  6 Aj( "E  Aj 6   6  O  ("AqE @@@@@ Aq @ A (WG A  6WA A (W  j" 6W   Ar6 A (WGA A 6WA A 6W@ A (WG A  6WA A (W  j" 6W   Ar6   j  6  Axq  j! @ AK  (" Av"AtA j"F@ (" G A A (WA~ wq6W  F  6  6 (!@ (" F  ("A (WI  6  6@ Aj"( "  ("E Aj!@ ! "Aj"( "  Aj! ("  A 6   A~q6   Ar6   j  6 A ! E @@  ("AtA j"( G   6  A A (WA~ wq6W AA ( Fj 6  E  6@ ("E   6  6 Aj( "E  Aj 6   6   Ar6   j  6  A (WG A   6W@  AK   AxqA j!@@A (W"A  Avt" q A    r6W !  (!   6   6  6   6A!@  AK   A&  Avg"kvAq AtkA>j!  6 B 7 AtA j!@@@@A (W"A t"q A   r6W  6   6  A A Avk AFt! ( !@ "(Axq  F Av! At!  AqjAj"( "   6   6  6  6 ("  6  6 A 6  6   6A A (WAj"A 6W#!  $
#! ##! A$A AjApq$#! # #k
#! #
#! #
#! # #!  $ #!#   kApq"$  
#! # 
#AF@##( Alj6 #( ! ( ! (! (! (! (!@@#AF@##( A|j6 #( ( !
#A F@ ! ! !  !#A F 
A Fr@      !#AF@A  !#A F@    !	#(  	6 ##( Aj6 #( !  6   6  6  6  6##( Aj6 A #AF@##( Atj6 #( ! ( ! (! (!@@#AF@##( A|j6 #( ( !#A F@ ! !  !#A F A Fr@    #AF@A  !#(  6 ##( Aj6 #( !	 	 6  	 6 	 6##( Aj6 #AF@##( Apj6 #( !
 
( ! 
(! 
(! 
(!@@#AF@##( A|j6 #( ( !	#A F@ ! ! !  !#A F 	A Fr@     #AF@A  !#(  6 ##( Aj6 #( !  6   6  6  6##( Aj6 
#AF@##( Ahj6 #( ! ( ! (! (! (!	 (!
 (!@@#AF@##( A|j6 #( ( !#A F@ ! ! ! !	 !
  !#A F A Fr@    	 
  #AF@A  !#(  6 ##( Aj6 #( !  6   6  6  	6  
6  6##( Aj6 |#AF@##( Ahj6 #( ! ( ! (! +! (! (!@@#AF@##( A|j6 #( ( !
#A F@ ! ! ! !  !#A F 
A Fr@     
 #AF@A  !	#(  	6 ##( Aj6 #( !  6   6  9  6  6##( Aj6 ~#AF@##( Adj6 #( !	 	( ! 	)! 	(! 	(! 	)!@@#AF@##( A|j6 #( ( !#A F@ ! ! !  !#A F A Fr@     !#AF@A  !#A F@    !#(  6 ##( Aj6 #( !
 
 6  
 7 
 6 
 6 
 7##( Aj6 B #AF@##( Atj6 #( ! ( ! (! (!@@#AF@##( A|j6 #( ( !#A F@ !  !#A F A Fr@   !#AF@A  !#A F@    !#(  6 ##( Aj6 #( !	 	 6  	 6 	 6##( Aj6 A 
~#AF@##( A`j6 #( ! ( ! (! )!	 (! )!
 (!@@#AF@##( A|j6 #( ( !#A F@  ! ! ! ! ! ! B !  !	 !#A F A Fr@   	 !#AF@A  !
#A F@ 
! ! B ! !  ! ! !#A F@ !    !#(  6 ##( Aj6 #( !  6   6  	7  6  
7  6##( A j6 A &#!    B   1!# G@   A$  $#( #(K@  A $#( #(K@  A$  $#( #(K@  A $#( #(K@  #1 A#canvas Shapes example rwa w+                               	                       default     default     text        crosshair   pointer     ew-resize   ns-resize   nwse-resize nesw-resize move        not-allowed   /D  B  ?  C  B  ?  D  HC  ?  ?                  ?                  ?                  ?      ?      ?             DNn ) W' 4 b < AC cQ  a :n$ MB I 	.   ) > 5 D.  &p A~_ 9 S9 9 _ ( ;   / 
Z mm ~6 	' FO f? -_ 'u  ={ 9 R k _ ] 0V {F k   6  ^a  e _ @h  'sM 1 V s {` k G g 	 Y* v  D W >  3~? 2 O }2 &= k ^ 5:   |! j$| n 0-w ;C    ,MA  ] }F q-  3b  |  7U >  Mv d* p c| zW  IV ; 8 $# w ZT#   
  1 fj Wa G ~ "e 2 `  l6	 ]?  X;  "( ( XM 2  } P  [ .4 b H [   HJC g  _B ja 
(   \w  a< sx Z o -c   &g UE 6 ( a w & F Y D M   C )I     p >   (  q> .	 E   { . G {2/ Um r k 1 yJ Ay    1 k __6  H gl qrB ]2  	 1% t9 0  Kh ,X G t $ } nHr    SQ 
  3 K~ ch >_ @]  UR) 7d m 2H2 [Lu Nq ETn 	 *i f ' ]P ; v  Ik} ' i)  T j  ,rP  w 0p  ' q fI d=  ? C  1A 9 p  ; 7+ \ Z   l K 8 Yv b a  @  Iu'  " 
 &/ dv 	;3  Q:   \& mM -z V ? 	 +@ m1 9   [  K N 7 6  Bh c v hR 7  1    dMf  )e0 WV G: j u ( 0 f  "  = W 6	 NB  3#  Oe  ? [x #v { r S on   JX  f v  -  w H ]  /  ?\ m  * %:   S W )- K~  v {Y * -    vl  >p n  (> ag3 * M  mn g9 1[ H 0 -C %a5 p 0 l   l Z !oG b \ paI kV R PU7  3 n_ ]0 .  26   ! i 'w  @- O    /]
 B  }    j\ .U ' U   d A  * k% {4   hjO J* OZ - Z  M  : W_ ? 8   q  ` Me k   QUH  r ; @5 { E N)  A |d d 1  wX i  :< FF Uu_  n .] D >B a )  "| o5   nj   |]t k n >r{ j  )s   Q  t$ }` t ,  ~f ) zv  VE ~6    1' n 6 V   - oW4 ,V    k^ >* _ J  ;m ,    .5 /9a 8!D  
 Jj / S N T" *U   p id &Z` ?R    4- 4 ] ^` g 3  aX W Q > qH -  !,F Y z T O V y "6 8" g U &8  Q 3  iH e  L 6 ! {J ! @ GU t: gB  ^_ {g z U +# AU Yn !* 9G   I@ V  Y +   Z G Cb !; ,y a *L{ , C & x<  { : & g  e+ = | Q 'c i  ) h( 	 D  N pc ~|# 2  V ! * o~M Q   a 6 :  rm 9z  k2\ F'[  4  w U YM q            @!?    -Dt>   F<   `Qx;   9   @ %z8   "6    i5 Ac          G              &RSPQLJMK    ON  F    '()*+,-./0123456789:;<=>?@!    aXYZ[\]^_`V  WbU	
                    T                                          B AC                          DIEH                                                                              ?                  ?                  ?                  ?                              ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              A	"Module.useWebGL = true; GLImmediate.init();" { var canvas = document.getElementById('canvas'); canvas.addEventListener('drop', function(e) { e.preventDefault(); if (e.dataTransfer.file < 0) return; var filenamesArray = []; var count = e.dataTransfer.files.length; var drop_dir = '.rgfw_dropped_files'; Module._RGFW_mkdir(drop_dir); for (var i = 0; i < count; i++) { var file = e.dataTransfer.files[i]; var path = '/' + drop_dir + '/' + file.name.replace("//", '_'); var reader = new FileReader(); reader.onloadend = (e) => { if (reader.readyState != 2) { out('failed to read dropped file: '+file.name+': '+reader.error); } else { var data = e.target.result; _RGFW_writeFile(path, new Uint8Array(data), file.size); } }; reader.readAsArrayBuffer(file); var filename = stringToNewUTF8(path); filenamesArray.push(filename); Module._RGFW_makeSetValue(i, filename); } Module._Emscripten_onDrop(count); for (var i = 0; i < count; ++i) { _free(filenamesArray[i]); } }, true); canvas.addEventListener('dragover', function(e) { e.preventDefault(); return false; }, true); } { return window.innerWidth; } { return window.innerHeight; } document.getElementById('canvas').style.cursor = 'none'; { document.getElementById("canvas").style.cursor = UTF8ToString($0); } /* stb_image - v2.27 - public domain image loader - http://nothings.org/stb
                                  no warranty implied; use at your own risk

   Do this:
      #define STB_IMAGE_IMPLEMENTATION
   before you include this file in *one* C or C++ file to create the implementation.

   // i.e. it should look like this:
   #include ...
   #include ...
   #include ...
   #define STB_IMAGE_IMPLEMENTATION
   #include "stb_image.h"

   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free


   QUICK NOTES:
      Primarily of interest to game developers and other people who can
          avoid problematic images and only need the trivial interface

      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
      PNG 1/2/4/8/16-bit-per-channel

      TGA (not sure what subset, if a subset)
      BMP non-1bpp, non-RLE
      PSD (composited view only, no extra channels, 8/16 bit-per-channel)

      GIF (*comp always reports as 4-channel)
      HDR (radiance rgbE format)
      PIC (Softimage PIC)
      PNM (PPM and PGM binary only)

      Animated GIF still needs a proper API, but here's one way to do it:
          http://gist.github.com/urraka/685d9a6340b26b830d49

      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
      - decode from arbitrary I/O callbacks
      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)

   Full documentation under "DOCUMENTATION" below.


LICENSE

  See end of file for license information.

RECENT REVISION HISTORY:

      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes
      2.26  (2020-07-13) many minor fixes
      2.25  (2020-02-02) fix warnings
      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
      2.23  (2019-08-11) fix clang static analysis warning
      2.22  (2019-03-04) gif fixes, fix warnings
      2.21  (2019-02-25) fix typo in comment
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
                         RGB-format JPEG; remove white matting in PSD;
                         allocate large structures on the stack;
                         correct channel count for PNG & BMP
      2.10  (2016-01-22) avoid warning introduced in 2.09
      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED

   See end of file for full revision history.


 ============================    Contributors    =========================

 Image formats                          Extensions, features
    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
    Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
    Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
    github:urraka (animated gif)           Junggon Kim (PNM comments)
    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
                                           socks-the-fox (16-bit PNG)
                                           Jeremy Sawicki (handle all ImageNet JPGs)
 Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)
    John-Mark Allen
    Carmelo J Fdez-Aguera

 Bug & warning fixes
    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko
    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski
    Phil Jordan                                Dave Moore           Roy Eltham
    Hayaki Saito            Nathan Reed        Won Chun
    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community
    Thomas Ruf              Ronny Chevalier                         github:rlyeh
    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou
    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk
    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar
    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex
    Cass Everitt            Ryamond Barbiero                        github:grim210
    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw
    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus
    Josh Tobin                                 Matthew Gregan       github:poppolopoppo
    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji
    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007
                            Brad Weinberger    Matvey Cherevko      github:mosra
    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]
    Ryan C. Gordon          [reserved]                              [reserved]
                     DO NOT ADD YOUR NAME HERE

                     Jacko Dirks

  To add your name to the credits, pick a random blank space in the middle and fill it.
  80% of merge conflicts on stb PRs are due to people adding their name at the end
  of the credits.
*/

#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x                 -- outputs image width in pixels
//    int *y                 -- outputs image height in pixels
//    int *channels_in_file  -- outputs # of image components in image file
//    int desired_channels   -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'desired_channels' if desired_channels is non-zero, or
// *channels_in_file otherwise. If desired_channels is non-zero,
// *channels_in_file has the number of components that _would_ have been
// output otherwise. E.g. if you set desired_channels to 4, you will always
// get RGBA output, but you can check *channels_in_file to see if it's trivially
// opaque because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *channels_in_file will be unchanged. The function
// stbi_failure_reason() can be queried for an extremely brief, end-user
// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// To query the width, height and component count of an image without having to
// decode the full file, you can use the stbi_info family of functions:
//
//   int x,y,n,ok;
//   ok = stbi_info(filename, &x, &y, &n);
//   // returns ok=1 and sets x, y, n if image is a supported format,
//   // 0 otherwise.
//
// Note that stb_image pervasively uses ints in its public API for sizes,
// including sizes of memory buffers. This is now part of the API and thus
// hard to change without causing breakage. As a result, the various image
// loaders all have certain limits on image size; these differ somewhat
// by format but generally boil down to either just under 2GB or just under
// 1GB. When the decoded image would be larger than this, stb_image decoding
// will fail.
//
// Additionally, stb_image will reject image files that have any of their
// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,
// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,
// the only way to have an image with such dimensions load correctly
// is for it to have a rather extreme aspect ratio. Either way, the
// assumption here is that such larger images are likely to be malformed
// or malicious. If you do need to load an image with individual dimensions
// larger than that, and it still fits in the overall size limit, you can
// #define STBI_MAX_DIMENSIONS on your own to be something larger.
//
// ===========================================================================
//
// UNICODE:
//
//   If compiling for Windows and you wish to use Unicode filenames, compile
//   with
//       #define STBI_WINDOWS_UTF8
//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
//   Windows wchar_t filenames to utf8.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy-to-use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// provide more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small source code footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image supports loading HDR images in general, and currently the Radiance
// .HDR file format specifically. You can still load any file through the existing
// interface; if you attempt to load an HDR file, it will be automatically remapped
// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// We optionally support converting iPhone-formatted PNGs (which store
// premultiplied BGRA) back to RGB, even though they're internally encoded
// differently. To enable this conversion, call
// stbi_convert_iphone_png_to_rgb(1).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// ADDITIONAL CONFIGURATION
//
//  - You can suppress implementation of any of the decoders to reduce
//    your code footprint by #defining one or more of the following
//    symbols before creating the implementation.
//
//        STBI_NO_JPEG
//        STBI_NO_PNG
//        STBI_NO_BMP
//        STBI_NO_PSD
//        STBI_NO_TGA
//        STBI_NO_GIF
//        STBI_NO_HDR
//        STBI_NO_PIC
//        STBI_NO_PNM   (.ppm and .pgm)
//
//  - You can request *only* certain decoders and suppress all other ones
//    (this will be more forward-compatible, as addition of new decoders
//    doesn't require you to disable them explicitly):
//
//        STBI_ONLY_JPEG
//        STBI_ONLY_PNG
//        STBI_ONLY_BMP
//        STBI_ONLY_PSD
//        STBI_ONLY_TGA
//        STBI_ONLY_GIF
//        STBI_ONLY_HDR
//        STBI_ONLY_PIC
//        STBI_ONLY_PNM   (.ppm and .pgm)
//
//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
//
//  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater
//    than that size (in either width or height) without further processing.
//    This is to let programs in the wild set an upper bound to prevent
//    denial-of-service attacks on untrusted data, as one could generate a
//    valid image of gigantic dimensions and force stb_image to allocate a
//    huge block of memory and spend disproportionate time decoding it. By
//    default this is set to (1 << 24), which is 16777216, but that's still
//    very big.

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
   STBI_default = 0, // only used for desired_channels

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4
};

#include <stdlib.h>
typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;

#ifdef __cplusplus
extern "C" {
#endif

#ifndef STBIDEF
#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif
#endif

//////////////////////////////////////////////////////////////////////////////
//
// PRIMARY API - works on images of any type
//

//
// load image by filename, open file, or memory buffer
//

typedef struct
{
   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
} stbi_io_callbacks;

////////////////////////////////////
//
// 8-bits-per-channel interface
//

STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
#endif

#ifdef STBI_WINDOWS_UTF8
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
#endif

////////////////////////////////////
//
// 16-bits-per-channel interface
//

STBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
#endif

////////////////////////////////////
//
// float-per-channel interface
//
#ifndef STBI_NO_LINEAR
   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);

   #ifndef STBI_NO_STDIO
   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
   #endif
#endif

#ifndef STBI_NO_HDR
   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
#endif // STBI_NO_HDR

#ifndef STBI_NO_LINEAR
   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_LINEAR

// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename);
STBIDEF int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO


// get a VERY brief reason for failure
// on most compilers (and ALL modern mainstream compilers) this is threadsafe
STBIDEF const char *stbi_failure_reason  (void);

// free the loaded image -- this is just free()
STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);

// get image dimensions & components without fully decoding
STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit          (char const *filename);
STBIDEF int      stbi_is_16_bit_from_file(FILE *f);
#endif



// for image formats that explicitly notate that they have premultiplied alpha,
// we just return the colors as stored in the file. set this flag to force
// unpremultiplication. results are undefined if the unpremultiply overflow.
STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

// indicate whether we should process iphone images back to canonical format,
// or just pass them through "as-is"
STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

// flip the image vertically, so the first pixel in the output array is the bottom left
STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);

// as above, but only applies to images loaded on the thread that calls the function
// this function is only available if your compiler supports thread-local variables;
// calling it will fail to link if your compiler doesn't
STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);
STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);
STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);

// ZLIB client - used by PNG, available for other purposes

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);


#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifdef STB_IMAGE_IMPLEMENTATION

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
   #ifndef STBI_ONLY_JPEG
   #define STBI_NO_JPEG
   #endif
   #ifndef STBI_ONLY_PNG
   #define STBI_NO_PNG
   #endif
   #ifndef STBI_ONLY_BMP
   #define STBI_NO_BMP
   #endif
   #ifndef STBI_ONLY_PSD
   #define STBI_NO_PSD
   #endif
   #ifndef STBI_ONLY_TGA
   #define STBI_NO_TGA
   #endif
   #ifndef STBI_ONLY_GIF
   #define STBI_NO_GIF
   #endif
   #ifndef STBI_ONLY_HDR
   #define STBI_NO_HDR
   #endif
   #ifndef STBI_ONLY_PIC
   #define STBI_NO_PIC
   #endif
   #ifndef STBI_ONLY_PNM
   #define STBI_NO_PNM
   #endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif


#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#ifndef WIN32
#include <math.h>  // ldexp, pow
#endif
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif

#ifdef __cplusplus
#define STBI_EXTERN extern "C"
#else
#define STBI_EXTERN extern
#endif


#ifndef _MSC_VER
   #ifdef __cplusplus
   #define stbi_inline inline
   #else
   #define stbi_inline
   #endif
#else
   #define stbi_inline __forceinline
#endif

#ifndef STBI_NO_THREAD_LOCALS
   #if defined(__cplusplus) &&  __cplusplus >= 201103L
      #define STBI_THREAD_LOCAL       thread_local
   #elif defined(__GNUC__) && __GNUC__ < 5
      #define STBI_THREAD_LOCAL       __thread
   #elif defined(_MSC_VER)
      #define STBI_THREAD_LOCAL       __declspec(thread)
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)
      #define STBI_THREAD_LOCAL       _Thread_local
   #endif

   #ifndef STBI_THREAD_LOCAL
      #if defined(__GNUC__)
        #define STBI_THREAD_LOCAL       __thread
      #endif
   #endif
#endif

#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
   #define stbi_lrot(x,y)  _lrotl(x,y)
#else
   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)           malloc(sz)
#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
#define STBI_FREE(p)              free(p)
#endif

#ifndef STBI_REALLOC_SIZED
#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
#endif

// x86/x64 detection
#if defined(__x86_64__) || defined(_M_X64)
#define STBI__X64_TARGET
#elif defined(__i386) || defined(_M_IX86)
#define STBI__X86_TARGET
#endif

#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
// but previous attempts to provide the SSE2 functions with runtime
// detection caused numerous issues. The way architecture extensions are
// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
// New behavior: if compiled with -msse2, we use SSE2 without any
// detection; if not, we don't use it at all.
#define STBI_NO_SIMD
#endif

#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
//
// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
// simultaneously enabling "-mstackrealign".
//
// See https://github.com/nothings/stb/issues/81 for more information.
//
// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
#define STBI_NO_SIMD
#endif

#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
   int info[4];
   __cpuid(info,1);
   return info[3];
}
#else
static int stbi__cpuid3(void)
{
   int res;
   __asm {
      mov  eax,1
      cpuid
      mov  res,edx
   }
   return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   int info3 = stbi__cpuid3();
   return ((info3 >> 26) & 1) != 0;
}
#endif

#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}
#endif

#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
#ifdef _MSC_VER
#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
#else
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

#ifndef STBI_MAX_DIMENSIONS
#define STBI_MAX_DIMENSIONS (1 << 24)
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
   stbi__uint32 img_x, img_y;
   int img_n, img_out_n;

   stbi_io_callbacks io;
   void *io_user_data;

   int read_from_callbacks;
   int buflen;
   stbi_uc buffer_start[128];
   int callback_already_read;

   stbi_uc *img_buffer, *img_buffer_end;
   stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context *s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}

static void stbi__stdio_skip(void *user, int n)
{
   int ch;
   fseek((FILE*) user, n, SEEK_CUR);
   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
   if (ch != EOF) {
      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
   }
}

static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user) || ferror((FILE *) user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
   STBI_ORDER_RGB,
   STBI_ORDER_BGR
};

typedef struct
{
   int bits_per_channel;
   int num_channels;
   int channel_order;
} stbi__result_info;

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context *s);
static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context *s);
static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__png_is16(stbi__context *s);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context *s);
static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context *s);
static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context *s);
static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__psd_is16(stbi__context *s);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context *s);
static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context *s);
static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context *s);
static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__pnm_is16(stbi__context *s);
#endif

static
#ifdef STBI_THREAD_LOCAL
STBI_THREAD_LOCAL
#endif
const char *stbi__g_failure_reason;

STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}

#ifndef STBI_NO_FAILURE_STRINGS
static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}
#endif

static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}

// stb_image uses ints pervasively, including for offset calculations.
// therefore the largest decoded image size we can support with the
// current code, even on 64-bit targets, is INT_MAX. this is not a
// significant limitation for the intended use case.
//
// we do, however, need to make sure our size calculations don't
// overflow. hence a few helper functions for size calculations that
// multiply integers together, making sure that they're non-negative
// and no overflow occurs.

// return 1 if the sum is valid, 0 on overflow.
// negative terms are considered invalid.
static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And "a + b <= INT_MAX" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}

// returns 1 if the product is valid, 0 on overflow.
// negative factors are considered invalid.
static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}
#endif

// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}

// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}
#endif

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// mallocs with size overflow checking
static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}
#endif

static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}
#endif

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
   #define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
   #define stbi__err(x,y)  stbi__err(y)
#else
   #define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static int stbi__vertically_flip_on_load_global = 0;

STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
#else
static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;

STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}

#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
                                         ? stbi__vertically_flip_on_load_local  \
                                         : stbi__vertically_flip_on_load_global)
#endif // STBI_THREAD_LOCAL

static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   // test the formats with a very explicit header first (at least a FOURCC
   // or distinctive magic number first)
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif

   // then the formats that can end up attempting to load with just 1 or 2
   // bytes matching expectations; these are prone to false positives, so
   // try them later
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}

static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}

static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}

#ifndef STBI_NO_GIF
static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}
#endif

static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 8) {
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}

static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 16) {
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}

#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}
#endif

#ifndef STBI_NO_STDIO

#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
#endif

#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
{
	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
}
#endif

static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
      return 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}


STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   unsigned char *result;
   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}


#endif //!STBI_NO_STDIO

STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
   }

   return result;
}
#endif

#ifndef STBI_NO_LINEAR
static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, "rb");
   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, "rb");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}

STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, SEEK_SET);
   return res;
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}

#ifndef STBI_NO_LINEAR
static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;

STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
   STBI__SCAN_load=0,
   STBI__SCAN_type,
   STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
   if (n == 0) {
      // at end of file, treat same as if from memory, but need to handle case
      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}

stbi_inline static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}

#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
stbi_inline static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      // if feof() is true, check if buffer = end
      // special case: we've only got the special 0 character at the end
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
// nothing
#else
static void stbi__skip(stbi__context *s, int n)
{
   if (n == 0) return;  // already there!
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
// nothing
#else
static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}
#endif

#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
// nothing
#else
static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}
#endif

#ifndef STBI_NO_BMP
static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   z += (stbi__uint32)stbi__get16le(s) << 16;
   return z;
}
#endif

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
      STBI_FREE(data);
      return stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
      STBI_FREE(data);
      return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
   }
   if (n < comp) {
      for (i=0; i < x*y; ++i) {
         output[i*comp + n] = data[i*comp + n]/255.0f;
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
   stbi_uc  fast[1 << FAST_BITS];
   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
   stbi__uint16 code[256];
   stbi_uc  values[256];
   stbi_uc  size[257];
   unsigned int maxcode[18];
   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
   stbi__context *s;
   stbi__huffman huff_dc[4];
   stbi__huffman huff_ac[4];
   stbi__uint16 dequant[4][64];
   stbi__int16 fast_ac[4][1 << FAST_BITS];

// sizes for components, interleaved MCUs
   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;

// definition of jpeg image component
   struct
   {
      int id;
      int h,v;
      int tq;
      int hd,ha;
      int dc_pred;

      int x,y,w2,h2;
      stbi_uc *data;
      void *raw_data, *raw_coeff;
      stbi_uc *linebuf;
      short   *coeff;   // progressive only
      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
   } img_comp[4];

   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
   int            code_bits;   // number of valid bits
   unsigned char  marker;      // marker seen while filling entropy buffer
   int            nomore;      // flag if we saw a marker so must stop

   int            progressive;
   int            spec_start;
   int            spec_end;
   int            succ_high;
   int            succ_low;
   int            eob_run;
   int            jfif;
   int            app14_color_transform; // Adobe APP14 tag
   int            rgb;

   int scan_n, order[4];
   int restart_interval, todo;

// kernels
   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i)
      for (j=0; j < count[i]; ++j)
         h->size[k++] = (stbi_uc) (i+1);
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= FAST_BITS) {
            // magnitude code followed by receive_extend code
            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            // if the result is small enough, we can fit it in fast_ac table
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}

// (1 << n) - 1
static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}

// bias[n] = (-1<<n) + 1
static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & (sgn - 1));
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static const stbi_uc stbi__jpeg_dezigzag[64+15] =
{
    0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
      r = fac[c];
      if (r) { // fast-AC path
         k += (r >> 4) & 15; // run
         s = r & 15; // combined length
         j->code_buffer <<= s;
         j->code_bits -= s;
         // decode into unzigzag'd location
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; // end block
            k += 16;
         } else {
            k += r;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      // first scan for DC coefficient, must be first
      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
      t = stbi__jpeg_huff_decode(j, hdc);
      if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
      diff = t ? stbi__extend_receive(j, t) : 0;

      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      data[0] = (short) (dc * (1 << j->succ_low));
   } else {
      // refinement scan for DC coefficient
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
         r = fac[c];
         if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) * (1 << shift));
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
            }
         }
      } while (k <= j->spec_end);
   } else {
      // refinement scan for these AC coefficients

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; // force end of block
               } else {
                  // r=15 s=0 should write 16 0s, so we just do
                  // a run of 15 0s and then write s (which is 0),
                  // so we don't have to do anything special here
               }
            } else {
               if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
               // sign bit
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            // advance by r
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) * 4096)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      // so we want to round that, which means adding 0.5 * 1<<17,
      // aka 65536. Also, we'll end up with -128 to 127 that we want
      // to encode as 0..255 by adding 128, so we'll add that before the shift
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      // tried computing the shifts into temps, or'ing the temps to see
      // if any were out of range, but that was slower
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by "s" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
      // 16bit 8x8 transpose pass 1
      dct_interleave16(row0, row4);
      dct_interleave16(row1, row5);
      dct_interleave16(row2, row6);
      dct_interleave16(row3, row7);

      // transpose pass 2
      dct_interleave16(row0, row2);
      dct_interleave16(row1, row3);
      dct_interleave16(row4, row6);
      dct_interleave16(row5, row7);

      // transpose pass 3
      dct_interleave16(row0, row1);
      dct_interleave16(row2, row3);
      dct_interleave16(row4, row5);
      dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
      // pack
      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      // 8bit 8x8 transpose pass 1
      dct_interleave8(p0, p2); // a0e0a1e1...
      dct_interleave8(p1, p3); // c0g0c1g1...

      // transpose pass 2
      dct_interleave8(p0, p1); // a0c0e0g0...
      dct_interleave8(p2, p3); // b0d0f0h0...

      // transpose pass 3
      dct_interleave8(p0, p2); // a0b0c0d0...
      dct_interleave8(p1, p3); // a4b4c4d4...

      // store
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

// wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
   { \
      dct_wadd(sum, a, b); \
      dct_wsub(dif, a, b); \
      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
   }

#define dct_pass(shiftop, shift) \
   { \
      /* even part */ \
      int16x8_t sum26 = vaddq_s16(row2, row6); \
      dct_long_mul(p1e, sum26, rot0_0); \
      dct_long_mac(t2e, p1e, row6, rot0_1); \
      dct_long_mac(t3e, p1e, row2, rot0_2); \
      int16x8_t sum04 = vaddq_s16(row0, row4); \
      int16x8_t dif04 = vsubq_s16(row0, row4); \
      dct_widen(t0e, sum04); \
      dct_widen(t1e, dif04); \
      dct_wadd(x0, t0e, t3e); \
      dct_wsub(x3, t0e, t3e); \
      dct_wadd(x1, t1e, t2e); \
      dct_wsub(x2, t1e, t2e); \
      /* odd part */ \
      int16x8_t sum15 = vaddq_s16(row1, row5); \
      int16x8_t sum17 = vaddq_s16(row1, row7); \
      int16x8_t sum35 = vaddq_s16(row3, row5); \
      int16x8_t sum37 = vaddq_s16(row3, row7); \
      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
      dct_long_mul(p5o, sumodd, rot1_0); \
      dct_long_mac(p1o, p5o, sum17, rot1_1); \
      dct_long_mac(p2o, p5o, sum35, rot1_2); \
      dct_long_mul(p3o, sum37, rot2_0); \
      dct_long_mul(p4o, sum15, rot2_1); \
      dct_wadd(sump13o, p1o, p3o); \
      dct_wadd(sump24o, p2o, p4o); \
      dct_wadd(sump23o, p2o, p3o); \
      dct_wadd(sump14o, p1o, p4o); \
      dct_long_mac(x4, sump13o, row7, rot3_0); \
      dct_long_mac(x5, sump24o, row5, rot3_1); \
      dct_long_mac(x6, sump23o, row3, rot3_2); \
      dct_long_mac(x7, sump14o, row1, rot3_3); \
      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
   }

   // load
   row0 = vld1q_s16(data + 0*8);
   row1 = vld1q_s16(data + 1*8);
   row2 = vld1q_s16(data + 2*8);
   row3 = vld1q_s16(data + 3*8);
   row4 = vld1q_s16(data + 4*8);
   row5 = vld1q_s16(data + 5*8);
   row6 = vld1q_s16(data + 6*8);
   row7 = vld1q_s16(data + 7*8);

   // add DC bias
   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

   // column pass
   dct_pass(vrshrn_n_s32, 10);

   // 16bit 8x8 transpose
   {
// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
// whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

      // pass 1
      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
      dct_trn16(row2, row3);
      dct_trn16(row4, row5);
      dct_trn16(row6, row7);

      // pass 2
      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
      dct_trn32(row1, row3);
      dct_trn32(row4, row6);
      dct_trn32(row5, row7);

      // pass 3
      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
      dct_trn64(row1, row5);
      dct_trn64(row2, row6);
      dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
   }

   // row pass
   // vrshrn_n_s32 only supports shifts up to 16, we need
   // 17. so do a non-rounding shift of 16 first then follow
   // up with a rounding shift by 1.
   dct_pass(vshrn_n_s32, 16);

   {
      // pack and round
      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

      // again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

      // sadly can't use interleaved stores here since we only write
      // 8 bytes to each scan line!

      // 8x8 8-bit transpose pass 1
      dct_trn8_8(p0, p1);
      dct_trn8_8(p2, p3);
      dct_trn8_8(p4, p5);
      dct_trn8_8(p6, p7);

      // pass 2
      dct_trn8_16(p0, p2);
      dct_trn8_16(p1, p3);
      dct_trn8_16(p4, p6);
      dct_trn8_16(p5, p7);

      // pass 3
      dct_trn8_32(p0, p4);
      dct_trn8_32(p1, p5);
      dct_trn8_32(p2, p6);
      dct_trn8_32(p3, p7);

      // store
      vst1_u8(out, p0); out += out_stride;
      vst1_u8(out, p1); out += out_stride;
      vst1_u8(out, p2); out += out_stride;
      vst1_u8(out, p3); out += out_stride;
      vst1_u8(out, p4); out += out_stride;
      vst1_u8(out, p5); out += out_stride;
      vst1_u8(out, p6); out += out_stride;
      vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
   }

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         STBI_SIMD_ALIGN(short, data[64]);
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  // if it's NOT a restart, then just bail, so we get corrupt data
                  // rather than no data
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         STBI_SIMD_ALIGN(short, data[64]);
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}

static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      // dequantize and idct the data
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case STBI__MARKER_none: // no marker found
         return stbi__err("expected marker","Corrupt JPEG");

      case 0xDD: // DRI - specify restart interval
         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
            if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err("bad COM len","Corrupt JPEG");
         else
            return stbi__err("bad APP len","Corrupt JPEG");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); // version
            stbi__get16be(z->s); // flags0
            stbi__get16be(z->s); // flags1
            z->app14_color_transform = stbi__get8(z->s); // color transform
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err("unknown marker","Corrupt JPEG");
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; // no match
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err("bad SOS", "Corrupt JPEG");
      } else {
         if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
         z->spec_end = 63;
      }
   }

   return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         STBI_FREE(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = NULL;
         z->img_comp[i].data = NULL;
      }
      if (z->img_comp[i].raw_coeff) {
         STBI_FREE(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         STBI_FREE(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = NULL;
      }
   }
   return why;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
   // and I've never seen a non-corrupted JPEG file actually use them
   for (i=0; i < s->img_n; ++i) {
      if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
      if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == STBI__MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = NULL;
      j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
      if (stbi__SOS(m)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == STBI__MARKER_none ) {
            // handle 0s at the end of image data from IP Kamera 9060
            while (!stbi__at_eof(j->s)) {
               int x = stbi__get8(j->s);
               if (x == 255) {
                  j->marker = stbi__get8(j->s);
                  break;
               }
            }
            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
         }
      } else if (stbi__DNL(m)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
         if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
      } else {
         if (!stbi__process_marker(j, m)) return 0;
      }
      m = stbi__get_marker(j);
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
                                    int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = stbi__div4(n+input[i-1]);
      out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      // interleave even and odd pixels, then undo scaling.
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      // pack and write output
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      uint8x8_t farb  = vld1_u8(in_far + i);
      uint8x8_t nearb = vld1_u8(in_near + i);
      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
      int16x8_t curr  = vaddq_s16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      int16x8_t prv0 = vextq_s16(curr, curr, 7);
      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      int16x8_t curs = vshlq_n_s16(curr, 2);
      int16x8_t prvd = vsubq_s16(prev, curr);
      int16x8_t nxtd = vsubq_s16(next, curr);
      int16x8_t even = vaddq_s16(curs, prvd);
      int16x8_t odd  = vaddq_s16(curs, nxtd);

      // undo scaling and round, then store with even/odd phases interleaved
      uint8x8x2_t o;
      o.val[0] = vqrshrun_n_s16(even, 4);
      o.val[1] = vqrshrun_n_s16(odd,  4);
      vst2_u8(out + i*2, o);
#endif

      // "previous" value for next iter
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}
#endif

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}

// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); // alpha channel

      for (; i+7 < count; i += 8) {
         // load
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

         // unpack to short (and left-shift cr, cb by 8)
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         // color transform
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         // descale
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         // back to byte, set up for transpose
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         // transpose to interleave channels
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         // store
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      uint8x8_t signflip = vdup_n_u8(0x80);
      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

      for (; i+7 < count; i += 8) {
         // load
         uint8x8_t y_bytes  = vld1_u8(y + i);
         uint8x8_t cr_bytes = vld1_u8(pcr + i);
         uint8x8_t cb_bytes = vld1_u8(pcb + i);
         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

         // expand to s16
         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
         int16x8_t crw = vshll_n_s8(cr_biased, 7);
         int16x8_t cbw = vshll_n_s8(cb_biased, 7);

         // color transform
         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
         int16x8_t rws = vaddq_s16(yws, cr0);
         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
         int16x8_t bws = vaddq_s16(yws, cb1);

         // undo scaling, round, convert to byte
         uint8x8x4_t o;
         o.val[0] = vqrshrun_n_s16(rws, 4);
         o.val[1] = vqrshrun_n_s16(gws, 4);
         o.val[2] = vqrshrun_n_s16(bws, 4);
         o.val[3] = vdup_n_u8(255);

         // store, interleaving r/g/b/a
         vst4_u8(out, o);
         out += 8*4;
      }
   }
#endif

   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* stbi__float2fixed(1.40200f);
      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
   resample_row_func resample;
   stbi_uc *line0,*line1;
   int hs,vs;   // expansion factor in each axis
   int w_lores; // horizontal pixels pre-expansion
   int ystep;   // how far through vertical expansion we are
   int ypos;    // which pre-expansion row we're on
} stbi__resample;

// fast 0..255 * 0..255 => 0..255 rounded multiplication
static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   // nothing to do if no components requested; check this now to avoid
   // accessing uninitialized coutput[0] later
   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

   // resample and color-convert
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

      // now go ahead and resample
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { // CMYK
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { // YCCK
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { // YCbCr + alpha?  Ignore the fourth channel for now
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
      return output;
   }
}

static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__errpuc("outofmem", "Out of memory");
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__err("outofmem", "Out of memory");
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   if (!j) return stbi__err("outofmem", "Out of memory");
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
   stbi__uint16 firstcode[16];
   int maxcode[17];
   stbi__uint16 firstsymbol[16];
   stbi_uc  size[STBI__ZNSYMS];
   stbi__uint16 value[STBI__ZNSYMS];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err("bad sizes", "Corrupt PNG");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= STBI__ZFAST_BITS) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << STBI__ZFAST_BITS)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
   stbi_uc *zbuffer, *zbuffer_end;
   int num_bits;
   stbi__uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int   z_expandable;

   stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static int stbi__zeof(stbi__zbuf *z)
{
   return (z->zbuffer >= z->zbuffer_end);
}

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   return stbi__zeof(z) ? 0 : *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      if (z->code_buffer >= (1U << z->num_bits)) {
        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
        return;
      }
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s >= 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) {
      if (stbi__zeof(a)) {
         return -1;   /* report error for unexpected end of data. */
      }
      stbi__fill_bits(a);
   }
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   unsigned int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
   cur   = (unsigned int) (z->zout - z->zout_start);
   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
   if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
   while (cur + n > limit) {
      if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
      limit *= 2;
   }
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err("outofmem", "Out of memory");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}

static const int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static const int stbi__zlength_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static const int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            return 1;
         }
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
         if (zout + len > a->zout_end) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { // run of one byte; common in images.
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
            fill = lencodes[n-1];
         } else if (c == 17) {
            c = stbi__zreceive(a,3)+3;
         } else if (c == 18) {
            c = stbi__zreceive(a,7)+11;
         } else {
            return stbi__err("bad codelengths", "Corrupt PNG");
         }
         if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
   // now fill header the normal way
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}

static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};
/*
Init algorithm:
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;

   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
}
*/

static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}

STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
   stbi__uint32 length;
   stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}

static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
   return 1;
}

typedef struct
{
   stbi__context *s;
   stbi_uc *idata, *expanded, *out;
   int depth;
} stbi__png;


enum {
   STBI__F_none=0,
   STBI__F_sub=1,
   STBI__F_up=2,
   STBI__F_avg=3,
   STBI__F_paeth=4,
   // synthetic filters used for first scanline to avoid needing a dummy row of 0s
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err("outofmem", "Out of memory");

   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   img_len = (img_width_bytes + 1) * y;

   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
   // so just check for raw_len < img_len always.
   if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

   for (j=0; j < y; ++j) {
      stbi_uc *cur = a->out + stride*j;
      stbi_uc *prior;
      int filter = *raw++;

      if (filter > 4)
         return stbi__err("invalid filter","Corrupt PNG");

      if (depth < 8) {
         if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
         filter_bytes = 1;
         width = img_width_bytes;
      }
      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];

      // handle first byte explicitly
      for (k=0; k < filter_bytes; ++k) {
         switch (filter) {
            case STBI__F_none       : cur[k] = raw[k]; break;
            case STBI__F_sub        : cur[k] = raw[k]; break;
            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
            case STBI__F_avg_first  : cur[k] = raw[k]; break;
            case STBI__F_paeth_first: cur[k] = raw[k]; break;
         }
      }

      if (depth == 8) {
         if (img_n != out_n)
            cur[img_n] = 255; // first pixel
         raw += img_n;
         cur += out_n;
         prior += out_n;
      } else if (depth == 16) {
         if (img_n != out_n) {
            cur[filter_bytes]   = 255; // first pixel top byte
            cur[filter_bytes+1] = 255; // first pixel bottom byte
         }
         raw += filter_bytes;
         cur += output_bytes;
         prior += output_bytes;
      } else {
         raw += 1;
         cur += 1;
         prior += 1;
      }

      // this is a little gross, so that we don't switch per-pixel or per-component
      if (depth < 8 || img_n == out_n) {
         int nk = (width - 1)*filter_bytes;
         #define STBI__CASE(f) \
             case f:     \
                for (k=0; k < nk; ++k)
         switch (filter) {
            // "none" filter turns into a memcpy here; make that explicit.
            case STBI__F_none:         memcpy(cur, raw, nk); break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
         }
         #undef STBI__CASE
         raw += nk;
      } else {
         STBI_ASSERT(img_n+1 == out_n);
         #define STBI__CASE(f) \
             case f:     \
                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
                   for (k=0; k < filter_bytes; ++k)
         switch (filter) {
            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
         }
         #undef STBI__CASE

         // the loop above sets the high byte of the pixels' alpha, but for
         // 16 bit png files we also need the low byte set. we'll do that here.
         if (depth == 16) {
            cur = a->out + stride*j; // start at the beginning of the row again
            for (i=0; i < x; ++i,cur+=output_bytes) {
               cur[filter_bytes+1] = 255;
            }
         }
      }
   }

   // we make a separate pass to expand bits to pixels; for performance,
   // this could run two scanlines behind the above code, so it won't
   // intefere with filtering but will still be in the cache.
   if (depth < 8) {
      for (j=0; j < y; ++j) {
         stbi_uc *cur = a->out + stride*j;
         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

         // note that the final byte might overshoot and write more data than desired.
         // we can allocate enough data that this never writes out of memory, but it
         // could also overwrite the next scanline. can it overwrite non-empty data
         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
         // so we need to explicitly clamp the final ones

         if (depth == 4) {
            for (k=x*img_n; k >= 2; k-=2, ++in) {
               *cur++ = scale * ((*in >> 4)       );
               *cur++ = scale * ((*in     ) & 0x0f);
            }
            if (k > 0) *cur++ = scale * ((*in >> 4)       );
         } else if (depth == 2) {
            for (k=x*img_n; k >= 4; k-=4, ++in) {
               *cur++ = scale * ((*in >> 6)       );
               *cur++ = scale * ((*in >> 4) & 0x03);
               *cur++ = scale * ((*in >> 2) & 0x03);
               *cur++ = scale * ((*in     ) & 0x03);
            }
            if (k > 0) *cur++ = scale * ((*in >> 6)       );
            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
         } else if (depth == 1) {
            for (k=x*img_n; k >= 8; k-=8, ++in) {
               *cur++ = scale * ((*in >> 7)       );
               *cur++ = scale * ((*in >> 6) & 0x01);
               *cur++ = scale * ((*in >> 5) & 0x01);
               *cur++ = scale * ((*in >> 4) & 0x01);
               *cur++ = scale * ((*in >> 3) & 0x01);
               *cur++ = scale * ((*in >> 2) & 0x01);
               *cur++ = scale * ((*in >> 1) & 0x01);
               *cur++ = scale * ((*in     ) & 0x01);
            }
            if (k > 0) *cur++ = scale * ((*in >> 7)       );
            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
         }
         if (img_n != out_n) {
            int q;
            // insert alpha = 255
            cur = a->out + stride*j;
            if (img_n == 1) {
               for (q=x-1; q >= 0; --q) {
                  cur[q*2+1] = 255;
                  cur[q*2+0] = cur[q];
               }
            } else {
               STBI_ASSERT(img_n == 3);
               for (q=x-1; q >= 0; --q) {
                  cur[q*4+3] = 255;
                  cur[q*4+2] = cur[q*3+2];
                  cur[q*4+1] = cur[q*3+1];
                  cur[q*4+0] = cur[q*3+0];
               }
            }
         }
      }
   } else if (depth == 16) {
      // force the image data from big-endian to platform-native.
      // this is done in a separate pass due to the decoding relying
      // on the data being untouched, but could probably be done
      // per-line during decode if care is taken.
      stbi_uc *cur = a->out;
      stbi__uint16 *cur16 = (stbi__uint16*)cur;

      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
         *cur16 = (cur[0] << 8) | cur[1];
      }
   }

   return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   if (!final) return stbi__err("outofmem", "Out of memory");
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            STBI_FREE(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         STBI_FREE(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err("outofmem", "Out of memory");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}

static int stbi__unpremultiply_on_load_global = 0;
static int stbi__de_iphone_flag_global = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_global = flag_true_if_should_convert;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
#define stbi__de_iphone_flag  stbi__de_iphone_flag_global
#else
static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;

STBIDEF void stbi__unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
   stbi__unpremultiply_on_load_set = 1;
}

STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_local = flag_true_if_should_convert;
   stbi__de_iphone_flag_set = 1;
}

#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
                                       ? stbi__unpremultiply_on_load_local      \
                                       : stbi__unpremultiply_on_load_global)
#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
                                ? stbi__de_iphone_flag_local                    \
                                : stbi__de_iphone_flag_global)
#endif // STBI_THREAD_LOCAL

static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      STBI_ASSERT(s->img_out_n == 4);
      if (stbi__unpremultiply_on_load) {
         // convert bgr to rgb and unpremultiply
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         // convert bgr to rgb
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}

#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))

static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3]={0};
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case STBI__PNG_TYPE('C','g','B','I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case STBI__PNG_TYPE('I','H','D','R'): {
            int comp,filter;
            if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
            first = 0;
            if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
            s->img_x = stbi__get32be(s);
            s->img_y = stbi__get32be(s);
            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
               if (scan == STBI__SCAN_header) return 1;
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
               // if SCAN_header, have to scan to see if we have a tRNS
            }
            break;
         }

         case STBI__PNG_TYPE('P','L','T','E'):  {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case STBI__PNG_TYPE('t','R','N','S'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
               if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
               has_trans = 1;
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
               } else {
                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
               }
            }
            break;
         }

         case STBI__PNG_TYPE('I','D','A','T'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               STBI_NOTUSED(idata_limit_old);
               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
            ioff += c.length;
            break;
         }

         case STBI__PNG_TYPE('I','E','N','D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               // non-paletted image with tRNS -> source image has (constant) alpha
               ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
         }

         default:
            // if critical, fail
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = "XXXX PNG chunk not known";
               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
               #endif
               return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
            }
            stbi__skip(s, c.length);
            break;
      }
      // end of PNG chunk, read and skip CRC
      stbi__get32be(s);
   }
}

static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth <= 8)
         ri->bits_per_channel = 8;
      else if (p->depth == 16)
         ri->bits_per_channel = 16;
      else
         return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}

static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}

static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}

static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
	   return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}

static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}


// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) { n += 16; z >>= 16; }
   if (z >= 0x00100) { n +=  8; z >>=  8; }
   if (z >= 0x00010) { n +=  4; z >>=  4; }
   if (z >= 0x00004) { n +=  2; z >>=  2; }
   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
   return n;
}

static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}

// extract an arbitrarily-aligned N-bit value (N=bits)
// from v, and then make it 8-bits long and fractionally
// extend it to full full range.
static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   STBI_ASSERT(v < 256);
   v >>= (8-bits);
   STBI_ASSERT(bits >= 0 && bits <= 8);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}

typedef struct
{
   int bpp, offset, hsz;
   unsigned int mr,mg,mb,ma, all_a;
   int extra_read;
} stbi__bmp_data;

static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
{
   // BI_BITFIELDS specifies masks explicitly, don't override
   if (compress == 3)
      return 1;

   if (compress == 0) {
      if (info->bpp == 16) {
         info->mr = 31u << 10;
         info->mg = 31u <<  5;
         info->mb = 31u <<  0;
      } else if (info->bpp == 32) {
         info->mr = 0xffu << 16;
         info->mg = 0xffu <<  8;
         info->mb = 0xffu <<  0;
         info->ma = 0xffu << 24;
         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
      } else {
         // otherwise, use defaults, which is all-0
         info->mr = info->mg = info->mb = info->ma = 0;
      }
      return 1;
   }
   return 0; // error
}

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;
   info->extra_read = 14;

   if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
      if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
      stbi__get32le(s); // discard sizeof
      stbi__get32le(s); // discard hres
      stbi__get32le(s); // discard vres
      stbi__get32le(s); // discard colorsused
      stbi__get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               stbi__bmp_set_mask_defaults(info, compress);
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               info->extra_read += 12;
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return stbi__errpuc("bad BMP", "bad BMP");
               }
            } else
               return stbi__errpuc("bad BMP", "bad BMP");
         }
      } else {
         // V4/V5 header
         int i;
         if (hsz != 108 && hsz != 124)
            return stbi__errpuc("bad BMP", "bad BMP");
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
            stbi__bmp_set_mask_defaults(info, compress);
         stbi__get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            stbi__get32le(s); // discard color space parameters
         if (hsz == 124) {
            stbi__get32le(s); // discard rendering intent
            stbi__get32le(s); // discard offset of profile data
            stbi__get32le(s); // discard size of profile data
            stbi__get32le(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}


static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
      return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - info.extra_read - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - info.extra_read - info.hsz) >> 2;
   }
   if (psize == 0) {
      if (info.offset != s->callback_already_read + (s->img_buffer - s->img_buffer_original)) {
        return stbi__errpuc("bad offset", "Corrupt BMP");
      }
   }

   if (info.bpp == 24 && ma == 0xff000000)
      s->img_n = 3;
   else
      s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return stbi__errpuc("too large", "Corrupt BMP");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - info.extra_read - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
         // right shift amt to put high bit in position #7
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = STBI__BYTECAST(a);
            }
         }
         stbi__skip(s, pad);
      }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
// returns STBI_rgb or whatever, 0 on error
static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
               // fallthrough
      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24: // fallthrough
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s,9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
      sz = stbi__get8(s);    //   check bits per palette color entry
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       // skip image x and y origin
   } else { // "normal" image w/o colormap
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
      stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}

// read 16bit value and convert to 24bit RGB
static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the "image descriptor byte")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}

static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);
   STBI_NOTUSED(tga_x_origin); // @TODO
   STBI_NOTUSED(tga_y_origin); // @TODO

   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
      return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return stbi__errpuc("too large", "Corrupt TGA");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      //   do I need to load a palette?
      if ( tga_indexed)
      {
         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
            STBI_FREE(tga_data);
            return stbi__errpuc("bad palette", "Corrupt TGA");
         }

         //   any data to skip? (offset usually = 0)
         stbi__skip(s, tga_palette_start );
         //   load the palette
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            STBI_FREE(tga_data);
            return stbi__errpuc("outofmem", "Out of memory");
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            STBI_ASSERT(tga_comp == STBI_rgb);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               STBI_FREE(tga_data);
               STBI_FREE(tga_palette);
               return stbi__errpuc("bad palette", "Corrupt TGA");
         }
      }
      //   load the data
      for (i=0; i < tga_width * tga_height; ++i)
      {
         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               //   yep, get the next byte as a RLE command
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         //   OK, if I need to read a pixel, do it now
         if ( read_next_pixel )
         {
            //   load however much data we did have
            if ( tga_indexed )
            {
               // read in index, then perform the lookup
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  // invalid index
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               STBI_ASSERT(tga_comp == STBI_rgb);
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               //   read in the data raw
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            //   clear the reading flag for the next pixel
            read_next_pixel = 0;
         } // end of reading a pixel

         // copy data
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         //   in case we're in RLE mode, keep counting down
         --RLE_count;
      }
      //   do I need to invert the image?
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      //   clear my palette, if I had one
      if ( tga_palette != NULL )
      {
         STBI_FREE( tga_palette );
      }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   STBI_NOTUSED(tga_palette_start);
   //   OK, done
   return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}

static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         // No-op.
      } else if (len < 128) {
         // Copy next len+1 bytes literally.
         len++;
         if (len > nleft) return 0; // corrupt data
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         // Next -len+1 bytes in the dest are replicated from next source byte.
         // (Interpret len as a negative 8-bit int.)
         len = 257 - len;
         if (len > nleft) return 0; // corrupt data
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}

static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
      return stbi__errpuc("not PSD", "Corrupt PSD image");

   // Check file type version.
   if (stbi__get16be(s) != 1)
      return stbi__errpuc("wrong version", "Unsupported version of PSD image");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
      return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
      return stbi__errpuc("bad compression", "PSD has an unknown compression format");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return stbi__errpuc("too large", "Corrupt PSD");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      stbi__skip(s, h * channelCount * 2 );

      // Read the RLE data by channel.
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            // Fill this channel with default data.
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            // Read the RLE data.
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               STBI_FREE(out);
               return stbi__errpuc("corrupt", "bad RLE data");
            }
         }
      }

   } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

      // Read the data by channel.
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            // Fill this channel with default data.
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    // output bpc
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  // input bpc
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,"PICT"))
      return 0;

   return 1;
}

typedef struct
{
   stbi_uc size,type,channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}

static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask = 0x80, i;

   for (i = 0; i < 4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp = 0, num_packets = 0 , y, chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
    // for the same channel in multiple packets.
   do {
      stbi__pic_packet* packet;

      if (num_packets == sizeof(packets)/sizeof(packets[0]))
         return stbi__errpuc("bad format","too many packets");

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return stbi__errpuc("bad format","packet has bad compression type");

            case 0: {//uncompressed
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1://Pure RLE
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {//Mixed RLE
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

                  if (count >= 128) { // Repeated
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return stbi__errpuc("bad file","scanline overrun");

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { // Raw
                     ++count;
                     if (count>left) return stbi__errpuc("bad file","scanline overrun");

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}

static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);

   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   if (!result) return stbi__errpuc("outofmem", "Out of memory");
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}

static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
   stbi__int16 prefix;
   stbi_uc first;
   stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
   int w,h;
   stbi_uc *out;                 // output buffer (always 4 components)
   stbi_uc *background;          // The current "background" as far as a gif is concerned
   stbi_uc *history;
   int flags, bgindex, ratio, transparent, eflags;
   stbi_uc  pal[256][4];
   stbi_uc lpal[256][4];
   stbi__gif_lzw codes[8192];
   stbi_uc *color_table;
   int parse, step;
   int lflags;
   int start_x, start_y;
   int max_x, max_y;
   int cur_x, cur_y;
   int line_size;
   int delay;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}

static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err("not GIF", "Corrupt GIF");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

   stbi__g_failure_reason = "";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!g) return stbi__err("outofmem", "Out of memory");
   if (!stbi__gif_header(s, g, comp, 1)) {
      STBI_FREE(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;
   int idx;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   idx = g->cur_x + g->cur_y;
   p = &g->out[idx];
   g->history[idx / 4] = 1;

   c = &g->color_table[g->codes[code].suffix * 4];
   if (c[3] > 128) { // don't render transparent pixels;
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); // start new block
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
         if (code == clear) {  // clear code
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { // end of stream code
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) {
               return stbi__errpuc("no clear code", "Corrupt GIF");
            }

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 8192) {
                  return stbi__errpuc("too many codes", "Corrupt GIF");
               }

               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return stbi__errpuc("illegal code in raster", "Corrupt GIF");

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return stbi__errpuc("illegal code in raster", "Corrupt GIF");
         }
      }
   }
}

// this function is designed to support animated gifs, although stb_image doesn't support it
// two back is the image from two frames ago, used for a very specific disposal format
static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
   int dispose;
   int first_frame;
   int pi;
   int pcount;
   STBI_NOTUSED(req_comp);

   // on first frame, any non-written pixels get the background colour (non-transparent)
   first_frame = 0;
   if (g->out == 0) {
      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
         return stbi__errpuc("too large", "GIF image is too large");
      pcount = g->w * g->h;
      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
      g->history = (stbi_uc *) stbi__malloc(pcount);
      if (!g->out || !g->background || !g->history)
         return stbi__errpuc("outofmem", "Out of memory");

      // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
      // background colour is only used for pixels that are not rendered first frame, after that "background"
      // color refers to the color that was there the previous frame.
      memset(g->out, 0x00, 4 * pcount);
      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
      first_frame = 1;
   } else {
      // second frame - how do we dispose of the previous one?
      dispose = (g->eflags & 0x1C) >> 2;
      pcount = g->w * g->h;

      if ((dispose == 3) && (two_back == 0)) {
         dispose = 2; // if I don't have an image to revert back to, default to the old background
      }

      if (dispose == 3) { // use previous graphic
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
            }
         }
      } else if (dispose == 2) {
         // restore what was changed last frame to background before that frame;
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
            }
         }
      } else {
         // This is a non-disposal case eithe way, so just
         // leave the pixels as is, and they will become the new background
         // 1: do not dispose
         // 0:  not specified.
      }

      // background is what out is after the undoing of the previou frame;
      memcpy( g->background, g->out, 4 * g->w * g->h );
   }

   // clear my history;
   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

   for (;;) {
      int tag = stbi__get8(s);
      switch (tag) {
         case 0x2C: /* Image Descriptor */
         {
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
               g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; // first interlaced spacing
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               g->color_table = (stbi_uc *) g->pal;
            } else
               return stbi__errpuc("missing color table", "Corrupt GIF");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
               // if first frame, any pixel not drawn to gets the background color
               for (pi = 0; pi < pcount; ++pi) {
                  if (g->history[pi] == 0) {
                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
                  }
               }
            }

            return o;
         }

         case 0x21: // Comment Extension.
         {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                  // unset old transparent
                  if (g->transparent >= 0) {
                     g->pal[g->transparent][3] = 255;
                  }
                  if (g->eflags & 0x01) {
                     g->transparent = stbi__get8(s);
                     if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 0;
                     }
                  } else {
                     // don't need transparent
                     stbi__skip(s, 1);
                     g->transparent = -1;
                  }
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0) {
               stbi__skip(s, len);
            }
            break;
         }

         case 0x3B: // gif stream termination code
            return (stbi_uc *) s; // using '1' causes warning on some compilers

         default:
            return stbi__errpuc("unknown code", "Corrupt GIF");
      }
   }
}

static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
{
   STBI_FREE(g->out);
   STBI_FREE(g->history);
   STBI_FREE(g->background);

   if (out) STBI_FREE(out);
   if (delays && *delays) STBI_FREE(*delays);
   return stbi__errpuc("outofmem", "Out of memory");
}

static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
      int layers = 0;
      stbi_uc *u = 0;
      stbi_uc *out = 0;
      stbi_uc *two_back = 0;
      stbi__gif g;
      int stride;
      int out_size = 0;
      int delays_size = 0;

      STBI_NOTUSED(out_size);
      STBI_NOTUSED(delays_size);

      memset(&g, 0, sizeof(g));
      if (delays) {
         *delays = 0;
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
               if (!tmp)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               else {
                   out = (stbi_uc*) tmp;
                   out_size = layers * stride;
               }

               if (delays) {
                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
                  if (!new_delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  *delays = new_delays;
                  delays_size = layers * sizeof(int);
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (!out)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               out_size = layers * stride;
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
                  if (!*delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  delays_size = layers * sizeof(int);
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

      // free temp buffer;
      STBI_FREE(g.out);
      STBI_FREE(g.history);
      STBI_FREE(g.background);

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

      *z = layers;
      return out;
   } else {
      return stbi__errpuc("not GIF", "Image was not as a gif type.");
   }
}

static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
      *x = g.w;
      *y = g.h;

      // moved conversion to after successful load so that the same
      // can be done for multiple frames.
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
   } else if (g.out) {
      // if there was an error and we allocated an image buffer, free it!
      STBI_FREE(g.out);
   }

   // free buffers needed for multiple frame loading;
   STBI_FREE(g.history);
   STBI_FREE(g.background);

   return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, "#?RGBE\n");
       stbi__rewind(s);
   }
   return r;
}

#define STBI__HDR_BUFLEN  1024
static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == STBI__HDR_BUFLEN-1) {
         // flush to end of line
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   STBI_NOTUSED(ri);

   // Check identifier
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
      return stbi__errpf("not HDR", "Corrupt HDR image");

   // Parse header
   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return stbi__errpf("too large", "HDR image is too large");

   // Read data
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return stbi__errpf("outofmem", "Out of memory");

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
      // Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {
      // Read RLE-encoded data
      scanline = NULL;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            STBI_FREE(scanline);
            goto main_decode_loop; // yes, this makes no sense
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
         if (scanline == NULL) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               STBI_FREE(hdr_data);
               return stbi__errpf("outofmem", "Out of memory");
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {
                  // Run
                  value = stbi__get8(s);
                  count -= 128;
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {
                  // Dump
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         STBI_FREE(scanline);
   }

   return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   if (p == NULL) {
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) {
      if (info.bpp == 24 && info.ma == 0xff000000)
         *comp = 3;
      else
         *comp = info.ma ? 4 : 3;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy, depth;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 8 && depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}

static int stbi__psd_is16(stbi__context *s)
{
   int channelCount, depth;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   STBI_NOTUSED(stbi__get32be(s));
   STBI_NOTUSED(stbi__get32be(s));
   depth = stbi__get16be(s);
   if (depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}

static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   STBI_NOTUSED(ri);

   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
   if (ri->bits_per_channel == 0)
      return 0;

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
      return stbi__errpuc("too large", "PNM too large");


   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));

   if (req_comp && req_comp != s->img_n) {
      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (
               !stbi__at_eof(s) &&
               (*c == ' ' || *c == '\t' || *c == '\n' || *c == '\v' || *c == '\f' || *c == '\r')
            )
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}

static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9'; 
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
   }

   return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value
   if (maxv > 65535)
      return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");
   else if (maxv > 255)
      return 16;
   else
      return 8;
}

static int stbi__pnm_is16(stbi__context *s)
{
   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
	   return 1;
   return 0;
}
#endif

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
       return 1;
   #endif
   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

static int stbi__is_16_main(stbi__context *s)
{
   #ifndef STBI_NO_PNG
   if (stbi__png_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_is16(s))  return 1;
   #endif
   return 0;
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}

STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}

STBIDEF int stbi_is_16_bit(char const *filename)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}

STBIDEF int stbi_is_16_bit_from_file(FILE *f)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__is_16_main(&s);
   fseek(f,pos,SEEK_SET);
   return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__is_16_main(&s);
}

STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__is_16_main(&s);
}

#endif // STB_IMAGE_IMPLEMENTATION

/*
   revision history:
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
                         1-bit BMP
                         *_is_16_bit api
                         avoid warnings
      2.16  (2017-07-23) all functions have 16-bit variants;
                         STBI_NO_STDIO works again;
                         compilation fixes;
                         fix rounding in unpremultiply;
                         optimize vertical flip;
                         disable raw_len validation;
                         documentation fixes
      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
                         warning fixes; disable run-time SSE detection on gcc;
                         uniform handling of optional "return" values;
                         thread-safe initialization of zlib tables
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) allocate large structures on the stack
                         remove white matting for transparent PSD
                         fix reported channel count for PNG & BMP
                         re-enable SSE2 in non-gcc 64-bit
                         support RGB-formatted JPEG
                         read 16-bit PNGs (only as 8-bit)
      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
      2.09  (2016-01-16) allow comments in PNM files
                         16-bit-per-pixel TGA (not bit-per-component)
                         info() for TGA could break due to .hdr handling
                         info() for BMP to shares code instead of sloppy parse
                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc
                         code cleanup
      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
      2.07  (2015-09-13) fix compiler warnings
                         partial animated GIF support
                         limited 16-bpc PSD support
                         #ifdef unused functions
                         bug with < 92 byte PIC,PNM,HDR,TGA
      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
      2.03  (2015-04-12) extra corruption checking (mmozeiko)
                         stbi_set_flip_vertically_on_load (nguillemot)
                         fix NEON support; fix mingw support
      2.02  (2015-01-19) fix incorrect assert, fix warning
      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
                         progressive JPEG (stb)
                         PGM/PPM support (Ken Miller)
                         STBI_MALLOC,STBI_REALLOC,STBI_FREE
                         GIF bugfix -- seemingly never worked
                         STBI_NO_*, STBI_ONLY_*
      1.48  (2014-12-14) fix incorrectly-named assert()
      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
                         optimize PNG (ryg)
                         fix bug in interlaced PNG with user-specified channel count (stb)
      1.46  (2014-08-26)
              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
      1.45  (2014-08-16)
              fix MSVC-ARM internal compiler error by wrapping malloc
      1.44  (2014-08-07)
              various warning fixes from Ronny Chevalier
      1.43  (2014-07-15)
              fix MSVC-only compiler problem in code changed in 1.42
      1.42  (2014-07-09)
              don't define _CRT_SECURE_NO_WARNINGS (affects user code)
              fixes to stbi__cleanup_jpeg path
              added STBI_ASSERT to avoid requiring assert.h
      1.41  (2014-06-25)
              fix search&replace from 1.36 that messed up comments/error messages
      1.40  (2014-06-22)
              fix gcc struct-initialization warning
      1.39  (2014-06-15)
              fix to TGA optimization when req_comp != number of components in TGA;
              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
              add support for BMP version 5 (more ignored fields)
      1.38  (2014-06-06)
              suppress MSVC warnings on integer casts truncating values
              fix accidental rename of 'skip' field of I/O
      1.37  (2014-06-04)
              remove duplicate typedef
      1.36  (2014-06-03)
              convert to header file single-file library
              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
      1.35  (2014-05-27)
              various warnings
              fix broken STBI_SIMD path
              fix bug where stbi_load_from_file no longer left file pointer in correct place
              fix broken non-easy path for 32-bit BMP (possibly never used)
              TGA optimization by Arseny Kapoulkine
      1.34  (unknown)
              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
      1.33  (2011-07-14)
              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
      1.32  (2011-07-13)
              support for "info" function for all supported filetypes (SpartanJ)
      1.31  (2011-06-20)
              a few more leak fixes, bug in PNG handling (SpartanJ)
      1.30  (2011-06-11)
              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
              removed deprecated format-specific test/load functions
              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
              fix inefficiency in decoding 32-bit BMP (David Woo)
      1.29  (2010-08-16)
              various warning fixes from Aurelien Pocheville
      1.28  (2010-08-01)
              fix bug in GIF palette transparency (SpartanJ)
      1.27  (2010-08-01)
              cast-to-stbi_uc to fix warnings
      1.26  (2010-07-24)
              fix bug in file buffering for PNG reported by SpartanJ
      1.25  (2010-07-17)
              refix trans_data warning (Won Chun)
      1.24  (2010-07-12)
              perf improvements reading from files on platforms with lock-heavy fgetc()
              minor perf improvements for jpeg
              deprecated type-specific functions so we'll get feedback if they're needed
              attempt to fix trans_data warning (Won Chun)
      1.23    fixed bug in iPhone support
      1.22  (2010-07-10)
              removed image *writing* support
              stbi_info support from Jetro Lauha
              GIF support from Jean-Marc Lienher
              iPhone PNG-extensions from James Brown
              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
      1.21    fix use of 'stbi_uc' in header (reported by jon blow)
      1.20    added support for Softimage PIC, by Tom Seddon
      1.19    bug in interlaced PNG corruption check (found by ryg)
      1.18  (2008-08-02)
              fix a threading bug (local mutable static)
      1.17    support interlaced PNG
      1.16    major bugfix - stbi__convert_format converted one too many pixels
      1.15    initialize some fields for thread safety
      1.14    fix threadsafe conversion bug
              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
      1.13    threadsafe
      1.12    const qualifiers in the API
      1.11    Support installable IDCT, colorspace conversion routines
      1.10    Fixes for 64-bit (don't use "unsigned long")
              optimized upsampling by Fabian "ryg" Giesen
      1.09    Fix format-conversion for PSD code (bad global variables!)
      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
      1.07    attempt to fix C++ warning/errors again
      1.06    attempt to fix C++ warning/errors again
      1.05    fix TGA loading to return correct *comp and use good luminance calc
      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
      1.02    support for (subset of) HDR files, float interface for preferred access to them
      1.01    fix bug: possible bug in handling right-side up bmps... not sure
              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
      1.00    interface to zlib that skips zlib header
      0.99    correct handling of alpha in palette
      0.98    TGA loader by lonesock; dynamically add loaders (untested)
      0.97    jpeg errors on too large a file; also catch another malloc failure
      0.96    fix detection of invalid v value - particleman@mollyrocket forum
      0.95    during header scan, seek to markers in case of padding
      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
      0.93    handle jpegtran output; verbose errors
      0.92    read 4,8,16,24,32-bit BMP files of several formats
      0.91    output 24-bit Windows 3.0 BMP files
      0.90    fix a few more warnings; bump version number to approach 1.0
      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
      0.60    fix compiling as c++
      0.59    fix warnings: merge Dave Moore's -Wall fixes
      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
      0.56    fix bug: zlib uncompressed mode len vs. nlen
      0.55    fix bug: restart_interval not initialized to 0
      0.54    allow NULL for 'int *comp'
      0.53    fix bug in png 3->4; speedup png decoding
      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
              on 'test' only check type, not whether we support this variant
      0.50  (2006-11-19)
              first released version
*/


/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
 JFIF       C 		
 $.' ",#(7),01444'9=82<.342 C			2!!22222222222222222222222222222222222222222222222222 
"                <   !1AQaq"2#BR3r$b4C              (      !1AQ"2Ba#qR   ? #'Spi \\\YY@FH-14.7{6 HB@NT2P8
M,	O#\UX	>). +J)JIMe_Y:H+rvN(Jfw=zV:yIoUX {lnU/3+ n|-i,aWF_ 7?e+^ t]9R2i L4 + f(Tsz	_x P i>S-mLF;|\q;Z$U&)W5P P,&kkifckb@$7&6Q_{I oN&&GUi 9AW|^}!$^O)\H2LBP-- 'z55}s8U~kqsK>J5 ilVnXO
AF'8	Pn.IEq "8@F=yA0A&@q-}QxQT=T o8!C EfJdV%z"@ =Xm~9%.P! l}|P:#kUMq1$w;PRXH)O84di(4W$	&teqiS{BtgWX@aib<(.DTk@:"$T-52 ed*7FNS)}3HqW_l+Ly
F\}<7VtWD<
v*l"+Ljd0y
I<)a-D 
2:JntwTz#c
[%lM|K2Vzbh`YspcQOC}h*0S gI+I!2CTS';H1ouwNHUfc%y*2A6B2GsD)&5!p ?+S>Sk`F`>Sb AU>[^h2k}JIc3$q;&icLk~%T'juxnh^T;;]["Y7{m
7xwp* <h1?0@"3$=}@O,8=}
. rut]
B0A|,Y{$@0P1&hZ)I J7e)`>	Jq  R d?D7Q@
=At +YRznRU1A PdZBr}<*d@)
t8)G8?/smdgLi=$~B_D  '3HtW9b)FeXi)MG*E:Rc+=p9VXW*]!L  8$YGU ,xf^IM0H
X!\uxMGU@%4}#YZ$rKrcZdu-sCX9iyFBC<B"Z;@zFC=G`IQW= ZC`:?heJ)d3t.7Pn?Y&SMR08Y&IV4W!-}=%esO-pB	Gwy4ZwP((ad>PIkLLc_E,BW8Y S10p<);	e @s~e^v*c^-MW!M(KaRb"aBU%s$$'u{Q &![A ,'Lf99,Eoa*#pu.$D^R42F#bm7V1A8VA]+;Hp}6VH_DX}y  P6R e.~A /( /( ;%x@	?;%Jd_ %pt| q  /<(!G7"7~U[R[Wsf?2T)bK(wY#)Ho	w.(f{
meu'Y,z)F85gK'JtX r 5&*QC\(,o[9 RL3U)I-zRW4bqZVAcpWcuU H'.Zs e8!hruMDl/ OcKdkp@JS%%FBR d&N?!nSE5pJLBZm2Kz?wI&kdE H$k
{[!|shu,NNDw8x[G<MG__MT]1'&a\*;d(oqm@J|aLw
5@1pqhG)$^6Vl}Qw4)*2Z,^Mb({+I 7pn^H{48Q#[.LK 5|cDeu1 ([oFSb f]|d
B=Uy`'!RbhV?& &s.`>XLA VyCkl+V$n 
z6)hmYFP.#(@E (d Y"/`@<Z ?o	J^(`%_BP~  Dlg) 
 )H^rL*5-PQ+.8U%G3B
2	H;P<{&'` *Rlt+@H4~7
B](0AcTwcM}@#o9YDM+FrEh^I5xNnI$
H;*?kXQ2GO VEN	Z(X0k TMSN$v@e.r~dC5Jy.i.BBZ{psu]2XDS #$S;i"FMa%e$_@bh4nx`Sx-*|p9*6S0MYFEnlHUFkK{t,-N-sJMp}qtdyF~YLpZ4xpt?~N	|%W3N{#8IBQ<#}^
IiaOO91#2);6-+uJ~D /[HM2GnQ*g&yLN5sdnA<4g29+A yR:vY8"9tYX_9uLOVV "HY'e\h@;&mc _pR8F\k dTYh''i3qK[!GxI<(Z65Fm0 #+ o;"7 .m( #t( l  ~{ (JIK9o* ilfZax$[v~k?2`8J.WPGi
>.X5WiU ;)#D@9	$ =;?uqHW\[0ik)'(5
eu6\[HNZmrA&78J)::\.k[< -ka~V^/j>[KNn0''EF6V9Z,)(s%Y`};:}`DZ5G@GM]l6K-cZmXK/wEgIa$$zd;54Nq
Zp8v!rE_NO>|yZ<ge4jxY|%5GL	Ao)h $6;5c.k> 6R[fYD8PXMR{8'0TH}Vd`6>w[M)zPwpUE__  P#NGKX ?l%cdQ/8@	@JT [/###R? pxF#~K?dpi (" &&"4C	$ PZFm~t~5eY$vGq~tgWp>;t*4vxI?/Y!qu`)8j&8lH;Smz/f\7KkQZKN1^W4`mq{,+%wGoOxi74d&pmA1Ild|Z,P2ME#9lMIE#U$P93Q^O` O|<f	| 9sJID d kK 9P4Qk#8B,w{$ ,fkO6o+R'ZF:8@ W`mlI+<qq+J'`F(MY@n THuMXN/)S9LDrE
W$;UueK(G5wi
V/eL#	q;hX;.`o/1xtq`y: g	Fc(18qW  AAElyAV
8Ect+/kdZT{7y9$/y@	A K~@&Qt2mphh9r0Gh8mIhkC{A((aC{R:#,K
xR[Vl:CKBIXPQaUAfe kJ`1d;#a>-3E| 5Y%8t 	tPv{w9qVoH ~Q( zG$p00Bgk5$qg$>t=KCAQb"ra}d*GF>0N1*ywKQyi
l]pk SMZ<2HV@ -t,{Hsw;IV9 6Xf1+|hmvl2K:V4=,96<Q+NF
Ka}
Uhb/|69YHl U+a_
c\!$r!5h8
`NerH"lmX$8e;*>Wf#Z"[2
O	O,/yhRw  8?5sX/AZG(YLOi CB!c5FGA0=Y;, >p,R\~I@ `:EGKHB^v/mh9)k>hg@	XxE &PhcK9@7n\$A;"Z@kJ N<0Ij
 (=L((PZhd0bKP6 D\yID	3`G} 2 Q8! %~MD3 )IC4RA Q 20v]F-wHGi9+eO9c/^7R6t@?X-wi+H
K$sxVfq+3fNdjX+Vkc/{WcQks>#Yn3F9[3tkl?QB0&027
'=$'8SD@7x2HY'tz~Ld*z(gieuC	. oKY,u#	k^yzAklpV_3VgGi. |=8iF5Rf>>?4h|C{l<~:%`!{Q4&wu=2yZ+e(:1,a#jVvREfG8isZK>#-Ef^#calqh3jqtx'%VD3;}N=Z_!R2&c1%P5{Q<	+Q#!_#_{
=i $EI+z QIF7	F}	k	vG*bxKC6JRF 	xh	9J'(E @!ZQ[tdn+`)FW8#	 9t). =F1p)!` c| uWR _R 
P;>&)dedx[
"&nipzLvr 
zwglcb~P=9hpSh$:}ciq?hd}CCP](:5bXvE]D[Kf3w'E~WPC]	[?HU)|MrvsC;y|1oBK 
x7K5YluF 6X34 VB]DWHvKaM[MI(2,St}!Y3@]Nha#b7ZchCMMDK0a-$uxtk oO>eu/p.}4ugq.-uRt_tOH]?O}/m<okWKsu@Ihf,6v(+z3i3kq#^,= 7]7KK9]DKX><GiOs#Hr|5SsHvr8_a{y$kE:~@VB=b$76yG{_Z(.j@AG4wE B_~ 7 @7FAgB(@ @#!>b_ a(G=SQLA -0#s8KT|$@ O3(cJB/%e{#|{ Y@s-6D'ub>(&ci>-<^Nc#69jEeyb UP~e%-3TM$>(~u=A'TA	c/&rF9p%`=\! +R%|^
^ooUiJm<#x'eIcuZ}7YG 	)c7Fmc*.H	 ~c`nUm:A%rSZ:Y?nj-FV#vvv!snf4MKc 5A26>X|jn0cFCA[6I wPo]a>;fzgnGZ$S{_ JY 6YVe:8tnJ	Yp=$kId0'i$8ZlpnlT^Fce(cTjf
4XJi5QL?1M-@qDZ}!lA]1 b[O
[W
k6-fpXnhR\#xVGM<IFrhL.#o*!G+SH!?h	2z-yH?+ ZA[;cQXm [XK8IHSgq1v(HAyJAZKF)GA7=i . /	+)) y x 
-kBL${S:%j?Bs_RQVWt+[otp3Eh!i6e$p*
i5t#I2[U2,E#hkXyY\\@')vIu%qNYmefO3A.8M$]{@4O<O4x\4|lW;qr) 6<o)kI;
) Oa{ mI|%v%H'/}}}U.?6@vw\A7vPj2{
(kI$A+Q8)en/=$0i
YK`nH@^3fK-p\s.Vv]D=n@wA;)O{N	+ >V-Vg/oh5U2XG$$#ln+v49>WkC(G{)+6F;A8Tc9w^S`,Xs	4qP7+!nYZK/umtjnII9S7c(56'et9T]W[ d@-#J6c7*G;~IobHpD&U5TFB+v9P0
I6vPNi}WEdi P'u|_in8c\-<#4?pjm\^XA_u;Z
fRo0k	lZhX0VotG_BB(E(^,n
:8\XWExAREFm~4
8KIQG R=1Ip3ioHQ(tX =Ih"Rg'vb#\4
2a);G)]SY \2$*s@9WFvYfE}yg.&}wQ#r7is`H4/ Gg(*Ms;
 8a!9!YOS]
F$ x'8=R~  U~# [	W >L/
e wT29z	.)|c&ko~
wDNDia+k,Bg#5+MX T#C \Yu 8 ;cfHv2R(h,8ZO@X/|,>*)L${;l
M{ba%J(u6h.$ RM RAUac+JFfgE~Yrq;McbrGs5Sa4%y Q
fS>lh=K"{ nX yk}k!^aJ8B+C/4u W5u{q ={g|]ta2,:koM{&	EIQ:C` dDXN2FFNHF@+XV
P7 N)Tg(LW;>,\El;jU-\R;Lw 5qaXh@@I_FnTs "(x)h}
{%=oRhE'cp@sR%[%l@@cM8XEiY3 bWsJJ4=RF+ PR~xNcM]RZVpn1u(pw)Ev(   E2v67%!y
Ap
MQ<pA=e<B[x>RDy"NRE{)$VJ(R)&3 @N{xW&X88 EU^"]?T:XjQtAO("F+*O[ =kF\0fiy\]lZ2#wfN$6M;I`XE m"F89y	m"?<1<mRWQ!*f 6!9>cu8N54	x%&frP {z$uh*ei2ZC[# &
vQ'p".i4=+@EF;^mOQNS,m.w	>wWC`rS[Dnhi>d/U!%dRk7Tq'4:@>8  )jb;O #|W)lx qw*bI#gi-n;f o<2cccqsV+zmcb<<{Kb%$p,nJ	yVi{px;n6Z,x|ab-sd}Bp}R4BZ@_Cn-.k %_	N{~3Eb4K<;$wj LXiKW4G|*Ad&QG]L6Q60
IW:sBB @ P |
" |$ ui,[J@-T ,`Rvw6
Za Xo<7)F+4och U )k|CM i)c~SH7Gt k N}@6p J$wGu$ Fl`0x N5HwD~%cGQuN6m>+u].T-WE8n'}	_@uv7r&XrVtbG2Vim4_n;v0*M.\Qzg .OpQ& y[#-~XJ|@H3E@<!;Wo+)"FumX5MPM?k+dZFB7X$MC|"O@lfGG
vm1pBthYpkEmwBry\eTu+g:\H+ j` 8~i0UKwN|2~7<$'QEQMvUFCMQ\:iab;Ez:K?2[5xU_#4 8l4>%Y ZG"=A]}|_'5YZ/<',p}DeCCV9I6	_8t#l0MDiz9$pW34Dd;!zDRkKoe\kwsN.	b:)~^FGn^6i{/?_O{5v/&33a :4dQMW>=I,?DNRv v(P!QkH@RcJ-tCsKMM3DPo}W|rGe{"T"8FmR|p'@o )< ]lQH6IXkZK@*)y7tE
r!H	$y@?.9&<O  9('C)MwH |s ;gt !=	`	6 FN@-y _	w@HF
eVw`m]c#Aav"i}6UYL ZJdz'.>.MR4
>/G
PPc4e=|8<}I7Wv[,mp#g1u%$v"XS_oz@=W/:c^l/\s$w;u63OW6\ztNh"i$#`@
tCAyVEJq.yyJhp:H4gNQB.zlzvWck=mzR#J	e^HKCt6Q3v> 3!q	#Cv^:[f!mP 	HHZT!ZEf5LI,2H{.2U$W q # TDaPeS_]*0z=Dm^]e=")s_#KpVKXh6EvvoOx f"GqW_Y'r43'EWaW?@48vX[}d:q  jI+hKpJzK+'P7`utEn)hKumt~>8Sb.V+Fhw!AB(|S'U ^zXdVpG6*0`P#zI TbHK
#b< 4vt.CbqRAk8ZDXhJk<yi\E&wVus;G6Ht&0P?		  ~Tr ]Vo#7!R\v5v| 	7uGJ3TvN{p KH ~8=Lv. R 8	 sT#(4	+mPV8%aAH5\dUI Pm9U|;3[$UdZ}k%=1EX,gu>pePq/pS `Sh r< sy	X)H =biBc!&4o	4%Q .0=cE5z'8h?Dl/kNm;	Lg?7$(eN@u_ v7rZmqfQ||2I=s	[t28Y>H  Wh<+(S'qO/tx)[.0MI4fg=\ & Q!;b#oA`
<$?c4$N
&_(#b=_Qkb pBI'"S=p'slKOug\	wi+:vYU Q!H']Xw|\1X1KkIAKi`%9+F;[rM2m#D:4V+#S=[@7~11tQ'Qwka7^nhGi~#\hSQh0=6+GNucEtHHFIZ]K?R/W$;vU+d&nl4c8LoLpU)>+Z(Uimdukgy)E/*A x^>s4z;E6Qu*0p	{B9DW]	94|*'I  4 uu ]2w;
KLG""VKF*N<+a8vtb8S/|{0uJ;	u<f>Ldcn2Q  U rdg9K b'6Rj/UX/F(pki0170)J`<osMjx	GA)jk
|Z C{( Jn38@pCt ,uFS\$F^vnsN KhN${y@/wJ 7;x0E<&nxnE@w{*##uYcGr}mE[UEgZfS#pq sZmk/M!nGbhT`)y-.CisOf"nrS>xF@I$^soEh;L{ofgOk@  8*#w6 aC<i\@6M{-s
L6
$,BhVc)ce%e>N&,0"0dw	W94lC`kA'=8C]i
*F=
/qoi`],Q0mVge<&idsrZ6f&N<YX2]$*QdX
JF_##dxbuGeRJgi:93u]v-]?Lk `+vCj/kCl&M`4MzfP/UwdEBILv; dlJ4QMp>s0kTV|t18I&9|6
%b<k\#+zv@Ud<OY4|-]LF	Mfj%'r'{<y&d!
8~4].Wibx$A_u	aqy4"M6$Gm' i3G|(h;~pp*5M a_tp@	E'wz E.C5XLKU1NiW^#!w#D NFT#9y3nShH!#riSU1A yO g08<Lb>2	 a8E@'eE!~cDO Iln0,h mJJm =% 8ye>i4n- 	G@utY iXoz'z |8/^3SXooFm!6;biC\-c,hQ;o|t<4R@mXf5<mf	.Fw_$7iF	L,}er|;V- IA'#G\`ule(WH7WnB{=T(/ uNmt m<>j-T~tQ)YNc2mxpIri>p'F/&Wt6!Ln_FK'C*(iaY}Ivnl\llrNg[t8@ 8]%XkMKniCG+,=J]1d7jl-7k&\K,3ts5Gxhz,*lmGX(j$:#F&5!?qcGT~ :y{tZA]I	
MN4n`O]qh\zVehp9W;\DZu}Lvhw[.w4C^C'ImZYc<x.T6?'NeN,Ctka o[xcY?CZTadg8`	0o0:O5?"mK):U$sK]Ss}%[s[;^y%!(;EUmi2hz+RXZ2=}J8 #*B@a?r[cz]=pGd_G#0>{\6?e,tR
{MP|evCydh^cyQ0#b3d
xfEUOGm'qVN08S?%]sY5AE7#e5U5Ws9#k4@ H]uXOq|(od7 	!9!y'bunkGtY	
i2<
b>(ps 3f-/q;_mBp|RH/;zmc cuI4p0u8j#J}cX.v
8THl[m1!IZE4hS1)-cMDs#i$S|-UY.LWb9&b; SC '7vz3/p~	e?8UX?L8Dr,+ 4HF9#:t9~1FKTI"KrgU&		$&P[;th!XyZ?;krTK8gqeW?Feq73D@6y*ORpS l+o,=oS~A-MJ.Xp77M)a[Z[U<&3T&Kwn@/RJ4U5Iut.&6JrdbmS_
i!6;.$78]|tz*<.{:E-f|+:IlQ8,m)KEY6ZHKM+VXIx _HZdef} pTg#c[@WFuM3^ii^Q5wc^bsay_O/6Pvx\n*H.%+VIl y*yZG}UT%$Ak
a dnQT3%Ye<b~i&V=)p>Z5,MJd	OZ OJJp: yX]`O4Vgqi FCud,l+aJ&i4WD>FQ6
K4G1|n=Q
r@$06UHq@$^7Ct<$"hGkW40_P#1HH'm)<yLbqF(rHCEcdc)t?U#@Jz@'kKjmC P]~DHI3&FYErAORE'd|N`aknJA\,dCx[rs jZZxPk\\rU{#7qhiu##14vH)pxn
>4a4>G}N-$dN6
lv}^y26vZ0.WK($0+7U^N*i .;)f5NT:unnrTpdr&DuS4]40QJ^szlM:_VVELdSu=AM5riKL, ZyZT]IzrLXFui]nN. c|yOtjC>KMWWuQ$C-k%= $_u~G&OtpH{@^+$2['&;]I=(^% ^1C?B&p2Zb\ |F)}S3MdU<^KE%h5QPkFj	QO	Cq7+7Fli$m![Bs[ Z&jp`# HGQ.$WM3=F[fH5yW|$3ZgB1xhBtnas;[d	;kzf"8Q$/GV^2k02oehaonFsz;c^F)ge,-DYO 5Dld'ct6-St> er#)y\[5V\ ]h>k#GOPUWktPU;]1ZC'eT+GX#QU&CC"4e8$:*j*M#~xLE@ wN$IH|EYqBhwsU]($$VpDH(E#\jd+\^i) yQpxJ3 .udeiut0^&4?J,&Mw8rUzQEw@) o))S#0aZe1;C-G'+:Z>G2Y4_Q;XQN ZXm	T;n]8c{9!Q@tFNC?K4-~Zs	HL#I
$|oaj=qC<{.||9q+i Bz'N Jp7j	AmH?:%c,FEEIS.3qvLu> 629iy#qkaj){+~3'd<Jy$Y0s:P6'h;$N	lr7L{8El6)r.k68{a"N+oFQhp 	oev@WMb\U7O#]-dtA:+~1#6O{.|EkFm. wiM3 mwH3juB=Y;q,?~Eg|$ Me2>3M30
w*;P3H<)x9i 	'Jy"yRv;NXV0|  gd04u(Q.w+os}wihWTgq#'>kx<$q# !,E>!x^B`o3<txY7W5Cc*db,$wFCl8$+2I(8 ox8ls+wa nC
`A8/IA-7 d`n:G]{=A5ir' C&]CYJ+gsCIq4EWO~Tx5v_B_}:.o,S+Mk`qA#coj;KDNk `x?I.*]rN#to~B5`#/hc6	62L8:Q`Td}DU/y* N W)Z}
VRLdM5}i/u f0o;nO:x4HV8rtL[+k]Y8Z<=q1t u(|kv\i'	?8(1zemcxn3K2ZIHN"g-OwV WT
Frv.*u9a6Q\&0^69@5G*Fa c%$foJ!h,pvS
d&'>D_;qj':H,-dIZtOf)@8+T	PK@%Q<q4Pz=GZ(9uV6%m%%lyOgugVmW)b;+N?HM./NuABas@TzB15o2Zn E/RZ24fdztlG~_/sI eP8N<&O:'<^c"T?hNC+` C{<3cH7'.#?)`mmi 5UH: 8rTscXtVXVAwY+ UeEoszLgJERPk>"/PyG<s_V<GW	=_Vn *inVH\8;*zwzK{SlC*Wv|(&E 8WMuEOk1b  1 )CQ97zhd-}'z(ho$dV[lti>Nc+;u9@u3w=?>u06Be /`46(bk@A@wA[8 eBFaG>t7`479lmcPT)RB}:>+oZL{;E&	3[)@9:mC.KS=NN%V-Y^z./S<GQNJ08Tkq|H gMaqNg]``,Cej@C]JJLJR=q9L>br:$xh kA+J	 A07qItOwe9qL\kAl>>hd,hmynbq $hJcpe^a >ux:1<~+pe8'oSDFk{{]gnI#WTHCtu^HOHvE!}'wL7Olvd_vN.CH @nfx'dArRNy4t E?}c7i{|/U}\[U' NO7!f.?bjYu^IhHbp93+$rE!`6jbs&Lu,xKZCa4v~xS8FKeFrNjb uu{YQ.Lt<l[BCm&8Idu=vVDHk4sDw+B+]D x\i#l5pis%k1^gMO#.q$i'EUH
_5.R$_u:n4z$nBT`Dc$lX#RVqwfhpd_A.?= W~CZvC'\TLJN2MZ6B \~Dd V;CF+#^N::*BU`E<-j_rZ:.(^Bt3O"kwS9QN/i<#z#`3R	m[
(B)UwZ	 Y|{C4?SqB"=PhtAM"|T!/ez!t
^l zK!/B`zAT" (B	}E&	B^}>m,4yuMTgM{.!C.D	|Btw+>Xm
<$N!{n,!r#,0$c&=+H!u`{9IHzpIM1HefIjg1!!r6Vmd~@ZYiABEk e'`	B^0{<L3[xBA^>Fl6B?^1~j_!`BI&_L>"qx0Mk(g|`8Bphcykl4ui'I V'liFY\!,vBL}j 
ghkUeI!< m03y4 XSQ0HKCcn |936Dd B3F>Yfp |,41_2fVuAKcE-^0ek7	Rm3$NgRl}A|:9P.8r|+B"Vt`(B.VwYeduBMT^R_(BW&#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

#define RFONT_RENDER_LEGACY
#define RFONT_NO_OPENGL

#define RFONT_GET_WORLD_X(x, w) x
#define RFONT_GET_WORLD_Y(x, h) y

#define RFONT_GET_TEXPOSX(x) x
#define RFONT_GET_TEXPOSY(y) y

#define RFONT_IMPLEMENTATION
#include "RFont.h"

#define MAX_ATLASES 5

struct {
	u32 color;
	u8** atlases;
	size_t atlasCount;
} RFont_info;

void RFont_render_init(void) { 
	RFont_info.atlases = (u8**)malloc(sizeof(u8**) * MAX_ATLASES);
	RFont_info.atlasCount = 0;
}

u32 RFont_create_atlas(u32 atlasWidth, u32 atlasHeight) {
	u32* atlas = (u32*)malloc((atlasWidth * atlasHeight * 4) + sizeof(u32));
	atlas[0] = atlasWidth;

	RFont_info.atlases[RFont_info.atlasCount] = (u8*)(&atlas[1]); 
	RFont_info.atlasCount++;
	
	return RFont_info.atlasCount - 1;
}

void RFont_bitmap_to_atlas(u32 atlas, u8* bitmap, float x, float y, float w, float h) {
	u8* buffer = RFont_info.atlases[atlas];
	u32 atlasWidth = *((u32*)RFont_info.atlases[atlas] - 1);
	
	RSoft_copyBuffer(buffer, atlasWidth, bitmap, RSOFT_RECT(x, y, w, h));
}

void RFont_render_set_color(float r, float g, float b, float a) {
	u8 color[] = {r * 255, g * 255, b * 255, a * 255};
	RFont_info.color = *(u32*)color;
}

RGFW_window* win;


void RFont_render_text(u32 atlas, float* verts, float* tcoords, size_t nverts) {
	u32 atlasWidth = *((u32*)RFont_info.atlases[atlas] - 1);
	for (size_t i = 0; i < nverts; i += 6) {
		RSoft_vector npoints[3] = {RSOFT_VECTOR2D(verts[i], verts[i + 1]), 
								   RSOFT_VECTOR2D(verts[i + 2], verts[i + 3]), 
								   RSOFT_VECTOR2D(verts[i + 4], verts[i + 5])};
	
		RSoft_setTexture(RFont_info.atlases[atlas], RSOFT_RECT(tcoords[0], tcoords[1], 
														atlasWidth, RFONT_ATLAS_HEIGHT), 
														RSOFT_AREA(atlasWidth, RFONT_ATLAS_HEIGHT));
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(npoints[0].x, npoints[1].y, 
						(npoints[2].x - npoints[0].x), abs(npoints[0].y - npoints[1].y)), (u8*)&RFont_info.color);	
	}
}

void RFont_render_free(u32 atlas) {
	for (size_t i = 0; i < RFont_info.atlasCount; i++)
		free(((u32*)RFont_info.atlases[i] - 1));
	
	free(RFont_info.atlases);
	RFont_info.atlasCount = 0;
}

void RFont_render_legacy(u8 legacy) { }


int main(void) {
    win = RGFW_createWindow("Basic buffer example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
   
    RFont_init(win->r.w, win->r.h);
    RFont_font* font = RFont_font_init("DejaVuSans.ttf");

	RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
	
	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized) {
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
				RFont_update_framebuffer(win->r.w, win->r.h);
			}
		} 

		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 255});
        RFont_set_color(0.0f, 1.0f, 0, 1.0f);

        RFont_draw_text(font, "abcdefghijklmnopqrstuvwxyz", 20, 0, 120);
	
		RGFW_window_swapBuffers(win);
    }

	RFont_font_free(font);
    RGFW_window_close(win);
}

#define RGFW_IMPLEMENTATION
#define RGFW_BUFFER

#include "RGFW.h"

#define RSoft_rect RGFW_rect
#define RSoft_area RGFW_area
#define RSoft_point RGFW_point

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define RSOFT_IMPLEMENTATION
#include "RSoft.h"

RSoft_matrix rotateAroundCenter(RSoft_vector center, float angle) {
	RSoft_matrix m = RSoft_initMatrix();
	m = RSoft_translateMatrix(m, RSOFT_VECTOR2D(-center.x, -center.y));
	m = RSoft_rotateMatrix(m, angle, 1, 1, 1);
	m = RSoft_translateMatrix(m, center);
	return m;
}

int main(void) {
    RGFW_window* win = RGFW_createWindow("Textures example", RGFW_RECT(0, 0, 800, 800), RGFW_CENTER | RGFW_TRANSPARENT_WINDOW);
    
    RSoft_setBufferSize(RGFW_getScreenSize());
    RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));

	int w, h, c;
	u8* buffer = stbi_load("tex.jpg", &w, &h, &c, 4);

	float angle = 0;

	i8 running = 1;    
	while (running) {
        while (RGFW_window_checkEvent(win)) {
            if (win->event.type == RGFW_quit || RGFW_isPressed(win, RGFW_Escape)) {
                running = 0;
                break;
			}

			if (win->event.type == RGFW_windowResized)
				RSoft_setCanvasSize(RGFW_AREA(win->r.w, win->r.h));
        } 
		
		RSoft_clear(win->buffer, (u8[4]){0, 0, 255, 15});
		RSoft_vector v1 = RSOFT_VECTOR2D(700, 100);	
		RSoft_vector v2 = RSOFT_VECTOR2D(500, 100);	
		RSoft_vector v3 = RSOFT_VECTOR2D(600, 200);

		RSoft_setTexture(buffer, RSOFT_RECT(0, 100, 200, 100), RSOFT_AREA(w, h));
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 150), angle));
		RSoft_drawTriangleF(win->buffer, (RSoft_vector[3]){v1, v2, v3}, (u8[4]){255, 225, 225, 255});

		RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 200, 200), RSOFT_AREA(w, h));
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(250, 250), angle));
		RSoft_drawRectF(win->buffer, RSOFT_RECTF(150, 150, 200, 200), (u8[4]){255, 225, 225, 255}); 
		
		RSoft_setTexture(buffer, RSOFT_RECT(0, 0, 100, 100), RSOFT_AREA(w, h));
		
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(200, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(200, 600, 100, 100), 6, (u8[4]){255, 225, 225, 255});
		
		RSoft_setMatrix(rotateAroundCenter(RSOFT_VECTOR2D(500, 600), angle));
		RSoft_drawPolygonF(win->buffer, RSOFT_RECTF(500, 600, 100, 100), 360, (u8[4]){255, 225, 225, 255});

		angle++;
		RGFW_window_swapBuffers(win);
    }
	
	free(buffer);
    RGFW_window_close(win);
}

<!DOCTYPE html>
<html>

<head>
  <title> RGFW test </title>

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color: rgb(200, 200, 200)
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <style>
    #log {
      white-space: pre-wrap;
      /* To preserve whitespace and line breaks */
      background-color: #000000;
      color: #f1f1f1;
      padding: 10px;
      border: 1px solid #120808;
      max-height: 100px;
      overflow-y: auto;
      font-family: monospace;
    }
  </style>

  <style>
    .header img {
      float: left;
      width: 80px;
      height: 80px;
      background: #555;
    }

    .header h1 {
      position: relative;
      top: 18px;
      left: 10px;
    }
  </style>
</head>


<body style="background-color:rgb(15, 25, 45);">
  <div class="header">
    <a href="https://colleagueriley.github.io/RGFW/"> <img src="https://github.com/ColleagueRiley/RGFW/blob/main/logo.png?raw=true" alt="RGFW logo"> </a>
    <h1>RGFW WebASM Example &nbsp;&nbsp;&nbsp;&nbsp;
  
    <a href="https://github.com/ColleagueRiley/rsoft/blob/main/examples/textures.c">Source Code</h4> </a>

    </h1>
  </div>
	
  <div style="text-align:center;">
    <canvas id="canvas">
    </canvas>
  </div>


  <script src="textures.js"> </script>

  <div id="log"></div>

  <script>
    (function () {
      var logContainer = document.getElementById('log');
      var originalLog = console.log;

      console.log = function (message) {
        if (typeof message === 'object') {
          message = JSON.stringify(message, null, 2);
        }
        logContainer.innerHTML += message + '\n';
        logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to the bottom
        originalLog.apply(console, arguments);
      };
    })();
  </script>

</body>

</html>
 JFIF       C 	

			

		
 C	                	 j 
	
  !1AQ"aq2B	#Rbr$3C%4Stu&(68EcfsFTVdv'5DUW            	 K   !1AQaq"235BR4br#$SC%&DTs   ? S@ @ @ @W)`%pF3; deMNZnmu">#C
ZJ=]MorquO+1'^,.W=Zq8MyW?lYj ;vvU=8 .?=W/  , W  ~_g  ^ Yc pd??{tXx .??Y2}9 C;|+ JX}9vSjjpV^^qZ jt_hGq6qL	C+3<sBQ]%P0xrR;b	 @ @ @ @ @ @ @ @ @ @ @ @U${x8 Iv&)|4>-)`$y]^eK R!_Qj[??yj[d EVAxq0nB gr6=t\ H?Z'b_er5K~ @ @ @ @ @ @ @ @ @ @ @ @MHFM}TG(|cn|3NcK[ P-rd}2+B-> JgnFxqRQ
]/Dq5\qoxjq[h?F' _e2is                         *XKoY]Uh\[D?>2Az:e6on[?+KfyX*xi{A}EhI>7Gtn "Z } _'PU; @ @ @ @ @ @ @ @ @ @ @ @h	>^)]t:{xegvd{~iK`,#Veljuuwa		^Jpw9' 3efLm( U~GEOM=}|q j<Val#F1Wc~eeYhi&6u|I[=yIH]OT ?U2*MIC^HsN'?q jo~v Gj*5T|+g	WN}{~eOZXg=%-:YnWfqM!Fqs*\yd~ChMT-(O(                        #\}M,N3@t.6YqGCfIrz-(@i` fbdu@-j'(G&vA4[ seT8\GPnlAPZG>N-V\9PO~r(V<y= @ @ @ @ @ @ @ @ @ @ @4V;T62^@b,rFJfecw  /( i~:+&PItm(Z]=^A;D4gF23=tYc< (.>{}
il13@yhKt.t 2D|[(j
'!: @ @ @ @ @ @ @ @ @ @ @1k:c[OX 4b g4 4PN=
ky2W$:{]CqWts-.Z:5RHq$=$|O>(y#cye>hlgk)G4nk(y,CUW(]C(-GF|=Eu~?8d}mn3)@Lz2qe[WPZ5@l1H9^>($ @ @ @ @ @ @ @ @ @ .73 @]R3goz A?+-*_)d4y67ZG[8!}<
4T[twOG(}1vMgQ\)|wi#@n96_yIj"fPkJheOu1=@zAD;NH*mDd*Mqn9u.Q]DEW[N6=5vp|Gb                  
=ot6m#v=p@t^&Q60]u(7% )kBAko	'7wq&d"*dO"'0z`qJH+swydUMoa @f$VYE6;w \BJ;(M_M.10?.Lr>% 1o4]U+47r;'nv }Ud5SUorDs*t33|<5S*DGf$>#@hP @ @ @ @ @ @ @ @<qz>4il`.?@`lq@\T{PKCVI\]M#y\Brt.Ti1<Gd ;RJXji^dvI@Z 8D,79hsHx93U?z4)Pk{5
g\wy<N+|{Z.bAPk#C=T$on:{#=l,;P %n4GQO3K^%5+$tMe@QY#H-@L9dm)tGhwV|ZZ#! @ @ @ @ @ @ @ @rE=;#`Uhn4Tz@i A@R~wMPX !)i.xqxZCI?gP !x_5qN OG\Gv\NotCngJ{I7a@RlZiE=l~69^y8AEV;zvp!@ih.Nk6VBCb>@^=z@@QWP5--.ImqWg @ @ @ @ @ @ @ @|GCW 6*v0&[ ^^@j-j
d9K;r+GR':GO^ Ax0gv<l
 @M~STA+$4o:TvlWzg:WpF	VT>x'2BIo@tk5_oMK>n~iw;ZDjao8e Gs3:CFY]Ep}$c[-zyw&VH~G>rL               *}-r6_!E&5PU8g1'  +<=	^
zu@I/'zy ;E @ @JXukmx=2jAwIGpRfpcp *6M 6kf]"9AP#@#!] 6x$ , @ @ @ @ @ @ @\ 6!u3Hrgi=B27@]St5 nP(-NA[+C0>$nks
:nvb}Dovsd_   k6-:*A;77@|4Z\ma (n<@[a.;|2?[MA=iVr)u( A;<              )5OH8,hlM@mhN@\trD/@(
r7iH]4Hbdn4o  5v5Fz= ;*YL8x@ @>ia;zx09pVhMIS/5Q	7Gx ;qk}Y}dU04-h3W*Q,nu(mr5V[vf!,'#              2<Yqc )o@t-&P8!uJ /-R@i!w4`=2QXc@V\	LydE\>FVtlwL$=[>z @ @uzcovpKG3:n@<	@u67u@vM!(&r)P7*WF0a
zq;(@ @ @ @ @ @ @ @`(U }f[<[Av(Ghks_@ZJZ5C26
r'(
:'<B#Qzo <,=m?i FchX/t\.z?5(    >j:_(-wgdDx .UW8sFPoH27g.&es#'g}, @ @ @ @ @ @ @ud,e75T.s4(:g)nk(Y
OT%|cuHPO73i@Be_Qw@qWE<.cg-cIyaDE?)c4   wI_+iiE{'~y$HNP[=I|ED@|jsQ3o              ^?gevd; -]@ZF)@]S0.TI6pg#M;k)1S	 `q{Bw !=s(f
b	UK##in#Sonm=GmOH/?g84 @y)	-
ih0,HD+AcXQ0Od @ @ @ @ @ @ @i s}9Jc;$P	=|PJs8sF*)w1bJ|D]cN<=g!2Gk B,ah7mW_/?4o@vvI }~@i  @+|cZY.~5cw}HF5ra(XI6S@`z*#(@ @ @ @ @ @ @+?z 0 4`=Tpr*BPPKl4 APja(hsA#y#9&&PPlD?<?@p0gZ2Ih3`+	Bx  B{}PX.<LNGnOT@utn18n/^ WVd}4ou4&H+'xG;'Te\#qhr"g|P0 oODgUvg:EYA@L@ @ @ @ @ @ @Z C=ZO7,!v
{Pv6PQH9 +>O@Gf1pkCGAHl|/!pV4=w82dlu|| =~OoE=6cH@XNAQ89y%ov~c/-H              :Ivs 4~zsP9!6@s9, a@{r{R@zb	
H #L0	8{G ^P}E@Cs/~:unecP1@q$ &@K0zDQ@4rOA5x<|S#> @ @ @ @ @ @ @ut>UIpZBv@[@XDw@Mz %%%a>3v]by:ezz5_-R<%hh1.OveX@AqGBtNC!8	f: 9;p@F@gn@lL+c @ @ @ @ @ @ @q h jbq>wdNt.l>c	?!tlwP79@&<t@D8'@E 	@p>>cKL($O~&@r/Dva/=D
dr_Gk-@ @ @ @ @ @ @]qI)iJN=wTo	QBDrJ\ Pa:|w@Ln~@r4(k<@@zh@q:o#9bDz4 <88$ 8Oz0 #J@@AeWReQX}Wc]q>u-H@oP @ @ @ @ @ @s~LH	 ?W6~T#Z[   t?|^#v@K..	P@NiA@rNCIt@	!{ z 8$}s(3*jwYVBXs8~Bd?2jhy @ @ @ @ @ @ @0SQ=\z;X\z?8i)c\dVcPh@P}`%U Pc1%L $G[; 1TW:Pr\G-j<~4wZ<~ $6D}@r@{]? <|BG3pp^O pP~HfqJo\,*TF|P5BSyJ}'})H"*XH;@l @ @ @ @ @ @$5'kI2VuQi>^qtUbG$%X*OD.-"csi?!x*jMSLqxVNf?r\rw/l.16jvGi/a&w:'gvDfH2w{jTo;wgA@Me	v(@r6C-T8B6v<m =KLM4 <|BQ3T@{@z>izV 5.BRw}R%?NV9CQ OyVy+e^5'?(8+54t]UYXYVR[t9F"> pV=            jA60Q.#fqWcJLO,QfRt=UMtQJjErzI5t5R'BB`<emIV) 0Z-}W{m{H$,A 5db*u7?BY-<FK1]^[\vL9_#2i"4u"BIdm<PpgIG[';:wvwR^n;DR[$|S9pllhc?Xugirjz5cukmj(,r%Tt{q#s3X;(7v =Ju(kr;nv6k~mSW%;*dwhCI'~6iF6R}Dn!rLlU*'l'^o#U_m	ZQl8epa`'5Xz-mw~y7qxZ8&ZF5?O-[p@b0Gz"(kqNPJ;J+GoT.O+)lSS6z>r@D .8 S*_W:nknj}tL.Lb2 2dd5JP?Jy=1|bt Zz6vz&Z~[4LU=Cv:j
XO4	 1^eF7+%JUqx
mE&-Vb+UZUHmd;7n ?/)~#W94IO-w%6G4Zya0x'>{,Op	bI)Z/76[xG)cQ#},nx\\S7dOC_wB0~qmFJmZk^?[6e{Ky $$8lGU~'"_IOg:ubUC]LJYkB}ybOvUOQc*9~
zTbkW+Rtw{-37t366
*U+K[}iJvSz{\3VjT[#[^
+'nOznE @ @ @ @ @ @_qR7	%f	gR0=2?KEzicHd,pB+QjA)+J9E.Oq6@K&kz6@OOC^k4Qg;/WZ5K7_Ga*k]b$v2f8[WF~|:r5=tN~Se{Tip^)z"1xI{sOx,9XfKduqv]%6	*MPq+/HK_m 1(L=hVew"<{WEeW]WUW2:Y%4alrCllIgFOB5#8r7wYh^^"cxDq7)U1='9Q*p&JW}.FoN4\eM[88.6z;MkxCU-9#u4o@ix\rzBrK_Bg|+z&*{M1qT\Ak}lt\A>rahwa"{r^?)p<(rJ^rR\<noMsjul<Km:j546:J_D`Zg'xk\0S.Z=KGC.t/IUe.eS{]ESSL)h=
vWTZ6;I(y_$uU]{J_)|:X*Jp^uGoCg'IuQOQGGf:Q-23:@9n".`3'YZm&xiBFZz*7[VodHg)8QSfV_8H#cqF2:&a{s
jrj$IoB-eMa8M]~&)	a"RL;UrU&+WE3(S$IJRnh]\5w~km?|K$VVP%<HSHkNjI[kCF#!>SU)FvSg+_WCStImluSGLyS'x950@S*)^/ZArK5$Ss~hihoVqKOwAl-&"1pWe	j_E_htV:ov$O['-uHkt/hZ[ws-U9UU*pmOYnI=f{l6[ouMi]Jy#5n6k@ORk-:3w.<q"8EXG*))_E}v	W.=p~yIVB<9j5.S<L`	t5 dk<)[UrL<QtOELx?3/,^ozGic{^5.2/R~sL~"W2nFR @8]i5nf6qi oTp/.)^u6G=Hs=,nCT9Txw,WyCwV^U;O7T(R4,:oNO^-wr7[L@ @ @ @ @ @ @=2gS6i[ f[
Fr>/d~ L?WBz+sV6eN:)p!Mt *QTH[
vQ0"k[&s+%2K>fLz%Rv$1^Zrg;Z:u{^ryYgzy{Gz9d-2N8
#:3WPRg$JiiS$m<= {B`[NTA+]"b$I*,O+,o<$J+*&S+'%X:mGU
6|%K?aOWi?5s,N]nkX-h @ @ @ @ @ @vJs_<vhW=>/d~^]nTig-7O1:aKhJgL6W!n|Uj2WE%oW7##wIfIc}P>Dm e9@K[9cI^#7=h^.N8Uom`j62lb
.UL[YmQSQMdt
4#|TD/F-'0a_-)swjvx:C/~+_3Mq&R|48*'tW)Et_ SQK%xf!QL8&QY5Wge,tr	$?a7gJ)E-L]#2O9_Ly%' .KDPjn4iY*"}a%ot#)]&'fdkW<wSHte,T5rLL1uWjK]KzHd=JPLPFI?b{@n cp'}'>7\%f             q]LEX""c='av=W4S^ 9tl7Wz)Ok
e=Za)PPn-l
u B"OIU'b4Q)^6Y)`
"}ETi8XyGY5YYF6J"=wuNgQSv,g49e'.N_-gIRWqRpC
+* @{,xk>{2ey/F?y5>Lq>kG ,V;>"{>k(jY$R~/w-4bl'_<.>idR^;2O;bRma\[I,'q<zUofv__fuJZen\h7_0}qtBEghco_pnEk0FM rN5{6k6|G(nbx4Wqn!BMWOBq/|l=-H9A)*|sj0Y:JN|ac_-=omZbz[-3L	or&i*=c2R%>V
^D{ #b|t,&uQsw^:._5tw\Nq-5bw57'+X%1+A+]](VdlWwR&RuQKSSU
oBg(U	p 
dSCmSgK Es*g;u/d+_k>Z            	FL	0~#e{,bfG~Tn?y~1a&{SR:,i#
\3ilT*2WlWe.Ez9Nl)uz{L^%ch2Hz6h'G=YY0<F>}FW:> ;Iox^z8/N]{O~(o(}%53:QS>ohpSL-s|~yqO~zmE-;pt#,5Rl&J`d{-6jCY &SpkWe}jq]n4:>N~!w7pg<Azy>CRS5Hq_SdpJ;-/ig}0p~,q.v
2q}Ks'5Q&STt`7/\N9xIqg^Rk8&X/'NGNfc~LS7w%^sJX\D3Yt5(;7aB8|bpA!YsZKaG?EUw'WSV9EXbby2||CE}zCG+; H>&*yZ/oJkik-hF>&xdLtqL5)F%fu&fn{Qaw	b0R|ixEsU}1_|vXEqhS .wn$S\i;>|I9bis_^o;Lx7E}.;/5QQndFCKt*5EtrJE^=B"}6etN*eT&S+*)|O+j)2! FlJ|ue:ulyN}\<Gq$rjNUUb@ @ @ @ @ @ @^9_UwgG27^eOK0eN]>Kg4)U0*=JxHB}G*h0"-IX+-!@D)KXm^x$C1+N^4dtWu&F8%UV<)IhgYoB%A !@.	fcZe}goeW[MV8 {8^oImFi=#'-G]i%%4#i`%xMW_f=}\]Ic1<~S~ldkDyf" ptlP~|:\*yToV[
lbZLPZ6Y7qHSe+W>=P`eiezRU7|9uP=xI2f^RxjN.QKx=V}p3}$L%H77r6k:?_x#Vqf=Xj)9bFUq,N_QA]MX"<kWjRO kwc:Xi=lg'o0e2"eMe9yJgcsyWp;T2?Ii+asVQ$WoIIka5i}<9F5T&)naWJF"#RBEMD"d
=jM3	N.HrOn#<W~.?[Go$t !Rp@ @ @ @ @ @ @6OkN'{,b~jGVqwZB8 rxUGzl$Ud'z)p"JE0jBp5wKM
Ji^-{Hg;hWapS*?G2. x)BZz> z]s"l8%HO+SkSNsmdq_`<yB
k).	}8/ kzHZJi+2	hSq yL~bWvG~P<KnymY,$ky5A<;{`Y/{.`glFC$cGpp#ec	FWzhrh25>h[fOktmj8y#51oh$clg[CNN.[0Yf*Poky+{H^t%*	#:$FY6}+8
B}?{!p]u5N&aw#ssFJ.wb>K-nerL"w`n*>;]icc]1$@a=F	[U^<>SN)/v_!yIM%vKmD4uR9KUML9$vqWWLe<&cNk5v
9OrO 09].JWee^
+/g
vk]%Ul|cs2K+l~8xgu 8s_	*5f:oGfv^mn"j90Apk\79qnw_/a,M{2:.t_c:u'
m_@cJW67y%.B|BK=<=S({[t^MC5wi=yiMY4v[=4lA7Zm6l3g>"5ts4*U^=zgev thdtus>i)_iGke:9ls[{=A3|1|:2o_e(yg9-B;3VMF`s\3x>'FCp!{;'y@^)qV-TwZ1Yh|#b^tTPWS;*y2<BlW>`x>fb0oy*QvJ->mv5F-mz=]3)WH\v >
0l?((tu]_\_ys	kWmM]Bv{+6'~HSNq-IeeE9+3	DHF<U8{yC~~tNg:/-C^2u:NEZU4h}\             OpU7 |)0 $lav=OHEQx!O 9t7gjQYc2dTDce&I6Imp`U^O[R,`^},o1 NF_i>|+qs- YQOJZ1
\|p]$CKI'6|2i/~v[|?j N4~o_yaUWTE=At %L]${g[ge5XRir~NRQob"XDpVCmZdhkOBV?OPSxidzV;5={=FLF{t>_n_"eq?_Gm<bkBv (?X\Ws g_I?4?#WK L_*U
/WvGf&IGN];]!._;- V;:jYuLo<z2</Zui +O|1p='o4*l q : v!<7)pAb	FCUKpjG
f,w7clke!|EM}Y43^1O>ip9;Lc+>a]7Z/}YyM[<s<)q 	\&]+nK<qjF~{JON?}([tg,{oo_=b<ogkf?@qMU+55(Zn_6j{Ln+& ++#]DJQ?U]i2:+l	&';+3$tfrM!Pd3T$/^{n=\<5t{Ek|             e9exkA!s
DgR?S?]G
r9&*gV'37)0#JW9
J,9\MOa]LR-ia$>ZYDiZY,dZfg:Z5&To(7B'T
x}]kfb.6lK1^<3
i-_i&k~%`?92 t of[fnZkn&Px6rnmK*eR-X
8j~p\MY,pE<n{y|KtxZ 39%	a)Ktt? -<+l{g};4M%Zw)?6<?j75mV\?n]A ^g $!# 2YTw|x')5'f[^*q"s)o,bst37WMk^1G7hk]-e;mtkdo<aa- yeeYam;>CS,,M_uv]0<9 T 5Y~7pb )St7d r?q# o&RrIu ,g  2^Qc7}G[Gw5U\^#|X+6+F_]>:cA-60;Akp^7e}7|fZTIjY'iGjhFq'(xHNZwGKi8IO,Pb:GG3+%kZO7?12u#9/et:P;[7zVVul9lR^<cDLL[:3UmiJri9J/F=c,n5bNq>'k$P~zg*UxJu~:}> @ @ @ @ @ @7Ngg~*ygR?+H*/zu<3~j7GJ[h)y=@JdZ\0}DdG!l <+V-sFp)4gu&}y}u=_A'~x
XV_oOIo.	2L[{::GP(nc5k
4crL_4R>N#F#U]5i5G7a:_rT9|f KymDWK:EXe[	'MTk:Pqq:Ge{O8l1,;Ya';r`')JWz6ZT::fJs5H!ysF;6*9.3 ]R53:FMWIKNjb0X0H&J9vaA9K[^Ua%fv`(-~+Ga3*|+KM&8SuuK55e5;$X9G($wl=$ZhA|FjZNWZ	;_SCUk}CP|'Dy\rlT-gRn5_Knir/*kk?gdCKR,?w;>3_i|/(\Lc|YD<&PL69)k	C 	YN6U::{_cx>IaR"fk=;U:oQ$J[a`h ;{L=\`#EogQcX9\'3}<vqK,	gzM91=8ecU\3^Y~]=E(15_rem+xei]6a9{3pUn+eJ8-

IJwgd$c$kY5s9`J ^~>"v;Q72;>:mB<Z94hX#MS9m>%rpI+1<nu&gJjKmKiO	mQOVVDbG4,pl:90m]G^[8SvO^+I29UIl-O2RCS=n_3<v<Zxe'<T7 8swwp[qKbJ<vUyj"u)!N\##_$ZJl0wZI!9yC-_0e%^go6J#pK-n>X: @ @ @ @ @ @3(WEI.ed{U?wp2sS'^u,/GW3P$lDy*&Aw{HkU7li>)/Q% 3j?\V&c~T F\%$mSJpoXiY $8	Y|*zT,.Ua1>V5^4y8/9Ice})ZYn_etVYm	2<~!p&8v-TT?@8S8W:*5M.xB~	QqTEKPe_/xFscSW+^sQq(9e25UhMqWVj~)oSUV1Hrzcl6C1	g<MIq~? ,?.@|97~1#'	5Vh_%]wT|1MW#\\\93;Le8Lm5N.^$jY;azgs{p&1X[{^{Sn/\UKp%&xZv  1-k.b^&Wk.2OQ~#(*50c	sFH(	upim_fXt+;/k:pSLGh-W5:4Pdi-6ORWyv6Xl}R:q3Dk#hJ-4V:Gg6R\MG+k7,[Ky{.8?k&3Ih_q7c'n4T:F=8[ 0s*%UlWq-bt=/u%+q
x~K#$4e>W*/Gg5dg[vB;EvNhKX_b3&36hDr9Ia\iV[L>soNFMgcvvI6u	yI@5V|W1;)]:L`N'9%o**
X+&[i0*yA{m3kg2\43Xg+_U j^f3sCQrqWlLOGuvR@yyF	#(;:rw1\Q_4@l6 :+T$PEr6Nx n8/5Rx:.QRs7hv)+fB             q4-@t c^<iIYw(GCX< .o|)E,UD*KVG1G3B^xtk7'B}[2an{kHz~{jJkqjs+nG4!#e
n7M]QXrQN>L9kZk8 !mQt8Ktxk\bFt
aY#o ^6zhAT9AaI#-W)-l=h9(=]'FTL7%C*uc:kDNUn[*^+}s}K,^[/g^NIu0X-X{5/u}-\1,9fz+:]\p|
f%EEViRC8 12VqdV
5*] k^<a=d#(~bR_AWY}Q$RWh]WH	5Qv%fSw$G4Ro}>`$Kn8/L,OK3acw+{K\<;~GMVJ/fkeRi=vROl\6N4NGcZ	*?3T^#V4d^\BW7$Z'M::70 5o,l/K#,LM3WuNOZ_r%eVRBZ0#r~Y\6|n
 a/n
<.CLTM}_+,f_{U;;o@%bYVj#f[_?TdGQkPA~%d5m{ApU1z/. 6tw{7KQAIH=4lG@e<:V#QM:|(aV?D\.U.=Gb1S)-8.qWE$K1$`d[V=:sRo5}hK^G5Hd,/y6,<Q}6nSR4BUy-7No+Z?Ave{g`uZm#9$8t?qMjV4~Zs;N|?<>7t<~' gB             qsr.v{Nrp]K rW2v'<U!O+S sb)rmiMN!h:k$S5VlhZ	i4GKXqqPI^ai.k%{-}VTkUJnBO))&Frqg<mhzTzAda%\]F](4K4hZZy2u@t5` @^8[=n:JSUBAd/qx:7pueW+c_|^|%(8_~X|W=8R
}__[nO7^R[nk3|0gB8g`pZrMI]eQW4r] SbV{U<4r^_xWn>sGo 59 MR6iy[dN.=zqs*_YxmZUL-dGHcsTH VU3Z5O&9H0K%0~2Oo3eW9I*}r'Gx<E,&]tGBkN \Krx'/5O`Xl%\KTA?g_xi{Je8+dlCujXROJT2sKolFfQsc#I#k+e+E$Ni|]ITE]e@^]\z7ol0xz*8^'}eI19k&UZ`
}>j+3WS-IX8#"qk_j},t8Ul`?6I6ci;wtr<<$y&=eZl!t0gI[v{f3[}TrR$QOYWE1p)_*|w~?}Fl             -#_r 1p0?twE i 
S4V'*5Q1:ZF 7;m`C4veZ'|0+a6l\5hsRniqWbC#F8}%,#sh046d#wdUM!J,h#LsY2+d@ mdZJ[%JRYu]qXhK5!n:rzq+}=|ziD}|?UgnSLO]ZAX\^W-[IvI8)u~>z/]OpUIT=22D;GE/.y*y(Ze~|{lZ8l P>=7qr,/Gz.cu,79u$+J:M7/8y9U5={E]DLg`X>j\+{>lur_K ,"Sw{x^)SZ+E{,:h4-ost#H>T+Jcd35vJOuS@O]VI{JE<z\~kN5&ckN}V9d>TpUo+g/KI*N,~*bJ:qG<q6[EDM>W,s#q T+f/ L|\<E->WeE] lVTRl4n\@#K_bDbQH$t;NpEl99L*wrN&M$j'V]OYqDFC|oRky%m-?8u8ZuVY             1aO}c	sx?q@~dd__5?_U)|Luz RfD# IctX+jTV[@KkM
'fM7<lFs87#Je>2P&RY-85VH04V9iJ=J:ti'iV@7\V+V+Ffpx*3LzNoIm-MhR[MtluZfYNbNFCUF*rgI8w54>XVz-U|mSK^9w%*\sQTt*>qE.5SKOErL  ~o6P4m=,L,\\&tU:6WA=J>A_Ycx#
<VJ_*~g
p\]V7%k[kqBND~LqYoj;p. C$o3{	k @x.,}8MzZk:B Ip}]1 I,yyv+TM,~%6^3H*h>YQ}6+&,3o:9'`7[#OH#4s)ckb3H|>u]MK[gRVZ6GX[(	y% 98J>nj6w^ZtZlj< jht4B#`X0UU^\y4lw5RZX]rC^A;XJp4VzehJsqgeMMuu.,694#/.nqFgKK7{
V]z4<+4%452vnb{C| FnX,8A5rK<wBihkxp{KpZC|(tm[?W!2;RUi=to=7^auV_gI^K%A!s>UY>\bZCH!|Mi 0N=tE_H%>\n#1;'%KQ);u#)RIPPSGpc\^1'7k~>br~%Rg /gkf             q}(--{UA>7e
q9u,Zo|-~[*aSKK]_p@/R;uPw-":fWHV|OEfKIVVK21cKC dnvdS*> (R)cJZM9'eZq-z5)GrP#Ly2[Dq+hcx38s(hNRV^Z8xoTm6jE+`s#3;
^r[Uc.vX}OQwZc6:7rAcCysjj_v[},ufmY-qbAe-eqfsovQ*|PMQ]OQ>RVnEU;TCd#E(ie}6`9qVrwwJ<Zv=~6]EjzE|dqL_-,R=I;_dyXyURn.Mj+N<VJVz|u6zw+]4k.5j
{}C1sfkTVJP/P|tRjWjUcI|^c4:Y*	+Kih$WW^4cR]Do7[OFWI5U;EDH")Z{^7he)W}I.m,xQ&ZW}y8wm5-iTIZ##xh>}-9LC~r[:cKX3\IPM`*;EWP]u;o3GNjk3DesoOUTk[]w,|%TU?E]v'\_SS585%4H$g **chZ5g,{FmkN~yG3j+Gp4wY]CResj 6pr|*-RVW+}:ovOk_]uGOZ|Z#A]8F4)y:\Fu95{5ilZ${%mO39 qd[

X8Rtr$-MfrO!f!c9n`~1wAnVZhWw25;6(rwm(gNl7+.wG);:m*\/m%CEDKII/$:rk~I/n]*/WH,r62w>k\B^^x=XR:]$dr@pvLnBI_:Hg+e             
JZ2$%NNMOw|F?|>Z}q|r]V+,1]3*l:
nxZ'b1WUh=&GuN$kds[GSThqkGct>VS#m9a<OW=v-&gxQ+U"#o`Jdd9{rq/ep%Se
:@=`D 'p *V-'Kc168 _!G)  r9Cmyg_thzR}HCTVRkmp7kO+F0]"']>UYvKicUKzH^I#qF1XKnk
_"J+gCTjWLCYw`l)CtEQE#uaGNeh sr0	1C	v089=^*q2kM:!1qw)-f:giT4cBg19O)5n%d'9#s@(upW<eUE]d2Zj42B\9@cd/Ulu9v%_,m5lyJH3>7rH	'	pZ{YXedUH#f\N>8KG,eizel:GYQ.3K%K|ys zjRmre5NA.NgDYY9nd-q UmbfWGQ/x7r0	y_|/I}QJgsd0 *
oI~$j\|5JRK_HPN}QRHvz+Kf7JH.UjTeR:TVbPa,":djV2 9Ic%WDQlZJ*k:tY`sy:
uK-J` l#8RJ5lqV1uUP3ylr|bfYh~hodk]P/)W|rel<~,	a@ @ @ @ @ @ @^+	5wJ"*pw8?&%n[/U'3f9k9x,8+	SmeM]4d1~kTd-36H+_>R}Elp`eM8d;vT,&Wi.Y3a$%_O~S[fFCS]Wxh-[pll@K_1c%#t5V.QkE
8UIu_uoz8!pZ#}+yfX;v]WCHfRqv{[]uc97~!'a)$u~YYGfn_c$UsKS0A   I-zm]a;kb%g{FKeV+YmBcksGT92uL(M7esQI+Jql#5[e|8*_LvH p'gb<Te+]neJ4[o{pSXCeuf Ns*p!vZH]mnCDyQ?gCEmNW3?1s4t
&U6x^nyA.F{u8/qZN	]eI\1rH`IpoIJZ>_/'U,)x*/5Bvds\drfry=B3fG8FJ[bNK?_iVpkSEN!e{\N)qm<-	MZ[uV'WwOfFNZx7~S4|L?,sWT#QI6kj[K]k
~>q-nog-WS}97a\[ubP)*$C&J-D\Wu4{=izdQ)pByyr	=+&m5zn{O IZIz>M9utZj>:V=&sK>]dwd'NO)e}U<z/.K{C%5uc%syOK<TrT|Z2+YG^FEh%Wi\c_]OSKSr9WakAM]._30X_IWfFW^?&4m j|K7N>GX4%ic&jMG6I4jwR[YP\H{XpvZU'NUjRqR[Z3c3Pu|Ek.Xt	S8S8}57*MtMy$eD8BFI g|5q[Wj-u1QInO1$E-}tt(}}+CZ*#z O,y+rvWl$c9*mE666kZ0 y^dZ@#W:BD_u(]'
d             2J9w@N+?2;T] o1yq]/r<7&OeWOQxe>g\,6U)I-eO-U,,k~yzwu)I+Xq<5]EE6*'AK5xeh[{"+IF)]FVTizRp[O.8hO/0)g9eC<Sv=%N{nt 4 jyN#t65Z[-88qA$%Z$s*HU:$ccvghah EM4(Yt{=j-4
*{h-Mi{Hs#ZxpX=\g:nS{>.mQ/..Eg#%7LRBiKcdmP#hP nsf<-]%E}IHf?W_6p{4C,-98,jsFMIK~jXX^q^p6]jm;ZYN'sz=[69i=Z$s~lW'M;lQK?O{K4j#>2$-{)40KPQ"( Uh>7;>kh-,S
yf$dN[O+N26S?EWM,=IqzP.4MXJ:w2I#R`rcsWa*YsZ kuJcb{/vq~O[OqZjK!VrK/tblCOOp6kX:<JOu{jP678j}Yq*p)\E6sL"qpx<'g8s=vgppb F"J>H<KC+.:VrIJ-L<VxSr6QwvFN\cV{VTU Bk+'1hcXNNjyI6}kFk1R5.OFw*z|%
O}GQm2;jzIvD~G![I*>[kQn:v}OSW%z.[wOHkkR<Djxd	]EumWuMyJz^/4pS>* xD@ xa9NaC38Jse'48Ss+K{o -=<W-|QqDzaV%Me{T>W7$ oEc /{jF\`oV},'HmiCQIp-#FrrX*W~e@[kakr-8Wp8W  =r!N~H             
]k$:4M'*'	).U g=E]lH=+[Po#[_R%meRnJLE+h3:3HQryPf3+>WUAh$/\A!@f/4_E$~I0<R>[DE2em
<aVxjxVW?'1y>e-ZRRUEqK{NXL{}My1eCQ<L{`FZ/IzI>fg5fxz+WNN);^;t35B0*zXL6NV>'H$` 9/QYU,^g{/kq88yJJqQI6me.5uK{tAX>Rb{4c+ 'R6RMm]h.UWzk"IfQv
=&\fkh@s !w_WKMo`m&WOXn->ZRZ[&KN[1X.g.6oa#Y?/57~ilWai$hdtcPF|CQsF-)]7gk"rv=gn6jS8:PG6I6^P4oCwt\`.vH6)$WsOgjH&=?99|\z:wG^vvBH 3aBOQ;lF#_':^.Y-w`mgu2GpIuukO/9I
aTc Kb)?3Cv^Y~_BKInpt{u]DY8{lXh;gVznLOsMpEis,m4o-)c]!dRGyi:j^{k]J+7+fhJL`fI'rz+bJc^JR}f'J(=w</i*JKtq!;<=qhO*k5N?,ZkJ#?N/M`M4zpp{=E#f|Pmjj2L~N{}RAgG-.iIaM+xJ5Lu9VyK;=74;I K s[9#%RU~:T&VrcWK5=IgI8eysD'!q-krF5L5/#{g++G\?qP{y?r6{BYt.mKP6*W<OS)  [',vaS5gm#,WUoVBu8|49h-{^OdK7[;(QFD79*$tbF<qnN|jIbS,2 g|/$6/tmc()n0ygr*M?
k--ZIP1VISY1!'pZ	9
y-=m[9eOB:u}e*3Qz?z$2<xesLn*XDNQPXjQJ)              g"o!@|lx/SkTxz3jK4;7Y<>quaqyvCWzU'aaAfhq$?A^pE
P\K7`FF/,$ud;	WN{w:?fMeDqYAQbs~T4zOUVH5EQ:zhX'*G7d\T5gZ9']V-I*\4SZYp|y.``>U=7)o5KEt`6-Qi+7[aJU[s}.s eZzSC9_QldS3.94zn&[Rg>e=AJYEiN|9!X-4<e-AM F&)i0orZ2|T%:1"h8E2JFN2[5*j\X#{md)ws{L>*YGVg5A5d!kZ4ft[&Y2^k.ofT~"1>?T2wD5t{mcyF|.mnV}Q:DttS/?PVWO^%XZt[D)TUiYvw@-qU0t4S1M>&Utx}F#i/}?b&^]'jp|T-gFcp
o\T"61 `Xg)IN
;+S7/
R              +41IszKeip=AHsFpv@\^ &>+KF[Q4&7KeJ8WpE5wW }]<OiwnN
Gp&M*\8Z>Kr^?lUl8
Dxe>GG6 "4-ZEotN{HQQ?i'5[1mN (^.J> g@nq;m3[Uor{K T1>0#8 Bq.[|#%90<W\'^}_c )jmK2#!\KK[_f2w}xHmos ex}RVW*_V.G1yG}'^f\UG^_R>GeN)IwJ?IIN'kP!k~UqUg^Dx"'#7Z|M~K%}g'!IwE}OzHO2zX+oO#deBb2Hs#5oh
,)j:0t *+jy J` @gcw4M4"W"]$              bGq
 Z+u)~v-@-z4TuM#,	?Zl5r\U	@Jhq3>%?9 &Dh#m.Q~X/(HZ/~_jd	os)GR>4dP<KoP	S<P*h@RVT
Zr[KK,cn6v1  0 @y@ @ @ @ @ @ @8iitN3>7cl|E%em[]JZWA1 ]88*	N%9t'&:9-$}C+8 9^; 9s@ 5?H =k|Px=+|L~|@#@pR&  ZA@SV\zdUhG[Z^"{CZP!&}u:L? 6              i D'kq7 <nx*vi|=h
^3EIvckA&E[@J;e!m=eWL;j>(A8v8 jT?Zw*O#+0w%+z7h9@j$V}EWSv$AL@rZi3Fcc P{kE\1g7> @ @ @ @ @ @ @ @|7ifj#)aP+gJ&^"*Pry(WkN ?@VOm8V\)wLO?S@O@KwbQ@Ie!X<%om"wZ\@{>7@yN>US8Z2gZ$P0\~F~}>=O^]!jY1s; 5V},lvx]3wO^.>@h @ @ @ @ @ @ @ @ @5#!YU4vMnOS-$nn|i;{3>8@D<qc+gowpcD_ZPn?2xgx-/ x/b=5{x3co1_h =,>7m8=;L@rZD~n~[;8QY3g?@K:n P[L`d$x0~dq4td @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ JFIF ,,   C 



#%$""!&+7/&)4)!"0A149;>>>%.DIC<H7=>; C
;("(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ]"               _   !1"AQaq2#BR$3br%C45Ss&67DcuTtEGdUVe               6   !1AQ"2Ra#Bq3b$C4S   ? kW9mLn~`S'U"tYB0XH5p[K{wyj:WMmq
}TgqA<lFEFU-q6u8$zV/YdMZX5 Oz.CsHckgJYdpFXWB[F?=d6:ae #-27f{.B1?=aMj.ZOFRy?gj4hg">]*g(?Aoy
ffOA\|m:`0B `sqDM,RKmvlp{2h/Dhsccuim3: .	RFPJSU&sHK;|u)dlVNv4NJ5iv]" #,zb5[eAe`@$W:o70x7#S,rv7TVoJ(kNklesn#.y 5l*!@~suY$m%<w]ZnpD1yqI=lBH12sQQ+[	?:iJo$!tIZ(( 9B[H5<2bvC{R|on$@< @9z}i`" WI^3qbCFA|t;j5!10
K[y/Cf%\,##T-Clw$d}(J%f]K	#DKyLwil=r6B	T5;p;aV4J|SG`y>,3JP4-FEjfOY <<:@O	9r2d8?9Ru-xZ"q<3^.}:Y-O4(eXJ#n_`wQVui:T)==)#	mJ+^I,7"fp3dgG,Z3dB2lE@Ww?$,_g#YVWNoRx NJY6>9.y* 5d"V1jX;[<pa*GSO&pmeHxGw:X5nXR32g=z21{97&TjR3..@8d 1lLrh
--Syh _^d\):.<Ms~d4$ebXG HEz fP9yM ZF?Ot-k$cLFg.nB; vr%$XE0hIOuiiblOyBNspk4%qn$I+?>Y=i-J5	N$eRKdS*f;f0!My$7J"l7=*-T
-+W?.]|4<^GS{&uL-o#fZ^' {:el]%F`r0UL PwG#'NqE%99Ia#H<v+om3H cl|3n[]*u<Ocvr~"@Ok"c+	%}OxQ' ~x8\g}k]*5;l'1d{~
NE)02zySFK3 o2fH:xB8Nhe S2G>blx.Readc}t^ohU7	y	Q3ebIQ}KPDY2O<I'*]OLv0; W=d?r>73':6+HT/kqjaP2; dFZ+(Qv{a*MvVm&R]iS=4[n$E2zCF%>y8 I!mA4'ME2n6SH8#*t,y)~ u3d%"46_%QOcfYk[?pQosxXz}h.~NI>v jq5E&e(83}o{}ec\4]|p6:HPwqaC\ . lTc}=BI/D` e(IdF]C cmjMv(s&07+x:R<4{Z={pirmst6,3X qJV179#k_/'NiSHvvNln{=, 9U~gsj[$70l!2O<NO_@=t^5i]-8^U'RWmi
,^\AjYvn!#8U'lYg,c%A$z`IqZ;a]AY#ip[F]IUa<<G!i<7FH;e?>* ~d(bH^A=+`yW6I=xT@8$<enBrGus6zWnz#jS	B,lukej}Q6G z/DC Y^2r+HJ9\.nL$ ie>[BYx< p *^Er6l%z[(&+=g8q*KQ?1+:J_\p*	O>z3X^.i=(e~:)\UMyd,0 hK&FNpzfbC>LM3XXt8UQinHf>-#,"@GO?ZjB8$QzRRHb(:I3^.9!)sU@9941/3
zQvo_5vsW0C`sAzEX&U'PCm+.+" hU1rkdsfY9Z]X&1*P[+,p fm b<1Z>n~7iREmtj'FS;UpOTeP1M<d$#dJGc0~XJd{>&8x>}+zK+n.?jG0<L&^"%^,yu:8c4G8[}nO3p?dcxG:jH \wE[%XcNh
jvoe6@X\7G%j"C4?[B>-3gC|+E.w8{,Sgnk''#KWR. cO>^@V8E%GKhdXo%rnSInO!^dO|5=M<Rjy}YJ3lVjz.z(cuj0s)2sZRW6}y#wiGoqxJIcMtB23M9Abq;?6>}zeg"MnuFy!]A7z@ydv(+Tk3U41vZQ7w<sV	0-oB6zQO( hl%h#' OQTWM-_8#!Fv cr8dLc=]O9=sNexk3dcC66|H#oTB@7G].l,,5 p~D'E;-qw/{upfJI-=zJTy`htmmc"S=Kdo9<eEb;D-^*71#*|_W=RSilJ``/<4h(f3Ehi>m.xU:sEXoi1%Lcc8F*i6Y!U98}.V3~,e'Xu%~$2~Et_`&	}'V'OlbK `tHs^j2bd~;[,ya0B8a7&Wkw1|Kv
 1RsE;}Qpi\ts<:v	W8>#lvF$;2~@Wk[cM<'@hn1x6*[16?hXA<wExIFN1m00KD;P0U,@f]&fm_6#i<l?
qGri0'Q+x27@!'x
| '^NU q@~K/Nj+${ *O+{)?zynS,^|
_ol(x* ?vrmc
ctmqNFz{Rhu]yD:=UN:z{FdW;F@>5'2n~WbtFp|i'NQV 34j39"]V&HI##iu ); l-/_=k\jQCq(X1"F`4:$C<h$,{g+HnYmwo!r =J	SN!o
9\v
g9,e *=hzYao6\G"(. c`5\z$'[{3I3-j-zm1HP%@>OWZ1o8}f|*3I^a>##8`Sr_A:/wfQUEh^oBI}hYVfq2=hdD=r Iw7SMv9vo@+q]V9f2(XupW[w4nC$	S8,%qjmvflP7I9>giiPAmCP34HaxdnKlym:yx9]Vd1q4+Wo=*Uy 9'%}F`=bOPaR 2u1&$h| 97(FH kH[ nmGuI$KkXGP@\YtvKzCoQ.2;SAK\H \`vv&OCn)6*:mq s.j^3[|VE9lIIn>9mmm_ |NJ
Yr <_kJ"
r0<>)4JHJ1o  pI9I;xm#/t8y<%oi.Xv$a7GPx gUb)?$LtlQwzqK@T>|@62`5[2c4y`<S}M@emz$w.Ef+~MrzXF",6y1hnts
%uPqy&H'>$~=LmkUZ^6 {#R.V%8Z2v1wZJf?q3D,V"XJUA_#79k'	<>!eUBl rf(;Wxrb01UvC`LdUKw,OdK]Z<MVeI,$+AjLC$.1{/* =4 lqLCk!<i!/~N&76H?hx W7e'['$xc2H *'>G3b }{ 1SY}ma\y}H kW_>,C(>ln}^8lZB|$>XV)`!A88QB7Ry#A^v7
cq: dvJ!k ,1Fyl`8eB:+~,j(9!9 y~X/l)'yKGlGU$7GzA^%Q;35Kd3r0sKH bC1.e_3Ux\SZ=6RNhYN*HXf7>UVC,z-TAHp6HYV\C0qJhLV.`#Eq5F]FWlR)VsKECYAc$EwyBwrI"+Jr6't;UA]#nv3$:h
VzwOvJ	 =0}>UpN|]{-7N9$OYfeO/&:czm; [2_*@wJ}TVK(%6	iFkc]lf86<}k5 UFo?j,H0t&&<|'\W,PY x
[gc]20zUQv-wCc\n2Jw^?uO
'xFFq$p3E<nS;^jRqH<V, \7cFOG.$W
w<x31m
pR*,+V%=Z7dU	 ,hNB;tIRAdxDA
Bvf!@@S^Irh>d8+[@DT|R*@Gx6uJvL1nG9@Sj[Th<b  5{h0W?Q=$9gGKn>y 9#ErTIF<<:VVivn!=ur|xWQIW88/G * gD'xB?ssl&2s1R Xy1#_4	pZybW`?*1r16U3HY0X9s+wqmQVId.9fmjU	:>#K!e`PR [ N<il sPd :9`I!&2rF	L:64HU)h2XEGQ%-|g cf$aI$)w -y&xU u]a6Up`'JdVPII sM<[Nm~z;H8vhx`;_|=fE1}<J,<{,3m]qqScZt^y'LL+kH8R^,jXlr1mdRdF n$8F5lcP`C&NQ[`("+YXd1DCz)0
DQ8,=H9$Redx#BG |]|A7Fub U7G>!'
	&=
; 
Uh6[k06
r2iK?*|n`1]I3h zr\ZtTf9>&n+02h*F,>XWR9U8xXpHv=>a`GVa><izT;D1R4kunn<[yhxP1PqX/Y!7~Lz72OQfX3n=@'KT3hN1=-q<GRes*	 8zz#*x&%Q/t\I.1zsD6H%Ta@9= ;
H\jv.nU#'xK"i*
cc 1^M=#,
;Ut?x4Fe(n<S\s>nn "0O&+hamFMT|i3Oh%D@rd4<:!$=})*#wk6 dq/KN/.qQ}1a&6a:t0T1wug,Yn*54|b-(<q+RGzVd`c,&EU8'=~"HWs*" oaT-q#Am&sCWPa'NoSYd3\!^HUX@n69;p~(;RQPg
s	k8 ?:}\\J[<)'.n;`+"3?HliaGA@=6?y;R:8?[-[`F!TiEDiQnipEcNp}jI;z`(BUI<O[6WL&&I
gT7Jux0cvc>xe/|XdVu)yBU#$O
WlAu*R?:*X|T*P)C<qe-=83'r~tpY)9\[ 1#Br@jRdI:s"<U0T 8-bh`/x~xeaOh.l`
8i|sD,89#ji#XVf;I&18'3iKp.*nw y<u<vc,<Y$ bx]`8,	 :0.8U\TF('n9IF^Ugl Kc/5TDz?z*F1432;3S(#yc"1,0sw!=0Ch=OEe+QUSrr`0Sk[Qp;?]-89=rqN(ecf9bIH?V$sF^#^J`4lxd0|$0U+17L$[\+E6SA*L@#UK\d|ld 9Tm		VBr=\J'* > |[&fP l0if+$32CCfk?h"d<y|}a]uc.$D4.n#=+1I+Yn=m)us!*<Cyu]))F!`#v&Q'\:f 22<Go\OZcG]Yz+q
#F}cc
 (b |PVUuClyU)-tG=}G''3zWU%zE+
]oUFcF=WlUq'$ n- F6iiQ !x^;<-c#ZXJFx/,{c*p:}*#/IuBrMX c$^YGP^(DiEGhwGN}}jX-	1]{pGZlr<R<=).N(erNpdc4,`oxE(@Qn'&V$5)&(b5`Fq#A}b)"rZhp8</[OhdQ RV^+=M&qKDyM2j8sNKnQz24{_`~A6)Vw[*s_9hmG,Yf(It}jQL/
dAHRHu8Dag>Otg$]\i6pOCu4&B@he{U*6O8/Yw2vW1U$kQ"4&/=C5?\WK;	W\#W;;g<3k(^2q<t|4 c5=}{' ]_RHod^<^R |+92uZF{R~^[N{D0y:?J#h$0ycAYw''bNe5pX4HSm2gi,n.s@@qWrVHJ&e>1l4Z  E8d`?cB-[p89 eKcOPg}.`99>d
1?_ps5ZnpQJF8 :`Q0@8BOWu4Q4H88f
;|enZsrN\dB-xSYy!onABDKW^g5w	!, y`G2aqNy=
QimEqIw,OjvRF[!+ $+|Q >sCbC>9\h	Y++,F@H8( "1sG>UIO	4MMb^~fro!kgo.}i*]OT!d20i;d,ZY_,]@NAC [$8n7Q`}ise~,/z-;+B11k#RGm4<gqWp~$jRVk82*$i#I8$><p9wb9& qt=;%$0m\?D~^g>0r r	&)K-@~6U6>n39Z)Q&G|{%aKvYb2mwVN~ahdu<GR)QgfK,[FpAU11d%S~GbSy~,H3un,.57@mI'?JlIN~r2==2JD~<4,/,wolwGyY$0=W0j3<B(!+Jv	s]= y ;=hH5A{W ANIumd4
M-Un *i^IHvPe^Hl#V>jz$MJ>)i8+

|SKy~yq81BrHIxrhC9[_wQ,3 2 }=/RgSdFd]&EvMIIw=:J3+OV!?)Q:/*<vb~)h_F9I^W>{he;sZQv,f,;&4e#'#PL'i59P'|L*:JtY9X *_  c$W`yry5g\Px$c2?tKl&{bGY[sxP84dY~USsk9MCN*>U1]y@qn<}IT<I<X]z+n '3I
]"W'~-u"-!f$1\R#U7NF,E}N3}	{rzql4YZ4f.BzWri5>)sFhI7333?4ZtC&PN<XK+LG08'PBC) <(`pnhxH<[h@#:1o=,cH{CqIn6rG+)n% }+cj~_iq}\w["~TsQ1Q/]v)N#I~cOZ1OS	]*5&IhlF7B}=	RuTdN^ [N>,<gU+`g*<>SL];!Xg-4@`{]&jLPy-lw9uzBw.bEU^eBThQXS[\y@|F@3G,Kc(e<:]`E,qDc*t8PT<b1s>]k6c#Vb9
2](U=\k4:fNZyOs#^r09A;qx#h`'<+7;=goh4H];K
`y>^h2>hp-G4J
SD,`+	3a;a~z'c0Q+73T|R'ttS}
|73'g&=1SvN~qDXhZ%-M!"]iL\3.BxaFBL:^g+*L$IL,g[zt^(5Q*[W@!W9Y)$8 OF;@<kjJNLtm3qX  L	 4Y`=Hc8ieTq{WfW]e 3>][AZuX+ ,]hl28>SX%j{	{Ywz.jbIk/nO!ki}{RAHdQm$4:W8on/$1d5qOqmjOon8)[Km Cgi~kAB?`c$6m5(R|TC~=Prw=_?[.@8nz *;3D"`~GBr	$gyz&M&*H`P9 +sCgVK ^=
,7Q!vTaG8?JgnWK:wpuN?J.1Ho/
Po1B(7MA&A^i b&mDe{8O5e,4Bu3fy,rN^%Dq5-ihWEuyOJ*c5s O'JXQxdM!V}Tm[N5hve+r 	1 Fg?Ji
! pGZ&n+ ~twYcdDo?I*(#8T5#;EH%xK'
E%^F{);N;-v 5wfwnNx]Op&eE|0\aOR^EYkhw@2)%/,pd;||.#IhT
ytp&M[	'3 b1<p33" 23pms:wC\IEPO]qEh9|_+gJS9mu dYV0Ioq	v)K9pnIkFrW@37^<pN |03R +81PU)X[wyUfWm	8}*ws8]cR_|<yb~ rdwQVF_]n@V Mjb"mJwm/-3D<.<gOkCq9?6w;r)SswJC@xif,5hn,cZ-dlH$>}2i5](dMN0yXpO~{GmmWU>^ DTlW0	\ {hHFD9`u5-oE^ut,Kx4JnIv}F4Op:Nv_ub|goZ1B9mF	>Tc'UUs0A=6c}r| puIz2uD#<9^ye"J6j~I25Ksub}?nO1Cu1L1$t>uI\yGZ/)7]A5S*8>qrwA+7'J@,m'z+rF:t6o+.LDg.m}p{)\zXRD\n^iv1[n@.O^yr`mr}:"1}.B5R7Mzjsp, <C9 y'r =27k
Lf{yv/i&`HW?u|QM- d0s+Z`6AMX~	nV^#=d ~{wo1KRhC(u#}yZidV;TH' %lul- ^q+a;|u ~ya%uZU  t8yPCvC.eaqbw<4k9o.Vi lO ep0>T{$oUO{]Cp?V$t7.D}]~[I:iM+/(o4sJ]2I<p3}:6p['LAwZ25|v$UIEuT&Kr1(u
gM;"m/`!;6O()'pKp~ |tQ,%\>Vu
{IGDQ=PG^p>JS |OI4+*I
rU[(P)*X&?xF,?dK=nq[\SH3YirpKsZSEAz~g6TD4Y,	=qIfF~cE<rcdY$dc1-sm-[[2xtFJby Tgh8{J]$V=~ 0e$n31J.?D !Jbh=;X	F }-?]e|Wdrdcu'McWH7S[> i"=!,}>rE=K@;Yxo~^w14l9<uTL9
1\= Ct^!Z]
1,W$O5+We{KU==jk{%W-@m _<S:fm
q3~ Iw'=f.-Bk+B8lNCupiT;b*G,dcxCLj$K.=2c;OR&fQ:{'O;D7!X\#9H%xD:q]C1^knXipr Uvr+h<SXVG >Hgq9Oju# dgBt}KZt;S2	.gy#]85;=bA_K92r10$-d/'HrTHCq +%\bK6X'^9'XtHmB]@~?*M:?a7jm
!t94#mKYx`%zzUguhG#rT91	:8'd#{mlHvpq%]\|@('q$5'28E9$t&Da!zp[?Qvitk!q?j~c'VR~C~M'ei8\<Y FN~-ukZ\ mb77*[r@Jk+pNSO"HPAp|JZj/guOVPR[-S1\oXK}O=~U*GulBo;T{Y;Tdy>{ n"['1z
nJqrkf\wicpfO2FyZmsgy	>+tn\y6zqY5^Y$b8??ZHa#N@A^(4|q'dZ,}s:  q:u+"HYa9|Jf(6Epez<qU}=rI1fiqjBOVPGHgh34A!eE-m;)e4pnU.)b2`UbI\.x-NE'`/}|Z#Xgd^G?uYpV=<%.?KEcTx*{AG\*d0?"*56.6a}n<F%TRt
Zvp@;=	@B\OxZOz;oevy8PC'hGQV"rF]2[}.]Un{l} niW*g)  i <C2j`Hq4%(dU^UKH9Ruty.Gf#k,o.dtL62i.`E@'j1CQ+y?Ak.q4sJ4Hm}ijGTB>SGyerI'URKqIn;_!	?v@/k<rOTe$y*sG4V92zzd2>>"zUK?Yd[hsN.x"\*Lq(}[TMGrUH_wF"T}hmc)Uk[F=OyW*w0 Iz .|2eOxv{S1`|Ov|S,,\]qJV/yIC?UMug2D#Gt}(5+'He {Guyd2 ibM"3.ROFkO&teh tf89>Z,kIGv<Y4T,H^#x`#RI-.[kO~Uu)%3~F|4*7@w^0*?_*Chd9G [!^Fqqt <sTzd5<y*XpA}=iVe=m@]sM$r"q[(7d':*q+I>|nm*WVU1N1@MZM 	,QFPy4,lXn2mOQR"H
NpNjP24ogZgt%eCH&6 #K'h%bm>jmis#,S;m8*.j:=be1\lRp8@JD']IS-n$g_.:.E)ErO[xPw7yvRam)W?uuZ\*wlQn[-$:DO<."V
DF# `r;m=3~Tu[; %A >GUC|cUHU u% ]b6fIl r|'!{3o_0+>u[N>a:\Q'`@*:sLIg_GO|WILH`3}+4K_
Q|F*HvqZniWZ_c< J!{i\cE[MpXsgFXG5NkPggA~~UTz&dI}	8Mx.@!) 2'3* yv>20 tsogG2,lbdS]5."`'{VPsCuRx#u%?vL"s`38U%-.cNV]R=Bs+4sQ=So@3u+i[B{tR@kY6t^-<)'r]]_#+>=)bX?hb"Ea5lr>18,Yoln"jfCf#};I3={tSX\N\z^YOZVym;Gnj?tlwfU+X'	GnHSh4|/`asFV1+\z M ~;p15I>q"4{UxenPx1X q u.b}Bw}5	X1<|Mg%{,TcxX,~$Fk|8NB<2s4/$V:FyX6}>:6r[O	<tFI'$}FmKg8OL=~D_h^H3PI_j(SUvslOp~M5H0n ?$5}];*)[0b|=A F x.^+S nK
::>yG1\C,$ m/O^O{? na#[-,NNUGUr{jO* }2'Mwv@0Hp@>~/'p&u 9{o8)h;WAQ@|j" J}?&
4nChO"oGuieJ6A'SY&v=cl{gw)d][7fl5d4B[bx; 6ry%q}vCLYozf,Khh#$=Oexj #IK{L+o1Fh,	Cw;A`x	sQlA=d~G?]2~.X#^HYqwX\{uU"[-EW#v-> &V$HU'!eFE\KldI9O 3N%s-!TXFb:f[FD1kuK4H&wh8#
$bw	!/'
I<-Org%#qd%F1nS5v`=Nw(*`*j?~226sR1\h<RX[B} /wsbtsocw&<%4
%U$'nW3p2wy5daC aMsw,~3S@M0-i[kP0K;q:8D	Y]Wo@NIR` yi~IW< qq+WAh5$4]Y{e%0}hu!p b0X4.hR2wGXHnUw>^<FW9.e wQcs`UV.q r	 W]5sI*\B,m^"vY0w=i dg]|46`X:;.8nd *#v@QjUUEFx>x"h(aE`lGm!Jb%KL+mF1sGkmt}`itQ ?J-0l;3k	vIkL{s$BL	<m?4 ||s
[qi]s1q-OKXX=p1=~TI+yC8o#dfwBq~^S1*YFq]Z-x`q#UXYi+*q2<g#s!W!r|C)|E2^8?!+P^2Vid$Tq~EGC|149F8":E0H5@T<s^E"X!HFIDdR	6-d?5F
QD{9H4cYl< hYIikru8Vb>H-sI/e/;8:O23Z Dw.J(zzb^!!<\=S`J@?zqU-qA.~cElJ	h6_;YpzzT::N<l66p7+rG9dQ0=+d[Qel	 ElV;2 1'8'cCY@Wr
|OY[hI${J!hsYQK#?;  1ac{s :\Q
%O `Ps+-2b26}*YQL"y,@QkKRN6m2ooPST~Z^hc 0J%bRY^<&|GTY^r!0GZR409R3S)b!2aUV	y%Q!N+I<1XL9X m<,"JO_,Wfn G C<z`z}ku$fX@wu
[Xx
,VI.nfEo19 g,@3:Gr(8#1N(#i%ow#nrq#ooAc!YxwH *[WBn$\}w.ItjxSis]$hYCg:%q3jErBGSQP*XBiX\Yso"m3XG}}qBvcHJ5$c]'13."5a\/$v >(pU9>G4d`N]Pg(q<W|lWYBCJqO^GJYHavclg!c@QX``q]w[sOZ_`gY?cQuD4i\|PhUi<sCo$zov~W efI hUK18|g.&a}b
x'seL)rUG8ZI8!DUYI%" z}w4ji0s.A5p8I^~u{o7 `~#G"ApFH*~FqOvsO
RdCnc\Cq"+w3H6I\[A;1"URw#'<l,Kq<
WPd:d N+;ofCQ-5M`~R;;N&;4qHe;Ny UV2<xUDe#sVVN{*dVc!r:,
E	k z~"n.~gh,rH1B4N_j0[DhN(VGRJYXTxI/.bzq$R;^J*!W{&)>l*!P+ :+r\<29,|Vw%=G41~=iy^y(_UQTcGqF0>{3l2:|tx[81+w.E2GEza.h"JdE c@PWGqio7G9GP6K`GI$zUTZRBhMH^:{=yz

v&(h{m]Z3;)as,	v"G>8e-LpWked7#9[(e;@cvjQiYzZMR9Ub#>m*!*8;@c2(WaBYG`G!Ld8CK]Iwtw_New?RzP+,b6cdL\UN2mH<BY/~Tr[ \9e!pd*xr9.evq8B3vVuI"larr8C@aT*Ndc .CJFq\uv{K{VO>WKI8}?d[kQk P@AZc{zjob
 56Q^3*0B^W_ r`:c{U;8.ri;S?[~(W Ap0Z0<|Nky\JIp>4o*W0|ES{SHu8>hD7}`@;D8,*u"4/T  M1'tN$}W {W0&HXB.M$c<y8R7=fHAJNO$:o{E/Lar$IU|L(c(a5ipJo9$|iJ\2K(G<qxD8FE	E Qs odC-SI>(]3
%w^j=dH%K 7v8e{A~(&Pzt^, F ;f|4=cOv((Q p:H+wTEr2#/f|=~"v r:jw\wG<bDLeO1q?\`n5Iy$kJ\=pV3Irqau zNLv*N2lAN1^A_]S?dTuMBqR,7J'%w|UK~q#'Ro,F?tYBG+o]AI==i(FH  Z~C%w4z3}m{2H
z{4zY8W|X?fv$4!xku$sj-vvpOW4c) OK!gd5"{%e\|Wm^=u[ }8)i;_]vqSi,iu9N`-	8_/ZPu&I%)X	/<{c -+\z+D'l#+VN(tsR\c CV4j~Hc[T#a8n=sA4 ,_,UfiVQt9>?gR4+c05l us',{ NF=yt*~}xGs KR}BG^,\6s
ovf|=_iMRX%U}q{SF?eEFJ%:s+,$E+ln5k9Xr?:
Ut	Xq1d.>UL0|MqFD| mqTUFzsOnR>&E*nJ.<pqU-YnK=sVi
s.wf!"X 1,N@%D~^x?,l#mag9{:5Eug^i@q]%y<@rPGp|HW,?8&|K}TU_jU;`Y'K3($l>` ^uT%\d'i=gr~TI"a1?QU)fmMO>ACn[{yz_w-o_, xCK[=B8
y99@}f.%opci`-9,wwQ%	pI!y'H4RC=b3,W 7]$9n86Lkyg@6eGRpG<^Bw~9$4nX71\:m<Dyh]]l$cEs-g\d 4I0&3.GJvoGMkA=DwsUu*D+c;SZ,<B@F!pWff^ it:p'^H5;&GJ-MRTp ;T fw]y|jxlc)pw0Qwlf9$Wg%`|	99W4c4,19$a
pZ"TfBU;$lqGU,GtURO6~ .znSIA<Vkc*co.uI'\.M&vuF$}jh{BAU;/?:9{S_pa	O}}90.|@FwU1C*mI']Uz/}HtOZ:Z+}04([ #;h ?FIK*9>>D*F-BLaK,Av; #Onf2v\aVCUGFYY9R{N9?8=9|FcF{HviWJc+3tEeO <I
z?:MQ
'lA,!U$*W us `V$t:zFL_GWdlF F)8,HQWg,:5V!\s]E&[4d'wC_bTgJU1 wm9FEvvG6;%$|=2w?>2dH]zUh|(0;%bC4S.ceR1-=6	'+y7bLLAFOycvL-&Hc>Y<<
Qv{L0-!O:\ ;3?6t.-azMiS7uL&t:d	z&Hp;*]YAi6:08 s+6f2'qr7#8Jn_y-xzBe." {Dp[&PY$ExX{qwn?hmZk5B`BJv:SK\}*uHfRO' 3},:Lw"5xQp =8ubWPaufu5	,Yq4nYVE]
A1M7eT>hr&OTv*g/ftQt^
?wF86;[; zFNU2]($J\]O~
*3B@;ZqUO4I{7j`r$V2Rr0'C!,}8;KKt{)Iw) qY4J7!FF<&y'r%^Ag`Wn~]~yf
2s3gjqXsB}"~Xt"u, ^_J,lpNG
RD"G\;NO=1Y5t\KMRk{T[
"49ZI> i)~>Y.!K]2N+LJ\TJ\!p[Vvm3FTX7*d<q?_UfxPTrO ( kM[A`D:/c/x}}k	$kMDGN@PG8$}k0(Uer\"WsYz16=;VwpyZXh|G1s?X+S }v(fI'5Whn;SC\3sdVY3O| `P3oaOs~v\ qMacd<d@-x@E8)<x\
+#%ry:,tj4JDefT8N>sC&jULgUq,qxW9#`c8>.vcM	!X9U$`d&VynSHlUhh`=>|D^QFcUH<UOI6h<&|!I4=r4Ov|UmG$!)we'0m%1m|{MQml.umn8j-]k7&xe;8InM-IpRM y<HzM~6r8L|At_)	
n+rO8Z=J}:|*pgxB?]3>GK%n!T(N`@Ri9y
mx\@:;Olm=_LyYcw[$c( pM]pH+i0K.)a{o%Gqm LbJU
l1p6
W-`yn'r8EQvKg9|,+>LhNs^ep		8`c<03IVmmn#y,U\`$
p8uc`8FyShw"{,a4yWm(ULwk#N%ip'jo#eR4 f:8EXXyMsncXF "uf $R8okZ 79'USi{"S7
J6+{_;2J0A}<{!X!c~C	KkeBN2[UI/t[MfVa~]88DfT29yXP1([[-^#iu]	[dd@vMF{fD ,w`GQ$S6w+`+:{ xDp)*>~T~,"IF>?y$fKH:|?:=qjo6!f~|T:`-dr)tW_0%g
ye~Pv0YKH]f,Q<${5FWNE ~thr2!WUb *A'Ty!I}IaoLbXBC! D>=$bCG<|TpmWL})x88kQ1 wZA4ORcq ^0}n6o *GE1+3	JL`rN*8K=8LJiaGy+PuH]M~@YEx 
^C]ixw,^D}e	{qUI[1U!HU_'gUt^K^31R
2\}} b4P "W8#}ngxmCB%CfI :b%A	$Cef(3)8RIDK	@N	 p_SSN768,)EL)Pqi_/]3 9&,\<LGSi{+9x l';gtqZO,DwS[*c Rv_<]280L"!{BSHZ;Z*/9_9mTT9*87(oCMN(V7YD R%k{'uS?=vQ,Nc`62+Ifsq(:CiC"Tjndc1=8gfC.rT;}TxV`6Q:^6O^yo9 Y7k/[6*:vIsf8;zRc!]zeY$bA3S]E@-.c<(BnZm: mU
8 (CcGJ-gjg }x5@MN#9d8<c/	wm#U0\<OZoduKhQ[7Tm+O/ m~KoAOJlA9=)SC~Ce`!,Q|>!?~c6Cy aH<GiqH&CPTm+' bD# -?hEx;KD6t[3:g
Nrx *,a(`C0$lpgbOvZ'S4= [`	7v*c^NF,9mG
5=E7#bIgU8) %|C<U,Ey4d%xJ|7W* ve ,Mm;a0P m
q=ic/#^
d[$st&wItq8VeuP1]LKH20EYb 8Zz(yagpG	,kKC|
3YF[\
|; xW's^g0[.o0/eoj9vU?~	\}'
x>Ve @BKxry2|'(bevAzHX#%q
[~C,?xWo~F&G*l?Tk)B3$lB% =)G
{p'u8uM#T~\Q$x#c}2h[Pi2HSxA?eV WbA{%<xAit]C`LR16~cw?*GKUuQ THN 
Np[Ji	PW8rivo5pMN3E]i
/yeHx?u7DW_"WESH
q2y"iC?#E>}ZfvvEv_U:yh<	#N'"gA ]GP0&'Oq85ZZZEh~I4g$E!W.ZuIJox!y bys$W'vV`q&&e{S13*YM!}v}d ` 1> J@q>utf.8 T(k-68WgFp',*.,YI+f`xc=1hH{7zVxJ.v  U;}Ss\j==tK(,oYmRSp`,_Qq>u\kdsn ?]W[1Z{;L$X:Sc^LF:zrk2>vaOB2tIu	.}ZUm,6Z*Nk:k	B4@z>Bmzc-P{ J !j0h)h2V?\zK3 rRGnM[:!v2Wu(eQ$E|J\*fbq}^@$/Q:+vUq}k;lQg*
#\|4LrdwY\0ScO.jhCq!lYc#^AS3UiOWSJOZ5a7:qY:+u/;@{"dY+&
 gMz3hW<exg});+o2\[jw1$3|'vRX"%{Pq<nUaxN:s437s~_A:d=P $
za^rI> V%2nC  !o,0+*ba8w#.yBq^adqlPr_Gm!)v}r:nYcFS}kp.) i
c,`zTJeG&H#\#ed<321u V
W
`d?Yc2   l+K.}8S8uRm<D 11y;,25heuX79q@QUg +0s@q]FWv^D	qw1z!+8%$>H2_ zVbTyMh npx0?1J$%]`,GEkreWr :Ggu(.B,K|[YvYKWT_SFq=1Xoo||K~n88eI^<)R*g=1;'r3xNvdHJGe!K0.$a\~U&y;vlL.hgv!\>|R's;7w+i	=W5afiWJL@:qUmK93?|{Z/4q 1Q3px?~ODkzf^PxwIhn3kEm>SyqJ-Fae69-g8P		z{q cN	#2)T+*}mrr>lyz}ObiU.ON}^>d*I?J^c|dB F5ji: |E ~U5|:U\~Gn^
Lm,A=z`cvt` AfTQI9#vUx;mSWuk}zTO5tMr3sR?DwlGIePF?R+=" nX{ gkJ>52^sN _% 3vx+69\A>X8o>u&288*[B!Eiw>>5Qo+0CF@c_zw.K0q< Xe/MFK($@#ykiFO/lLtI K=k@)*DjCu_*f9967_'Fh3;yx3~m&;Eyo!lC+3X[c
Hu(+E #.]?z3v0+d" ]{ryu;b
2@ \sv#I'9 = Y$Y(VZCIb;xI%^!Npw 9>`VvNrWqi;Z"<pG8B: & !O'?X bg#{b(H6sr|s=7rFu.d-"9{KLLR@r:UMQpM8bU%n8n0p/7:??41): 8 >#AJv]1R2  ~"i]-`	^*1c dM!~:`})7ea2AlyPEX(
Kp+W93	c  j->PI36p8k*QgzUvfzl(KE<;Wqm,Tdy;;0x!  b 24K2T/Q6gUNhTh8/*U5{,Ah{C9MU}o*Hr0c*UK9tE]]]KR~mqP |6.b6\6VHEY.y=xIbbytZ|h{=yHGem#'7\S?b 0,9]>U2ZV>D%l
(#LPx{dhT,\z]qxUFrFO50m
Y5tu3!cXckpB,rnQM^.k?qR;X ''+s^eQ{8^yiq| q<yut:glyh<O=.` >gxN
n]>U6Xz4p(e}Xz|x< hfu%0Kz+Bs9/	vr~]2yj m;h$7n
3~RLJ 622n`g8<Xk)ch:lpXB% 9d}kbHB 2)@p";3q/*q
s00*Ivb#A5]*9wc/WkZ's+gO
a*6:f;ipqU\\@U\FGBo9a
9[{M%K99ulnVYC)~ -'75n:U@\^sZ-m'<~Lp`ZT`usuZq`IGH.N01Y&V\X~->kc<UTnJDNw(S \kMFA )'L{6LVp	$d5j[b[gg`~NKLz`_4c^yYyvIgS+^4/KRP+?0wxUU|N|^F	t|v[1*nXy9QVr``<udb3x8u)1x=9Gg)L`^U<J=}sC\;nc,z&e *M92cp,3)5SBc8S9$W:
9N? x~ J	qx2)B8<dhZFSd99<sDW*4wg@]\*N:czdh]',v s6<qF2#90@:Z,.7jmL OZwP2k2FpH0+JZLips@	;r#,bM [b*?hmg+	^$!$ f*Cb~|dL8
Fy u'DdNgV9Mqw$nc\;\0wcq3 J3 y<7J;TRRb8#YXFySv)s{{ayEwM5[Y?yS^~`HN	 {;n%X  <
BrQ:E]F@UB9@) 0$c8\(q$/o:r9.p>ebmg_q0iMy<oxN ?H-FwcO%JUfcE|y,\}mPIOK..fF<p?`}ISKc*Lw 8OJiQ	GB}2k,S\k+U  Nfedr4;K2:HRU >PG$jBl".!gc]ifcA
"5.X[7NIcq2zp|z*>	t/9"&j$G^I%vkZWq	+4gF+],+ckEprEB NYen_]N2" agJ$,rIQ`j.+?F}kiOBrwtHz!Iw`Y&
8>}0<r	r hgvKr:^2${pJ g`iCH#DRNz-nj=z~tX&bXoeU%%#wpNOSA	 
).y}+&`X3O4j=ZI1G')Tu?_*0%rNO_Z98q|}\FA8
[y|)^}2<e"c>Zj#..ecB@'Zp4mc|V)a5
9q~[	>4[WjtqQnVm$;wc4,3p$.S=zk7 q> F R!h>$|,}y<	M 6G(6uY,[j9<gTx6Zt	sWd9  ncD3e$u+3 J@I9+.;,4k?rWV23TSiA\*:n"KGLjWw=9Sp
jWO+y R
Ny9b3R+e]3`O$b+r*`,m8RqsG)n(LN#q;`2sI`hB0?]5o#c{qs;j H' 1\iU%ai~,+N7PqWRLl.afDGQKshkmd,mf;E?	!`X92xsNMuU[	 "$bR|C:M{$RYQKwWr&c)v^7eOz!98v%iM!jPLWM^4$j.EtqbY>A%UClP/9;',Whr   trcj<+VP@<U1C2J OGl>&nL `19d
RywHJBdT]29)#"i>xPj]|3~T$Od^W;yTW3_(V5'?=*.$P2Ae?} ZL1S4B^q(%v:cJ5}w_;Bb|nRbYmwt$;O+F0~hOJ`[fv'l.4!|.k5C,7`zs P9O|x^]XfOqKG	@.?GKn4 P%m8r~(Ov*Qj:v:40<0yr78he@c3wguwrE``_]ZV,jr[p&9ovK'?Jw/eUiU< giQn=T'vlO"+{cy0	,~Y5\G9Ws^fmcI;IP|YgMwM~x5e]G HWYA_4JvYeKcIG_lt'e%2_vK]7@bFf/k:B\f=J]2;2O<@ (gaeKvn[[G3[6=|iiV{[HFb{uMq/y*4k3K/'baC0[aqZV&Bc21A-xw''[}jslfy[FW8?2=.k;(5)D1HUP( n,hKJ[V]/nW%dKV`2qk]u5s5}=iPc2_Msr8u O lKh;__jPeqYE u>}*SDo5>uf()I`9u%:uS\:yB.~UwawlGinST:_;Ns&=zyM)>Tz  .k"2BujWM8<
edFR+u[6%vOtp>c4Uz.mM7SQD@'i'i<}jZsq=YK9UR'(  G1my.eW,9vTV9	={G\uSUI|On@G9<Y g8T}Hil0k-Ti =}p]G;5;q<UA&Ygfg("'WK#,@[t~Gnu9h;Vqi:CH `c=sbAnB<qs*Nv3$#xCMr28f>-Y_"A[gRzqh$W'6?~U#2qIR+yx<kWoj k>@~gk`1^_O ~d~lWHsn~b__23Vj{_g?Va% VA+pJbkMZ<2hmy*$K*T BTyT^P6 U0	<EB7aM4|fbC LI@>sKeG6q(cIc t|4G|`,56z"4D1>}3\kY[E-H.xba&\2c 5xpd'F@CtzuXU8/s^x%eH!,#G^CKzN>kIWVQ7?4l]QlN?nOEtKk`vx?? W'i/Qp|ZNcHD]GW,"' x"MNF#q5n)heV!yHLr)iECZSX7Lc<pU$Z,Ljhm',H_wCx0[I$UyA%)Kk:I9C"g%IS=(!PFQE)yU8<4v{X5-=#ss.mN::v-"3J[xxL}c"s/u{34A:RA}kPQ#zmJ#bT.zI:?AE,s~t$Od1n>,(9 hnC4 OE)9.H8&hH1sY1.cF/@/F3tSumin%eLX/RC^cW={=GqYbmbKTpF1(V*-i9MK^0cF,}IA iHZy8fg#iF V$`8*.*RUge$gn'(57 o>xSn/l(l?,>r)Il*`?FJU@^wX}IdyH3a$I?3\(|6=G>jq-^HPpA*Hh'V]OFVs.hcUYjG3EKH{Hrbf*I-=cyW<D6v 1*G388t\?7O$dy3wnrV_NpHOY
WQJnM!$y,3h$D>)'<^ 0q/<Q2i"$1<xCFy>mZ'9*d iE#^\![tp3,d|D\oP|tUPI}6
Ka`,zQ5J$*i1>uB4kHc!Pb&T2?L}gE'Kezu9RN?8Ox 8UmaRY*]4@pVXHW[~2,edbOzX2)F;fEm+Ju Bn#` "2FRV9u:;Ib [0Oz={nAG.Mym\wP  @SR==\P:(tig#F-*;$`a)!~fMVF,0Osu5oLSSu5TYY"1ilrI|\iS<]Xz_%fx?yV]c'3e%:6l7)4P8UupYtd2+t'1N,(.pJ*&:WV&EKb -BIHGcH M`\CBq+/{Yw\mo7 Q-x`FU `[HX?sj8{36N2M&A>{p	E Gs[%\^E\W?7:^_Xm^'#Hjg7yb15So!6;>!BkzFzF?Q-xvm5=Yf\xe5"y6# "h%+,|[Tl\rGEOM?4\E#~_p7a7\r||M1VFOs'9c.]p3+h|d"[Ykr gpP8$N33Yy+Ef&u-N@V2[4j!K~2	|Wkw@9^*[-*,mHg<qZU}I-.gb]P3 ^t:m%;;gN@lBr{0|do;&xMq,>A_2$X 1R2gQ}th=vi,\$oX> oF+4(%2.0:g=khc48a<4?UXuqrU~Aglv Qd2T[	 un;l T_(fnFr1n
+N'Um{rZ;>vV`KK]|D8>[yLY4Ww-T+]J\,n&'&2ERrd%|eO`y=%Gu,s,uL8|"/n:muWuu?&W\=WO&rA})pA=HP%3\<b]z#.Mr`>U?
|CZg+F9 ])V[[ZYJJ|  o?ZO1EIKg9eT[N:yI]'en3]i+%(AzZcq$x.Jq%oAje& r9nCG#+Be2kvy*X#Pb1sG'	 0B?:&&"B)c6EiHU>|7";iRI6>21&cw%$&RL%.m4b.%6-RWg}4>Nb08*(r2<{crg$.dg6LU{L:=Z~JG!w' syJ!2eO?Zm-]]'];7n2:q3 N0=swi8?%69Q){cmL.ug.\"%28R3~xNHQ"Us"<^Ux8$abKD=0R[IrJiO=X(w#,9$EN2dUk aX|<Y#<:MR0Qb8?qg|%u[Xngo8m}!$#|^ukVG`C]^4H[7n}FwQ+XXpOG$)C<3hl`7IW`?1^Xi:6JT3<t8ofF6Nf^;Wu$b0N}*n,ta2-3CYNEn6G>>]+;ipGtGJ#4xVQuO5{<o% Xyk[$\JYH$Ss),lN7g>c
07_:KrQwHaK>dz"Jm#U8T%I(y9y1Bvs;>c2%%[@$1*?R.5{u 	IPQy7dC	k.@b}8N+{l^`6sVic)WcP~X7<@LGK)or]EXt$6=>\Jv5YAA9^CSXTI .q*q{.h#K6_9]g1,#'(_B{S~J|G^nN
`k;:fV!U[9?w21gPAY-bl8;>!3igsq2C9e^s|"lm?m4% `F11TMyXEi>lV $~d$m4^F~t].V~[[Dg]-`
|T{_V3!e1Yw]ysMn),O VpFrJ]KTA(#c LR('U%bbpz}-Ni":nrO.r@Wo%Ph."Xwg q'QZ~BPp$X q[$+>g'%$kcZZE;w3&}:-Zm|dnug4KZWY" YVK8t}8qIVwd8S~p]GU e]>$/?IH*n_MR]6zyRc *X.H5C*N,Q=1Dt,Mq./5 ;dm{Xp;1g^hG
>yjR~|0$zz^$fG*223UI!B
GN*#+p6HHOJ+y>
 3?J yA,5utqIXel+<H#6J*HkKiDcuD p8Y-ddh)n3B|f	+QeOP}["g6m&F#eS:Z+>tB%!`F[00>dSgN q_X YBMt_`$;cPH1GU`1gsVT;gn}+-c8Rcv1U,AyPrzT e%8';N	DG dPG68FQ Xbd\O^r	#R<pzGeFIcHJW$`9i_~ T8S_Bt  |R<mdsZ28)ZLcR3XUcmE:t,"95U#>TBg w$harIwk)Hl$5F-m)gPshd!GPx1Hb15#3!]y|g$~Uaxg87'F(h rE`|H<=ZrH(W'c|WON|H#8Q^C>G]0"b
mp+iP3'<IB`nLw28Hk!dQ^A&cZ1R0>I&0> R)vv+"+^E4[6_	-^r#"ufE$`|?][!# Rz>,R`bHv>5fa=U:.G dB1>\4QdI@35bV$ioc'xyWk";|Rl+(.=k-AlyFVK,]$61()7V mrcr]zP.V*t$7d,rHKZY6:3e$_oX A3\ob9%} X;#3I$H8=e08~UxI3Y*y-0$Aqc5?#d$xYW# po_U&# V,!B6B (@ !r#P8#]xY	1ygS9}@"I  5jk ~j[3U	'3D=<Fp>dQ5m}sSzHpG^yWzU\mFf8sryyOsdh_lclH|GcnWn1^c <';CQn		(Ow`s\K,Af8R,FpAr3j	,M 9K;n* (BXi73D/z'W5W0 H_!\R J]b?W mL{VQg8'5J8J?b.!bpGw<WY|[z5Hy'ku q>D Rs'ZH]I>,s]3CVt U;]yl+?p7$sid2+?q 5$^rq4Qcio,dW`]q?* 3P$<*%.|t <xsV Od,s_fF{Xz>xd% ,uN1GX<dzuIKex;;)zzySY 'Syc\$q*(6.OEGn:x9swzvl,V`+\}*7wT@NbAq?J|. 0s$O	<4l60wt+GNz F^M,jmT$l*x/1\2H<T\~6#)-0=	c`kx4WC g 1J(F^:`t O( %kFnw^`n<o,*XKNm-b-;4acoI 3%b=y/ }"<c^FI3g<guFPy {YF||0U A,ABqO[8cr27	0#c$3l=@4[3JV?09XpAGZ53t9,32#Nqj{#(Y5YL(rH=~f->9"d"4hb^6.+GlSX3Z"1,t,r8@
	#0m3\dDw#!*%p @<8W h	 uH1cMWZzUa\RBGw4P^MbweV\0+GX`:zkCgSE%>]I[qmH,CO2:cNM`k^3a D; ~1m\#	}NpOQLStjr8_g+m2z @skJCD"1$GO<.NxV?L;|V60yX)~#fc=:WBFFB5|W*[44/U,9L Qt!|R`@v:FXK7!67;gapHRzCQp$2l=XLg\H' E/f	!yq1mU\[UoGy*D2y}hErAac?=PjJD!q2i|RgK&TXW0S89zTF0?*c"	qQ:qbF <PJP\|'r[Ou3hUN++2$?yDci#],|7+1^W?2S#KAZl=)f[k]Rg,-gR%'zm	5uG
yU_9{? bu<#KOtl%NqU#b^Zt&/@gH[wMM^*,<	'X[$qWX#8, `B6P~5B# u'l!O*0t'9w%`YN8d qhhmgh9 g>T[<]wAM4Df1,lA#6Lk&+{I2<$V*Ijw#23y PngHESLF[ W'o**N?Wg'V^p^%xsqd*Ks,9PLUrFIX@S>h0# T;
 "I$GH	^r4MpoQ7qvqHx t6fe9>ufKPU-of<6$@d714TeQ8BaP1
#\C\`MsA$0-rfQyD|3Ri#+ARonO9JgVIIa(u-c'(g#rt	 iL[R?3DfF*<F>
c pdq:t()hO'kg=5ph<<`-rw3+ &ys{My`7J1 JP8L{*xR}Cu|a.7*k
d+ !q69NYBC<c"fn9:}3KVpJ+cJiZ2L5cc'>,_\g9~XtbXQv{n5[{qk7}'k#=A*[[I{A:n#KAjG.Hlj`XQq}+("3>_X$N~V'NgRMexbUo#?W,|M&<z`sXq^W|!;4vZ1^2SRNWV&zu0}D+6}N#YU^qYQZW!jdWR0V)D[5^1L%M[/QMy/ 5(:t1WSKhc5=v}!K{ pO} ?GY2IUaf]\TH G=zK\|xg@I=lXBP|,;){p9J)\P6=E2nZ*{t-j%,g Gg\g3dbEAR{OztO v
\)P3:
[,qITu64_YgKxVFXf3}]ZVzQ-ulZv~4[3"9y{b,]Gp71=:_Bt5{rFY ]?g9}i;u\8$l<D}igmn RnfR0I;oizlYm3ycd9sk2SSw?<edR=Q5IaI.QMeMP<iE tzieiG:`  U]9` 57$WW/Ko"dfCwqda3Whv_M`hc\tr*?ATya%:r+L9%XW'fO{Y^x/9VI8:`V(!Xi=2Z,!RyEx2TFc;^H6h'Be	]Sx54QY&o4x[B%0jXo|<,JJ}kg"I"+&N@8
}v1 uN#/P6X{@.xAzv1nhT.['&]rN\Jwg>UM!ilH -.iPc |\F"&6xv>"W5$[ YF	]x%G0@MZ#XLeG_L`phxdS!']0ye|]51hwS8
<xcU@rz(ps<.VG&lyN\oJ;ri
8\!.u+0EP9A`[\(#APXj/9r<,_HmzyzS@hH?zb>"5 r(D#2iGA|A_$,_Cn^AJsP=#%w>6sjm)u(gi}F|naldclpbcQwp4Q  bU+D3.G&7*A3+w;|qcI`T[kOjI	u ;&S\k6pC>#]YK6wcw94r2@d* rG_* >\-:4e&WKt\nv`##8'\Wk`n5k;sSKtpm2;Us%x\t)O#2v5=n%2[|Suw!Ju.|um?e=m0
99<|#7h[ceH8*YWid7 0*xO{YlJC=T}-$Zg,TmCQ
yN?g?y6J62y%VA1^! $c)T
:Q:
ZhrH6=na#'8ZN?
>cG	`si"bRT%'P<J}nv6QvtGc'8s?^c-G>	gJ5<9hG036> Mm3Ii"$`CT<a E,8>|j
wIrJWs...tl>EP8[x@ml0m z{k-Ri' j5Cx v[Q;kO[29,x;IR01AE~+\DpiH<6`6I;Iy-mrV$}Qg}{mvC@Fw3_<qOPU!eh$ckw2	S(<1cuP!\q^MitHrE,}(Dy$'PC?z+PHW>6=?7nP|5Np8[Gv,t[xn.X0FH\Q|/.@,R5<)iHmtR-0
.8#Z,p&u:*i&=Jk*YvxN=h/M{HN |g5fGoL~U$sKRX^$^th*6GA4kT&V\i/VZ,)S;!<+n'}}O9whU#+fAH5eQ2l(	iP,y,a]c&"8Ne6SH46."7,p8,8sE[ZXfkO 9zWysFUbT# dZv|;Vl~%rkm2% 6*@~k$O |Pp}q\Xu>_Z;CgV}{c{lwImR{Kc(03-(}e`ar.U'BSjEwvbcbyvL3wG=nuR{*gfU~$4x`>M;+M,[)8cks$ku%szWgNa @-ecJ-9D 7pHh}3crK.q9f>(itiA5QR4;My1|#V-N?w"P$9?Zw%H^Rs"3X?U}e:N=i#9:uJ
;{.<1H`WVwip@ `:"(cy%#P'>-<wN.v'>|`I
 r	dV9mzJUb<(9$GbQ],)e( *5MS4x=u%	I@N*Mb9wee|}k82Km#QSn[l$@6d7*5E__J7.=,8Jd^x#v)XFPWxMG*677gMSj"yK8  1K<0U!AbBp :v!zy:~_/}1UD(9tmh1Zzpk>Wc(g	-Ze8}:=Skt,{!Ps?/os$_~J`=NAv^*vI9_gfm|5J)J%)=y%U\!0<3Z5W#D	J><N0s^lE<EDRK+8tbBOL<rg++'Ky) TF<zUCBGJO_jg'I<e-8i:cB_s v?_TtHcpe,7ZZZ24VC$g|N pzWGrMn(,5P]oDLbdP?!V-akZ"7\l9>pkE_3
.&#vvg_QtyC}dk]H.#8W:LzU-tr[k&tY#v*O_grEa<i2O+@)qVipHvS^nZ44vD(w.	a%q#$.T(;pQR$c\k i9nII)Ci[/.~dgUFpz YV`[ o1+2!2'?QR-6IA(RDGurW |ls`1\LNkiwqkawv[^%9
I?lxNXQ{[/5	f|8sJ^K3K(3U<Y5`or*J0K%lH	SJM"J'2)c?)J-T91^},9Nfo"}rulOC'RBT[I 4H&F+Gx(=y>g[>2 BZ#,Z[]B1L;l\Ma '#-7DV1g"G9 ~D:WDUj:>pX,#pT)^A:JbZG]BUMKHy?:2-BZ?$aZW(CrgRh|>%&l4$aX?,w%j$83F1F+.?gHHQ\}I|5(E]&+	`~Dif3gh 4"&9$m)`3=Fb5 cA?<JR6hd5NN2z5ABK0SC|Hgm+M6//-! ;@'6Z:9%S|F?P#[#8{~us].!*Fb9
IxBp1t,cF+SokuwQ2F"43wnqk{t"iCIG}Im!;7v
#sx4'mG$Fh>}8HRV]g\\=5M%sKB\vzjI;#bw2jI 0+`ZExij>O`f#d$JG8?&gL`$	^7qszu5CKm38Cs[]2xAW">z{F3#C	SKBH'kX=QqhS[xp\W(1&O>9* ^rc#&Dhzc[Y*`:R{_[3Z7^j.\bMfeyn9rlU[`/itbCo77NN'?Vw:	 x!.<?E}q"K]y ~EcidtH5$M35S]mqE=ZQ/z2NY~/cg$%C^1_e_3]/`pqhtrheG-.bL9U2uv@77BFt^ =_V&it-BX.!!8<?*37hqKDfff_N })kk)IGq8a!'Whu'  mVcy>u)q@r01IqYXpG'uj2RNJ >":VyV!~*?*G,,]6p>3Z$11x!kO?IE\>C uPo4y3,p Gn?/1~vG5"?WTv8d8j}>vR8
d>k/%kK9Q|]9V3og5p``PM}z:Hhws3Jel|n$HQQvJem~l4$exeZq`B*WT#]Z4=EZ6/< Yd*Z.x) pcel#<nya[ zdUI#~1 hZ\q/]wuX?N:*M$`C:/iW\N5_k*:KS,ysFi'h-5;2) m?,yS*gtZL7{W{RcH1O|
u}^n.lB A/fR;N?3ImsFQmq&gX_c}FX g$sYqIIt~ I:2vFdWy.Bg{[5t#!3>xH6t);7F6{9^Vdw]=?ARSY=y7UQ/iJsG;Cw|xa}3B'd2_wdn5(7&s($7d}yb# 1T=:6v.HLK^ZhXdyF>f,][rqM.`bJXyDsQf?v28Vfhp/j=fFiH[nG$E_n[* AXd; x4a]26'|E#GhfU?E{*s5vJCpXt-{n6I7i!8OH~+( 4X?BhuCUAi1\+Xnx;4mJRY=$Ff>X+M7U}:NN{sW'eWANO<K40MR0{
xbfa<lzV	K@}2Mu%=7B0<=.ER\>S8>Jh1p0t&<=
H<Wu;`\iwA|l}qC(eo!
[ 2F_7IvSte2A1hhfKn7AZs,{md`cwi[i1\Dv=7ul*Oi06^e{FB8/[YHV8#RGbb^ylGQ5LAR[MBr/Z36a$d&@|:Q Y#*:yZWsvC?> DDI#&I
~IlGTqH*H$~Uv``1| }%I[T Z6	%MEe`vq?G_vkN&+{UbivW-Y`uU8wh+g3@%qYEg$z8~Ac>cHO	$"];(qn/ubggO.N_:[#\&,!r62'`?u$JHwcYm_g\ad8V|Nru=H@uq{s\.z~CgcOU*r3s'~-#Q=V3$Dzt{y|#K+)G:VQ+u|1sRJI"<CZ8J}VqA(o Is="y*IW#7 	#]mM*5D}.!VxD<8Tr	~d0fc`\v8!Wu 2)-s-u+%Y2 `?dZ}p{XNV8K\UM9e	mz0Vm SSWqKoUB<fHSnxpKB
NF=^x4I]6*N<X23bXYw7B2x1c8P>G8B1/,16G*aT9+=*!(pZlg%[8uPps>H`VbJK5[x[$$p>~=Z@p"'qAXbR30'p# T#^e9|q?GN:,2<N NtQ1xIld&[l{_i2fz\}h$u	#1(xC2=IS1&- 	YuWfPJF9D`o`28_[R] xUf-Un#L`P0kvrmVr=p~YhInGB8*`1 1jx!~Y*q)+cX/F"M'{&K9kS8}s|/C?YR[8?r \{#o#EUrr9 JQqs(/]^us8#F8,N^PK=OXX \X(Eea'PWY0@9 bS$ {rz-GbH3]t9A?:R9{ tC:CQGd^O=+4f>gdmw!pOC wePO*FU{7]P7?:N\wpg*R8\1Y~<1W"Pg2^CM?VuY-#mN>x5:ua'>TWs`g{A0{|>TSj6HD_O2\S{-6\minEmDdS.\yuWDCU8 rqJ`4A*]U'5SRx* 9T$`3pzVh%*6,5T[%$y-33bSq^g'9y i1m{Abqx \F9#$:w7h-m8a&CY{12I"}b+*Ce<6Hj$BxA;rswY[j:W6)#$J2u<U
%[zSqklwuQ?'QEE?GZ)kt$pA#*"Y$gcmf5d1x'ur]]`UV  R@B|`u\CQMpn^y+w.bx?jh\FNrpHsrk/^ixuo)#?5QI"5\lo!W.c I<D'.qs>td7qi!g2s*G[r0@Krh6$.yTMwn\!K6O<trV4[*JJAr1t]/)os	D*N' })(7xeZc-s G;Z72} 5f	 )Ww?Z\HLg>Ct#lrJ#@*bigZYYi{{b+fPRe/vbs2=O{M2\J42rK.0I2N?[T.`=:n
M+#>s@j[dCpPk	dhB rUm(bI
0~J<4}WUX d'Rs_@LX f;;]STq!&8O#wr6	s>Ox%9CC6UWJa
Plr^M
)fF onszR $3PJ#81f5L	Uf!\>fk 2x>\v2[@Mb qGgHV p8??Z{Wxe 930n9  {OZ}F.T	HLO%$FCsT>39{#n
X|g]2;'OyV"8<'<KD]"q9):GHm#))|vaAR}3U|lHo,$y5\vHI2hC2UN03T6ijG8b/Y<Xq> U2nTROs}fr@$}-=v-&a7R)$QW2x9i_01999'Z"}RNrBhR;r1ddPZgZXI#'xuN\F0~YA8al5@Bp?Aq ^2!wW- ~J-(l7Oh4rxU*\S4I%#\AuvU1>jV>	
N|=*/x]m-s
0F!]~a< /%O?xc nfW|Jj<+n92|3N}2*J=F=DG$S%N 	,bBs"KDdr962ueg^5X-y=j<
2|QqQ+sx	$Sk
py|J_-w"Ik"H[$pFrh3DpOJ%|vFw$d_Q|<JN5H@ljZ1#&lsT%kdUu=F2]4d?I4<o@,	=k5fp{S!K(7Z{Ah\[87?b>F?>zg@Z9{=Ohu-VoNs2\$yP;s&mj+TRr[i}y8iirJ/>Kmh]{Xj${N;|CvnV,18I{TCs>Y}Liv(*Lb_lU\|u;
'"+j7wR,Og{G#t:L9c:}*BH ^uL"BFGYbdR
)?Lgp@wI8(WF;X W1;.0w@<U'iW{c$5r\F8sz1|_hOZ[;mWBBvc>` q[nD-3`%!O'iF*QX iO!
2>O]0 >)[_4'=9>kp>Yr,;yv>eh\\2![$P3*m1"Ew7eNpHM*$X]	1g	Baz	7H]D!8 ~iWTlxSA%$1!#I#<Kr0n4G&]J,	P*T-	89WIyAr	+1$k(8'SA<i;fhzy69$#[%<&7M:!wpn6{
,bcb8 ,jxLr1@( sS,r_@Z!Rp{I$]?Ou ed<t*q<g5ed=	Y%`a/v^~,%+)2GE$1p*HcXJy<-y z_jbo.V/!&;8F.cOT<t5Y]jnUfO!SnrI>+MkeYc|'y;L%6PtdSH&I#xN\tiE05Q}$ub|  1WYk~-n)Z39B@X4h[=7U1It$u;)D  g93)|0Pb[%cf5]7
zz&|$(_$#g%rOz&Yg;Soa_<qv@w?jS<t*BT@orx^oA;#Vo$(z6>akF]<*2X ~XGBkrYB/~8>KR=G  =}jmf+FxNrRv{%Sk/li~d:I=r6u_:	4 u5\n[,wcn6{[tv! ##EZBTOzu/66:bY;(6k\91UG**7 ^nV# )GU`sjTb3T,lGH"m,Xt@i cXnkH@hsUn1S\1Lp>Db~udRHx	[wV|C*U$qsXT#ZTh}PFUeFqXi{,bF6G}DKUb >r,,\ :M)UPN{yx9KuVIlvP@aC@f,px'+$ap
wdw%ex Z7G"y[cg+b#;PFvo}n%Xx$5QPHPpqMz6	+:uy?$4rJSgO_kz1Ec>+n?SEV:Le&2Weg C8TrK$0idIQm.]5YnN3(@g'?,yK1%$B*y$H]9'G.,
?L :#cJEz*i9"8MPgA v;! sq\I"8>~tEw4 v ?wJ1<9=FFA9=oRpxw<8|E(MH4|7Z4_\lV	s 3OY<MUN|fm~D]Kfq rvB<r:?uV#s|?zH{`:t?ZSo_EGA+ U|*aL.JnvHG8#&.0i24eHsn=N+JPmvQ\g,]v6# :iS d)uj|LK26z~v%{2$U.:i+T9#<{UfvDQ;z++G0*ftLy)UAM8J82FGQ)gdmpqGN#bpzw3(~?Z,d!@y<}2kYJ2G'FaKy2Iy-pI+\	
8k&2 1K[gc ^{NVCFYULY|E>
v^]cXk]2Cnp0r1]OhW1XL;TsL"# xcKYTd 
},n5F0\ZhgLR;YRw/I'9I.`H(QNhXhvz {DyC(+7S&?J-J)&%"|"!zA>yIL/v~Vtmw
>~67M4&1o!$8}WqB9+a&=X/OK$H;18R@Uk`$q$ 	 ]A.S+gGEI[\v\oc 9E`y Y=(iOE7vkvvy/ iwEWmcQ*dbA&<}+b(9F }zB&F3yD$ke0n]'T9CU=C; |V	
8p.1:z,jycv$n/@o2kBl4@F0"YxW\2 +s
1>\A#k~'H5M*gJp9(NXxAg=hbla1|M 2}H#!Z$Lov(6u:t&,09kISaa
F:So|H- 
=MW@ 6H/ft;_HQ*@B1k{unFWR|<d,tSI7zvV9%m<;AHhy*Lu@>*CygDq<k;!!/;V4[kuYG S0*c.2'sn }/ \ Ak.H<b	c_]jqK;>8+X|Dw[8/dy'$;Xgzt"]#9wBGI|l>e:t9`~;c}!#~G^DQ*Td9=MFHm'#?+X.`T"@UdL);5PFJpUv$zb	Zek+2;)%:1U9Wftm]f2nDqG|`,}:r+s{X.Q!*fZ}JkM#&ix>b8# 5]"5*@W !X
gi3&sc?h#]Ic8a6s?,Zec2k6\^"mcldc:A1+do-\AB]j9R|XRocnF]i!mS!w8IL,3[V0aLHnNTgjve&bEnk5]kQg#H.au_`0px\s3\"s n}8}'Sw%Q'M2lE;
+ `z`K&O{.'h![gxz{* ,|JN2G)}G:W\KZB<0>YM"*Z7p1Z"q^])m0U$+n:>we<m!cZ3S:\{[5te+|igeYH|';eH!]RhliayV:Zw6<iU"'1>2)wRE^=s$1qk{y0{FQ]x&m#zd)d8s.,S9>x+$EEC<#5t3][^}Ah,y J}F+U%UB?*iCu]Q6-#~G;1q^^^X#JOTg'{.1]UH$s<1F$6	'	QaT^jz2F>[vcA;*(#5pHK	77i :vC;w'fwhUU48!:eSH4gVS](F@!Z`AK	?rHQVS,Ka\iGbj6#eqj$	]:t[;Hv"d+T|C\$cSyreDQ!9?J;ELKW*QTqN  3D"ZM*Wd{@;zhxp\4bt sno'vDRPyoaBgz^bRA]phZZFR%>d89 hq{M5q>B^9`o\Kd~66x c:).=#+gYtGuDoKG5du*BES}Z_{qrn{O*Es?DF_3:4SE #~TZwgjO<',,qN,J?z)D 19i:VW$y GO>1nyl)?AHQ,Z@Q5g`w B1Eg'R>Cf>mc,EPa(Zk_k(T(n d/&A*N3woDwfbQwry08;=sVXVw*:&Z,xBg+xQT[sdp}?Lnvw2q 8DcV[k]N4pnRm},J.c`#uG:k<jk
Xv&HX;k5vt
z0]
stl6 tlUg; lW`A}vwPw8M7G6a;v@3G=zPMdeTxuGp.,#!,n.#I/e>X30|]AwczbYwp7y+[6juE_K_!V28QIf.pq-P q\"."	1Bkk*@R:S+m;&Zk5R%v'qkt~EvK _8#Vw4l-e:E{BxW,r.qrIe@p8'`~uWkv`hvivVFOmP;
d|V::~f_nxU `d%@n;*YI#U98qe2w(,7# #5491;BmtZ*":>~F[5/7d?*4H* l c~D"F8%&_zt?j=?C@z V\*C5|^F8j49fpK*P:8[FGu&!$yH>'/b$Bwyb2}2#A+mV0 O}|FXAWs2a1"x^3Rv,QeJrN]VP`uW]XXZbSqT1&#eZOae2F F$~u0)by=Nj4^O)O*Y#y`7x^V9NXsD;+YKJ9 ~Cd)"~[;NBU~I<MjCjG92Ft$Y\LX8C^[}D>#:g\may+XA:p|?*Eq=q pq?!32M=?	?~|?j(>9x~95^P.e"`[j[=Nq\\vZou(OpY,vtZhulT?c|u~NYPe pKtXp=D.kSM*"5R	84&k{N._ENH+3Wn^w '>uDsT 
\~I9l$ {9?q+,},6a:{R7,(o#$iq fKbJc$hcR:<9n7v~ z}BJodRb,1+1743izdQ4=A">jgImMNYF`A
fyaUcOA{lj"2 <%_vSF&+=Et$HoXTg>O20,|<[G^R,(s>t~6< SYnSQ9)qZoF3Jh~]G'vqm Fg6Yofsq
[fl $P0nORU>	jY	$s#yTYa:g./dX%$ iBr=: `Fl o,\v7~C*#8E$ y'nYa/#8#0}q@V97h{Df\|d}1bF<W7m yc=X?rN~H*&l#E`hwW%!,ivemj(!$pIL]&Vx@OGt}@A @pp+$PVecMnb<3okWbl4Trq5(WttSMW8a=N+Ai^]wHfum9Q0Z8a*t~[?|-5:j^?ou$i	#XivU3N<]h%CYRx`4mgg7mjQsw@$4g_L[ 'x`z=<BWm(c9*?D?|4{8 OV#G4wh1"c'W6Dv+xXJOlg],_qti Rxwqi7g;U%R>@}(x4Kk0-cO6Q!n]&|}-s,S~+IxkUJH>u$rK#MF_i6Z"'i<BA=kAu5#%3~1=kue|9<{v~"C	pwIvf6fMY!80GdhF#evId `'
quH}($W3.]m2(nMHN<>^cF&<p|W~*f$-=HRQ$ezg,g`9LT9yDR2^|_L@y;G[:7y@E_/fV=LP,3A.<V7iw9$>g=?i;^l6=j65#c=k~_8<zV:fc8]7QC9 
g\UGN?JhM&@3GH,9 DQ\v> ~{	yW'Z9}jI7zQp*4s jZ ip ugR*1|}FLxAG#U7zf;b2F E;4=5)uPO 035W!B!s[vn+fG.;/sN)<bh%\}/C.`{Av<L32U =*+5F)m]s"'#W	r&$egN*mNy4x!0zW'f=YD)"k0O; d 29' ( FX|+fJ|;Z(mi{O<l_6	=z/`c-bV:FIMpLR*Xvrf[{<ng!Fo5 _LN*}w,p1ZkF:rk=V 
:1:gH+Z sfoCEX`Bse;O+EvCWO1bK!_	ktrDOGi?LWm0NG<|E>]=>|=;$~2'g{J#/x?~@Qa^\I;gpA<}iUi%EN$hp5gE"'\$8gC]iSIiI,l?:,;B0B~?(u/`aeq!<a226v8}M"U$^:nPOM'jRW0<#8$Sz<tg)[T=LdAFUfwBlCfIlU$@P+Yw E{Ae?w\M"t|wpy :Xt4j:@8xZ+&#e	8Lu%@8, 8sZ_o"J 	cq'fo&;N06l<~lYwVHN ?6N[4f8>~H"@I5AB1G3XWC9[Wa`%T|9Uv><,+py'ZJKvw2pq?JT~{;Onq<Rcv\Qw <MA_ZFe$G#nTeJ p|mn:F,dP~I YM?jOv	01Tj=/lt%`gy;20r<qy>G=M!G?S$7+}9ZVC,%Ulg(|=y:vmo\6,F|ZV6GY7L#Z.Omq?#T~U4oN <rp=ye{Gv}<p:q*&y9etp@"l  by'rUxBrzqhyuFVWwT]~y>
-QGfmlc z x3m dXGzr`@wpIl
yxqc#R%	#syg@-	D[Z,4X@*qQQgjA_f`wQo5*G!FnS^0 ql`<lnQG+iKqZ1aM szqntz~jeK~wolg8Cr;)U?\gu{*p3h,,*Brry&MV= zpt+ aI(jq+*t>_$1CeV0?6WFl2pA/p*nbGcyUB  dLx<*?::mjvX>0R j&6id;\#w<P	p/	--n>ROZ~S#9YGmKFq8F[pW@ 	RI_l*:KB1?IV,9x5`rCV3Q3Y$kV F 'wOn;TJJ$f6$ "P$.YZ QU:kxUs9?9<D9)#?n2-ev q\VnH\@##J{bj."VtQ]CR^]gr< q?C<0p 6=+_}H\muK^X8z{zUNkFq 3[+8?+D`\b|v?jzg=(Om5&a^{q=)R6d4R\x< I*1! OjnM)<Awg 
yFaR5anwDy$f$IZE{n@9J =3[?+dg> Vu9dJ9-+F: cOStj+$l|dr:Xq+L`y=IkAX(3ysds4NOj29-`j6( ?+nn3*?bob9m0~srvd">Erqp,jHk x?zk[9,V'jHC)Gaw!lG_3[$3g?2UhMi0Le*7>,yE.l:
m7q$UR![Y'2zB$q\`(mjYbH
HW7-fl~sx ZXp(*C0\m8=$=z1U-|fq6;[REc&Ku,dNEBHNOZMaq:\J@d 5qG '5we%eQ}<dywj	#w^0h{!E
:`Sf2y3 v3SG75y;cF7gPK<7B0?3Lt'k9>dg^z,9{wex|l0OJY#Ssz(^_ru=R=*,':'<snMqU %0!] 1UFwH0+MZL *@u`"GX#',u#u6IOb76M.q~<$$8LDAZn[wxqurGtBeUr286 !Z 3UG_QsF:)iCGn.Wb"<c8RB9G
3( Si+S:h`0A#OBDb@lc+/$V`Kp}) wKBg\1< :^lDX9C>_$	& [C1'><I	1EkF\F6vG"ce'}DAn&:exk4$I^GRtG ifYw@q-[H34]:	n,Ss6F4|O?y{C:\vg'<{Sdqs6xQB\K12yO<Q!SfiV{	hd-K9\/@;LE3FVC"J/	s6,D;Ah@g&xUP	2gVAuZ=4 jn8UK1 sOT"S!S'>@TyR?zcDRH qU3BYh`x&;_Ai;
77ew.I`q5FdJ7OA|?bmIpn~]wW gs?r9gH@o	7:EC4J2+nd$y
(xJd9`Wy%Y77ilXcs y=iXN2$o8 gM;7td]9xUDn\	@\uvFrCE>|1xFO<&d"4[bgs<S#;27$/!H I5<CaN3TuK}+S	2*;8}$Gg(`nXc&dg!XO)HPvk!FOu5z"hP^+dIr\'=yf	>+-j_ZQ}zg9'laCI%;p68'1mFnzgC	i<9'Cv6}0V *BKFQ)W#8nFs*GY,@=zAj-Q\FS\	WtG|,	WX<nC78X}0,A>+d'Tp]M9:-PE"UMR1;rd]3Rv4<i,ZUg<zW44{p>xTWs'4wC=#	!Sx\>x$w19b28ACmLv7T#muj`g zNK[;g^EtOs0c1FjKlZC/Q<VBT!P%`nm70[D\{hZ] phyffw`3N,c-#TwQ 1:rKs)  -c	Wpw/5V&mqMIN+>LgQdu* gxV=]&I$YE;H 8=,C
=pO9ljK6 g J30QY+NKgr3HO8qy9 sO|e dp%T D>T^D2<][;6<{#ZV|=w{sRsWU>-D'rSy#t"=G##T'Sx
aF5Uom+=V'my  H7 Fz`s3&@@{z;rrizE6Iyk$9>szt<S4Z*iGKflL2vvW8?jYw%5=PH1$c.AbA^W HWa@'y!SIY$irLn6!u$$%cC<	T D%`9AD+ *[,kI`@1<?#Z.Zx3K6s`8w$eWh'+GP-'MAn__2Km4H#<CjW^;pID+
#T6#>@LNz\nOR!|jEe$\'''?:+a	dTw(a.`Seph;}gwuY8 i.mRnK=xy@#yfvvxb{9f^+Qyg-W" O<IL%DQ@g?eKo^u#mE[$qw#+@nSH<|=yfe zzt,92M[wtT*quuvo%YC7r yV5i%y9nvOL+"UdQZR\.A%x#|jQ Dh63X"zd-b9u)fwu~Z# %Cc?3VYOs- r) ~>t+MWH3XZrLV	EIRQq6w=zRyQ6GC>;1znm 1MZ%)aF)dP[H	8jqC!&b3$32;,sZvtr_LedNN[9 $w4)6?_J[Y[P FP/=q#~#M-$z2L1[97J&'IJ1n9ss96g$J X>DbhN6VyF38Ghpnm]qANz +KP>X^{UK1bNxQ4<]vch/]0-^0==1+ptK5[ A#Yf h44:J^7-rWs#FK^3[$iXHw(!yZL:x).6 ]{] dRNp>
 A'9P|T;t.BK6	.;Gk~f5x9FRU=8_
]8+*<h,[jf]]1$ ?q^Z7)#qY<<eRnWJ9g	p_YZc&Y81euq
iowr7-g[ w0=ilREfB\8lFxUd'V~.t|{:qHR.=sn\&Iy@5'=Qs-	]$B\_vO5sQ]hFF7{? n#X7*3]P6~me:e7cl\LUFgz x_p=9#?Lf8!nH\5JJf<HU8vsuw\fEgI!|^)w38W#8ZYe0?IEt}eYp$)f=.-Wzd[<@Xyq3
Ykx5P?3y!s p9tMnBQ;l=gnIpASc gmq5QnhXp>im'|pee
.nU?s:[Pv#+#-"uy*|4'hE^88^3[-#B]Z,Sr-?R9C]$H;k%sV2UE]X	XE{f1X85k^EDy~bO@PD&7zOl4.&1*6%	p'v	L^BVW&f_J[	'i'OIg5-$RIc
	=oOvgU.%p"Ws++re41npdh4{nLA`!<ZA;)bs(lcn';e6"v-8pr?UaU~j	vr6xjP\-BzqH2V=Ec<".2IUhy$x0vp~[=7Fk+YQX#1R~ui7[b<p'@SDHHl&yCf'\9  $%^[J6B<gudeq1rqi\i  |^~'*_&#8>|v{^/}1Z{D2>\u-u+3' @=*yfhuHMQ8"?E.460Kr0vyd[:qBpAp-:evyMNT9V}ixPv:2yGQ_@fU"D RHbKs$0
wtI #M:vH\?l(u]3SPpcoS2-c=I8
k3cw,#E*|z(DmXXy~-*,	wpUvz5q:#%E<5]wh}FP=-}r
_gtz>kldXh gu9aN<{e!zc\Gynnn98<AGJd[[/:v+G=r$6QdB:qOv#XKn3B>6'Qk$dn2%CQ2UK('hF>MZ (b^g#4DNw8? AO$,5L O,v`psj3tYpKq2N~}Jc!YPV#jM[iZcd`ORY<(=]$k+`wma~UY0b^ ?/yN,E $ jS)OL_2w_q[;GK"Nu+I+Yao2)y##GS>?a]L>d6Ac1^LvMc|<We"
g/#'_*>dD[I1#3LO{g%uIcq%%/.Zb?*1yL,4~leC=8)|Ped W99
s.8UtjWXuj
F#'8XP|u6xy5"lWe-taK8'A@=8;I3vnaU$OqjNQ3UR%.K	t| zUY>{.PZl#9 </Ap};c?fR!#|7r&4TKr/Trd|[6~(8pLr^vH_Qw$f_SHw3<)x``)al/CtL,"2q31F_N|? U'q :x9{u)!rD|8ngLgM(:? qXYJ|":@&W	1N1-V/yLrBD+f,:z_g?[UV%m1G)3IyZdVAfKc>muH!A=<7]DM&`29Q>LzqbCyIQ:pGo5y5bq$G#nN}4el4iqnncPw<sLeEu3*.mcPQt7*C[`v; u,C/rj&0@aBO{PR+ 9)=3W {%^#H\@:a^FR?[$W$n>&5tZ=yg)\AG|k_n*<6~c"%5Q+'bf.f@%$ 2(#r8?uvw[i%]o|b3K0^91BbpY}Ao^_<0]LV33Hj5Yl..)5C	|A' Uk91NWW,JwL bF:`bEV]Xa6	i"+NYwlr#{s 0K:tr)[]V2f
H9#7,rGNWjSY
yn+%giS	8 `2ZEUs6R[ wGOjf89$O#sVV*jz fXj:ucN89u%	<r0<h% r09e"bLi3Z"7jUu `r["e`qq(y=<@b'Gp 841^q<zc#>g5[p-U,~O.q]\F-`H<!H4"qiA$Ej;FCmDc;xw?LQ'=w5dcXe]Y^$C JmRMf,-]I}d<'EtDYGLSP.SJ.9#2$SbJJ":9S  DR?<*Mr4xb6TBg-E;Q?ku:
:=: 'C
[p`>[2k;Cg9ETlw;q{}{q"Tc2wmCQmtgv*ZFkget=[Qbq8t)&D t>7n YT4+=>tK.|^BK*i8u!%;Zgk[?ih{e.f;rVl]'q}z|f7f;<TSH>e{bP8le@{qEvHrJUf	B:w'vrqr#d=07r'vOK9OEufI,#F0<PZ7g@j0Q1O1/c=}K0[g5{ 1Y1$$2vs,NVF<$ys)Fb[doNSxU70yDHg{yLyik*8F xs'mEd0V.G #)C |*I?j=+re$yq>X_Q6Nd0#[ATF;lY59, =}{S.y`p	=3Ztnm*Ka'4{"KL7bKUUE>Hlhh)4-/zwBDP)Rwq_ZKyoq{ZM r1\ 
G_,r|&C5m`x=y$F9&|uJ!)@z/}WOdMIOsU^d Q9l^y%{^u-[OHm1G2#c#-t+F9/DaYaIql[
HyPOf.ckIsB`J=Lc)clc!o%}g@})LR393 c)Ife#}.GV<lu?3S8/hlovZ'^00<C%$#?t#R]46u\ic_PFb ;	c>GguT^$~ g"?ZmRHKKn$OywpFgTzT6s"KDA$*Q^KOSjm#jtf!@$LLj"8$
N	=)xr8QsYlA,4$m9N{L&8<_J6K(H\`;N@ym1@\'VY)MIx31>	8JqGvFkYdllXXmdsqyX`$,I@dSi"IFieq4>d,`z`>+_E
f':.9
ne:c		$f VEni[P
3(k3LwJ.|ec6EZ@dxN>G:o+\oP@Yq*B+dgpZChg\c/ m5%`Ou,#Q>.X1==kBEx6	f~;Xy{e[#CX1R,cv1:}+[Kvl(;WTI|$=r~~uu8EKiq!{G1nW<hR?qXJ.R:gWw3n	Ws
oEw?g852 88MVg>/xFcR{lcE'v[}1=?MwZ,][n"+Yh`uFVumcb`$0)e j` 2m:Vqp\o:+]<Qk92Wv'A3tpSWqH,_3gdg]<>d8Ak_Vk.j%^5x@O$^J?="$qK>qt;s2J5RTcy>ZHdthUQD,@?S>*kALCgWaq tvb\G$A<@9&Y-3V+!Df-SlgcFBv*LIw{6rYQDa<}f(K(zz{A5"vh{24z5RsQX'TcK8o_XoqC<t. $&;@N}:vnw]lc>x@<]q2'V?9	pOx#p;N:g48*[>DzB,`y9N(o\moN8/w(W@l8Y+%3,.0y.c-%9u#wJ(y$pqvEp[vn[mG+#bOnV|}hmN{heVhRJUFMTqpF2 xj*Nv/kVH`uDjt>qW&827F`O>'b_#5moS|2t;sxvWN0a 3cp#'hkydes	F9i.9d$#]O&u	 g\^HBrK{s%#\<=j#iZ7QnZ% [m`wg!UkM4zL^2;H~wQr6 C 7O_ZD&Uye'UyC&Fezu<;=lFBNqz&)Ts8V;enD"0e2ySR\1Hb_	'w9v/!F>U?i8W#x\`	BF}0p|+oA>mw|@D$299w%YnGh_`1|V=T"0aAeVI'	#9#foj5MvXwH 	So.1V/*f Z]~/?p0
G=~bN	<#j:e9( k`:Gwp#\q.:{#.HbinI'"k9s^+HXq'*I  ;0N	1idDQ	 3<:)RIc8:$qwuE{K]BO2bS}u'uFapz?3NpJfE>vxZLO. =[~PnI+]uus(e#cBGwcc!vCHKlmjBM4QN=qTxcNSr_}CtcaxCLys"a~iDWe IgEwm4o)$ >E+!,1HHrH"mJ2qJNw\<J;m
2s$		5_j+?Sd3.! nT& U,rj{|1IxExUBp9#`=NzIs)Xazo|2rlqP'|c` n`k2 |RM.K7z qO$#WfW`rO+#[A4Yf,18;TzX8+ZXM9#GQ(p:p<2'jkBZ&bc-|Ca<`!ql]~\O"W_U"mz!b'G
.!^}!zc'M=Mq"Eb.CSFw.u}|?b|tT]FXQY<!I@'z?6j gv ,3G$j@Y xeRkc!4V1*)!83K7Lts0Ddk_D/kpvxRW!.+2Xdb0h4p<0oFxz\o;U/ilai{]1*6w1xxg Vc`]$@< Yij.I|V&l3R;ferv,/XHd6:cK@\xr2AcT RkFnwbQc gX)'<$D+'3Gknn];`#>~J{+r*f
p/\){duI``A9G,(K(Iz **eU]cy)kf#LO;@cic>c?k=qt2e@`|8kGLv#G4RFqRc<gdD;B|# 3}T/!W Heq#;`gk xRA!MX `tFA_<N vDk5+ |p:Q!4k%/ ! rIfFn&1Og2,a 7E>@3]3RX#]F(>&k[H`; xza>1+5+zW-LvRB9<(_!OQ\ 9E`NM7R1, )ln{7`4d' Ou[D2-_ 0Gz##T56m3v>%e) #;<sO,9^ZKpA}DhKx;
9 HPw2'-jtTiw'k{ewv(#9ciWdThj%.sU@
X1=?:-yWzP*"d8IR9%7 JH#,P({rA',xJ-b`0$eTAtK=(. yJ#Q3$e=8ev#Fxp8.RUYhT/,\Lehm HLVFsydDr6Nq^IEzjs zxGJHV8.LUwR[cY/v#N6?2D13]wO][w(^1t*DD h,~Uk,"vC }{$Jz36Eq<$	`^vRqWi6KOw=WNGZM(b`(;1\^DRI?O*.|8TA:{ji9JU8t)mldvG3$1[~	 g)^_\1e:Hn-q\*!NixZVbrpw*5[s}yI?g0kt9suw",mf-:ivT==B>C+B0]^\MbZv&c=!X]UGS\x:U[9?{<zb36S v~T>#n 3	y9's!z?-mP|'(Tmmr{4n2 #FawC.d"BYUcvmzWe,m?E]tQI^{ZSrnRk})pl0<$6g 0D8?MRa;1_k6MmufF	)[h
0W|SM`R;Uz\='YXdl5#e:dWg Tm6<6'<i34/BTE,*[;v r}Tc*NNjuP0H$SSu9-"2\,:!uKN/W<:%-g s1qrvc?U[Hd7C[AK#T'R;W3Cl9umB1sHbu<6mzg*dO;@98y-bm~x
Tf5|XnI,8<d/;W\*!G=23iu(B;KrkI{_eqZr{=D?y\?R=wI>@r@$c.g?3/inZ&-<bq^I*ydQF.q/;
Oc[M`~"'RqdJ5;u1Ug:Nx[u=u2|~S<IBh xiyZm y>1Kq1#S}zvL[c=![U},r}3XCRm_}2\3:r.4%-\>q<cV-RG.K.PVFa2A	DoIVYgC 6G?nCg&h!1ZL78 >xa!Ym/ '<uM*A
^Lagy?:uYD\wI<`ub	oxHqk0w3^ s*^[6F>=oXvJ{ aESSH`|y 3EQl|_#Gn|f97	h0vy#	r1/s!vUa0SyhDh	p VCvf	,1uT\I6<9WNOdd$iEE?m?:4)#  ORPix(o>H (LG#_c ^>k_^+[8,p.:}iItit&JO;'Pzsi*,>A_yA=:Wy-&.G NO_Jj:qS>sow4^=&NU>hlt@OW>V2}pH(^]5SPYLrml&N+,iZa4Y1Fy^:\Zt1ddV%qn;v	1@kk<q-$,CGA A#:"'9fd^]vW=O tm7]JEP-"Dfg7sBaXVFml,`q8",O\thmu-]-,1"f
h{(2`/gZFc qqN p$/bV{MH]I 0O4A0V)Q)yT5hXcIaljx9Q
9]~Zq'H?k2@\#1>?95;8^6;AR |;X^m$?:P5j5	i%E}'7]w'}Cp1eSiq<LA1}OT_/}z~u<-2>6HxI/PBdXBpqvR\" q#-L\!yZ+kS?#GPpUfZ[^qwv/(nC7h(EcL$}*k%S
6:KeJvm7(}z.;8L]h$z! ZC<dl\7>yw']#K{+s$i4] ( /1u4w_<\IkebqRQ;h ZL+xPZ35v[P?Q~h'WEnrG^m+ce20:Je(kyeIi/o
C85^9tlFq-/dqW3H1rNI9<};~
7C
Hp>Ghm&AJ{
tdu Q J gH!M	 dJI4%<cIe nq ":LhVrlq@ I.$u#G >y;FieVLs z*E6-EI3[k6.7}9gWlKwxsr$LEFFNp},F0|}W0zV>+x"RJ9Tp1KSf1vAj]idw*$)eu{pk7{0> ?,MvQmqoW AuDk;!#f@)hsma	+uI@oFydUVV8$8<S$a\T/~Z[X`<q
viv`N988Z		*)@*RBN0Y,x/L{x)s/Y:zi!XE0~OQ}6)f+: ##C[^XKq}h]\[Ffb@?LsB{]6l.a^vG$;KmAXsOElO`L+I(+y%I Q9KN\u}v%|wWE~C3V79f'j9[c:V7_{WBYjao8SX}AO?9Qj7g7%#]y"$CJp)'B:= mv~LLc+wt3\wf  =M8upL :V	nuIy2I3g )v]tM?[as'brU3Q2[5w!|A_#TbC#(P|})9FrB4Yg)Kg] w%{aW]%Oi^F5dr>Y9s	ceL+zo:03.ZJ%i!S6[U?ye!pHY,sJ}G5i R; G:=:`g&tA-
$5PWUAI= ;Km>)~+^E ;Jdq1+=!cd|K'q,;s3KRu/)m4I@^{}Wav-"%DJ9	mXl4[#S>d
;;-|Gmm\*Kx>bFt0L crn^.*	Am#Gp2q>^t,o2n=hO\:6j3*)`|FqFvD4m|/u8rzUB>p{&%tbzfyvXJ\6W9fBzd*]Y>y</._G-]7u l~3Cu>gci.ejfE1^xGB?:U:G.Iv]pH_B#X;Ij16TvVp;X4*x>ZkC(d4jc  T@!
'A>dDb]D tfb9v	UgDe>AFU\[i9(idz4+W^lU'	2pF=	RyBmu*6%?Z>=DrG`&T x ZsZk< Dxj>gg|drrJUFc,"vvM5[ZIt;>dj=5(~]CAE?D98+A4po
|=y w>zg*-a`K`l9+>&WGnrgm0NE;#uGPV3t[+Ds_B'gI\+)e+e?qjS g'ETLJ.
%7gSiqn?S-;?c*\hQsR>i0w t~/<UN8_\Gw }AK"bqI22JX|LCth4F ^tf$u0j/:f3tA2vG9g|H
omodKK;wdyc	o%wP8K/qLH5$+;. []N	($A	I:] .!P|(m<MN!#S? /k NG\;=As\k-azr"{Q6ju}R&^X$688bW{DR 95Fo$0l.,*^@}N4VHtDn?z1Ty7A'LkBd]8u8Uhz}if4VYFP|?}NZKiWiht c<w
Aeh	mj
]K	@7i
<UrMG?"kEuk}OOd`F rOF_sikkN9\n\ANT~yY:kPT1$r+l7\ex'>sjk?~XEJ=_	 V=J<m~[X4 `On62_@I"*<lRCjV!Y'!a_E<]fF]E>s8od&h8$>rs%9s(S<$Ck7SA;m6s??V[bodgx0sK('Y'Wl6o"]rluCu7h@WFvzU_H;7~I`l|ECnF%F&YY-'B|2;RJs VtL3+&t[<in&qKNLc>^2wG9<u&Fw4en5VYm/c(Z1<<
`[Kn?iCqENsQ	cHx^@:sN;1eeK&bQFG07D h;^OGqj-ff<(& ?zl+qubCN$ya,ea!Wf/E+Eag*MR7f6`(.MKsl2I+^PuKTfXT%BO1XLte3S4#sl7)r 24$Ok,Q-@J)NEf9&dbJG\Kg
ECidK` 9chkR9Sldd-gAIdR`:Z8Ot/KmC<gZXOel}	_ZK| 7MGbe#
f;[#4&t{@u :wR%t;^tcZ[;\p|*[4	l*l
2 S1\CrwH yYXk#hq| x<X8Vl.NSl-: @!#N}>P!y2ez8<(M.bP'5m~
I/vMu <f uwR;Y4
K*!?M
ne}3WW-?}KF2XucVVSx2_&i[HP, ]>+dO*^[c
U*lG#}&	2DW=kIm;E#cL~kP<<_3{V'^|u9'Z4k7p>@/>-&4=:Xs#ss!8sy"JFPiin#9
zR1'IXsE9=nc^}q,T1i^86S)_B#v0Yv|?3$cWq+.c dk1 <w-t}Es`{O;Goaj1[dH=s<$q6cYG)s?Y#Yfr=|vnad|9P_r<EIGqM>:MV)e7V5IY$MgG{Jp\ur4cdf*2^pXT?nX?	b/js,PsW Fe>9p1VTu31XjvfFf=4.|G1<u.[9@]."0)8>2F{iS#J,vPiq[o6@vsw(U9~ZF^|X9c UdOz69jQ5gdqom~H-IYX}_^6YF=Hv~p.clPC}1M<ajTp5PrIG$O#q*dJ8a*Oqc?S]{y&(I$
0GLSi-8e{C%7n?A>z7(73*nuS~0ZMj]eL> Y$sN	4[/gc5zE]Q]5Psiz#mD[zGgQp'W#rx9`b=R)$;c&82
=iZl&_ 7Iq	JN=+=2 #9G"%V-##<(M#A t^x,~EqIej3RKii= (kb^w+r.9*x5#nSO&D_p Td]	9VhVv/"klEEdP@#*@V8f	?oNa&b}su"Dk><Z>P1,H>fF6U1S?M+PQl>k-(4I x=A1p=$jwI|KR23Q	>}@N*[M?PWc7#@+iD=:}2ycsXH[Jg[>~Y/\Yr<=is<mBc%s rp0xuX)MBKk 4K8'=[B0
p3 zI!SSCB	|p<'G$`I0@	zqt"[.s1>a<,H&d<(Q64FHFlc^)d=E6a$+qsz}zZ<DK|B9#nf uRkQsY	;E^!ny:zS?xGui$C0Y	4naH6wGPxtY1sId-DPXd9*$h^Kxw+'=0s94/beu+_ZvXHpN?0x=JSY9eT7F9Y5_~]A+ Oq	5+#|RB#uxRIcb@E$b ^$c+pP?eN|iEc,WG!2O ">ZM+nTc> =:rgDFxA?J#R3o.zN{>X=)dGM[P[w)p<qAw$Nqjfq~o1AJK-CH2HKM2,B;m.}Mzo G%L	 Oq,qk
CF29
GOSDG_ [Enz_5nT+WuXI-RI$ H zB||bTd*RJoali";lyP3S@5LV,{%dCuck2;+Km$==b!8bzn~u(%bav}~WqK`-Dq$q#n	JzcQ/]nYq> q$rn 1:}\X|5mYYY< yzjv_) ],qWy[y;8&W1')[J@;		T G@O t&xy4-{yXe	GveQ;Kl9HVw[#'U~vS	]
Y=GOWm[]n:;GO
i*3^_E	sY4	F6X~f5SZ"fU1rq8{4fUt[rAUw81.2}RSQ'+_XAHbx[0R	kYgJoRN_&$FFv3z>U"3xsR2[x|020p~tEl6sMisI#>hIa9@vpp!%\}k(	rb^m"lh!PJh>Zj"e hJP6'tqqVD_pra`ijQxlY#d(Az$Hh)Lbv'3[*l'\xr^qH>@0GwmX~fUqc"Ldor^jbv26`bo&5!<=:rtA6JFah'chqdgiR'hPK]'aZ` &]=d|#m%Nr0G>_Z["}z`fYQT }=seyu~"(wu|?*dF?*y^*Czzun[NPdg >^kb`9xFhlN [=IAY#dq18__hB	v{K;1p02)ctX3]<6F4[N<(in+9,J1T2'\%lI#0>5omG=csyEB@3'IEXc I\`=t-b6Uz[W}xOi	aJ3T8tC|U%eYR{q) d9&#;t[TWT' 4td3(e8=DCJW(9\o{x$H=<KMa+mjVd1W8^7 *Q5Bv=VG0O<Ie2*M!u+kE%]xk.gZIS\\EaW;O}+b$mQ88;>38h#L	Y#
9Q@|h=@bmEH$hi(sy=% 5UJ'3(<y[,h	vR3&s*,M9)-GfUv4JtvebKDFk2g1 w$wCA=OtI'qgA].VE>,{9'8v>BKV9qv%G'`]t xGv_/8i#SO_@(Ie-pzGzgs?8rGaj6N6[QSnKn 9<N>^;_ 1.IOXY	gu((21LP~5F99s()R5sf.U@~9UXw|sd.kZ6n'"AIWS?8eu*U<)+gp\Y~ps[Ec[_6L9$+(
X^5" _
eq-/+qHdW=DNF*x =3L{i v<X3|),H7=4_izS wO	$sNE3FO}U+QsB(=KS}g7UpX1[5\^G8AWt0jR\BQ~F{9|.tc.|=Q!2:GZ_IKI8S(,DDXzcgY'c kI=hHe& V{_g19$SErO5Z*=O^| uL,k9]~uA2
KLlFB3LhY.H`:q+jjE!`ry=z`V [U"M3fE@S?4~/fBgr25COruQ/(u9"_Wp>}hIdi#F}3sM.=XL*F1Twl$ ^UFR==!P?s:zh$Rt`<O$j9w<[Dh=I&5U\d|5$@ d1ZNz	B|8`gJ`p:lY1,7pu_^v@9
.pY,V3HPX`o?YD}v8r*dU	~6:rlSiMp_,9!Y~c
Fd$?AY_q*3)}t(4k35Z#&{A?`&\G
UI6pyHHF,~T<NcgJQeU71p[#ZVLya;0I=)lNE`vi)67.f~c}jY?g8P!po^e#eU9?z:K\fl&s:`6n oD,yaO?-N|cAmb1218+mb u?W% %!Ca^7'lJ4BgJ,fa/L8ur*o]2zq]9g"6{1Vfej[pYe?JyBkN2Ci5k+TD
Q]}wMnI=it. ufW32vx}+#9juKvT:wil`xK =8($#*1>E;WplP^ )"vn9rMjd'on$q]#Ri0=x,irm9w 69 	&!IoJjmIw ID\>	`tvj>w(>F}UjneGw'NzJF%!%w<yQU;d$Lar-w?Y$yW>RA|Y5Z&S%Njv7Tev4 !zWI rMjle?U3Z 9MovsLZW['"	r6)ebqB7@3]V`\;>6sJWdxRX~8',I 9P: W~##RG5zGV,3z hxz(;M83Ol z`F}4z0\m\\Qnq9#wlNtTqu.Jb@Fpy s2y5[hX8Ex>U[r  8=ryjXn;$;O' ^rNu\guhU4h9dru*,P.I{*H#t<b96Y$v$yJ	t\=/QXn!d,7mc(G1]m`R) pN1{J}*Jk
/V4i]9R+<'.2n <B4\'5M)5fFxm~qn ccsz	KJk*7>&|+ XsO#5Q .m9j5l2=GDx_?ZR>Q_U
6_"qE[vUdb p<[F<OGv~W}@&yOhB'*N}/x	AE+b@y+dMWv}0k{f1,'?>!DPs4gq-9Fn}|&M$1PmcN%:N\s~s
9Nzj.{F\^8i'xN=<jM!*::Yu(,][wpmCao%mlb	`;c Ig% %IU3.R\,V+:~\f,:7YGM60u$G\(ZM  G; b/	];Xg#5Ucc[[ccg g|[xRcppHzeo'H 8o-t}5cntB%9?+Nm4-mms*nYc:89azY;{_->J6YzxV*\U+v 3cF,Ad)Tl7Yd(bl4Dq#'$?/*E|gWi4} 6>WwQ-("$^TwyD9QtfTa|k 7Lyxf|8+4cbKG+2R?V-R19#Z";4R|@AYp2jk; fS{'+~jS)qkn y?fVb5x<IV?0Kiv ebPI gYvee  y9V@qK5:]-'wn%<B]S
Np99p%gXxW*1+@cPUvrI>U6[x'Nk4ePO#s]IkK') #1@7}QVpd_:8d JT;PG_RVX'?k!l +|<gewSv{EpGp#?*e6].9!go*x,d7MO!5K%O[W ._h%Bsr8Vwe,}Lui[4:U[gIR!Q ,_6RQ9!U}@SJds)V|=`\rxDcscT}*Ag4w6h4?4AsJO#Q_3jruI6At
zaAZL^o3OAvhfibIv#|W8xBQnsGNfj8l)8U4LWp*&q^5
qYzTTt2)`wVS=h(&sw1]>[TPHg]p+b7&HcyX&]Wf![$_E{l 4!;Jz2B>Bddc?,;_.%@0z|{
CY`THkRr|TO3fXW3zHC1ff9sJi
qkdn\ghsSLA<`ccWAP!E0{=;k7izRK3?Py!@>d62}D!"jF\3hi @pk]9*^>^mN0	2`j"k{Ld$[ *N
,stLHr?J~&qMc+"3lt^)4d2AR=M'c-]Q$Y<( I vSygcK5=*;G{?$1wJ/	8+>~n;C.?FRc"
Ct
.kA&x3 '
oavCUc6#$'5agy|~nRVsWdqpy f1*>krFH2>4t`gq*=yW008S|jb\,F`#f#R# 1NH%:zUFe!OS9?GMrvS:~c}#F :1 )}]5+iJ`iu`H g9 ZYLnT
G>x5O+&iW!Lq!~5f4)ijbFq}=kU1`KcJKfTyp0G}>I!Z HI bO#=:85$WHDQf#'iw[p]fg<XiRoqAqu[.rqQmr'A,;RD6x2Z-o!a}{~n$,@OUR02N8&l4 9vF"+8dbr>W&<~,nJKrS`	hp|n#Wmam/H]+L$7aybL	j:\2Ke7-m46;0@v9=xYNZ,VDld&Ix{s	y{MZV##+/c\dz"3VBFp=+m1I=b|
$OrRb=\u=[XL'!XR}q)ma{0xuC/$V%bhT(-&??*w 36L")?4E6:rzPs<zGx(q.!uO	A-B?\	Az`v sNm:h.cp {0<s+p*RX1 y3KVc: T>s!`rZ=>i8}^L>-JiwI7DX>|AhvC3j@h
$4s#XH?W{vsUcf9c&6<q[O,DcI 
WcsWG}1 -0F[ [O zPj7r]w<}`p}]vL#= ul\U:en`u-rnI*8*nz]^$XIirdKd^+ko3Brw1%9ZscUc'k(^uuV<	r^@\Wp'|0_YcD!c}	yd1'uDs3_69|\i(= mX}	9remLQL;D9frzC^Te+!^A7W114AH<UcO?x
Su	gh6:_&>LX Fc7.Yi9k<j&E"vhKwVesG<g	'7/RH#\TO4rA$r0&fU/c$U;[g/R$FJ;1qQ4mJK6$ 9 y{%tfCeKb`u;#-<u97q\nMe^ 4T%}3;Zw?]T6<qA_P=2F?:+,c8*\O"bcFTV =8Z'T-e-#[i 09Y@<6',0dOZ[
i,Gn1RmPznQx(;VO"-y~ak24@I0GbzgauxT:zq  p|UvZ'Uf@:41@4&i
K@qdc-_kd_ZMV-?[,-Q[Hrxtpx^esf9JDQcR'rip#@bNkSz|OPhh{#igtXFFZvKq0Rsy<`Z#Q=f
H8fhlrA*qwT3lKq4 iRL0/ NmJ#"quFRw~ fj;ZvcU[iRe,~1sH$ |_j][K$>+cn>". #$0B<2Tn C5U
VVJ%{MlpF}:_ A 1B--C$[kJDg*?#il3b9	c"FL2rxwh>Mr5ggJP7z_k:Kxcb.8?)kKKZN1f2.I1(msldULO|]eGR2!?rFEJ[v;.d~GH*R.SnJ=IVe n1_WdU_>D]=X c+a%^gK-w  t;!.:h3w(lAF>@Tg4VvV{&MI!dg[JI]F@S4>v>n<7F G#';]s{KnIU5&=w02]AS ~h;-#oR|Hd @:I]" CYnquu}7H@,B=L C^`yRvq*LL$8'Zo fQ6Y/o[m:X?
+: &1qkr	\g2%IBOUN{>|~P|B^'>O,( 3{RsW$2gpAHgUMz dl74:Z1u0 ef9{kYjL?{<Gw~||3kdxYdx2t.%3JtHFK*xCKy'mXbz2+q$)m6:uo	FeoM:!t;02#u4W $6[2}M8KFw`qVFVc?c^]Uo /@}F^'{F%^!LWEZ.G4Qm$\{MS/gN@9
[wE IH+=}~<FlsH|X  e=Xmr,|j'7yyd+#Hm#`8$}=~qVc('r%\O	Z{]dyj;'%C 1w8ljI;ph%Q~cg*Im472 'p>3Z=Mu	;WL{D?>:QhvR\vGbq"O>xJ9iO,U1r+g#	9>T}Mu`E;#*0qR+fkR~-_v~=^$M6L9HPkSyW8a%h4{wn'M.*(_(PDI)`~W P	s&2`e
Id-MVn9;Wp#n2J;M6~M$%1;R3XdE3!e "x WF7i`x5uitrP onFw?oPc /Y7tf|&M\e8nCG,^Y~-wSe6$ZL+2PA4%@P(jS$,o4Q{i.u;!'6Utj-4DPz0\HDrh"kA[#|SW<HQ_RXH$Q\` k4dt%uWsFqKQRY83.@'qZ]>bmGI@x85iR=WLb[[$yyLEnRrzKV2<HN1C7	sif)!85U'mC`p+G_%dB`E-8sec%A>O;2vvAy{lu9	G9CQ,F8'dfarw(+};Q*.72=+4Mnn^'#=1x~`1qZ&14l$lkm<`c#7hu`I{ae%,v^'~	UMx*kve}I/Jq$^Z[Y'xC!//G_>4QWb}>\7tGLX
K8 Pc0\d|2Y:CBa$3]SQ_V>B$0xzi{;=~e60.TgEMa';so~ wns`GZDv2Z0XpI>Xg{@a2AzZ=nP--;pGHW$NKZ|3jXz#d1\xR^N7z|Vzv?sS(\eg@rxQ'99"]"9;gB^vAyo
N:
f>Rry5i]:?{m+VckV$KF)Z]ZHw?jE;RUxuuw60.
r<8 yqLnfx	
CYX8G@GU$y`xotUA= qRZ\;sjLLPgUJfe#Nq].\)_MJ,I@Tp9?t^FAS[GR+I%FyA+=O*TiNS\'_OQCMk6}f>~e1)`z(LL(pqE*eX3WZ[kN{=}s#EqrvYs9f!PriiuS[Kk_\"H
=*iws*YNM)Y(F
`cxC;>}KX<HIxWiRE:0=jNz,xp|/<];Zv!9@?CVkp3G`$-1`V*0k'AZ+S.nq q4;;1ukSFQl3VWx6> gtoo2pY#8   WVF+/#(O@F$kA4aX=HTc#gw=b883YMc d&/R0?"9:pRs]l$2:K#C 9RH<*yG4vsZ#1irE{c_fLnt U(I_\y	\r* ?M4]iEK!f`>^XTjdsLsKP3K,w3QpzlPxt6US[;n0pW>[_ZYO3yL@:y{UMh>GR+<cV=TyDwaB<CsDFTxn$?6Nw/z8(#nO%zkaXs67TrO1SN\	6Q"8kmY9 n2M8Lc BJ`be->`Tzyt4TkO'	'[:d3"bNp2Yx TlYr\v[SxE 89#e?%s:S3'-yR+`?*
[6[i{,Bp}Ju-.XS$m U@6' q/Sc.mbI<zs~rHpUd1!lW<1Xc+/.a]XQM=.HH&5kO f '}3IPU S-?T_CMLw8P^
DbX9$kcx_=;39KB  p u$G?(\Km"?S!vU8#iy	S\4,qmM:WwlBNy1*]#dLUH$z.
15R*T*nXH/dn$LA";m#Hq{UawB9 `6$. pv<N9vu@	'(NQXl{Wdor|~3Z TJ.kr$qOi2/5	Q	Fspr	59aN^H"$h>$F}GP^k7e2$: y7Dw$.G V(%\X{	XqT]0IsQK}Hef)	C&*&9Goc<,H<*<\0b~ieBX'3dy
pD	KEO.<Wk)f >t`.M.6	:DEwfnV .F@KWZu(o}[@`e=(qYdAC2p>+C<]J n8$}1mk9Z"K21+0\H#xnQ8JLd})=1R4C.L=i@;_7 `;H [hwD%-;;)D+X 1bH9m1 {>%C%O
4v<oogsS]^'!UgwX)2vONDQ=eo- IQ(	Ax24.]w
KgMoO{dHFAfq6mcHqltObc3%fFOxKA(JNE{>qK'cGvO%s)U;,O[J:c#n|==)\g;v_JD!1BGPj=[>14%F%Bv	&[vO=N,:sJvR=(oNXsK.<@>O}USE%Y+6	?QR+=	|qR2qus0>q9ec9r!.snq8oo+Xc` SY3,YG9 W&<8XK:y8<}  g]Ew2	# +W[%
]TP.Aohc`;}<i?i}FS]1YfOQOg ;\~1O	p|]<*EFaxF@#mj'VMocY@4v$xry
L27jwQ i',O-[C1y\&aww	O*PR[&AxKLrOh*)$sB%%bdTY]'SAHKx#BDQ[H-s\`}3Y&v xHo3+GYb0chir:WM qG dF%O|0]P 
9}u +`<G[D*ZN8 gE`2n3U}H9 k+8.Jn@z.1y[Eqr+#`y=llb0f#2[1P LV2pV+g)i8:tL1,Fnw`y 
V
NC~8*	<'we#z*GCiV:3CS?{9>OJ^k$3Az9G*3B9dS)uKl, MmcW7(1c 0-{0Us^`U.DR#reO#%Ny'dy2$]}<l R1qUs9[gOrsDtg'XY/&KcD/]nvG#5x@
N-k~n+&RM\T6}sH`\>!#R ru,
)\'9KFVSji.r;+F9u.7tIGRMEPy9 U97XHX vywjY*34Dg5`A\\ei
BG4[K ]q9QSmIPSoM@1AfYN0
Gec9ZS4rw+pqzgEc9@)eB%`*1W=3 qY6#nUJ	Nz[gsq4`9`M3N)FGYWmmV)'xc(1?,<8LJ?|Vb hx=:|#{$E'W[+$J_
?S
"8<>U{Bqz:O9H2V\{zc[\r9T0F8 y3Y]P5D= \Ump [Il0UJ"N'h/|n GV~J'$%ln<=6x[U$\~  <Kw/KPqvnvw6k]bX.yE$y"3~M|06N{9LPr#,.#${dqdU9X1
ve=aXvgR0a-%Q c V]m  1uMr*GeH!Ac^Prjb*V[{h@,yJGfyUjG\<Auu;" :R(?zN[mGR[.!AZ6Cv9i2y%$|k+:]LI0n\)#lP-3y)	{?<*nRTr=	3S<eY:{PKtPJm+3`\vRY2
]Ja<rPIc];&G/chA36<sqN[u	{ @<Ns$R'
?)e]B=W7GCiW-.Wy-n]~y5kW2-_zs&s&n~~@i~O\?L o XTJ.TzuM^E%|(0q=jp!xC+	}Eq26RE1B x_|T>J^$2
>^t]F|A#}hn--$n8RAY FPI>|fd9xEA9{{W*"nPS?jeN9L	i<<RBuHtckn#zu>-! :I|wRDys%psWdIjbU4RwFoJnmcJ7]5+#k9KnTrY]!`P)j=@[L `in4 iyjA#e66|"aNvYX Y94qF8 955),Z)GW~Lkh9=c\OO#nN?$3,
 	GS\,U8
 

+M6Kxa8u(OV|/j0+VU}16% 34w$/lv6(VYX#-XOBqAljkj@ t?\T|>T'<}jy6Yb=c]l;n]H p3VN q\*L`H+La H?m,fBDy
y*q,Ey9H$(Qn:S+%LuAcHXm^D{fFsVTFY%7.*:rq/ Zs5-xV,$.I,g)(Rr<lH<~tLeykfDh7X{q/gBQ!5&+n"Cw%8-SEqsnFwidq,Y!Hg',#?0Hy|6l]Ym[kFmJQ'Zc`I0C^r!H&v"s9)I$FBF={Vf#lhrp=-q3^TJ95rc%S~%-![Ao(KA8oLhn	:gTNg*s$	`x0}-Lvvcu=s*h8 e898*m1jV24.'4tXm\KdP<uA9]\q*cK;!N	2i1GE$S}HzqvS#CA|jsGG{q&tA;sme.q>=9_"/es]^iC$XQ C|h2IOVw=z^BYV-A_^4x%j|/NZNoSy+8/O4VE6Fay<RBAfAI)'	4Nsqr{RFG&+O
HWg'DYYoUGE-HSVg-*'\~-;:{SPO_.b,"Q	l}rnYJT' 
8B>[M&g,98R4"9vf`PQ;Gux[p~_[-j56f?),&$![sqmZ++I;&q)7&v22M|"03rzVM>$1>4bI(iq]r_2;,\+s?Zl;7).~-$e2Q*0!A#ZEt&$HR==~oM@ Uw'n 	^GYfHLC"[kuY e#Fq^4  |O$e'g;:q' Df)A{^_'nLnON-R"d$ol#[c;(wmT;bwq)#)c V Y*=85\snO?"}jeqv3EkiV21p {qC
.tsRAk[C|j6>YLUznsc$8jAW.[vCs!y,*[".$'qz6)P$f]6NGQ.2BtV1N.&*[701a[7a[i'{P,ly$ql[H*w3wFcc8|gbF)aZv_DpZYdqHvp:S);0k~Z6`I2W5WeKT1[g0cO;?N:ef^2 ;d2Aw D.S^4RNq8T8Fi])%t%ZL&F\
G+tl{#uC-aKl	vN>U6b3[!H qK~Su!YBGK}G_/c2rY^\E-,pyy"ISzuH=3_YJ.Ini(- kSooN{w*nC "o#ePy*2y3F8=k6Ir:wOu&g4nxtOj"7O9.jtT-!A$(\lDCyb>V+ _CT<qjj.;|5^yn`:Rf^2pB,VatF0YBxEj{:w":o)LUSCj1pu3Q?+=$[IX  8; x%'e-}^V+0n==x8yRw?E;^GyF~5_P}zAil)t$)G)P`)eUpw68g[Nbovea@x=0c9Dis[ZG8sRoF/kvNq =F:MvrHeAO4DxZ#i;[H~4mdty8rs	eElm:x Bz5;T={Mfux%-P%y`V;5]6!. {x=5xhK6pz/vCnBB9q#RfbD	
ElYX#tW}2Xb^$h_g8<9#\%\H	SCyvN^ipDXM,QI ~8f}PWTkM2D(fp9'g50T~#e(a"Xt]C=X4I0IMKIaT<]F&dR )? v{Zv1?:R]$qL&X f{
82D,5`:88>zn&;Qyvyx6hd u:7{n7<7&^Ius)Dw>T^[^z[\8W*XkfYej1~ 	narq\|\/<K"n`	X/A+=e]3:c*n*w/tvN_l]2Mqy{U #o8"wQde<ss[<8fus]B-@-$B0<yIi J# ??-(w1y#~BZQVq0]G -MTpUwRK(mhehM>w;q81kQ^2M70wU6NUF9aYm+9	=:)
vWTbi/zy	G;pRFgc,xUXD3=hn_IA9>'3<0}yiiZw`)`s>\Z	1 b}r:HecY%n'/rQ9q)n+aw=A,mpr+{jDMd2>eYU##ju(`M*TwOziE2<ui:?0t^x%\|M7>7l+569?Y<v$2.5=5%{/q g<k"GAf 0=Ec-7p/33W=wrkS\_w {=f08F?Ue<o*O5>ckG>EL:q9;	?EFQ&[xzD2V,NF1kP>&vmjYQ*dN}<#"#Nw5m1';~@j="mFx J_yi8e!I~Vm8N8ON	69j71:whR'bgj1Y9OO,1%Ra`ruYg*G?&@qhH?Lg	%JV+r0=Fw@mb?.T9+'; j&.D^W[7$HD@=G?TnT1uSvFFM:,n|8-J-."~!#UEr7Y UEl!}Z$fyD1n90zO
P+g7?V})U"K0tO%p3
"cxxy3Pm+[ixlm'NHtt~K2~(ID$/eL2\:olEl?UL9O|t"RCbPh:k=Z}d>tf.9c8 datwTa#D%^@UC4d#C58u!]0{JYk#2#&G#)[@+MS"Vw2a%m#;9r&#s(F4%o:X9d!pqG`2 w+	uP(k*n =3Clok9
N0Gh;'{mqkK% @P4?:[xYN>H=&E$!q[	<uJFuuZ8Mu58vK4#g{/YUX	J<p+Tr5o*M%9Z+M:&F/B=q>>#SI2%s$?K]H)5h;wnM88Qkk Em# ?_zo Ojcb$G\Vx'Lsw?@Y~T
 $$5EFv6%#mA zU\.0 )sGM)l`>/z{DcX]QF%8}KH!A9
&hm9'r|3#O	_F8N|%5=Ud
A'<`~C
Tv:aO=zga5)&#t$[pS]A4yg}=Fd1qm<-$ ..ev ULdPFJu.i8o&F	PG>^2b;`>^1CRhvc$<;ikV)E6LRxW&ps}8qXQct(@?z"2o2wgn0	MJ_i]	bteh2HqZUFyFg ~ 8&lH$jqUASiQ 1@1 gM1]%ne6`f*&W{j8	5s!RzMhmYH|0<=w5-Y7>{(>ZB!
$}f@ON~TBJM+~&K7>=B`2w^~u$E lFrwp.C(@tpz.= Z(nr?_SYy;.Pc-4l{tgO)KR0E{i9vQH3n'hO@wm^6Q}SS7ZE}>h9jXI#K[;hd	*^RB#C\[iI#=@lm3'~F3>*E+(4#2Nf]k9m#$m;q~n0q'\&i;3#[JoE{BJI-|84[68
bxR)i\~|%d##k@*o<D	o5V dU.nd$d4Vvf. e;H=rOI%"hW0PuY 04-%.}v-Sn=8v%v3#7hR;`ulqZ4
X0^:f>kac#blq*	t61|M$cn'\-uMdU Z8W
6#To<=kK6y.#Wy :G(`A.G gj3>&s\Y(CEnI gc=+{bcsj^#nG=/"[`2Ozz.]+Lu[	C	=|;nlJgS>1}pqg\HX]Rd8~+	KRI!\`I^H*wR0cVu-58)%~*nGGC\8_qs YgJm}KKWuj.xm~<WquuFrs3YqpUPXxho}mueqs4%rwAnG\4]GEl9w1[H$yWFG".N@\_j$,m$8#>[E{M
[qVF=3}d	V	7y0x4YGl}w0f_*CxcU,5>y]7[i@0(U8WK(iaj3qYaH,)!d 4}rjw61&	S#93vclnjPI_PH2^F!} }RsLG^Ne@(y40RGx/Zjx:"d*I, 9rn;FY7XMic463^o4+ bX8ZWT]EfbyxTc$^%Nq# [: C.ve3C+cj/BG4mzRloIdqo9S$I6a]el"aTJYux`zX+; c0,q30X#<g C}jtD,aBSjA)QZRF	?|D[]#>9<+1kkON{2U'>xsey,uYc]Ea5F)%jy	Q kUXwp}iRO	 7QX{qG=fe%v~u:=A&
sTw-H&K0n0	z{c}Ur(cku82LgpT'G'{<P+r<=z6$.z>tW+XLEDEy]KqPU%[p}ON<s]-2U*H \HK<en[]"fU| Xfw	"%^[_( I887N\-NW;tn=I.h94SYFN	Rp=qsSivkvw2fW-9LV!Giow1S `f%$< 7@>Ghx`owY-no=*?	#n=j|#)%nSA<~u:8nZH&Xg"ZdgwNsPHM]N>8=Z8#Gr7^1^rg+4K{,r^0SO8k;HH4u/Ts+&[r7#DZeg(RN@q 5lJE?bN:NiS8>,:&x|u1. 1-<m6I
L$5'WA{o#YG=Gf/ eP|Ay*JKX2DOl|#>}Y;jETp9qzdr8L"({H'.k 1M Nj/h,Y38FIFKw8>G4e,\{Xc8'\7?<Xu;X?f%N1M{G-]3"`9 qhd#}+Ghaw,qj&f	?LI3R6X2G&qJt PRhwOj@fN9&b#;e0:m<@Md(4!Fwv& 6)bSeHHZ#mc	oGV+r
FTdrw+&d(Je'~R%%%Fz~u,mR1hfd1 Z 9Rvs9v$6<~T=M$YJWuX!O|:myq7D tt#.:b=">hP :/c~/# rwmN0o
<GR"7<NP:>tnvQNG@L"KV!cL11:<r	
H^:1!fsA3C`9n27  F#! T@W&RRAr3<9@dZ Oaae:Z.;dP>~J>r2	Rr FybwG>hnMLCxAJI4krdZg302P~Y G4)xx9eK+8l9uQ;gybYFTT`+e#WHm=IngwsG0L$bH ^WqEaBj#f?` J=65F;X$9 :]@p8"	1,A?.xdA;m_WIp yTEq{g|xF*`3Qd;r?J3~$9 cp1d*# i09u|*xGn}1V@syVtT#HIV$UEov;^At\q!0zy8@vLprgu V ^wnB"c[@Ku(fGj$	>*<sV%p.#Ifv7*v+O.lr>-<dUN9F9R=x9W qrA+#`gP "&%o!1|YVr+0P1ot[c @-hcg>jLK QoP:O'5bL,+;>yUr&F>*X@7WBeZYay*9
^	?:e1<*pr@UdfI<me@F"0$s+1[TCgvl8e;y9> j%
	>y+'E$ O\#u%L+pVkG?RiC0;A|~
UJL^E/v2NQU +_%;RWY"I?J,"fOUL#b@HXc'41aF=	TFr\~/cM;%Aq1<g,O9#XF~gq`BEG
'!3LsG341C=ri;$I0DM"	OyI ^N~Tc*k3K o
g2"uHJICiF*#TeVF%*a?:Avq1
= |}3zlau6T7cf+8B)$P8Ghr[s;V&>6Z9ibmRY&<#,T*)p1~}m\)8b|A,d13P,I$^ ]I '94gXu r'$~t-v(L".9>v.lpy\Sw6w5<`c_;)6MX,GXl3`r3|hn# V{HAfd L+@VjHz})5&izvkM(Q\9$:j>:sD6r9ckK9'%~%*HZKw>R*C*KRNN2zc4M@id (3}f2<yQ?Pwn!nxM?E;q$L7m$$X0#Q@cJ;bF.>viobbT[vx#1t\z
7?%$9C`vO! cHy_u';{xy*Wv6a}5p()f~QHpwpeSw/G4%\!S?j)0';c9#&RKF
yCN O/Y/@=nd?pj$r\$eN:Rp z*H~.)`G!,{1@3i3Zx=|p8c#&8:uwjG\BI,QOdq>y6:*?v9Y0Bci_s|u;D
C bee>%eO+jh,ZX_3xWn%wzG`\"$LN>z^N[c#:a<nd.r~,s<-3h9RKQ0\xnP8TRe#s},l,lYQ17)b"VM[8!8d%p5Fx9U!2-9.r\6qv]JQ+G=0tr
),}PsSjbh^oAa2#Z}h+BKi,!TMEG+u?bph	F)q;'`O;L&H*pg5:cU->dL#NQ(z	gb_ek$8C$u'/s3x>t- \8+\!qw(  ImOj5YU^M>*=E(lwp29QH$> qSV7^teK1I[w>DeBzbn ZYg@+#IE57o`HM]qkd};Y]hO:)8[O(#"c~h5\>fg9> 5Ac=9`Ad@ =?a7qSX);#Z#$ c.&\gpgR2GS/f?T9[k1\CZCn}@Ok#j/ii_<L`# O{I"j.( W_VS?TBWh[,iI5p,M1?e>]Es!F|-*}7> KPW C./vE>9I6O ^Z2~K,SLni`<{A#!RF62=t1$kuWE|vl'w 8oKtn6A8g?yQ)*z /A#vn2 gW/dRB@~ :/1F.]g,]5pLVR|@cT3=q]<9Z\V^4++q(X{tPqvCnAi@g\1$^"H$dfa`	}qGqiw3 l~FX->s <9#D(CNs)$w.>w?#C"..&e xCEk {DBpQ$RYRkyWOl]73!U<wf59L_S<[,5w?Y9$yyWX;9\mJFQpD@X,h`u)$/+U1H djdv
T8E>JMF<d}}C8f+etzhyfvCH uYPzFs :qx<5>ZY6hpF/uK=t$X?|RP@8%}AD@}-Xmi<qd%  lG5}bLmE@h\D4};+'%+gmtN/-5FqC^vNZ6>L1VXYXg0}+:b1}4=S_Y]i-kIgv*.Wx!nlL*c1jn-C:Fr"F#,2zhV\K8,30V_Ry$qz~.'O;ZY/oi.Vwng2>?QS\x!ztHV7)sy n>F7!j/9n2p\|C@!pTN47W;vtb$.=C$1cQR	#,c5)eKogZ1@wJ<G}3#Up2d#3+HbiMhc7.>Tfb\lZla"*sdKwXdWI^N|
K?}mXUO4N*:,\JE :`\6Yc>uY5r6*&s<,#GyhwZlr!7 e^gg:pq["K(NJ8J4N!\@svciNdOj qP#& [=v76x `f%HOtYC@hl<0}9]v=>~c;ao,%ceD4g/<Ys#E jNgP9s>X(cOd^0BJq[ox@?:HmE"%qv?	H`bJ\qVEnN=;S#*ymbMdKGVJ',2=,e)e#-{B$<;5O.-Gmk!Y##j2[)L;sQWv#@%A<1*NC,hD*qx5sz X0Lm8]#'qz)2vZXw-$@}&.Z<Nj"m@T}W&	dC1fN2xhlb/c]Y:ns\n<V'a5dG+4<:X6I]? "k#5=P9m.U$	-FK[tQM,,% 6#$.eW r98;FF\_S]YcR Wd^
,mH5jZ\o48l!b9=56[F#~wWuwpM 0|D]Rxer14y"PwsE'eJ("M=te.Pp~<pFJDA~Nu
C2W24LlF0]?vQURkg9LLUuZk\=BTcs^/9c.$8a+ Qy`[<]+%0QFI!lQTu6%B4mt/ LEi A3SJ-('`|6-XJe$J]1&dbv7{uj4.G-np%nq	$:0{kUvT+0XGgh=^E-9IU  ]#RnW>@b
P@+qV,So+g9:A+,[j3i6ufUW>M`.M[HO@A~sw6HxN!cZ\6RK*y#@\<RY6}qFr3'\`(G?,[x(Q-K:T/a,Af8laa]q/V=Rh4 =3],Ktd=zs<
pjn[ x>4LzjA-c M _C` &Hom8;x$6'XtA (Q?!@:i>>j]O2h)-e61	-l1Y?K>QOW9$)uTS<}+Qd$<T9><{blU<4c\;'|d|Wr&Z:\d6@+q}$Cc)>{AZyVDf}me$6s"80 "5 d.s]wl2E
lg.V=knyX:H|=/(IZdde_=]]3Li70y'5Z	m*	[cy9xA=i[u&|MGPfi:?h%@W1ExMH[H Lq +oe"fv|OUe~2hBpU|jhy-1cx^G8{EI3dlt8Ew[88e9F6#@t5`NIHEE 7x8hIrdyPo# f}1CL}2&$9XYR)=K'>Bj2)PK*K/bpTa:dEe;aw% 2qQ`Fa.D}*R<>JkWZ%FN	c~
Cl$bgI/Tv,M<	HyOu.$h obM=F~8K_^;l#@<QEuW/${#2b$lKI4oPw$>	3bnQ-iA<ld[<&mua $1M1l#AbYn^*x0	?WkNkH/v#LtyDtgDU>| :jD&
nd
Emlr-Hz0iGdf]eO[$E  /gub% FQp?1+pN/m-5l)lwo?5N =NivVH-x8[X^NIb3Q[c%<&Bz jQy2S83h`1J	E ou$Lv=o1Ls`T<cMRKXk|]M!Ph;A=qumh*pc1:g>j.d]R,B7lrF;B6sq[4bjJXiwV1:IHUz}}j)n6xNAtae|>l:TR"-2P m`A	Z-HltMMqdD[#6y1h%g#l /fn>.5|vOw=	eBeqlcV(?< jK^DQ"	D[Omq<LL@zHi?]vl	d
	~tEMofmEQGcpClAK#`_*}Y!N$Itc.6sPd&\^_];I;Vrx7zf4Prx\8.#:tV8nWe&/:JKq\z`*qHzN>KWD?1;1L3&[~BvoIrr2	A{?~	t'+^J*Gx7d3PYg=SK(}O&m hQ;?W\%:	!#S[?wqvOiHq6@7fm-	c6\0)y1%4f.&BR3I@Se	o#@3ZVm@Rt0Ln]nSB:^H[d;mA1J!H 1V.. eN=g4;	S*FhTwB$$Tub^uvRfxH`a\+4@vs} et6m"nd obs1_zS:e>!z1v,G =A+f<hLz}X{?W"35ZWl7bk(=x#yDp8Q_(Ht 3Tg4GVX y$3ZdX@TdZKF2dj{m*	hx~_{-&d"89 }l^;;D2+3)F|=-M#rH>DM%YivU.oW?-RVV$'j68#i1./,vvqO_py4eS3Z;/3*jxWS 10:F^W]AW/kr;NtIvU%d\.hwoM2xp}:}:a	k_qsjbT1`x"zO|I(n32$)FfT"UA?ZvT_nYOil>r*;hr7Dd>I$QPB;n ,}>eRkmAgjm5eob<@;TO`~42+GQpxa3,7Y*X3Tkw%A9S4yc2KX\zG=r	z}kc?<1$~\vlo`7Zi<GY5cAzm/0AGJsfid\ 37-r[4Eeen]6ddAp{A"hQ}vMmv:c5U	,G~Cx7Rt$x[%q|ZKH	3W3r \~f0U
_?:,|fIB${~?:H?khCx2I:W\Wk&]FW=*T;TiygN/9$Ak;r|?8EBO'uTO:uHQ,=?19K@rxLg>T/&2)_*N2~^q}t#Vzu$q1Ojj	~TEg5umOG?+;[#``qU"r~rwN	$u40mbO^th|rZ+`|jt>[b[%C;X<9>:f 9Qq`NpRvNGl)7c\6f-~#0}E^&RvIeYRn<CUoJ:l8m<9Af;Icf8qb|UKIC'x3Hx;
~c]Xvn}P>gV%l51,0}Yuu'l2c2| ZOgPKQ31GEjZk[(IqKT$l^-t>~x-5K:8F4v*w93J@g}j-b1ldxrYTn4><EV+(3F>&8I)*t8u t;55`Q~r(}\7!G3iUrQ+-X>M-y$}j4 fv;[}I q2OelZFQh^DU]mak+i#wL}5t!VcXHZ{}b= =nIFRM7y
pxMUbpOQl&<d)84ctUb8{cm.=HPf',yF=M,ltJUyFG?!W@FD	gnO7zXLt?RMV8C{sR"YB?NJxG[HF6<W-4J	ay"H h!q q5=c7;l}=(s~EIHQ\3HWrW_;QbhvG-[F8>};-vGi'(=+VA<~tve(2ir`FJ})EsK"'qa}}^w <{c]T~"S<e=nI m+g.SU7v3swd,TrFqs8:Q<34vu;gS|U,%[h??W67:0 %N`iy5=+tzr~l+)=C[7sq,fHb)<ck$6X>B{SsmJ1&u' 6{.Lgs!C99?J]N/v VE@BqYvY9
%2@T]\ztzYY<~jX<y
X!#L{r1eBR=Lz/B|y >My#%s'mseZuOD-}xK+x'<gmiS%T*d`TcAoY#rR917i7Fs. ;lUk8}-$r#,:z`T=l]o{(2}w%C`,=	^EfPF99w&5Ky ]k\RY{MkDwQthS5{140.ex`Z"D3	<YwDbbCFCsdE<m+4iM4:>9Rd4p8 9R}puoo<F@8$eh >V6pT	@	owi#gMd N)enE+`C!~\V_ck7zpFG=qW\cSPR~)D'z$+ 7IvFY6r"mV' /-YSLQ@n<r `csM<uh\x)RIu}st9	I>tSEqFEa4x>HDm/Tw VM`g8TI;A JPf$_(i/{#\&2NRJM~G\'P0#>4b9svk(9|zS9rzP}?JFS?jG-m}I:sO;sqoVX F),/-HwlF[>\qJ*H_!#)_2's9 +Y/UvzA9;HkavM<Dr=8U(#s q~9njdAnKHE&
q=v4=uFcWFRI#<T["^!6/VRPo8d~,8< &]js:-5,qL
\uVG/S  5:m`bDA[Y!%\L~	K9j`:-w&	e)
=<f(XyG=iE uJv9cAEBtl<8ULu=0 o`)c}kKxj2o@NOQ\XJK,%}?io/^A)E;]'OrxN3nmYF:y
(]w}U66avf,nvueOxX$Mh?K&GHZW
A =Mh" B<|Zx!3yH%O\,maA J6[wh@/?J:F
P>~rExd)}zRZF@yIO\t~<%aor?ybppry?aVs^Fwodtx;RT,,?Tj:	DX(4=@wu%6:y+]"T mK8 F8S\,H<N`F"XZ%[ #zz=]^GAwPeQGly<su:'yP,%,2Y'OFe$N:^=Vt1^>1PGoRx:xG mbF>i~$Vn2E:Gld8`so=4s]oR%2YHYGmJsh6<!z=c|f IR;J{J%q#8G6my\w;u=isCYx9<IXT_[
K TmqGX5xDw$Gid~ybF :Kh%fzzx[Pg<R;[^E7AMGk4rvh['HVXt''wNfF,<*&NIc,	>oyJ%X ?:%eG}2/(FO:;<7|czjSoc@Kn
q*aAQ6i>Pua!Ep5zi!"T1U6}A>Gtq^?rutySe'k%i.(&p06b}R1W,r>}~BS:wHU95I'LZYZn&Y~Vh"Dc ,FI?NjFT2DGfxXHo?*[;L)<(36T~lH3HGKq"9kr"b#s'~85d%c6ldnUlF%#tq0I<e&x9,}DsWs,\E'v79t;IP@#~*_G:`0swp>HpmyK4Np:jq[)-'Wx$<<<a)vRl'LV:W
)vs8e%r]AT|_ziWhrs!VQ{`xJn\)p`ClZB=N+.3,  =*1n}feH(y+\tT! X`~7,$#rq`+(bJWjsO{RhONN$1hix[d"Ict_6F=+<jlNFO/ 
``@_UlaK'LL=>K1u$57]Oe"W['?oyW')y?jcv#>Nu$	; 1OUNq.7Zb>Us*9!12Cf(cmaul%2	X+/?wy1QxgQmkab9G#$KuY3^"/p\~_3[+9c~^NAl|]RNh%XV{ghKJnlu#Kw.TR<q*# 6#Z$`	bxQtN]'}3Unc#:	`sZydRA]^K:0g`2!*,q%Ao!@ sXjy2H<WzR3@B< zZ1`vUS7^(]x;i-PcDp^Ilw(=N;Kek7-#`kmnFM=H>?c3 !GlN{_d KsHjD1CR[v0TGjUN\ 9kiSlXqKW\@"0IP fSxtGiUPw.8< FdvD@=?94M6MF7h#
9 `KxQUIPp8kfB$1>nl<0zS:D]GE=6BLQ@8?UG.#y8pSy8u9X'? ytN;<FDs8I*$D22 m*XddE2|(|L+RF>B~[F
xL2 yCSB0s^<K+:x)&T7 9Y e @#e!OeDxr/eofR@5l: }iDFSU):=j=.#[Ml ,y^8?*6}%dYTI"%QT9|u"C -;H]:,E!
xJtpQ^0ik$3('^_*|e$A>qE%is @NIXS8 ^WPpy n&Yzu'_6-ONz5_mO;>x
*bzENzps}T-1b2H>;dG%4WZ0:^d^(Pcz.wKsu*[P5I?vr QK2g|z]PnGTh#MJ8HJzrq^Cowxc";<]V8#p?T$:m9;5zGN+]{Gb# j;nin# 6iIe2W998dv{6E6`G9EgXvcH95S4Zn* dre9#=je$uiB$^r63P&Vvf!=	*? F1iu1p4d{3r$FNH|^ eH4 4o
r|d	B_n>8a#.=S3MIJBNgdq|<q,  zw1w.\$vSyVAA`NB#AH`#:8*[<eEqnqPNG[jM6%dmFXG;xf;hDhfJYuCK4]Mamh!
Y|'9P|^]J%%|?*). 9G4e46	RY9ki2[64USM!o HvbqBK~@yyVm0YHF*ZUl}=O7M1_<FmVZEKh),6OL&6.koR;Q/98tWRq[	 :\(hJm]GvHWzu 0"-:{XcF'
gMAE=NHD8XZDKXU~3hG%"f,q,W?LR)EbO5S@ZxAXOVrBT1{hdF{%?}wRg<"CK^Fvp!`U${k+cmD6<@>u34c5u#8|V_M3DJtt$U4 {0 rh$~xVA-8%8HEU&qIX1#vff<%]53 n * 8`_wgbrb"Qc/:wMdc('''w#n,yXE~4y@RG Y	s7]]OYNq=3q1VIW$dr<|n`ThZD>zvdmga.^RW6o[k	p'ZGps?<*pv zy^QIgLnDC'y~G	#j8ltBYq!]JHTl woL|!)rV?L.G]={#3pO z*M&%.s	>_y?tW Hi#(2#s^TosBv3}ci',besmEo#j.GNwj#":dR"?f[eck(^m^V,Fq yG%hr]p?LcycSnmd'<h-P3AZJQ]TzysGgce#g_)@I (/		GO:eqi1CVkg 4&K.c'?U-d Ns9R{x&	,Ha9WY//8^[|L0x8O]5OI{)IK~>nFp<G5<r-[i#%AbMs>Ri
u_m8u5F0#9#:$|5y{:V"bu[ l3' smRu'<AMmw4*3.!A}G>2T'i<E}N6Q=jH!uj28ZFNi9 +3[oN_3\FY"'ea.r=szhJh Bh sd`q. [9f(c7)ZA~I!%:BOFmNFlw\[Et<HAG+xu'."a/$#-lW!d285rl94<Cy5d~os+Ia<V{P53J8b qRp'-;OKu],y.^}SrA8'@P03*=HDSIm=Eu)?[Xh`ZfWo7qn\tJaMrpB9H9:vD|K3xo9\!Bq"LNxN3k*sPPViav4l8muOQ
$<s1Bt}6PvHN u? 7#-(i :qiiYxW<t^},4UESV,6%q([&X.~O%;q,r|T=dpGE
ZXZI4$w<BH_]f6.@P7L6r#Ux>@C#=z&kV.HT@s#rqE2VjO ?pqi-$Yke[4Xq|WwHm&+V1	smvu#Cn f[XW$'*6,]W`d``{._BNn /aoz.iyQq+{MrK376cI.V(YNNOFI<"s#!?y-8ju4{A^\liU_*\h6j7p	!?:>OAm\68uXtQ-$?sqwy"6> *P 0~=Q8,5J>yH(SEPK=gKg-J?{HbrS7/.m=x
)KRNjXg)uSXfs3rUm]q}>TL+Kh$G8>x,{
<R*MeAd@Gkkxc#`{rrft-x7#,NsD#,\u&t]I.
2_F3mCTa-T)NH?U[-'0Iq+/	<56h?:_:UmqX	Utb+r {qoSimC~Y< zs&c0B18U6PsH#]2065^L:UKE:wSr,Y) ULaB~\PA39<yBO8^T;CqR4ycg:u=NylVtD+,N.?yUw:tRh>9 DGQccuY]So[]+S0 UK,~tWNis (%G[2r7 `zDwvv8m#'+Fm9C\p*'*vZ6xAm$1/9IfO8WL{ I J
)/M#&ylOPl9qXy5`d"PvX8 *onlm#>kNI5P  *8'<|N$}]O# Gv3vO=?Z;`DIsWLDs(	& q *qg/Mq& qpI5Ji_@<8,yZ}> Ba?2S>TknXwGm{/ejuK,Xshi!.eKg	4Tl>$7\m	=2e#c`ycQIef&(+)H]\/"U]FV+;>cZ;nX.[aa Z9u9aF8rq}iuV_0e6&,nQ0!;<;=3iZu&+u'mu1X{e^Ph CpZ[{('#M-lSv#ue]Bq"9C34%i.yb|I+>Nnx["[n*	u\bD#;>K>]84NiI ]XaQG?zA/i0Ibhh9R+rr%8dl:  ircwaBrR#?[Icv}?i1qJ.h(,$BY<FIfX;EJj\ 9:$[O;\Y$qL\Tr$elf[x2h`\U78iAMuvO\bkF;n"8h}b<2Hq;Cdy~#GNroYN>2ac"RePuuikM<vD$eb5p8&mthq6Ngj[K);_W1oK!/#@a,wq:bB;XhaCc#v	V7go;"	6(;g	(GI	J=XUkvR=OZ]fU'I t294w23^/dm#Lsrk4r=jo!#-*2'6>pA=DWq}K9u#Rvg[_F#ZH3~!4.*Mlb\#Fzh6z.rfIYe0pN	5H8|o/YC:6rH99pXI2j6 %~CD}~TUftb2w*w.X.}[T$|Qi'	$ya'|XM!q&O]'Ja'_QUT-<yWm"}y/Q;@SI)WL,PEZL6P| Y[#[7iJZVBA?A=1;o{[hvS+s2pZR-nXqyl!33AC3Z<.CM)ee;9T-<PhnWnJNMf,*F):Xjofg&D`yC~$Z1	c	Rv(}zlM15ssiW	5N+9	Jk_Yi[`x%#' xO>OMlJO URqKW<.SsI4Le]DIdVn-[;=q0Y#/g#@2nmbyc+t`u$	rKHW@#wl>@I{">f=x^d|:}T	 8Ytu$9#v|Fmmk8B$IefgQ\iq!>{VN=ZU-*)BNRq{-A	}B: >P# ?);q|LA,F8rr[i",tzw3T*U	yhqZ0*>6xYABFV1 2gnq9Ng/o6%#oL2o?hfg}I<r|rI}F
PkI9!my~\Xb;.kF.m~x.Zf$y~~uTnTSZ\Xp~\9ad=BTC:#c}n0zvl4 vOn.$S"0  c^]:kaj.hUIB.QeV\1vpqebdE'ch-=Aq(A.O)2+pr|>znDYw'SUsYHDj%aQnVRbM'P6?Ge YEgRQ ?#W&A[js?+4cw4h1IqqLl"MbBERCm^Y6FddOF|Q1<$wQsg,Xh.[CU\wG6wZ&
O_&i=	5;wAe>|+cQ0|.]bfcpGzI/Wi=F2}7glaGcdIRsyM`:&7#}LvPnm>p?[ix:Y4q/&3`]FJ]B0$w"Jd47&sHv;}+2F.aR=:x 1\|8%%CG_Uj1"E&F?hMD `ca1&1
JD?\izTNT#p{
v7c>%y Z7_S\zsymEf,d0G>])[.5~1dIW'#Gb\^Ym43F1gjFwh[v?DUbe2q wfGL*#n[P|hs9]>I7vr;JcC]|\jHQ[R<rUMj;$m&{g41L q8+>`s|^'ej}= 1.. e?>k5
F=#R!
2D.JxA^ySBrAF<{GIqyj.@~r1T>s
j6	1n3R]Yr.X1^S~EGu[1G{9<)m5ZYOI0w09'QI7 -rXU.fM'&="!b}0_{0_FQ$s]W")?J61Xv1_JM7aCdPI>'t(Y"^`DclktOwD
VAW6G,2_j~"p$P8kUs/yxe>W y+"<ud6Zpn{uvBflX$Z/mCu@Sc(R >+}D7=<}jp^Fi^Qz|ZozuzAGBO$pF2Ouh<6#nzuiAa\z-6y2XvCZLs$CKmr51'>x;vV$(mF:gUwqp|})9WPc= `uC]~' dnSUx++mn!8 IS5EKx pv@)eug<b5Zq[I)#:t+ m U=t!Pj]6nr>SXAIofs Z[slv y<:(<M :}=4NRdwR&8ok7zS,0i%Sn/w(Ir`Y3"29?H5Mww:<qGV9bmo&{'R5*GLzkTV|khdYiN}NsIv`-Ddu+N,WY`b#*\R"otjJ`C|*(p1rObi%odu	?oze"-XlP9#(M5.5c|:]w?^!V8U?/_ZYsuh.Kk|BD.?\pjVZ8*@J\I8h;4fn1$`qCuIBNMiK0d"Z91Q3k=\ 4g)1qnD.0I$<{VZK+xP9U
 &j=xmn2 N:'qkPwQ<I9@Ty-W#+XI98/z(R&tRN01ZSC" eO*C,DobORYt7ea8-^2vL1Uq12,Nc,Dg 1%y=7mB"`$1u;~[;Y;zV<5wGn:T4SZet5Hw\<TCvvW70eT#]Rb"Y |.	7@H"U\g- 5'
\KbF8O:Kk2wp>tu rQMDQKh|r%Xy%F@9gEF(dFCgX{;l`j$9<S0'K%eMTs1Ml5>2]iI]NyzpuDy6u#d1[#`mA2O{_lP=-1_**7ig;VKg^t~UbinLAt@Qkf]C1N88ehS$q4-mv zu LA]y{[U?!L1.rGDL>QN|93^7BIqG>g]&,IC&k,$;g46I}}l7pzsY,4=8+}2KoO"1.Gx?*kkh+l@`<qJnEEcnUvctA0;avgWEpn<z5qqb_3\KC6<=I%2Wz=)$'p3"K#(#%x3"P1G^*$8P 9^(ds RV?Iy:t\obHk:'4+8"%! Rq*G`@]SFQSnLr40>aPbJ09e#\}|)$$_q]&\qFLc@i|MA$Cnec4b73~]N9`yT;m>^J	"-%UR6	@GoGcw9R$0ccZH$1Kz$h!q]$R|G:REE : PY"Rr	nqXQH1pX|@(#*w471Ff/T*Gc7\$A%F_:++gx+ [FV%>yKA~Q"6vp$!nP=0@'v kWqnmH{7428A|Pd~Wc~cf%6w'ZP^dk4VWL ywqcA`%V`	k.~f[F'GpT<uLU2I;m#!^6{qEmsB$'67NyEhQB5cv4d y>\ :Uf'$q~dfqH?@5L8P98 pkEEjdXqf}p Cwg}L(U)+zy`7 sq+`	9,!1nZr{Q&pnE$ddn>|@X<$c:%'Lc,F1>vP 1;s)r622Vb^>
dp<U);@sxoZS?p>YO1f.Kn:sls\\,((PFGye-PEq#ZEcq$P;dF>'13w83*Ug"OD :*0x
=1:[rJxvY<1Y,&`\?GV p>gbIKW-Bs_=jnp:PrkWFc66GSEiv  yPj@d2-{L'`<dlF ZYc2G5\H-/JyM,k^^I< 9uyg085MhTL@+0?8  J/'-P(	*_\*?+Sl$}r>DUipv"PicH4xgzW[FU2x"";rGu;6|N'Ghixd]}Byd<I|l{ 
 0VH_YHT7N@?7I|"v,s7qGoh"^s6<]|VEn
s>XKU Y#wGX"&r `P9X:Ay.Idgs4nP"rt!5(wjyw	yd
0y^Gjg$@G|GV?\y
aX^ytT<>"'>~b|`u7yx$wW_0|6v2<nzOXs W#
;U*  {cc~tm `0:fg(J!b <5YF{71Q%>:pxc4jFj\u4Bn*p5?vB;cg8 8 ?U {c3}[0 ~}lz?zH >J?\#.ZA#/BG*</B.`G=|OIf5amov>dG?s~&YZzG I#z:y8
.
9Js]K!8~#]Z,bU,2x0QLEb	\(PzAwRBBwq
C)Xx >j4VbY@\Z:Fc Opy>U1I<I3273~Z^gj#T#?h:X}3d$O:Q0x,A^pO?yTf%WU2 GMZRnGf2y9[n|YP	gZL'=g# ?j).TTYdz[/3K;If~%s||-	bNpyqY
Gac}x.$NL;oI\B
Kl. 2o:<DR(ps{iZ'd SJ9e$c8|(kxIJsrJ~W\op>tn<WI&YBlDiWa~tY!7O(tAX0;y*	VCh7c 7BG#G-3./E$L$b~R=mj?4A;w9+\bn8=OrB K>H!AT`9O$`iu<7CTd.8 c3I7nJ-@^ T|I"V" 6:~k7-N	CoN}r$uxe;3G gXm^+r @RsUcG . 4D=W
2:L7~%xeSq!'%wpqZWiw,G3	$"gSgIQg\4j1vCl,"#c	wK:#JR19|Di"3HY]FG-5*+HyQrS({nf,
xr8Uy{j$"02<=ygv$c),Nr|JR~N^t3[@_wk[-2;iVo?#RU.ybxO*a|B_ZDczS$ivZM{_`*c1{c9QEmG6T4%O:I*q_J9MKO\\3$BeSin`+}N5+M3|#9~/s,0Cxzq9-yK4xp~=r^KktC0Ci#<jW nU|QI~o+K+uriqI`H72gj@!5\c"lE6g?ZmdhV]XmX$|Y2/Q9%`OzW\8iq *# )rj}X!_6}VfYQ$jwv_y_^<UAn65js4wy
zMg
=nmx(`F =)|WM;[F	oQ|au:$`~ >({1~$en.$gE ^}~rFCM/t=.!	\_,YO'>>
%aoA *eF^FsKICT U30wG9}3R.uAU*E 
-kQhFc**xsJ,v#<6LnpFWOVU5dwi23H9QG< t!!D~_*-.lI HdY|;N9NZS^dl<oyc+vN7bqvz|+<Cr)gr" AHe1xux/^6cY ==fZ}ea I	 /%%s4G!6U]n=X|![ KH Tb `{[v^]lmdrH<,1=E90\cDV\;LanF:^3ehe]:z#ord.30gL$Q4@G-,sA[5`BLy hpH9O))=cFPybGp.;xy {:}uou zzpkwp+'|>Y,	j[RK)=18)Eih5nDrF9:6YL)r@q]$Q
|5PUNqXJINMh(O`8jP@G>E89Y^M~`d=<:TSs(DB.cxTapL|M$8$;5AfL)6$ydYv%$xg%G{m|cH;JJFUjj["N(Jdg?JkSo[ PqYY?.b1(]OQ-`)Y1'}Nj`T$A#,LG0xQn4Xz
(i6pR|Z`
uK]-].?:gr_w]hYc
zDGP``p{.9 ~,8b!`lMKW{\38 naFsR"OPNmL#88/?/Ggfva@d \Vz$yPN9$UY^-NEJkxCq-|4(4*{{I4Ly?nOk$d9u,LyHHzh.jv,2<#-5%\D7k9Cu-{MHUuwr-ve]3O	T}stpUgH3l^ziUKI2
 @<{RB]
pJZQ[[#@r+< 98Rx97G/k>L(_<zM2(	Y6 &Ckof%!i]evp0<REInC<Be,u9BfnM6\z 	*.MeP:6< J<L9`r{jWw;- '  JSJs882>c>t 9+gfh,.I:CyU^&e&\|S[?BGJy?YT+IAP2\HvD!Hl=Y3Z K+M W> 4,}>Vu1d;kM4:o$vNHT}3jO3Zr$/_aVIai-WBbvTnO<scUx7XrPectNqn)fw uFJNb}^v9f8UAikb6` 1={Wd@_/n)Y\MtT+)xy2Z.-#$r d~CIm3"J<&NNzUv
eyo8AYc8&x;9a*]eB[~\dUs}F"TmGs.3LM`Up$ <zcC|<#NumWTD9#/*L	3w\}Kx=BuU"AX<1-b2G#q83qQM!!4[p00	b( 1L+n[STH8WR`HBm`sf8AN#\I|/%lg$U-4rt`=0]7QF^ND'odHc~6u/R,~)[qL D9
o=981_% ?@ZGH3j`INiNb2/ {gJ3iwp~ Z!\miK9&&yPe*/f9.( }d~[*E
*,?~^m-XTU~7Sv{
g#y`j{-Zh(sx#;v}*KX]k't:Am1}d4bD]92$q.H    h>YK# Nfx	klY8ZR6zj.}xs#p b3|{KosPtx`^s |I{Ge y^TkmJ31lzcL0ORehdiR";ZVVS>5 p/&/#e>U\Z'U2+2$s"
-;exK4k!)ZX-&XT&fvOou	cAFRN0zUrj)VV+l`,y8=Q$A&\ aUIr*Vn`u}RDijp}2	tMDBKNU.&]=9$P =M$DkwwZF&#F<<{Qife&c89>jp,1sfc%|0TAq^wV',A?heorLUR2`=~13.zy
Qml?$#G=:NfPKIduS{T}rdJ^MKpG"!8cQ$tUG
5	r^9L\JwW|~h@}NL&6rb!E(-Nj|8Y
FJFJ^3O"&	^*]
<&d[n>(G,E60/`9R-iciKuw&XqprT%O1sLW5/[mP&^N?T9(!OZw{u"\|0OaI2[Mc2o+B-4+80wzJK>dYI[s`U~8g/:C~d1im]e>!F~f+nJ[MBR]jM$W]^:]F0r|]k:h58e!$Mrb|5f9oOX;QFVm-kVc +0$quk,F&$GC[{tw 8{ACovf.$wHH|N<RxLedeB fn%8Qizomv9jSX$)[9+z{Rm2 'zrnVRL_=YTPvZi`(a.;-gcPEuV{
m $<:;-*gya}og*B`X C5jWUtVs!Tr|[8gve^NB0@MK]gRIvq=|xb(Jz#)Y`%h!WCjFNPGi8wG#2Te17UrnuPt{{h(JrAv6g)~\oLf=xzk1j8{$"V@F8>|dq\.6vsR)fA/-H" K9'Rd=#8>~(x`*.m#Gcb-M4k-.4Tg1E*Py"IR>-(;|:hu+vBIe2=}D}_ cL$}Fi9'8'&:#o
z4[`vCWzs*v_l^RK*p"|xex*9L7]A d][2]+]aye%m^ed%2Kn6x*}F8c2FUU>#bPJ]6nH'h#bN0122`+Ah5.=zU4qHfGgiOcnXN{@dWPL#*'5NYWywE:Ivt`yqwC}#UeyoF$ln5$v/TX%Y$1O,xoi7~!r}-KtnpR]=9Qlg\^r-8IoFHSM  x~gZYrina~\y'f)fT',s#I=J~Py@ ' }oyf'?j<j1&rH?_Jor0%C@#> @E9s+d]RI- rzi
jc#b79/[mBSo#2Y$y'=zg5K&BTKv[7~D?J<21Me20>k;6X]SPD[WCwJeuPX+&YGqbvb< }}FtcjF7y^i+Zn/X{fn9Ce>?v;Jpr]<H #llAI<ri_$r[iv}~P*=Gpha^$zmrcSvt[6$}VVMFU-%$pLs0&;FS8::Z-)Xh22EnwKco.pU,#>XDW+w!XngqOZnk+f5j9u8G,f &0I/<1^6]r	kx*|jKd-\pl[$'WF3_+@@R4;QsHj r73O {bXTliTe[#'2Y%I]<O^(uvXB@,i2UptSL,?He0v;xv:q+4=h3Yt"DY)&C}?kwnK,GS8m5+{Bmhw8l9Yvc5ft+IH^@P*HmRyBSd3aeLy9l:=:4$c,^;z#H42^3 VOrVYHV6c9%<N
$o+*w,?T]XvjD\3gI+cY5wlg{}R&q-y>Cx&`Ow4m%
[3y Uvew|~TY[$1*Tw<F`|dgoCq&OLsUzm
0Ws<7j^:$c<pIc8!pI1STS.EFe=9oir*3'x 8:(TU-csG+1wqgdH5%B
>_q~ZeUkybm!0|nH`C{ydP
na_AsI$&megs:TO]3;`lwm_E{K11 ?zUFkyLZ&B;`IR_:L?E{ s
hJ, ?jY|(e,+7$QtFs%Wsa5;ek]egG\rG84HjDf]$s8*ejH>T}6Bn[dw9THR)n=}mG
IcQQryG=VX(>m~l8 #+*zU+w q %WMuTB"l9>E\BPN^;Klgk4>Mx-HX$n_<}<UK]M~z7e5oLe
T6V)"{IJM^H*00?ZkMO\Idw0,N@#8B-F RO	}i58_[{,rA$W
9]6c#;p?*GTAu7
/%*qpH>~	Qhb[:)1JzdA- jYU'k\6Zar7+?,VQ&x@ <dtZ}i)Mm0
CI]b *.)/3'(rH9Sm Uv&n5Ig"VC'AS4:QS|r$v[
1Uk"6:>EBJ<`|kj$wVk%p LR/AyYd[9m*33sceu^YpH5%{KFKZr;`w`9~Dij>zd9ajNMGnJyHX{;ceg4\Y4}*5#TwUJ 9aSmn0l`>90/vmgppoA.4}Wc?:r4N3"2n?C JMc}+K 	B eo- dIOmU`	y$C,irI!8-nQ8|N9y`T FI,LC 88tFFVaMkEO\>uu<g~"EYBGx~x*O Y;7s1FY%m5']NV(waT{n B?+?mr
nb$yG1_ZO{P&rFq+h-%6vAVKBG7vl;(L8?b$<@bF*&JwD)d?Z_pdv,cuH+q{5&l6H%[Q:giaK2?jD t0?J2=<];;)KbtAuP0CzQm}F *0>Wg:__;v3 }[fB	a R>4E$s%If
FcR{ 3L8}>,)s'$HGkQry;cdbK&@Fr %TFqQkF-K|#r<D/__}:R:u\Is04n9F3x=8=Oi{/u3aI}yV},=`B],N?I&{JRI-9$y}kZR oE9!__2}hH{l>H$g-s6w7=:Z}7U`XGt
}O<*OINu$@((fHAaFJf[{NE$uY,L>.zVhy[>Os-M!lBwysiT!/9G`` 	MZJ4`n=9lg ` SDF.$`1\<)Vi9t}},:'>pI"E#;,~C:Eysq5y9}hKK"8.; }I%p\#.w$n1]^M7eo4Y<1wi	]<hH@I[nX<3ro4kuQO"%\)mcBmyp>@Y $pAnXXtHuI(<VGNd<\X`G]4L_hr@$W8	ybcC]o';F9?@ i5b%N2&*8!sDGKe.-xm *H~`R)n6&~B97Ml[DSo-l<)pA\*4Ui5&MO+Uj[&!3mQ>tm\ydJ?vdvI31F|'YlEM#I  ['/8u7Z4vfRU^5f9\j]iwB%^Kq)o]iVk,a@X\m-v2HC uf~u:# fZAh+XhX:?\BSz;y\\;+H2z XD)c M|''On;J1\H~|phKXF dT&v;+dpINi$
o!&G'Vm?.}+2 <q A+DnEd$fZA,$0>x'L#y	v4+eN <gnliT{i`d c$ ?5I@AK*6$*|&Uz?cPwWPydg|q0f8%r1;^V/km$d`*D#wL P8 pOsrh~C)VOV91lUId].??LPj9i)W{9em('g988I?5l89^&-+~~]h
6(#;#5D0[~y5;A
8]H
x)s>m6ciq#R6 zj9:BQdf2zO_EJ R[?[bORI^?;{sOPy[<t^:tk'%e39+.D8VwO%pkw mWym >uijsbmi`x`|"rsy2	w?=F:WhYY@vR!3\\/JNA8I#PKx_V/^sMX._FmE#7J,	m3@.7(}~|R CI)XTb' qV
bi J#Rr
8~@=Y;)a4
/^~	cH=+HBy5j5Tbf`IzFy]R{XsRyq@w%=@$TL3O8$>l:~<d	Wi`7>k0,2hFCHF0I86n=9x$yL`dT e%Ft#5!z)[`t7Hse7 |E}"o9kEo\n\tHc2x`'n@U<bv}<t!H*z`'{ rrqW$p `ANyQnq#q'a( e?r<\r21Uk(U,8*T9sdc=dD`uU<tlt90C:/ZA_W:iYxyS!A?vZbxa	'rG& hu[<v%SyQb-qE:
gK%K2T?Sh`l6YA}R-6ONz rok l,?t'u<XrH2A.UW2;= 
 Sb0ts1!JXd0Hp:e|{ BsLRB(mXN%9*deh $;JvyW@yI[dOInR.\xZ+  {V_]D#\d.)h\G_$P
gQ 2c6z H/*Led,\	kWPPi ]mr|t47NEzFGVR3$>d77@<!iyz#9UNE\n#gqq\/y0Si,cyPa@7[#Iald89^|LLKe_IN0Z$-/;PyzT K~Zj{)r[`qHVVK;IRH1|7n!ygd(Lt&}
/1
<$p01h<t8Lks(G3~tdZ<hlfK;(]Ie4_LQMAX,De,6yX U	Vl.xku0kVl0`x:u./a J8)98#rs|UsM4[qRUbf8ge%2  e'~`f0?O[%,Cd{c uy
TX	|c,bg\[ (xqXXG0:D%0a.O_QH6/J`9XP[&I4q !<	Ha( 9_ vK?A#y:2cH)Pq$zQm!$9$'|1u/z{	apRJp1y=q`/e
h :q>ULw6L$MH'w 0@e>*0 c+m[jZE!#@^y]^4Z6,(TM[2+7v1~TVmVX:n[9=rp{cjJ]b{?3]dYs~(	L+3N$!C0ILg9/'r=Nd19dBC J_hH<\sS{A+.!W:J5x,hH&'`$ .G\{CN<hmD-;#`rt5iKfIo3w>y5(%mvG2==fEh`n$oZ0<#bIlQwTp#oIS	7L6<<h@R0q_Oe.t1:s*M3
"+.^B',|qFzmjFFFI(n^}QpOi<ZsQN#0s<z"nvnHEI9	`XR;(V;DGI*LUgzcrcTNHcLe}9M#J[ &\ F+>.Y(v,pzQJ	M6vp$0}x+Z<K
g*7Vwyq.w8^w?j!i! DPpN:dR|[+Gg!ww sx;y$&W;	 s?XuR|iyu+9$yN@ ^1fWQMz'gT'}fHq6gw=+apsm$4[&O2r6pGd7s:bk{YW2	ca4tHI&+k#[i qilYtoqK[J!en<}0:Ws6"C$p_ ;_8p}kgr&t/ ~bZ.L9V>X9N)NrMXvdh+rvN<>)zjoY-}FzoEsr$Xfm4{(E.wm;}&lir$~eeL#Hp?svs*w+=_ffm"Y3`V;r+? ^J'5krKtu4Ms{+38<{Z&L*R2j93jW~`nq9j:PT<,YG<p+Xg.'=fYY 9&KP=XFzSjf:9:\+)t]]?QBw\W+2~O 4*yD%1:{p^V, |8=W?ss+:v*l=4nVyjJIm`; $9bf(fzJiaTLY'HD((*0$s S~1\mSUL}<>
)]f!m9ZFl>+ G9+fP9%Gtiy%upZpK)&|.s `qN*A`T	6]?JQw996V'8'r^+j5iJ-+g\.,DN3$Hg?*Nd&3Mz2$*~MtCF@s3TuE["/$.Us|9sMIkl=v9^n#N~1[\5132OUo,S-0=GorHf(d;@@<qmB[pf(V\J-cil<yiN1/.G;G=<:.H;bd-cSg<cLgLn 2#I?zzRqd<wH#+\ibBsC>iG(t=,6mmJ	#'$z],@r}I"3@cmwroe 
H=<'TxCu2ye\\y\{^>$l1|R(Bbp6`kUEomBAkF$HIuwn\O{YMe^xB3y: q}|;C|=OnON3Q>-I$'&\a}ijpvykr?'73\!;ouL.1iy[ ~twgj$'eHG"[$+l{5oIegt_h\&,2OLz={Nmmv4#vB}qj #;q,"==z&},o:(F=~mENI@sY#Vn&wPK9\:j%RU@11M4#=!^)1zm;-sjXi/
6;J
|*PB$!NL~}<phg-6irX6YeP/zT2aEVo?]B4'')6v^;yaw xnomzu(~]ii	ngxHPG3Z&!Ld@2qjQ{>o
3%1{wM<Nv8t<R	_\gL.x5IWc }+MR3~tqDu*\9s]%#ci3t(Dgeq@osj:qBy=a!;^i#U}A`coFs}*TLc$S=)4UJrrtD0x$adxvy3_4lytZ3:gq[M/wrW]&;[ ^[@Gs|K;$r~wJ!v),d^M>< iA^~[>6}w=<:\u4"&~2[qZ n|e(*c<g:y K#0vC3t  ]Eo,
B5Qso!", cN	*mwd.nPKn+<y<Q^%-^ :!U%H># ${d j2b=wch;v,nf`~i-\q"8>(NX&FI@h[HKf>gm#,0t rFy#{?k6:WLDH!<|$dv'9oAtZ#pyVUe4d8Kua'1Yh!$OI YF+6B1\6 yTTI$aBK*~n]P('P	Y HvH+{aNpV=}+']s/8n
\j23{;q=|WFe26S	`B/^jx9g'vs$<O{a	V9 :%u968Y5{/U/j-'1 3u/C!URV#N;^\!0@w9ynBGZ+>7Ny<sSF>Nm d}ksylT?jyM#nf/$)NJiUy!&7(!-xPiOioQG'Y\a.h[.8#+3/_.b^ {+Fe8%p%fqsn$,1?yS0`zq7fp;98,]Ig8tcW"6_b/n `c5>z,C+GezaTMF+3cWpM$pdO-VS6U;Eo.d{Si	VRN:vmbo iHE]V}1oY."DrR}/PO#PLXm3Kh+%['5Gv5K~v*uf8qO;;@5IU3dd/j.mB OAzvr/a}Ni|TFG=rvDfd/%YjGfr[C"A9$taktA-?v~&&O5jw3G7b,A>y<.),D`Fu$'A,tW9-7>2hUUm&Jnc\{F3qr 8>^",r#wu)?*RK*hX37_Fl5~f.#kUgSsB$a t3\>K\^'v3P8u9CQE\D e X07=Ji4w_m9 Mz{bE 8!NKZk:00[H?z o pC~r1+AbmSl :l3 A80?~+qVxN7vJI[XX<$bA$jr 'dQ,}ayf|E=jTz)j=+GxcE-%_3kUWJA$SySF(+(LPlcXZkqAVfMQu1)p+}+^svvvm(jKvviONI'{8p(C"'i"Ly5C(\ \}fN\X(tZ~N*vZtR_oA8\`
Y%NH$e?.kEktmMJ,Dl8 |%dd{J&!!HtI'~HNjb5UEwA1]}inT&O[EvE9Lg?|Ik%2Ouo"nb08Dpw1isTm&T~ks F)H8eNd%4{ijsBwG}l I<>Qz.}n!brp	9J
-(Jwh;Of/s}\ZLy!|J_e@>56 N!=d<<+2$0.HMOT6i4]B,Rr:{{o=Z~]RG a8nH;A78#M3${V5{Hv,GHfLBp06 >[0&?>D(]P>(X5`}v39`Pv:Nn08*5+\g-9> q
r23z*=2UC	[@$/vF1z^O{n0q|j.g9DC=:*R2F]2-0dvEW	U+Fz7 - 1XBA`<L
|sW^8|^$|{];L7L78>a	JS;<HQ6Gv|,Scgn;N	8ZeWd"XczO1Z8N?3k5O.&ylsJ5t'dx- VJRR3WV8W&'G*=f^+r]$r;,cP:d[I{>< O^?WUY7=|^r2K5E"se_RMF/Z8tEKx8nZ1`+^}vD%yu@j:TWfBm
ABx'Ox&Vq;!@d98( y-V |pcY=?*iAcI8-Z'i$f3nLssTr4|c g\St?Gee`|,.df448*qv/Y7|pqLq3Ksa3>8U+s;Hw>GP>tv?&gnw2w} /Ej%F	M:wW |iud_Lb>X<	xI9zw&i<2d I;v{E|%\R2_d#8w\YDH*snqKy@QX/OM4v~-q,\?Pex'mangK~uK|[Db6(-%XmB01SsvL0]Z<J.j{unPu!}r[?ci.[wB9GS IJkr#*,gU%G?c8P	}kD;+H$ c gLW1v&&WT@rSzX&2 D,M\>*D ?8nh,r71$s9TR 2'o+|D{\+f ,!dhe9?4)Atz6j,tMQ~( B#/!Bs_Ub#}oNX;b4.GO *g@R=}DrW!}k]6{,N2l1&g} 7LsPs<<`Oj:bxqc\dQlNUsS(=N,fKWTYEi+Y*gME~*Je/AS=e][E\A\e-UT	6%3Hu ,xlKs#&A<gPcm;^.K{W}".Zl,3:U'Z1%:'%-leVHyyc7Q95No}z!' GD/aP(]Hy?*^28LNs+G%#\)	E\C:c>Au1o\"< To2zg)Kdcdbfc*ei95b ANXaj"n[O<e{{Co;I=>a^h;GBo&8[P#*W+(P6,~T&Dh,J#u4]BkfHdiVzc&I
$cU8Kq6a
C{dmgRHt[6gys@xYsA$Ly~uz<Mi@\l+`^Iw)`##]]#F`	#-IzE;c& mY|${E4B<'ZvSnG+Z}n } VR>?[a(I#n+UYh)ky-Pw"+pYr6m3437@LPI+51pI:6P~}ExJ([p;v`!0<[iH>hP{S#qkWN:<>@.e+y;#<WjpGmr,~XALwF|~SULy@FjI guD 1cO#D46~Mgu.+==(;+Y,d;;UGAj\\I4'0t<u[qqUYPuqj0u&|>v'Cwf6-pH8}sh.,gUwy{i73bdpq Zff{nVH$H qM(j	F~xLy`^Zc{[h)"PT 9uki?rcTk8	Ui5lbg$Q]*Y<%W',rM|8fz1uML&Gpk6:={58d	glArz\QwjV5VI@Xs:hZ]Wit]Eirt$eaaz!X9UJbF{~#V	| u?F>r8H(NS2I 1)<>f5tf^}GUfG"t )R#!}2&cj<98 eF8(2p}+qYM7W@!m)<h5A#.ik}V(NT4 [J;r3Gj^<93GIzD3d6:=MtN&mZhsO5Te;v6y#Q\D v;^vU^x).03~@oj~[I6OJ	# uqS`{9${ 	ILR3O,n]1py8uOzLF7bdU#/>^t::mYy NS]r~CA?1{sVw6fHA=s^Q4xeiSr@b1FCoKF/jwpDfS8pA 38v}k#ECILJ%$:Q6 H| 'jH7!DiD$;I.1Z;&A?Z\I<H	yEa9;,G>&da`v/M>,J3hC	?	' ~(P(0R$Qz*kqjx({Nhh,?Zc0;MY8&ir $rN?\C<QjJ2qsS-{K#*l&adW cFAg2Icgp`zSU$*D| bg{#{C'4n(I=G}cT~EEC/Z*crse^;; :s\:emA4P`<RSp?E#!q S$Bq=Aq'`Q>	YW).9>u+$qR!1O}UgV`+8N=Qht8?~nrgoqO]ygbHeU-'&Ew^xH-c *KYS+4I7;B?Z 3b`Wq ]3> wAA#hg+xJ	BwbAygb?7U G'PeUpyWLB.3|E 8STYR<0<7~!N3];,;0	v(@*98E?n'@>~;88H?$suSh B[&2<2#'${ks/'bU7@:#,8^px 3vDc1HdJ/ yk'X[20+%:3%4Z$x"O^%c>=?M2;O?#E$\AC%J"K+< eB`'{o]I~:p~J,I8aRK(i|;
BAB4M+=?`\S2K Q2As\oEKP?#D.*Oc pN+{.}?7GY hpJ|7wx|}FK-R0e]*u#dEL~u6
~0\	;^B'wN|*	#P@{5-
[}afvm;NGC!.!1Yd<scdXn$(r(U)S[8+rpO5h},{QkwI$x >B6umbL
v7U%"2Tbk[w >J+3O\Z847q<
7ObfqX3
=	 
I:4-,vv\d2}vxq(7=:B;dvt%;9P7z?g.{*R!I	R|CyWZC{n&;QZ<><*JXd'?j&e$-\ I *sKD{3:xd).r\z|%&$0#na\P'iu]9r.aa57rG\zI {*B+]uMr&kIv]FpIFN~HeeWr+ZyR=E1![v6+8Dr|8;r	:UN'$rw@P0O9\|p2[H;v{(!HZi;qN<]
Op%A[1Y8y5-axr=:i;L;DDaT}i4G}pshY L9j e+2Js%ru{}hsk0r	Y}<8o=<:rcEqV#zq$	CG.< rq=f#wm*HX )-Pu`U9{cDh| j.: Iddo`1jo&sh +2|>{vyg}*k1?3;P8#$%Y7'n[M
SNb{gaRg^EyL=} JRLM1j/
EmL<#y;W`nbXS"
XFy8<3^+O!WnK<C:-jpmph/J@q{$1wyaIL}sJzTLyA G \uzwnm YA dxu7n#)dm~X"'&EcsR_:mJd%{3TUQ@([M'>vYeE0cj5>Djr[* e`lp0p?sUCOpE!7V/Lg#E
H*=jU[P<A^RA9?:s#N	[I !'Y}X%_<->C\;FY,#9Pd$;~}]tKFT=0	O ~*eyfyec39Qk=qqK0dmKRD-9=pc I.G)xu=DG$<A]ZjI^8e&m!y}x.vSS)G\<:V$0x3+MK>NSt9\wrs<f#ju!`_oIJ&CT2vEBQ; &.{ g'6-TYraKtTI-*FXH)uGFcUUq\GjYp/fVsPH1"|s]&2!I^vPaw2HTdh{/<34=~Yk9S9Vd5tLoS6UIUFG%Vb 3Xu;.RC4m^`O<^yq
pNsVK$S!Cq\5q2|i*>
@;2x/c'Tt1:<2;/y8\39lglO H189fLpCtC[-uE[,;66Q8\)20(Sp6'{ qTp|fy$H)%'1DuX,BzpWRU*dR+O)]jcG]r?J%39r[ryS^nLI#$)p95 pH{%?Zr]^r%K~hOZBw1dg=y%g0spQ7a`37&tF7o~9.G|nb/Y?r@xx )PKiJE {"8B~^iHH(n	8<XS3DJGS[>2urC*1OS)hq /w>3]!j3IX	<<KHwhT`<dBZ!*:ldZ+u)wJ(21Cq;sB!Y!JsEA"FP~m%%<XNrHlonLQ|@g!Y>:d U{`qV#|KT{HU1X'<1UEDq>`sFh#Xs9;Oj`!$p9{yPp Ub{1|p3+~1<*#}8m:S9>su>kz#^H+g}:t`8 r]kM|Dw<g5Rxx!dt!2IY%qw{x &8~x($On)/<3@%SP6)gw>O,"t^I<Co.w j6c,@ZXx4eq@T)2[H0yU3DeU q\ =dsJ]B>	ZV[4PchKi!sD5{pv{%Qi|tu5
N3W~gm@etx1&%cKyNR[n}rF>fjB(fj( `uwyaqR1tJxp)>[Gju )Kvs{geEp0#H(l&=Zn$6| ur,Y<{c+2+Mx=vFkP{q&XCm	>ce=jd[: <+$.V4._|=3{{b&El1(|S(' @Zog=z43-rUCn+Tl
nn"ti.Xr|tma2FhXX7Fe 7a 5'fP,mcp4bX` 9m:rq Ip|#$&^YMGfUM	$8{oj
d3\/FbZeC'TwA9`r=2OA4\?huHbvKr3s>MUt'j6:S?&.19U31\&vR6n\`ZP$A8 	r2,p$=kuzOYAf[u_ZBGj'rcM<RsO*C y#Fx*l*03\[Ayg,md!9/Q
v~e(t29%rzSg o=1Y8 XV@H@X'U.0sWZyStp%`$=+y*	bH{R	>$>0	&v"X 3sYlrc=8_:]Bk)aEU-|r<5yss?/ 2F=8p+xAg7>)Y w=L/J&26,{e\^FbXcNp[9$=#5<N`4Fv:#`9gVIEQ:xx_*Uj;_t0?U#TXe;u) G>#:;oiUM+PcmN@gv9Mycfvsi%pv7G/:7_YrO$1tvM<j(n?P~Xcug.kUI0TgX)/$]Jkgt\!{,pv-hc:P;{2Gj.Q 2)zI P	W?k5WfHQF9=2;Es*vkya%a$s@xO?8}~IW=_6IW.x Sk2"4.1t6o
wy4-cN~h`6#ml.]Q,MaRFOJ0D#lw6(wlfu\'g-J+|KWI/fBi 	2>J@;HWFxTon2;X{O_dncq.Xg:E;'01I)Uxep71Y<4e.1Cjl'' |g NhrFW#;5E[ 936YbyH?J"(;/uHcLK(rFqVPm=NJ:6[o{d=r;j`wf#Xg.tdmhV3 P%\!=3>sB M!OS_ls6/f><p8#+n{9qi.u!}lwgO]p+ OV<S,<|;qm`l$}I oa6UL*30Emozjxl&Mxt#Yh~Iceg$/v@(5FC Tv{~%qfOtTE1F?_z;P7z+F-My][lp}]y`wE#cT.L=kH21\>AI.cS$4Dx.c<Lq5nb9 QrM7 FH5yI;;-6p6j.\cJc*$
|29U\cI,9@zY&A+#c6j3Jg% S:fks,V:b+O8u
,^G%t(`xUm].U,esFv~s]e]v !>M*(Y}bhA+s==)po\d4 7/L4dvb|:)\^ye{B{'id8	O"QTDOo8M9#2r@8MvkZ-	P0|Mg]|,nWLq".->3`-isyKw`q^Y0 N=)5Er%[h5v`)}>D# i#I2)[r3GQCHn)dl70PyC2niV:Sf/m?dc]C:Drqq[ov+|\qYm$!0#(# /]K
snvIuPf!^gm'.ee$ykK]B@3Q;'xf';gR.htKm:X"K1iIH zbXh"OswR<Yz}ZcSs$IioKqUewvX  aXDg5Tc'a8?Cw$eY;$0Jx J9mb
C1:Kr|7'9
@_Wqs'WwZ}(krgg6-lQ5`qNzmSi#1i,8}i;6ke?	|=>4a*,i8htJ`z:KopDOUg'$Sn,LWc~x=j{k={AMO[}/He	#sH=sFMwKH=?5MRawUU'-*CZWh";=jO{yR>PJ'f@io$e^6$%<i)'ew>J8bqN&ZP(dz}y$$aq_VRp ?^ZVra`r`y:LEnS6Ic#I- F{9GCIfKuUiIl0@k4v>C};jL&yP((sL^L.4aRk9\*O\$Lx",;u)nt+{)eZ5)\XLmbLqoOj>_?]?|SE*&6+(s!]K-8%!uKN'kZf-k5q Yp Lf5cml@ r~U@$[Oc{0}9B4MVWM:Ii5gU`2vW^PS,ewBzO'4.CVMAsjkX[m> T(M2yIfePHN>LJQ&}9S$ nAJ3;SC Yo=p>>ENKh.!9nz LUwbxd]V.7eCvcNO<FmMzHLU<Vz}WPE||N,k5+[;rsQsO2%`B1^IvMak[`0	HyLEq%LZ>L>u{`v[iKz\8=sBz@'>-Ml47ku)x :UPari5H9]<6Ju&qg-u}}3Fwa#hf12vZ|/P$D|:VsZj|;7XA<9s\7h.TorK )0zMd2:6y=Q;e-{kHio*|WhaYK}nm`=?[jfLx-._zU/%]5Dc[eAT23$=f= Rk* n>`/n32jlan^>Gu5xaI>WkwVp>$q:V`=3dmztd./ S8*_R*DIf^>~,Vu]^<W%Q>M$_ZHtyF~-Z93yl@9._+20D!?<uMoHmwkFFT#9<zsCw\Er[kGp:}o\!8ly] lq|SKmj[+c3w	r>>j/m%3mSp~]^s<nnl8Ak+$2E}:sRsV7zLyu9HA_zEi[H9]9E1 quKel:%U]-unU$B[\aB%u4mmpl~qS'f4c0 
Mk} up3(9bv U7zQe9DO'#CIX)<F}:|,R#,G-o
yh5yB,9RlEGsh4@J t9]B ;" aovByaKF\	k{]/Fy!-O"3F;d55G0$,BqI$s?Z+U$F>]kLEhSnwY!%UP3-%Kx{]Hr #c7>wdP63yqM?&m7R)?+}//p<C,RnLde|_j}KIn@O$V|!Jidl-O BN90N}5u|4Z{h0C2q\t^,:gr1#gi?ghOKHSw% xY&,[+C )&+D4R7 urOyr[y9;NiY$~\J$+]&<9573|tJw b~_ SfdE u1YsbE#,(r	;f7Zc6PeERUOO8>j[)%Y>{PpGhNGO&wv|p]\c\,	_mcU_zq9VNI$MV:F~VOm(ims''za6XX]Ih"TF4E	1q2H{VK~%GGyQ/d+'Q~ F0GOZWN|]^?iZ[IqBsS KSd=}	gh;/hcB3j.LC!CkxO\vhdg\qKtAmhbX& b=hCF)TSDgc~;1Up@~u\c{ Q/vuIg=HtJ~=GWA z3z:)D<af.`5Ee4_u{&t	 dJmr4$i&\y!$m3^21nxqq<~}HM-#`E+0rxKrS6QI `Uv]I{v+,jB+7:Z%pm$O0F:,,BN
AdsKeC
$:>mHI$F>8?4NhyH9
"#vYXSrV~;%2<t8:V~]'IA:}OXX-_s	I.xxl$Lyl qq=P:D=J.RZjq *GS{-IUz>jvNXONi}AId;AW$K~!e>kUA8VW
b.S  M Flv}c~X1@<J)[bs\|u 9[g51o^H/9 vP[n7{(q1'kgt'fmeHrf2H~>[-n8?IESzZqk*`zl	qFS	*J*`SQG'gn@.q/fvm#a+>.>Jw\,gT1{U-	9}@z\ S> hvHuaRTewAF1w9Y6|	=pkkqAs4F"Ir6VnNjY"MctIY_}FX?|W(9@
:
6	m[p{??qUA,G ODTe|q
TFf^r=]"rc p X#;KlH}h<zrn>#m *UZPk]*e#B@'P'Jv'nO)m^iQ7F2q]g$tD a\=z=Gl=\Qus*.r9=sI?$mRkVVtn}?f	0[p1;W^'emN?Z5;={Ag#[],.2?<DvKWts,^_<dsFK*@>nSa~ByP~@p|B6q=vJH9bjeqg.56<FfnMwf.|j3>~H\ry#`N0x#@53xS[`}$-0:W	)[OJZ<dhZ$jQuh*>?8E?z[8?Jvb(_@[~7QHe wh]vMMmn6.F:g=85qjYb]d\Qj2P2O8H/iU.Z b48Hel=4R0CaUv#$9xq-A)&Nx[IgmBu>jc>Lj[W$.8W$(#89?7 jiW1$~Y5el|)IP)2si9r5h*p;vrhl7R~gCTh#NN:`*pF8B' KcdC]7]?O u/Faw(c9BxHPxxOJ]^jWs|'y2.Tc#P;gb9&U?@sDj5I*Kx|u Z&$/lyUMg:Q-h|6wS9xop	TyNdB"NxT$7_=iv{RCAc{)<mnFtkHY~r[0\,'<FH=~SxW<?*ZyuK4]ANpsA8xIyvK7\dU\}	m;5Iq*5,
Z11MjNj2nc#?>3&M*B)8_M-=J}+cSfJUgkq9L[g r@S xc[XHsTg4z?jBjr~'pccf#\`f7*KbpO:}P]=|8=:OJz2it1{d|V
Oj]?r0g5KZ]0y&3T[-/>RiZe)^_7 r9[$Duz
MB<k]D,}PG:lK.+dkRmy=p(%H K{	vAg{T-v qFiK$pdyQ84%  A[O/}kNA~W54.m}9cVLIJI!C F
nI=(X\/QTH!y>CeA%xUBGGK}X# UtT~[i'2tU	&YF)Hp9$.eU;>$:,l_:?[X sZ@<$N:u8XXc";b~Y'xi$+y*H1?nt]h +v	|.Gf!dDPkJe+9@f
'9XZbkhIF s
HqTx@
s[pp}qRGbX(u+'dho!>cAJoa$(|EG&%GCLRIFa@ZtVVr2w!dK@@ ^N%Pu>3GnVv Q^6l+jR8c9d8Ru*8`~P}fi7sXhhX>xe, .I!\9$z FpiKvQw,kt0cBukqJ$P[HFdUHe3{K,X0svsj,Ybc?W<G5(FB>,PaRM4H99#TX* = =Ep&|o(i8UL$;OZA< R>cMBgVd@o<)'nd'{Jx~`He)fGR?vT&T\-_ufz<"\,@ceR<6qr?OFkO#EsPrxiK?{b^`VxWs9vv,_aZUO?gVUSHZb
W8^9s q1S2r##-H\XKU} $#5 *h7($keN2yZvgrjc'950y%r?PSv!g<^(6Abnflc{6EhMCU~\
xbf*#,Ty[h7'z/eGLvxP2% p63q9= hfz|]|d3) dq:^H	$u"C2=jj){H$`pI)kQ#S[8	X@LJ*K S+N^Q[s,bR]7?:~sTA%W2"POdql!\,I8  _[n#UrFF136"rw,'?jQ+0qg<^yq<??5vh;mF! 'RDvjW\7|NykN"V#$Ua_G ]_*!R7|UeNH*zlHI[&'w`bqvyu]m#,Xvb11 >RyIugZ^,JrN|bu` ;vF%dfUgs
:aH0UIxpOD9??J5#W19o4ek	Fc'
E yy9]dlT1T>~pa4TePqKO?3I,{ISf--N#qIT  X]I~Q(kD.Pk{p;gZq# *0AT4:+y7JkGTbvc8:L#>ynpI^uC3X`)y&F
 G)#&`Jy|FI9:~?#J$cJJm<3`F^rcK8m+#,Ob#[hx:jZu0,Kq+zm&N+9e"FrV^|c?WBr@|$UQ~>)X9r<Lk#sVN Z^o!;P[>PdD<xR92(fJL.:k.'2 8h:`lK \erJy,Ok&5u>GJ@6_&xF=8 uz2!N21n)ux~pC7z?cvdn:d14&!0D&& *%\}76}a%."vXg8yVn1$k$`FXEJsM;!\zf,#ybzDi~12GY.Mws"cjzB  x\^>SEaDeG-Uy3Hln18!9, <p>t 'O,y<We`DKSh33DgmK$ f[3JL+B w_ytu;X<X!r *;#eiV1APL770*n x=z+=;v;QbIj|dwgPkU)*3sC6qqjom HW%GS<bE$	<cDwn1x3hIs\X2J@Z+4`|"u 	?*Ar	J(1B5VEE0FWmMp~ I
 Y&p2u>Un@. z]CvJ)kl>_1Cp{M aV$`z
CAc=2MamH`Xjky)#y_eriI(HF~~JWcesM>}GifS4B
AzqLVnYI#@ss@i,_3*>e7s> 
3]&0F~}kD*~I&`v\jF5d`tCT=mfsY7OJqC!;y lv% 'v=()agmRnWO?A_sY?^i,Pp2XF2YAHB008|/nD$(qQQV<y\"Kx.6`5,8$L	=|/|*8u7c q0{h}DKC2PC%aF"42slRA,sm >Y-w3 1=yH7;sf.Bmhx$u=(6&k#lPq3uKyJ&}b2)r8a#qkzgHB9#vuS0 >/8dz&X{nqq\Ku'ldcyVJ1d7&V6K p=iRmg%d%0Q?U&BPvA#:Rt&"99>MQke>Mnn]Z a+;<, ;QF}+E'[Z{xHylj6G[)([pcG&m#"r1UFQgLsPsXu;\(QQVAU266$`F1RFmcW#2#}N*Y-I6JvQ:f}c+n!t*$el=q)dz`|	kE?k5&? (V1*NZUm
l#)8aFk{i;$z:"%rO<iT4{+'\ZaS'IwdBfe1d.:i	sn'?Z&i< Z6}q@JXerIRRwP* h\['DI9Gup}}<r<=2[ KY"{Q&#*HcB/1YODw2J+;KVgr =)g*cg-N*9^a6vNqWep@>}O%d>9$=8SinQA	p#CxX(goWpo5s3rxT)l.2=!eLg^Hc8kzNmo45Uu#_ZDu;<([Km6e3*1Xw}3Y `<%0Zc5 [wt\2"G	3K'<sq]|K9#{-8{B+W#+u)<M*;{wL_k+\zsY+!.1#CS6p20r0B3W	R2^YQ{d B1IZhI
3}XHr#Yzxct8\gdY.`t[l ER. g^vKp#8}zRR#2k CW^;gt%Ei@L5q<;kSnJ!MV v &.d0VX#^nq$G$i2pEG?gGWr5{i',^Tn}LPP9I5e 8s`z/Z.J|+6=[N`zeK[Z5BA q\XPv@JqRK
ZBI s,qb9b,q>".}s<"O_>i6YC 2W^1]XN]fK`spt+XH
{T`>GjOvn
O;^]~#.]z#4[LcFo(6i#zx-8xi|;HIJ l1Gi?^F0o! a\3onN-?	pGoyqZ&x$w}Ej:W%h9ec*tnhP19l7`>|K%Jn=?S49fr$6;6)8([nj2*qVEp^n4w!ccRWv|Z 9S].o>Yt$~H!-^n;K;av;08f[/z=q!D>`x888|b>V/#XN4;C+k eC-tTZA[xv((fHqZ;Z'/ pn?,c[dG)	]}ms[%2ZtR<wXVe?,u2w4ylp@F|=ctHp_lj*pq3.*!uS)T)4K |<76rI*  J3Z4sx(n%Xcx8R7g^ .Pd~4*vVAf= 3Y	TFw|]RJM2B]]1d^nMmh`'0	8OQQG>\()8#'q}iucQ,iw1J(@GSg\h%\Ch$L|}OhlG+)qvS1@A9rYW%wx4b<AG]Zv^)4xv':,e> g93Jn7) *g`8P@Ff <zT;v\nlX,s7L\4jb38e\,@IQDQsG\&O}6TH~7\$*wM+G>Z}*jok
/z]
134T_,se&"jr >FIykA;jZ6(O^@=EPrD15Lv ]tKucNJi jFlQHM.Sq,}t?Ws9{]I0wvqV+'8Gf(Iyym-8LHTVpcD&<l2%mYAa" XhlSP!2J!R:Z GdK&R3L\5+kbwLB}<s2I3dNi{2*+sEZM&U$zgp7 6	Y 2	6o/H'9TXFr3=2sG}p)h[=vl*8\gkgQl8M,&Jx'j	$<,^l3<{[=?WUePG$8Ms]H|DlQ2qp 6H]?:T`3xa OVGnDk^kupGv{u8m3u}ZfZ`Xkvwh8+m~Orf$:= eR~5+~"X% l$,0[Iz\Qw6:5m<GqQtmMV$rCqDC6lR^so;86A6K=v1xkW\ ^@P	hOx3$)qjN`h,+x{h/v|[~t#'8|H@[3}zUgC0Y#9\ *:(1V3@V;flp3'*]Fu46;&[s
-<zRD?fOLZbnv	%>.\:^jD_kAnF68D}[,
2KDkJd<hwW#f$a!hOs#>E?jyF(X$wAV!Tg\I<D,hg?JwhCm'^1Lp(${v|9Ow}Z1Gt!@+<X^Ie|""l!IUXCg/`Uw`pHiw !;9H$%N)#S$$}[[F,E]$E %iUFPO4\vbBWMe
tC'Gl>(f646n8gy%%Bswsg<EHPPNl'\Vdqk{7x :u"|O,sMxV%"I "H f98128*up,F?i(co&?!V$nA[i9 OY3jxDW* )#sTKe5^?$I{)hT7d$UXG.N@36!86vC|A$[!(lfG{IiFc.i.V1&s_F.#[y_hqt)3LY,-%#(|,'4vSyHb*G8l;Ig+wr\$GH8<>~NN(?d5SkL-(6GCPnm~vR$v$vMg]b#_['E=09ro^k62vb194CvH
I }0k|`d 	 )8$F/4[3Z? ZYT,hu|DKosnw~|?Uhwg`6l\S])yJ3fwd;k6+>G\ zs\Uy?iB2r3( x
jkG&@.6{`N=x{*6*3![;i:`?ZZ)_,kqK[fKkHBK8 ?4vYm\0n<9b-2rk28 duTJ%rwxUdc [yYk)"ka3,4cE<Q`Kw|PF$ %5sxgjki&XVHP8"@;dF=0rvr]Tzj[UxKmc1o%So@L21B8  jV^aL	WI%ndAe|-t@(G|F/w[Tn6,*(v(46BpDXUzqzc;go0E6Y <m[XI4.DlL~)~iZxxI"b{PcvbgO>s\@?z8Z;q#Zhu640gl/lYHb>gRiSg/]wW(9>x[z6 '>cmv[k{@W}8$`rZt;DYaqVw5HR0Uom$XQ ?AA<~uE=[0n@g>cW^v~k8H~.yNFr9IrQ.=P{y  Gd5+^+kbGa*V/YC$P6WFlT?vq;tFJ\!9Gg-]>`z')/+m	le-3xY1YTul[oYiB<	G9,=3AKyMWC%)Tw\S4p]Gck} zi5uZSJn?y:.Kb->mZk,7@?y\?@,Xz/Zv1x a>HA\RA)h{=bs_aWve$$?Z8NH~gY;=_Rll?,WQWe$sp~v$	+g'D$vd}OOqm)!HBuE2+FGPykWVYaFLktrNL`ygL_~d=	3'1;("8pq;5[=*-V9.IIr/`}ziZpO\bEgo~ r1L"Q_"/:Dh ltkPOAf" RA\/,(h@#Bd>J:(nf<gN 1Qc/ "vN]4 9 pH~GVIqw e8kL}?d~u!9\M>=&}:$`G=ilvr[Nid&'^V[%vN#mNv@ k:$M*4Gy'}}w-JqDgogM8|Rvbe~"1phF9e`cX3a~K0'|1CX++cZOY:k2c9J2f[t:@ ir.26zZm[Pd22F$HdN	90RnX~1ro!g$(1|QX5vJx[JlHV``$Wk'f ."Eskm>G]BX$~U;~$m7nc9<H0Z@<.XtK%=a6zrhb(;>fWNVc{)eP?$p^W3d@2V$zqhUat)w*> O\Ogf#R74XG'-|J@X%dm9=n!`3 *,bR	/2=OFrk&i,U. c	~%pHa\1EZr%W}Ewh/4rn'lElIMHIe]r:h\En]urK3IJ; f 9=Zg^h@ @#~)yuy	 o|>T\qv6i_j#^NiencR\,~+5F<O\r{ 2iv~T,Z7gnHA"CM(fYLJb`\z7!vnl~t=bbD	8`td`rIs%TWD2H23ei%m)qwr@1Fishk~!Q#1T^YnS2l[	mCQA?Yk'/m;,T_xm*v/)||R# H6YN)]'km$B7xr(aYYS!Q\tCp (	nrgrOY0BI 4Ni5s"#*A;mAZ[jQN	''*Lo?vf$4DI?*{3EK",~x^\*a qZ){1zwcR[,Noz9,kJ"igMb@xg1rA+&29kpiW=m%]vI`qcm-oWcv$yWDr<+,vZ9WVg??:8-99g=[vzC&#7w<Te2Bnyu22w3BNYn~YB%1 <x0qc39Ot;nb0I''4!%$[	Ag5(XWmvTv :sghT:gX=Z4}*MN8#^I[nljw8+/cH4""N}r$LVi/fvgvbK*=
f6pP)`]lC-ui;DeFeFI3)
DiY|::~eejrYfTGbJF|&B#4a	qnEeU#wH8Nh(^m^3 xbe| ~IXEK0 Z8;c]&{w*;Wc(Sgh}9w<{o;py]cnp_blWI&ha$09f^(Y.ntW0:,R5Vi"ul41GK/#~:fN-.{59A?GJ`3Id^
u=M&}'<-?;M?EU}M3jRD@<c'2z~}!.lrP!lqH0X49$;p>u$6#Ye CFR!^ lgpvF~x@3V{kIwZ/}cGC]VL	eJM/]etX	I#R	>G89gdwI(<d5a n84<xX'
g9n5cu!Q*=G^)+K5o,omq)QYCYCU+RG#R-@EMNcn"
6n98S/>@<Od?+0#ol
xnGw35`9)$WIp9|s%bbTxV2U\t?{Pg)02sF;!  0>u*%'dz`'Yj`3\20+ <yUE@^ kEt&tw-Zn
?z8^ZTCsXN=hMUc9Jg*(J6nrG^}_qX/<e|~h' L\9vFA1^D9?KV+,I+
 ,NaSd,7#oyrrN|\JCw:FZW:I63Bl{<ors
J(@{?ze$Q-1%w61+ y.Zc[89b[qw%0b):n`U0 r CT-rx>*s( 2bw!YHS%|?evA8sJ{eY*6uba`ohv<}M*+p9r|j ]e<L|O1
sBh3x26Hl+,i#{f6
<LsWBP//"vN=ODl
G_T6!"DXeXl*F::>w@!tFd\,'#3]rkn#sdRd 3Bcp:
3MFc#$DF >|;hA$`qHQWCkJ9`N[Q\xPsqAwN$ 	Drr
%jK<iz>KCEs0G &Vg_'xh$Dz!'48|/-#+>Y"N^%Rv>"z[mR:jpp|cG  !<TSH<Uo	eP,D|Q06	$cf	;OfGVe5d,0~ :I}Lqhn3mI `H?XC .X cU,,BHdI)}jmdOqznSj?()@>YR0DHNx</"ep)jV/*co<|I`kF#YUmS.dlo Vn9+wml>t]diLn/*U8aGFLxaVIQ%*n|W6-`?j\:FP<GwO$7%I>+o&a?SIT6TEDpe@dc8EfI]#*t:{18b^kH9/v8|CKW;{l`!j;!|)Y`y?za6$}'lZf_,F9^I OdQ=Wi"')"[zI4j8'mZNN:2d
_O$8za#1{kfsdR/w,D!vIVTdy#)oWrczh;&o$2`9pGu#UCr'L;GcsKJdR3)ZH+eC%*w6[C>yV84
\;~~wRCo-U'7bK(@$2\,MQ9%[x>aM3qF /R_/ VumrYHa9pk0D;3Z2uaWHHC\n[ X&|UM7k7WJJ<]D,rOSA?+{\q.Zm^4m1:`HcR)]8&yrE$(q<uz68 vN*ViCw?NR1yyp%Z5.{3"x/QzPDP)0S>?9a+`m8fQAl$t8VF;+Tg(#f2Qrnhy;$(ZhW$qR$w{Pq>^1+e,}=_3p1	O6U)r@2wqs<`G8*;uc9WH>^urri1F!l@*<~\nA3ZaxI<+U]HY(302A?1YEN
*!G]tp2;PL:q0<2$rO>zY8`Hc<m |W',M2T7Z.;fOPZFaQL`17@G$`{t+ef9uk
<'Pdw)qB)D/kT=K <&: y?C]C1<=QY=?jt% ?e$cz&ghH!\`HCwWOn'Fl	2y7"x((QC=cs
c|L0>trv02:~uDebT	2Q>~ pAIm-sr3VE%wbr8~u1s2<py9$C++Al(l>O"Lv lLNkBgo.#_zs;_ \&yvL2'?^ UN$9>q:Z!v;f-g*C\AP3{u+c> 	 c
/ :VX8hs i1^F{^3Blm&9xBw)\$`yzkYU@4\Isp2;	x#<f&)%Di`3V6e [8 {U64q?;<p=M02r
CzMFysj)Cp9o,o?$
7addMl$;b[/tj.Djh g@bmcc]uF4TEB#mO%f29\3)V;h418A *oe`hdW*?Pck
d^<g%@<yHDxTXtn=z`jUQ'ch+@.Kaf9[0x% gCCl
X#d\)\)F98M}*[vaiOcah5i vsWvjqm[d3B9zqCv_TvvU8_!88sQ_"7z P,X( ~uf|Gej-p0{srFQ/U_cu/yrF0=pC/vGqWVG]NP\5(\zL@+o%Y]d
s|kqR&.KsF<uI/_ny q=i.5e	2 oiFbygvVY--3FB2FT ]j6%E8= D%\cz:JKs3HIU>W=z|(pqOA|T( f9Wyd+q[P0>98$p5+8n:{RTt8Cs\T9"=UG <5+v.-<4Hy=@nyT-4]r\PrTFr:$BC9uKl*OR8}*g	d
[3#[H?V3H$@z:PV</&IDOLGgr^Ax$vroDx+A6iceX+\z|(#O_5l#e.g p3tT|Wu$/9[m[.7gFw}5". -@3Y!~< Z69a=}QCvc{ka$U %3\d+>3<`zBEm`rs<W!QZ\*BMtd<6mD3ws;eB:yZ=!" 6yFkgV((L5x8"9pXcmb:S>zDL(['aV}N28Xi>/:Ny}C'<+c!nk$O){l:c8[T_9bb#i7lSGG$@:Gy8YlCshxSu?Pu\\}im0O=jx]Y3+5$#^hzKW2_Ht14cxSH3U0|\|MhOQ[R$VsH;M/oY/e+Ucg f:Sm[VN4.O!>W =3sW	,>r1@2k\8cf8QxZWJ\\8{W26OWLM}O J=AaY7k3V]Cf#5EiP^GmfBG84&8$Pl#
S7$gTc?W\j:yd>U-{dgM>@;=b3zI ;+l9	Cv	f;n#A!ef<mM<-BF<	!MRc<qD^]05l/0^9P`:P!e9 >gF?h`Iv- }96!@$r|(odmL6sq/_c	u& lrO'CoG9]^
]!^*dG#TclS$Ny{fo@%Yk6Mg`$3=h}6L%Gb>T}3$nUr dI$Y&ERs|r,5Mi:,Tsi,)HAxCgG'5].c|0$UWQ<'=u=zt$ ^[_ g"zLSsUVM]wMqs{P\I;T7PFuh*N\*NiK1xF 8bCki#L4<u3(-c	=6v/nX!UB_>siwRx})4QIXXZfUluVICB[)[CFUVx}UAjzx ]8&-T$F=[."Um!X1rN9dtG,z	rK wk=^W`lQNI.mf1 ``W1RMTh,H_h d)$Y#mM|DDQjW/Dh;
+C8X`V4Qkkf!++Z2W]0k.Kcps[8br_ogOMl@!`tl|Ev=zt F/x"9IEl%'4Q%<[*
	LqHW<{vH3/$:k,'$N? TSv{JBpm;69	GP2x,-FYiW2,	CbmLH}Vrn!;
F9Km.vq=fhQBY2A9RbE#D272Dd/|:%p]nR`<9F9W7Zpr	3"y$i"y#trx5FkOiY0I`WVE:WhH#lyn,JR@GC}}kRF+53iO)sXr]55#cI'Y[K)8oZ
=bINrYWiOAWK$;PpOQ5)42;x,aGVhh*u8
]cRPxL|MrO4K"BF|:F ?:T'c,?eu2=0zf=NK:k"@)~gnsM\l 3}jJJfY U)@ *e(E$dYs=vKEw3L[q1'UArH % {qRuOJ
ZUz^ZMP.[nJ;%'96#"k).<rk93Y>K09 :U5Qq+$R"zbk"J[sVYKkvpZvVHUy1$rx8/|Kejliwg;~uv{{Q0^9l{?>i-tvHp ~A&N=	'{mBYT9:t`xcIcRpyu`kV
\Zh"{Gt.z>$*-,}iLz6tRMu%IBQI4gK O nX4r"C$j-Uqt@q( xOvA*J`f $\<
h_q s R?JjFf
=
M(9>3DIZ7)eF $K 99<VP-bn,`(Lz{yT\V[GqQoKTtVNqHIVhU6Cdq5xJ<y,YR7XWwbfi sk?dfv2!Hya4VHCP_Z!msWr>C6lBiv 	|+pN|
qI?hlK!I\AC?:~0#@>0	0@pq
2qKL,>T}6ifUjnBG>]qdZwc$#?jk}AwuLw0:)zvWZI5q.Y9I2:Xn|:Jn89#EfnK9~v9;! *>nv[xA/=?@@fL2sSKnay~f]T9V`|w_o:d~ses2rC*A(xvSr7R#YZW /C 7}3Y#]RB^W%O\qXIvQ 3<g@|mfB+U$;E60X$9 V<`+aa_Z'1J9AUWo4Y1N}
&-w*,s1@N9g\ww[d#
5k&,ArM_5Twzy/ERu-AeI-u.d 0*>=
H6:\ZyA+u	BT1Qp>ckKq<'MVeR@) #?Jh"M[^9#TYXv(Pyyg5rh2o:4>`-LG`kdm46$J}3P]+sdQv75$8#m>Z+yE+2y'gG\\yf=L+}:wcen<} Yol4r26yJ}r{#]>A=D U23?yhukKZk(S<^LXnu??zU9%n9 #2_gW-e<p|r^Z,&Q-o`{+z!'yQWwbHmgC y\~IE"Z
7w|kjbq 3/u[+yevL@J!gblYOq5kp(b Z>gDv=wP^K!ccR]VRif'9?ZWmjZZ65]()&RB15"`Y/J/Z{K-(NK0 qG&$P:&$'c9E4W`+s	mu_6_?eb_i2 iQ{+WMf )~}O$gdO>^t{orq3w*0F1b\<pJ[K9{9BG_'Rhq+:VqBOxqsvnap:U2Ah_7n hmk{7_ HMJ;qs%Qe~@/=jS6{
O15gn h=X3p#B~0Lmd}-#J}O~7N]wpU<t#=)d)_h`+c<pQRb'sg{Yw@A%dcHa.M3]G(=9%y5pQ##y+af]q9<TW5Vz=o&;D.i~'xW .IW_I uDz:) 
S|k!aMLVe m~Y]hqF9H6jZb7Ba88i^.NVuop>Wd-r\MIbZ(06?ZY?qu3d{/>'8Rfr[j?by2co,$[YPZIUnR7tK	*gs)lYuHEGnzmY7p0m[y9?jf;O}!nY7=@|^eyqR|RBu+7[[H9;B`d9iWipb8:yQmw,l\ x<!Homm%F#S'OtLEmJeK?JcM&,,dBN@|IYL8M428R	`@*,@a4e5kwsp1^rm-^[KmB+h|Kr }9i2y
GkP\2'nfF
=u^ iqfme j(DYOOJFH'b9 t3jjomm{`&P|ZhWKiPXp dc9}@}>!m`}@V{bXc!|+?6`u^D)V})}* 1KuT"Xp&$Pj!k`$$1s3HSmuX\\V^iv,w:Q\,\z%{s\I2<%\G,W	8,F;$3' >+M[j2 U2(xbW\yC!}LLB	*RSe,ol;RhFj. Hfw'Fd,4rO#)|4{D^6 jzar;jrF;B	I f$$)\6FjGoZ@8Y*`+\b5
Y(u
Tz@ s'kfsq SmGItn!kREf
IX=9gkg:IGa9ZMgwQ~Go,M }|~g_\_B{c^1QY99JjZD:cY..cE5O8|k[[)lLq:M/JTfiz'>Ue1U#<*y&O/";D#f'pZL$8<:1z;N@?uUgG:eK?6gJxBN9T)aypk 8=ht+.u; <_wL(.X_9{?$Qfx' r+
VM1[vO>D/l{:d7N@==j QNzW#\,uD08;$vRkzgXbB[t5(.:08XG?,*j_/ggI5')'^ilC}JHw4:qM%p\U.OdhZ1i2:TIP"]i?R@Ik[Puhi"RcOj>+UFE[5T\ns c:>pXq4'<`|tB^/	9+VnqvsZs{V$R]Qg:
Z[62N8~XLI/R1ke.[0:}(pQLY V^x u-*=yK3b[z`G/7bn*	N<5o"2nGn<)e{]]U;-I<Vg$hSC 7_s Tu6 bAiEp?*5V_c/\biUU<|"2#\a	Gwsj6QQV
^FPXP9]s3WEB?_VE\mB?gjR:IG.pNr>c|e9 :<h+r T(<:h6hS21'0_oz]2~@I W;l- :l;H9/_cVTY%'d}z1F,c;VI	qvIA\I6vb+wu$VvxJ\Y&2WP~`?NI1f*8}hInIbw[D'<;vl-ZDx9vEp0|XC/D>f
EE1CDvkP^YY>)9Rs'{_Nr3>EdU}>BtLqF"d>,L`"(?	KyF+<[Uq}k@sF<(C,	7IJp ^cFKlr0XNy'j*ZNYXa5e$pL$aapU`NyEk1?#	'MAN#1vZ{B&#hc;FW'zlU<p	8d`5lj1KF@n3[IU<2Qj/Lje#*)m'e[y:uK4IX1|1F#9 Uv4-Fgee?JP0*.1x
8<*J"8 '<`zu8 nTpW@B/-cg11xP@Ygw{W1[;X.2IH\'1R {eF >O5II\/s	 s]K"C$:	&#G>T}`WP8@\('t6	cHcOXQNd2| VRG10MQ#F3<Ggiv2M,zvcP`})7,JkX%V<B[W \s`h^LO	y."(TfgyM"	qU*$KKq 
PG^MxOtq.|+ktX1`Fp||E Z*-$}V+#V. +b=L0zsIlJ<3N6s"2;iy64H$IzW6I SHKE@3y{b%?}RcF??z^B3rps*ype.A]K67WwBY6wG>*%Ix]|q4~Dc#j#
G=3Y==tRj|&#G4!>R%YY&V
yV*`
n#@FSU^ggQU#,pNq%W=E2=GtSXt>KmI'$yg<ew:!m;px:7'6"a$wnQ3:\0>Dxb72=}2Gv0tmRq2S CE@y} *vY$.R1/zA%S#$Q=g$t+S
$>g9}#vGH-jf\.e8>jtcDRFJx!e%\T`#9 UPO|M.I:Q1WW=[?w"K>Dc1B;sov"@V	l cg<Nk$ulH*;YcF,<:c(iXC<EK>O[lKpnZk>eOzq%;?*95CDn}(X0_L3] x>UY-['),w9>/T6>xa\4 !;*M34ZV?hgG)e+C;7&2r n';~h[)3]s.y]FT6={dNT 5:"G K9gDqX.#6cUJgD{XGsT yzGpKS ~HH!) j5N
u tc^sX!PX@84D,7+< <0;_#3NEu"0BmWdH^R,~ubn~.=CGf<+ 0eR08| -Z9!w[As{V 
g qS}Ed.Hds`=*G@46wX*'CHl23P<#TR*0ry>={SpJD48PH@ R- Xi8P\m& &Qbi'*	to*nB*O]vhZB#O'd$N@B'`-I$BCA[ub$9|TaIGL^%D "8RF>`o!x #:u2Gv2=G^mWmk'Luuly	({/y6mxQ[GlI,0V*]OcM&Rc]{[iiKh w:n$A00/P1$g%YC.<\Ul_sU%q#:$A[8bx`$A!`sA<V[NT*`:N;"cWG.ce"8L@[?:FX=?b6\z~W8W+v'NFiKns)9NyS_*GOx; 0\2@(yl' /T.pOjF $cqsj&R\` ?/pz	e.rIUa%69~>uSO>v+$!=*SY{HO_s<'Hx'#pr=k	A?y-stuun
  >kL(`v2 U1m,9-zPpRF(##K(Cm6y +El&3xY'u1:9OR=K	excfe%@0|x?Y.T4'$|P<K>=(+^$q8
Hg :YI3RfF xU/z>NsCATW!)%N3g6]Rp3&p~ex68i' BTMgQCYBxTt<
MKq'pr$ Ub$,Afir>w~Dx>GKw899N^v8<,p}iB]EQ >~=ve#8X>\UcKghk2>m1.11$RXaUuv@U$VMyDh2ll :7c/4|AW+s WOF'DF> #}k3$W}{^z=xOz$Hq-e/|tV{@,XTwzV,;:eSnRA8:~D%=O5dv lVXC ~_z &]BE2w![BrM&;:p+#2 T	8JVBtrXc$P&h?*Q_6	)u5SF Vp&?,3DqbrVnA |Z]#._2W>W$w\
:c9<QZIKXC
w,~w#c&	8xHW$UWD *LO`kTIRpwruKCzPfVqNy'PdU}w xsL;i%c3 *e`[pm,-oi*pO>U%Ed#/yA604,b#zU%97mFrVR s^>^y$imA;@~cV*JpRciC5^	-F!pSr!gXOhDfm7g8ZjI*G*VGg2&5B:F$><|^VXvXi@UKbF Pz+.2z}g8+qu.2HDG&7y A[s?5Tr2b?&{(l1tj\RF509c'=-?-``3&dwdq'wx tZtzq5s1{z-7HecZ{;@3Hz3 THz6k'^!{rFr]>]pVr+w#a,,z$xQ#4W$sDRG5-$P2l	51.<Qyx# ~46Uy@I+!m4Q_8B}G#85x N'C*. DHVtBIKb663>jnMPYna$C#n-SMr 8 dt^`Gc
V~**,r0O	=2+kIai(@QJI2)VoLL{!|+pTd(8DX N**St{i.(+$JwgNIWT2RG#$?lO\4zd+;N"('C%-6y29IfoF&k8=y4uQr9 % qHUoBdi='-FH=;QF/XF8T
xMy%$>);mA p~ySRYg\3d!)wr">?nG.#>E&E`Q|tkDN@yZhY7K:H.[d7wGeBe6*u'=h.p-F, -3nZrda)u)l@C;]|*oub	< Wqz~UX{wr 4*?A}].YB p9H8vO,VPs2?	?ZrnFj.u' Fn Qg9 >/qhz HBhvsSC1 k` !zuk(MQxfydM}E!D(8?0@2C>'P17x>$m#:FF{\Zx+,1p@??l-?HT-{yVaUI@I>mrbye'*[C=,DpB
^wyxqqG*;!GtpRygSHb{rA8yeYn~i,eUn?\Hf?cN~
`Lm>)+ivp1 ZZ.a~X]V/'AC Li	4J$dkb] P]J" 8*(PT9R1 mI&P>j
OIxwcWX=0Gc' Nwwqs"K?zP)*CZa*#=`ch>d6>B%`nFzvkPd*y\^YKpRYc7&D</Bi@<*{C{-V!.0zx[YHo32Tj! l':[\j7iu]Fq?~k:|Oe xdBWoYWx WF|VJ/g/p?V/$'";,#E`*1TE7wp	*}IV{WFdo@ (*p8rMqe$ml&>0c *C,dSwW'9S6cXmsDPAGib#E>j!@'2)VDHjz\Pm<dn:.K`W?'bw,W>I2>rr^@k0(8>|=3t1d+ZLc/A = p8q09Sy%dgxMJ_#m*4T-2o0ygNvNd~db y;#$|6'Xt<R-neZn82uw<:T%!m696w6s}FHsfvSsIuLEb7&B29{fj&cy0?ItiE%-iebCgu1s\Zj1Q~"@7gig:Ux,,fylEmQG.g6pV
U$kK}j0iIu1H-.uNR[x: }+OSBb>Xj	I nvR+9xU=c9EymQHgE3Ydr}?t-9g)1ks[s}oq,Z~.TSqo	k[1X]*= -M*pS2B%Skf# |UjPl9lq4/gW|?hXkd494VuMsrbDt'fAd\ZD1JjNzdwS_2=.I@REkrGY?nF<[Aw	Z!ojvj2{G@#%ml{hl!95.S0?!n*;ZvcnlH
_Ve-*bzskgcOZIS/jl3\rE R^.lI0@1J+f5,u]\ MA3t>Q~X4rq{AT$ZbtZpk=-em*3\-v^8'=k;x 'M#HiS?Nh5[		!$>9s XsytZSvnX>d|lPq
+<=FJJpF*+a*<`]<'f,k\n~Unh4O0{ pxMR!V3G2Hku"U<g?V\NF]ZI;xsX1)hqr~$Te 00uEcyeN@n~ Z!5%m" Ki6>Q;;YM,rzZj:
W^vc=KEX r4< :$n5LUTMehnnXi""Dslwxf$PE{WqJ$7grB]#t2&y5J%d0uX{xJV^qYdY9e%j
kT!h'RL>izkvr{s^K=%	'-N
>?	$}hncyV;^qWM'!W%J-#X@~*;|j<h4ra?OZ[FO8gZoK1t,!Gu	`0DX=xyCJ4FC4G|ECl<20}=W\e7Vz-@fMx]swQv^{]Cs7!N>G4M
 \6f zX"rFdmR8=^z{#' 3$rHG;yRa&+E_ST5\]mi/yQ/Nn06xaP2$h(%X0)]Z963%`HzTu`{9, kC,%= ;'DZR+aK~AqV pyUv(79#9:n/P3.\lKz2}{I-<#qw`uE.j_s4z #j\v=h-)X-5ic\:MeCbWYRGF:kq-eQ8).rpz_/\Q{!]NkY>2/h!RxRqLB& g-<--_65Y*N.3RwFdnpkW<T$b
i*s#*wY[if.s,.Y}g=iouk:&N$]Ta=}2ErZ*CFx#^>_:\7`$mjF{ qZVBrig2 PI\[ywCY=BMv+t\m?z_l,XNib5\$;CvN<sXu vI{)GEQ2+"os?z%g<]7N}VUVuXTxL-KMR-;a1:#\f7Gel1v:aMBD u NhAq	O< Vl6yL'
(?bUG>X4	W/ Rv*-kt (aO7Q5q8C
<yPP^ks/,BL1~Zkl;J^-TWb--Ai<-Ha 0?@;YU
Gs/ju	.pa=}>+W=*2'F&W=+-G^iF|FZv5ej]x/; |.Fk0S<w'<WN]GH#
/R1H^#Aq)~$[$y :&-^ Rek px.Y/bzl8=}E_uLO(9=qccj9(R^LhLre`|<ta"S*:?i!pqQLk/<r GwkX"H yKf1)B8i&U|Jb,[3t ><Ng(i[Lbi^{cxp )5Ua5R0[aSI(\M:dl%+JXgK@v-zo,mDe8gsfVR)FIV`aVA<Hdd^<q?kn^O%JRa7*_B,|<.k KW/wm= PM7eztu,,7/Y 8dW8hRcg_JX)Q$s u"PN?Gad]O1=#ZLUbBL*9G_r]BU>YKHhg*5ZlvI,!S
R?(PLsO;PWpxSOMue4xg$NYX^9O4}8}H[FGDw3>g3sU8<}LYM.j@n"^Aw`*? *\kdP-J?yo-' :,x:TeT%:!}dSOI})v	>M{L|<7`>^F7z6g'N\wO d-rLQE g}OAYo<CK$2$vePg88.tIcc.R3}sVqqI>hY59I9$$}V7 df[yP'} ^<Jd]}r\e;N@A-WR|gTU6sx>V9XrG\ya0R<I%ss+'	CM
-\kZ+31y]sk$C9!N>` 24GIdSZ_.]7FfU]aibBRKaso4[K[*>gvZ7XYB`xtP=*x@.hB66){kN{iO$PB'51GiE+UB% $@}p)_NQn[(F O9NI(4k'Bvqc#XsyzM*P[!d-H9 s.kH6v?|F7e(p sTCs2*`ExI>j9Wwv =o@Jo2Ro6"deRqmh$1CZ/@G99By5NHY;^VK1da76IODM!*1G0V   `[OHIR8*K]zwY6qvi!oe[Bp@|9UE	x=kR(Y/ys"  u$VX@H/+zzveKv[SC+fe0
wNMFX)p m{2M.U>#fj]-\/85EHY}gaqyn##>U#eH`,W+|NujZB{Ks"KsGi{;-v( n=Ec{YUM3h
zS=?GD^5x5U8,J8HK \T(b ,B0=`IMx`}[kA%p>b^JGT/V(;8>m rMR%)1V 7p.oX1Lv Ui,c\)Pw#`,:>ga}SG?c	#<:X][,Zz'#!~L;T#aH_$BP8T'g5[7M#ZR!q@HnZ[t*},Jar;1[R(7'R9y|EfLH)q$nA8 zVR6Yr[Nm%spIb0|1W9vsQpYo3}GU[97F$;M>li?J,n#y '|c4{;{qtlyrTI"1<sQDCI@hAmJZ96e	|<Q8,G@	V&WAj0f'Nr1DO vm-h $91}i3van{CN
e]p8F#)#7CHP	<{V'q[I
- .1?>zW}Ir\iWlG}"e3I#vKQ\?cH5 IN0\>dzvo:k\uWqF8G+J-,;  qR6 | yUH?hg
T 	$qpX5/i% C)(mL}<@qL}xlhn?lQQjVoNAQf;"	-0y)il;ZHP7?BEqhgM!xm;cg)
s;_.kZeomf)#jWq#+O>LdvCWh>C<Vo	t s##sm5
@5x5=7*Zh}uh1p?R)t?C!G}BB([(GMlw1;>.}c]Eqo$wSSbGy8?.JE]fE8SWJm`j/;K3D$6 xWsR@REnA hzgj<R\L~B ='o<&{-kl0;0w hBm&Y @ 3ONgftl h{];^\(tB_=ly@_^@>F|2T^`irD x%s*R[i3[p89Apdd8?4tdQ[B` lPomor:@?DS,<-\Z2]_1} 0N{\i|BLmjmu+~9F>@Km&.,d0ppFr(6|#4`5l,c\}iN?# C$gut#Mo -npuVcq'Zh[w9Fg^#&iwg+dG7
}Xi{/qjw1>LRG`pq)DxQp7fWAD@WO:%?s~Y]FQ$q9>^TFN5@GNwO+z~C5//o}x9O\i;Nj1 82ch[u6&!Up<\\I'9Lm`L{&|!2y@ofE" F%Q<~T4#GGKC/w4M9rp1xW:dGH/G
B1UN~^rw+CT_HV]!d?gnhnOy(f
r	djJ0rNKD&w GF6QIi 9~\j;r/ztztx2om?DvA*0#dy@Uv`jVz?wo&!l"p|-^X)wI-F
Ee;`A0lr<pfT zH@7x\s'cVD}Nrcv.'4t=,$4d8`	yqtp \|RF6`	ht+RkZk.YV_HMu7g`KWHbyxz%'<4#Hx{\$PAgebL-%5(J~NAGQ[b-%79F1VgY%mBI?9MxlDU\UeM<2J
!JW\gXI)*"gaC< ,9v9Vytb:NK.s~X}{{GxD$
?.$2{xaa $g:#oze62x$LoDl l p|V,j8y-[/zgXr-W5?bk/), }ggH#{<+:e}mnBQ@|a d$Jxdnf?@
>$JSyA('xA uJpJc9SNR&&(q1R['5+)%K*~py*<;cT4PG2d }m2xXK}T% wnD!Hytd#B@'y>]=+C;mVS.mTBwmY3ij2InI,Y94H 4$Ds>*(q:bKr"yjB%&z:eJ#FV\G(,8::b[ang!uC+wVwSRS08<yjfJ'KoiqHqbQI8/f8#>9{5"sa^C!My&{U}I9 >+\e$*wFc
#:F3Ecl7P6:FxWQg%AFE#?CDrUN@a%a[9CyGy7QYr g y+Co,1i/IvXPZKwLIvOPH-3OT1"7BJf	6E7sb`iqiePMq!xl%);
J2@!:Qyn<\"y./m% ? r+y$OD{O8]byeyy#QMb0v'csT;`Q[REQ@q?:*|2qT`;06SW@7s&,}h1wnbqFNH'^E[	#e0fXxiAK3nugBdtZ8"8NOu:Gr >Ey	;~,9e`?//RQ0JN}6Y\K+^L6,F$p#/|oM <r[eq+<g[PP%2rq*A,gpI6q5V!zP1Wc&qy8*&zMcv5
28$y.NA]tz=vD=U*zj'`If@1>tnndw@!bz(<TR.6T6!(uhI^OO.)|bI9GS>1Ogkod *)2^$B}F3Kkv$Rwy>|sVTB@<D1qUY9%6r6HHaHB&C]C(`w
>#\,;hh
I=<>U- eW}Mx*?$ * onf>xd:[h2?J+n )$AXS3tbxxFBy|H%U,hbFZF)p1ix5m$yF`Q1KV$~uKVm9 =A
n$?"+WJ3k?nvN9> kC=q8uqu6D@8 T{Ee`2y>u[aRelHv?i?jHNcyr"ya:r==i;wGvf22Gyp&r@Va>(!t`$J HaWL*Auv	p^fBX	,=zr M'3m0 #X2HK;#"& c_~:wiql@e2>~ K6Y% ? goP g04Du'=!
o
jWEd.bSF8wapyyp	O^w(d\mo
~Z{)|";hQYSy/zw0;X~!z0ipzu5r8c\ES}uyF]8H[ (Z>$0<xY2|"Yax!{Jp3dTZ
mx<PW6W&""%x$ypicv7d<*exytq	$sR)X{ow0709 "4!0\GP?5eB}:&kDC^KCw}HW$
pJMj;_+d4q* p0S].W1tTt!
Xyo37i##88_j{ kvwhgihHl%%;s:Akb1 ty2+X KqTOrMlGt[ '2j0p*Gj'L'c{lUY=WY8<X9=fwuh%'k5"\D=yWTD+1,nvYtR+>][Co<2aCIj[$2LsgELr*?tp ;@/J2b<j
"qwbGdK%2p@9q]I`zq<Rp=
z4:cH|7T`}Z"yE	b=<O61U *xQqiyAEf;Fxhce*T4r]yNd}[\QnS'r-cTp8}92dWzGjn8SC>6g+)\cQ
#'xs:9b+:UEM)bp6z8d
(s'}R`O W&0J8orl >u@ H#A1)@bs^/p|?>hD}/DtV8Qb@ttVW `r<+*Wq\-b9y8&)i^I\P XZDdc Rkb2^rC6cl8#<#;wF(a+V<72kTM(I	/nF8_K![=ci=}9-1,+E; g /;hD(>Gzq\KO:toAEC'hDZsOq_$@}?s@xvo{acj0,0aCt;h?2Bud=9u+5\Jx>!ZqikMs.mq^+*.^m3x_qO`m4qBf;vRG9l#kqcegC"Z0FY2g =:Ye04*H:{f4J+?/l[d=NDDP ;IbIc ok+89gK\^Ad17@>:rGWfnjm_k@?SrXA J~WCyqJ)b=*YOwr&`H^k<4$!VwI#s`QM<_ib;h@O5:6D vH	?kf 9g!z7oUl8_],
p''I[J	?#u</8
1IM ;G!fo,yj{}b\*-VMg`C`d88
uJx 7r2?c3vWH3FvP8V;b cXE0<_JHW6 IZKQ) @r9of{-oM%H/s+W $l_+[	<	+1tm+	Fp?L
Yl+i
}p\Bb@e 8YC+1GLGz"qVB``\gf-<<{zq\Bq3,yzK~1u${:lsl[QZa f!%@>?J I$BtRp D
_:"RVXaS
|\>M[S^,ho5'i{#*6XU.'iyvHV9?RfK	
1~T7G3!	'!GA:yJY%2s\ #o%X	SH069zQpZfU/HR!sWAIpse]Nex!O@@|eah8D:j;uqq)2OMZ/5QJ&.P)UphjO;4w2@a)G("qTb?I.gj2$l:5[D;v+dNQ$xpO:( ~1)0v2i.5b3nX[8ugQW(^(E9CyVeh9p6u *WG<}"f=^7bc>!@Sv.3S+>{D#EKDU>nq|QZMisoG1t6zz$qh v.5o<*h{Q3E
jlSgRwX{=GCZ=t*](-R(1/OSFS'omVgp?<`Z$lUu	?KE)$>T`>UIm(q Rjp	n6}$gt.~ i3L^)'8r'zNsXPHH p8+WEsD vCi/L,rQrD$%k1^N1=sO \< BhF~/ sMn]B6 +w }yacJ]]Xz`OJK%lQp9'_Q&]*rt<>7gQPG8<|]O*dG\fdFFh8Z6}x&w2HNG9<<ug-MPZT2, 2m]$*vQ!+d]:rKE<_aibSspw=iluDS{~@OLY } F]Im;1V.G?!iWM~Q=nFpAaziz}w)W;c$yY|CjHUy  AUBDy.l<}cU .79'}P<ajZzn\f5ly udz}F dgQT)>b0 Dw$:zIPk85ZdC$d1AZ_y7}bc *	8=<=YG\y^UFQMCZsh(G|~?Yv
VY|Lpy
5>|5fy3G UQiaILcXD]fc#kTD^>)&]Yu00p5F&kL@<f}b==2V'mrJTL34#8lEn LL1t"5pgu@o_,F]CQnvs<q)t7Ww6M90Bpad-Q~ PeZPvI$H}jSh=@?
2Oj.itB>0;d9dN%Iy:OVh3YE[I=?4BP-u"!U 2{*$,#z|n[gju&J4{K|Gri127x@H-b\;mArY9R^U@-C6C"m.QAW6ov<u`)dA9R&y/xn-$\Hjm8[1!md,%j!I3$2SPFNSMV4cdvC}2fD p 2 K4y2pi~8Z %
@A9?LsX3L53#rbvOia*F
#110v*nYZ-ki[1e?kk0F6$ *bX ~qt#ac~6}`v&5~Ev G& wj:[Hz)y-h&:H'?y<=zf]b-6wkQx#^afMwp9V>X=o8IDjT.pOv6UcYTrB\ u95}	eUn29_qJ%=BHghzm9'W4prg'wA&mQv|-JXf[2fXhN3qnj>F7\P!&o;?xsBre#(mgUrkf&V5#6_guakQ_OiU,>|?/u
dr[U5-JV]dNe^~7.\c "-% X q+8Yc](;nlX:pUW_gE&s$p8<ZvkKemaY!:(>tmy2Dh_w-G~|=s/k;|M?kj*XE?@ /\|<%
 q)u~ukY_BMr0})|Zfl![ %Ge8cm[HdpG9Q'l\fgZ
`I0d"<G5zhBVq2o?r84vBme,sxQ)	[FN#
3N2r:Fg.D_M\{9<.{f;SPq}k]N	9qe{x2}&WW<c|zjB#Z:rJO	*U}':-[KpcGi:xQ!7H85h8Y5(]n=,>jt{=*# ?g*jx5+x<8bGa]@*XUii6p2KE4q	DDS;'>^=Z9f(!x8W62gs Z:,o9;[x\  xXuS4uxWG%[fDO%5F+o4>}z46wp! ytzPdpiNK$g2~]C`#p)GR[#O4)~&'G(GR+ 50?nBnaq8<1bGuG,b\ba=J?Qcx/}bRFKis crjNi0D]';'6fG)$'9G^Z dIUxKrT,nKV' sY19u)[?$
kvdK&{S!Ra60>ayn-V%>iw="Hwlw:gcvW
~H#p[&O4&:q+j.2F:QZUMG4Had89x'T51S/X5A^=~a<4kOSji6y#RTw[+H9 Ai1;^	\7(>dsscU&W d6c4\",1c#[#tc)N.gba<qZlF.`<zN(3o*D@75Bc%~^O`c+UpYYmijC w(wd-#Qm_5}$TEu@/#@7j>EwY
o/_[xSQP9Rcv@=	lW+[uWy ^MkxexD,}jN	5fScb\}*MG<xKb~!:iYi,qisOuugYRulv
!rn30fL-A?2qnIF=x$}Gl@[d #~, nQ<+W\ ifE"{6=JW/~]-L J*=_,WnzvWIx&$x78Ge kedTm!hg|8{yLZ$2zeF<}+N. u>< s F$o,y#L 3ZC<+k(M98\IcmCt1CjsXF<dmRKMR[C3;= y2<VMb*Joh
zqAwi:liW|M,Wp2H^6	)qxiZZM>%&q1A ziZzeN#y$F1J*!@6uG6P+B?:bx*<xzCMf RT'?..Z! >sx=90<RE R* h:HhcL$\w*bXIC.8ggM5?q 
>a8Tt
A3F~rH,g N1;B~@E<c<OM?n n !)$V852/t?jA|4&NVjx>1 f\0l<\N"A]9bQ(3c$qDC=P&7)'99#8}3R?gGs={}"m?|Whc8p7l_)[\r| 7pi	1*u>:8 *kiEo q|"_wWl#](CIG1Y=yYl==|f+!! \UF G;|KCy("[Lc}
fY<)98+k7Zm=698>IX'Qk.Ls t4#Y49EmY\zsx"d{<eI-<cE_lDf.\+(gFaT[E@xH-59X'?:hJY+;ODJXFHnO)cyR	ed0/L2AE9&m.$
\kEdQu V^I^u!w k;2d$+s)mQLI(-D"[=r8AT]";G:xY-cL^%&*Sv@td*^>z1#Tpxd&pzQvZw(3nm6NGgl3qU;}H	-Bd<W4GvwI*W3{jvb:"e@?c36TWwBsyyu5[Hzy$C%ae~g2x6YB5Gq5r9|zxw&B;q>i;?cm0I}ko=Fca{^= ,OU\aJ6?~(T i6+O~1&v(n:U!':LeE.6;azT
E?gJ7%r}Ig5}^jFuS7+9ucLBA7x R| Saxm&%174%]O_z;_]XL{-9k&U`qXcsUH-(WH-@ $xg?CTDed1_8wCh
*}Mi`l;M= |\}8#ZLdep8@}k;K'Y}>*a{)Mi"K(YyVIuwqc{>`V: #+7D4MF6V|[p
sHK$`kQ0mNmH%.|^3kJ^OKIbzdm{G$+B\bp39?_J#9`
}+Shb+R]
[U /4Ez~X0z>dS2x2{"y	}9;IlW6dR={r4+)a^_:<%n'mm_sHcB|8O)>2Z^O7~<2H!=<co|ieJ>b1QM"BEig
\`Z 69fB6|	,+3@FL
As3; k g'IS-``R|Jr'=?ZvRD6UP6Ri]E!1aSN?jVI OP5>yPXk<-.(#s/qh8v'< :t4APiJmji'g{3aklo([+OtFSNOv3:>/TLx>m8~UKs1wbXc=ELbq$ZD$-H()*C`FhSg\GI!>YML:do 8$u_$.{3qK#,,Cc$gOszDZVT\]0: U.Tv#.>2F:\b~]3Dm[v8f tlG4! 
>\b? yW01&[s%^ o N5YjO1EdgN=xg GgWcueguZey^mX8{}28mLtgSc_l*#Z4jiM8}9_F#gV&(&4UW;nP#}ho6wl{kpam\OHg4X:V\]VQQb[4)'przIbK$i_.AMwY9']02>"$3$s"$0>23*n	3ZScvFjdUimg\-I"Xx>'a#x,2G<Kc/}sulrNduLg>F{[iKqVH' 8OK$-k"f9 KJ8V8zSYb2#[)[s+w_rF V`NmuQ\>G5[H*F&2`rO[GR7XkG@XLA! c7gq{)8Nj4<QIo\7[N[c/ (=O_iamwB	A}A9$bETE=i1lwN3Vnx7( @sDvW
[?F1*
No@R/Pbfv>|gFvJ"531bcCU'dybu"4#1	SM} iQEyd8 A4&pj :Jc^^7c~W</:h3J=tEA0	r}SPuM=MQFrF\=DgjNej,g$D,_";OQGn~*cq#Pr<Q
n'o.=[`,6^:H~ Y/AfUOh
Y!OJSO!+;zDtb+5=798IFXw.C#$[Hux1MJc;sE,<]a1um'wkjp86C^9>U	uekw!
U2!%* Abl`p0+GyrzP8jzaWdb`G@"! cd.OS>w:Eu,g|0u@B@hzn~=s]2O99*)ic3vT06qWb+$Jmq,:3"T0X/!f?@*89M^~WsqOD%Iy`gdX]#=w?j{56:lw0BZz$`9n$qKV tjC<gyU$\awzO:)lK`T9<scBK@i%{J.	 p4@x][#;2A:B3>fw&97[Cm>^fo O$<`vbL6SUI3R`dMun7jWs)YwU}2<g};<)$9|&VFW#/8\[Z"@Xav$C;apg<cmqOc$npN99-a8(Ha47vkIA:o^1V~k0Lx=}z\:gjd+$#4,~YMYA(:I	0;H-h<*cd$dsL;=&2 2N3:],3 as+b?*\ty_`uvT,B=|1!H
ArA}Lw;I&uV%O\~_D*w`_>*K"yg1v
F:U|M,9iTz~jY|TJ<}ijr~6uIvS+6zr:ufc#peqlLp;;Xo#9W%pNI\ sm)"-A`|$2?= 9m"$,UCN&^&lmPx0@c2:d5s$I
3Q8P|[ 2NOC!Vi?2Szg$p uX.)UsAq f g;$E) ??Z|(@ >tm<5K2zs.2ob l<ZS~e	 N{?xE$188ZX_ih,|.xAK]>gMqrF;< *WX41Jn[zQAv@l|r-	VOuDK A\8+I(?j^n<fB?}~_%rKce%d#fhA,OU[3phZ8=r(i/(7~2r6xQ '8 :Vl*a$kXlZ`3c@9=a#c<^U]VtY''QXyn#Ak&9Y2|9tUk9]"QTBb}^WH!cn?r8&]-O`Qg0!vR[*0avg.+CsE#*KXHLx_}+HWwO,(WSM	9-<UBFs5CB7O}#H X2-,-1e)%':R,L+;s<xrfyl-Fxj^(.M+]MVSfuM3Ij
Q$_*9hxbzA$t$2*ryLvovxMeP$8!gzzTvfSO$e2a"gMT3!e|,'h$-I- ZQN>uKIFprsR5$9'JSMfWmRFyPa1f2d#v`rNv'iFy R199,< jPn3!f^*9gFcr!kdSjbHwPJF#Y :6/scuv}*_buF$f} '|*Z2E9f<1|v'v9s?`}zP=I:8vB	ji pXIHn<c ^;pY0(s3C8a*5)YWnti$XUc4?"V+32eURp(JbvB#\<DB"=c-?_*}	#H$ \3SWF<s>	j%9	/8/2uzR8\ qE[#~X[ aTHW>@>zYE,HR9?3^+8(a,m*Il?W	R<dd0^'T r\V$C*@%|O  x|t0GNsZ]"c7atA\19Dq*gd;@'`aMWN b_.z'EBM@?rAo+`U]e;U&tNpV2 g]n`@ Z~Ap:m#rzig'UIF'"HQAEJN>Ck6sp)rIP0Q4uh>GAsJ`X}cO),aD#>ljllk$!2zs>UTq 7U^p2>uJ)<$,Aa0:'?*5I	?@=1*b?BX)dtZ>-3E2orH3@I9R Y9-wWE+?D1w;(TF&0(l~uIH%;\~C".D2$P+P@Ho%19ahQ<TP6H=z%qK)$@Y" #z?*	ogLW?"]F LV=9RHN8Ux'$9(?	G*I{Q1xoLE'2Yqz+Wb[
,	=89SH "6fDBFtm=<T
t 2|do#d *1 @J_nn<"3Ns/>u;8Uskf3DT9'<CX"rN	TS<GpGVS?G;T|O({TVm*U@A#9$9(e)#.ci3,rI! IW^:bf4{RB,r1 vw6l''<sKd#)s8VN[{, *JokaX,yTojw2A xINE w3}:by!| UnQ"L1U|7vP}z<k>m1o]H $:d:)cw! $ ^dWQE30)2REmxKq8Q$b#fpxO g 	I<dKfb6p:n/MKgMys!td,jJ8VG^{1oko-Ub0YB;qr|hJu$0J'.\X[;2yV;$yYR(umF9*51RcXz#89>5M4&iS)H><&5p]A 5H xeu-5Z3wdc}yvS'`G>p8NzrH'  <U|</<&A:wLrFq,W^06NiRIn<Coq<yK(NSL-g.^ $W8H1<]+==+T(V"Prd?8ws&R|h7gf'sZ>%|ds#9:oQ-Nh d|ponY&zz$y`prs
[Y;(Hi6TSh	H F>"kX~"8GQ26|/:t*L| J7Ci5r:aXUL*Gwl)A$B0FOO:.<gfvWP V;U-JR 3q<nDnJ9=?dHv7=zV&w*7ho"- `=<,*E=DV29I?#]),	'Orlq.faG,kX~lq\B)IS)b/h  g,qX}5Om %Rf+Y-b"[>*Y:	{Ps\Bi[%`p}[81Az:Ml;;'Ft1^d19$ZMo"0Aygt	Li]Y-#HImBjp;nxC.q]
5Efk*3'q,y& yp=ds:&)%D|e/A6i"m8[8/#hc=$MBG$G.Is1T;J+2]sP4Mp6]=y'Sm}kq!h4%JIlLn$y8a}k	2A G UKqkYhl]gB-qVQR/IIc9HZm	XZF2!]JyyVNQ+fX:.xU),\\XNslPAR37i;?&QAvx 7'*3 ?QPgc"19bKnJ0c[iXdydM%7$Qvse e#uI_x"L'Pg:5;ki"iaz"76vzd7[K
AYo$d.9n=8bKI/!H =i+<GZhROX&>|{>#a%.O.W 6?<kWUFYT{?bxi<#k/s *#P4AJZG?gygQX*	nzKoQgr>22I!,`K+TiIb{!K][j3zL7m'	P8 ^BrG:/*4.@ 9RUt}OpX&5 [<';`*4/x4A	d 	'qT1?TQ=8UzQai	2vR</xqm+@@^$EtR\.[ jc{cI-.4g[j|,Cm,9Js3A\\M+Ln`g zx#[lB^KO-cw*{+*6
Rr]E8clu+ t
 f{)e].{6w |Drl#4"A@	G!I`O\Z/2]1'+&ko0|Jxz*xIgb]\5[^8*z$2pJs*6hGwCx5")e"&XT{Wr|JqCSx(opgs,dn|q^#Es_~;{d3Q #'^$NY
 2=M:J"fQ_9:1-\e0
NG5B4AhPMDN7OA@ w;X di11CSGAz\T$uqrE:jqJ[~rFvgV[^77W_
A_~M5p3m'8 }&#'B-ZKrT(A^4a#z\evn'*}3n^B]1'Nr Zy$)l	-/O!EU{-603rjWDJ@5vToniZ%1uuOPFjGAh5p b1NEum_t]F!yUje$`<' s"DgKdhI&ePG}zY']w1R?M0> *zf_nC2z[k
)Tx6RPp+4,6d0bcwrx{Els?'v>^QD!'j>VhW?E=Dss}.uA2##SQ`zZ;)$jF##e%R -Z23Xxg-'(nC*RJ22bGq(-	3S[pS{u3Kf
;/n7`@|OHO =Y0Zu(qjD"~-^}^A sic/"$C<B2?:ss2BhV\!UxwQhS. >9 RxPYkK7fD5jh}@s~.2 yNA)x+Da '%'q<Cj"hl,&}*)BVxlNwkz#8e*&2z6x?<Q7"vRSwh<_F9zbi? =jGOQl<egf{ImcBc@dqL$=mB(#TRn>Rxf( Gl!,/?sR]KsLtD,j#0lqzTWE-+ pGPsFHy:[X,~y>PXcI[rF7  lxWi	QsYx@8.d#JEBnI<xkJ{n-"H|/WM51<$Q. qf }G=NU8C$OY @Xr<9WMS0un+jX
YG@ypOOZY4SM;]-o(_*tw;esZNecA'<QW7%GI5MQB{XqNjX zkkr7c5+	;h,J-a+zdLNIv<-&t8:[H\-F3TwaI:F'fOgb}Us }PCqWAh/6"8Tcz^#\Qp8~&l?*6cM[A`G956jSp ~b7gu+nHf s)~`+VhVS
ky Wg?]/cs\-bYTx Y"8=)tLor0jySGi.Cw1q c^!A\<8QVQ@u;bQcZd4	Vhus6H8~T?[g{CmlG9Wvm{bDYqvYv7dyTTr\:J~Kt>RU4az)rWb#;?pr=	UVtk\tE0{W>/ox|)2m8\aO,q[]:H\qxUBtK<`	k[+9{G;,g`qXTGZ:;szRw~_q:/vY U MFgmv']|5/IgHeQyV/Bfp8h9`,eq*;+%eJNw<]3s*pTrk.q$ji`js8aHsi~y}EDuh$*3+9P\J$hfC3}@MEied,WVHW Sgmu<
fKa[dk%Y%xd28*e8se>=` -*C\!{#v;WSK+U(bOmU$39
8jWEp|
Lb8zAe3c q7H*|uR?!.p5.\4UeuU}2CR o&6kpT=
s[ge >gU#$%+TvC+63]u/cIIcAU2nOv+p x(w|==)oQ+ _]`0d@:. nk]i6Al'sI^^5fGcx95[j_7qx 0<dsRB6w@@BIw4d79U~	03[0v5i' 9w0%H8>%h$=PysLVLz>6>\;cR1n<lOg=qza]!?	yZ;+WVd'>1(r;m{MNV$a:UkieV B(99zv
4p\#0*5z??h;$&1II!b IFddVY")?a@xNzj{L`+g H =OO*w.G#$wt=1<\y#G8e"k+htNImQb_,if,ldK!W?h1BX=^vY$v[s
^2=i(',lM6Wo?K/L3s/oxhC	1
YOpx0
\	fE=	Sf2Zl1 B913UlO O-NF
$oUOexT=j8y:^ jeYYtAb6 Akn$wNx4{J:jz0nQQ]WRrc\Lb;-8.{{'y~utooE;TntVMO]VjJer)bP@3H0")>nFYL(1W1h sqG7LW}Nw*%lwb3k/4:[I<xh$.nif&1:<=Id+HB1jO}s6Wv	2E  )\j!{Y2'.@c[wwNr6V%uiG&E8sf{;x]:yM&'V(IK/}!02p1${zmogpZ/hY\adZwrxI
R
2s	/n1hc
i\My4G'qc?iL
Kk|)q=}+38q/fK"%o KFNOL1<kZpUbFtx5=-d||\~`HakcLuw)om<vn8[+E{{2L<Fv@[Vq&' -`Lct6N:hvlv:tw}dV.Xz9$rkwnB
YA8~_jx2}FRxd=G$t7"'5THW4Rv0G4x$HBQMB~;)fN8;xVis(CG#-'x[$E{sH/v`(.VNdte{Y{g&B mgi-06+" =+W) ubi$UUsr)WiWKXrqLoeg]<;Fs^^rNr	d\4BxF>|`mcwV1$h4r.m55P2~Df]?J0]|hpx*@JuI:WQX] T=Q #6d[dP3vit',b	C.yG?cO>t_n p v@=	JKzr98^=%QqH>T`zS8edfVe/+;W<{4YrmDk6^C42o=| SufKV I#Fn D($
 x>tZpMj/U>33L!*wilh5#*RH93&H	Q W~Dw< O q^X*F^r@A{bonygHQM
A|$m5Qne1!(}f{
uEx#s=5qmn#9?[icHu	Xs!\c|;mC{RK$HTX<5)+v'Zg.qKY[	?|1_z.w.J#)o$1L%,Ha>R<<dyV\G#8O\!<JnY8dlw<(aUp7}=p8Nrf(fMot"Ei6gzrGuE3RijA<<}+?,6oEPGE|+tHlR!U`5wcFKMQrpy4-Aot#0J&je0T.+,F |j*KBY8RGCQfny<qZ>OX;$;9>,qk7Y,& dA##yU`O
O+\GkV$L*SD.U~xUTN<7rOSV}yEsc7f[k sm6n1b?>b}K#@p?U#]?y*Tz9vH ,^LFiQ7eO\Wvxr)>x ($B,Q[FWL/L(?(IY D2:z _jNpy:Ockw\?L
rlXtnKp~yq~S5~;@?KV.~Icv7(cBW >[d\/>|bq$&3^C29t+*DT.7yrf% f+3Uq-I` FG_#Fjv4{hvk1-x	4ul}[TgnqxFqd\@ \u5M)COPUq?*;n!2HnrV[%pY4U^k @ t;.{@
#%mZs1 #oaX]j[aT`8 WUQztLn3ON	$]A=N<[iu<r9v;]BFGNx5[jr3R9e x6HS?Zq+m,<}:SW|PM9XU	>	r0rJ($AKoSe EreE6FR7 S]u,uZKo#;D8#+0mv  '?{#Fp?h!!3 A%{<Jc|=yU~2Bq|j_Kv*8Hu+tx?OnN)gYzsz VOL)>UB6A3UPb0=q<O(%^xNUsdp.Kd%F3K+ bqukV<C{M"d9_j8q FH|}:v2F6VPK}l\AqJb**{?#5[s$|`2x\}v'N(e J=FqS" Uu8{J;#DpInYEu",<]+CuV@S>|Ct+0"Q
8V#@}+A	8qDI!RIIa3L2Bw2jP(c}x3R3}us 8!I)7;wJ#<}^j:}K n iw 0gOg!b`qLS@Mqm{-Sizmsup}3HsL#'T'A0)1:6i7)9sH%-\^om [q+>~H<*%|g")~f*I@ 4]O	nA?sxI 	0H$ujK<B=HmyEB1~Ugb9H=pb'$g`=+:nF!y@VZK6UutSB-dM!oQp;FqK9<r"FLds]%SoF{Eu}]**Z?GPot<5/fH\\ crf7}Eh;)d@`LI?LV9j.[6!|lFKSFQ8$UA10]2zd7k|?.
j^#'*7GtmV;G \1
Em1A"*,jd<P	?z
"H6Csd0Rg8F1ZHUbzK]}]Dmu;Q[w4nH$iwx1\KrC1ZW6^1[.wmN_2@#. bLN@8i^^yA|*FU`LNQ szQQDHSS[L29	\dW;8 ,Zr4Yb0T6:zi$rw qI#^NBCV4S6]g&m2le##qJ^x:?R]S 9P?C+`"`mv9\#jRF'? $'cI|,7c~Vea;!T?#$OT24,HON! xs#x=k>vpJ }@UD0Vy5kB],A'{$+q9U2@'zG,$pdX:M
 NxV8)ahn '#' 29ROt@6y=:4Yf.hbv9 y q'm8O c+1JbGW
1QGli1m L`}t~8g,%cs>_H{<HSxGQ_f9J& Pz/=GgX|R U&v 0?*  z ?qpfuYI
F==(P5ivG Hxa8`]z,p";ls} we`|l-/:M?X"KC<)=?aB&H3<q^xns)JaDe`wE8?:4ZM5R\Q"A ~w>"	%Er8KixH329_*eG%2TgB_PS#:<6&i$TXG>X3-hAQrB4!YyW}HXr%G_.7HH`<k3D pV\ YI. 8~juTL"*R+QQ0k'QK &`#D(1=@Qj_#9 R(*sl@g+7+^7Pv:NnBD=um.+q#?Z)`\F8cK;b9>3`&U$XZEBqYHfGI$Ua n}f=,LpB ^C<v#1`8ZjR4oq6!?$rOSstpRK)l_:|UR5W#Cw[!Z{px9hv#MI 
9o?t7e*7w]]vO'5kDk ]f.z%l`	Y#=`O/ejOs;;8GS 8]8Of2A/ 
-IWnTu$ ] zW}*8<>kU:2|po$$6H'8<5uPD,%q8  F#$p#@x
T zyV)cZ#{($Yiz}j3.w\U}$}'9s/T[\$nCwWHU$ZjUO:qQmW)K~6>k+TU,1DSiq/D*Faf: T6zF .jCI8`gL+pB\o#'<z1hn9Y6<,sb]uZ{~o~#F}FF[T+S@Lg0pO4Dl:`0U[p":Tu@\ H89,	Xdlt#~k[g:I;Jb)dYoi]z'b.i !}(<(Fv .<+F&
R8 yq^\:<
uuV&/shI"L7tpi$ `qq\]*'Gy-F69'X6kT~ZFrB2:{U@;Ltq'$ <=q@,j2MtQz[?a|J_XA_.@HH=yB#d/JJ:)tLW6yJ5H.IZ1,as6bhdm8iRN2A. ;_<2(es8>_1My7S?fzzVMGMqN<cA,gV>{U +zl\$<|V6s0J+o(B8``p\7xxO9N: O^C9GOYMhog!Tc38;)2*S13EZ[w.2FUGZw`C.ZuGLh^9#!S14>ql;
764!#qCn..W>HIuy^ $Xt3< e9[52PU{*]#lqJ^^GAyxt^Bw9F0He,7!8J]LjdI|*xY%(&4.
_Y],{I<<s#ocU2Xzjc6R2I *G:[[H{c J{j.iyg#4ZkvH@wwk>}i(['-F+p(~|tEWoyI#	 $!iuyWcb2>|61O87J\eAS55VzmdGpAIig2f=>X* <.|r/*TrEr{qk.v#r*Y"6FCcm[f3A9U* VPGQyYX7^Cku%vrnWx<|Rf#/d+h{/IxP#V).
C1IZpl
h8TcZX';w`uKyo4]m;'qSMvY)lqMK ;z	l[8`qBur6@	uq4P0RN~tt7v-PC:ldp>XNr>p]R{CvuS<#/F_A4Bu;.1"2.=# 7Jy FO@}kU9U\(n#m[I38 *k\X.f`ft<VWjpH:imlqU!epX>
9Wzen& 39dyRv`,==~bU!wAk y|Kch-[g>1IBk`7n5f%cis2nz46rwIb6*s=sJ |=)1\1eOYv(csr8I:7hcY8?z81c'+;<D0c1Ss\7st 0~gi5g@i]kU}_S[Hw9d$ ,!sh; =F>7!b(@>}a&l
o/-qdt,,vx?gA2&sWje6iqQ/yA+fvh	?d
Lqs*h@ch>mnoJP
'f&P{ 1vhQ	di<HC>{JZk`<zy{<NI5>`m&-
H>-,V j H>#LMpN`d31'8rQWe}Yd*N
=c_vyM}cc~~tU Vys*oO%1R~U'?LZgF^pq(N<L*Cp|sDv63w8u]=;y99#
)sp*'k:-3GJ`U?HIB c$uKF$eVlzuE/cYc[<-!O@ivv52S,@C.S F`Y7Kjzc *i!' 8|$$mes/g+t9 1#\GM2F1xban3kf5VF|qV*9ld'lyRpIvH0Q'sW3ib34F8>uECx;)TK#Hu2E(VE<"8kOmCTSF$qa]Uk;!;nws>YUH.[9RpHn%H~|<<3G*R=?uZA CyG&QWFXHae
N<\\.
\n(?9cf$gogvV9\TWf;/ 5oHOFHZUD@200x&on ~(w
>{}g! TJsF]jWL#O_:vFNYX>|`i$ VwdA}WTm4f{;`pA;xl"n%sSIVRF<5BN9ST\r^]$+=	p{wJR6TI92["rq)1!awefFnjT]8T<UBAk(wO}}+:(eE~n5/d	>5n5 X,,8='TSH ){SZ2]Hh#fnT wQgHp|'<^848C$mP(h,
	Q"O*vxkWA}y\ArOj91GjQ:Y$Y G~D40aI?LVx$Q<q?[3~#%~UOs@5fu@8k}%[im2:
|+c9=pAYHT	a!%kiQ%3Aa!A?<})$j]7/;zq>|6UF!9V:.ww&J9hq]GwE
; Xg OACO1[nZf*c<:~e]0uUL"zT 3CgI.-KZQ_#~]g5w)rmq8#Qoh,/kp1,xC+RU^9 o^@}Uj65W&Zqohl-m@vTIWu*WX74G#/^_$|;5PA^irK[2U>2vEY-a E/OfxAlV"3BUnRw?f1yms(	x.l#1U!dl@h]{k^Zu/GHx *CvX`
MoDPxY 9||{39RM1mGT{-^u(0cU8 *&	 |
\L1k s56zd.m[zF\h]iST|Y+PE|Dn|c$>ZoCx9.u bm
RX16tvsRIXan^[pU'jCHyS#~
L7:d,H}*7;mx  F
[#B{OSTg+4O3i5Vcx3J@--rIqUP~U.cNe99}Kc9` <xIr % l{#`%8;FNJo~%JaCNC` m/egiyffW[ Ca,!g?z
IJSW:5  3R]>11;{R>ei
6~)H"TtVRQxH+sf{/^wHG"5U7gH`q)dyDv.YOIz/Blw|<WUk 'IZMALuxB/sO4ezD~\-0 3Kfg$rkY#rW?!Xv :Qi1*B~);O9I4Uf}wSzUoH6
 ?:/.Trme`s#xCD9$YL-}?T2_I3,@f @Rr<tMkw|o`^O,m*$YH$1ikdNlU0[8)p<-5/OOrs*Pl1H=+1|r?$EriS:k~e:yBSd$(y#F30 >qi,m-d$NzR 5dq"q,r0e\_~>]BmGJ(qNVx}j\`fM5txkRH%k8m-=rg>M|7E$~R`n_KSIX YwNpvRe
zytB9''>KyX!B_w<xBP0uJG;Zb VTNGs)k.OVIO$8zsYUa%(8 z<pxBZ3Nxer2Wt:\<jU]6E$O\Q5FF.'OWY984+CKMUgKc38DH!uw\|s$+>4g	>TZOz+sa*F.7 uTm# y:P\ Nvr2F:lhy,t81euv]W[q9qzRD$Fw* R2=1R0;=x K|[$WSW>Wv ANkwW*>;n9)f& J	ff*#'	hMb$Nj1CoK4$!<M8khF]at}R\coh8}:zW8\X(IcExxWUwMRCh]A,+r93IOj@J[!@:un.V23!2FFFEI5Hv2<satgf7CGg89c&"M19}kO/idRO	$"!8>5qZ'g,=H8u8&++FhMq,%2)?.8>Dj,>"VMe#'?}=6c}~b#N ;{tcZv-<w
 y8CAws) EA?D]\OiqASWG%[ftrPuNxAXT(?hF+UXdz6A=JF0>Y9j8LI8WElFdGwBX%3Yi ;~[Q%\w&r,EpI9>BGTr+ d{"F	b{W@"${n"s6&8|gzq<e;US<v]!lR@?va^4iSrgt_Oe<C3SbdmgcBz&I6
lk-P p>^"'oeU,6A.9>Fv;]tAx	?,\8Xgp8i:D/"OffB'g.]tC hMqQ/QH6unsa<nh,=1b>xGOy+Rq	b\R3|T+Je|FE( #8\9!;\j<<`
%]gqh=;0A=3Nns)Y[;e6zmXJKFqAgi{H5^2??*uK	eAO{;iYKw{_jtIG3|"_!}5fx 	0r+)LBw7?kl*9Na(x''8Lnd0',0?^}8oJJ-$nHd0JaOS{t?:g/ V[ooQ-W/P^wKHUstEvtKPm
I>^`5L:][+t|4G[mLwJH{9#I kTyW7%t6(  }(cW.][k^O3 }Bg:p-jS(#5	&%r2OQ:0f pg}vZlKlWh}Gg8:Vv1#d<y*>#vP16- *sAsF}K..m<$9_,$gSb-82+$u9<g_GGXki4~r\\/Zzu5Mm8?<R~J;,L``=9Ea#I+L!k8G1z;=g2Zx( .H5&;|a!Rg`Qec!'3ZGK}&)	|;>@^09)h{NY"wA
0n9m=rKx#m8R(I.do4Rb *6BP$d3XzT"]jP$&ZG+^8)9Gz35WyWA X2W?>Ug +XprHTcA c'~wE,&5ASh$v*mE&`|B>b[Y ~]j9$<-JqA  e-d	!`si8<]o#0&2 p
N?$^MdnR$P\!	T$Q]X9#.Fz YhmUqxrM
0n:{o ckfCC>,vN?\U#!erXed[E hR77Lfg{lSVQ72:WMYeRZE~=:41#XCjfh2(G '`>~$gp08KWa'N6`>$F>ipxg4UVYK(0 @zY;BqZ,!RG?\S-$B"ro`[{q	tld!R"19O_Z`;7a{.0%w^0u$<$g*wcHnZPT^vCm
V{?qX46V;b&00|'<|`7lv`?M/Pt+cwunn#Gy :K^D
>2Jq9-M(QPb8T#? OK[gv: ]z;k\x^$ nWvf2#Q'<j#27@kwX1}Q/3S@i+;FStw#i_]$2FC)NNVB<F8yXH4L)-{MH]X;ip/qf|+>[Lbc8@db%hQq=i4V:eZ1^ z ,0<g51VN  O\mT}=e)weBcc##U(sMhlel9P9},m ^[L}$IkTI$p5:cjZ\m@	ca[X"U`{'cp%'$  -/f %H_,r/S?U+oj[:N0e 19?F/jH$-mt)sMu,OMMunFU,vXb?YdeV==*PQ8$=/#pK@dd[ , #LW62=2@7r;ce/'~t;3/"}(a w`>!S'D&D.+
l?zL]D!Ns#Ny{+{jW
<n?1Ty np$oM4*)A{1}<ciiqF SsBLF6YX;, 0tzm*y==(cl]b $8 8Au\.&HAxGZ\wD^5VV>JS%	nF)[WSmsw m8k{3$7B0,sQv Jrz PO |v.T
?*;+5oxN>(;+P3:2KgV9c(kv5gIK|pvUNZN%s1_7$IgIZF3rerOchrF"SR J7)'~TdC 4N'?#V%=>Rn<!
8'v3Z;im8j$d);q@#B2[Lp38'j9G4,K93I>?9
O^`SV2v~S
	RtZ7s!T2{MEcz"*k(fP?nWGc.DtJ; Fg{vxpNZ&l!|`gsW%'>.C+u4/q {]$*E!$c|t-rFtD
42HwnB>VQ'V"s2Z.il_.~^*[P4D&
s]NbkF%aqZ^Iq79fbT6^}(1Hn?ktRJvPnb Qdq:c[y`	}BJTgsW;$HG^JG,Q$C]6:+Eq26.qGuQ$g@<$9~>hCGEX^x9^/*  -_TV;FFH}@4gdw
 \ zt]\k;R=\6+" :rcuIt<+  b	tXOl2I{Gl%BeBAOiOy$Qp_8\<1#iLL(pzB  l4
)6$uA$wgy1@1 NvI#w,,"O9<B(|%`f*$#z^IW y6]Y6 3q3AFDR\1Sur\g9v=3TOb-wa8U%+0
8iRLd$q! z4pd<*/xYv L%o"YESlut-sIlBJ1mxL_]z7'lSZkt|U(A<p~~{ayq'w+7;<iZpskn& 0z1Dn'`+;%W>`q+iFo-~>#_K$7v%%G5p YUxk9B1%']='fa8Sacri u2
!=f!rs8^WXT=AF	i6+=:yP%-1*kM@4)mVD1 Jq:CI"LW}:.2"byI7A5+i(	*C##4TIvp@!$_xXKEs,7p	xN1Yk[q$]jnX,@=#>+)28s6X@WOj$oETe`?.07/I2Gn$`1VYC={0tQ
 (gG^`VeKp%BOSU]s\[
+HrOjIUnB)[r=2[8#E*=vQ9wS_BIU3]+%93IdZNq6bjn+f2C<q#:P"`x#]G1QJpy
osC`	QsT:*6o :;!&sUeZ1</#Xz:Yx14rwzUG>VrG4O>z^,$$#9(%W20"sgQONa5r0p| " }3g%sJeXOju=Z_I,<AH85w>C2Z79xlxx&	F`$*y]!$t'99Oq[$K-xhrzR@-&2'NeAd~<TIlI!<O +CA)B6I(nH	Grz
pE~5(qFMs%	r(j(q*@#_],	\O#h;|rkb|jI$I6v+fb?Kz=$mc)N;u'xlv p ,};~DqwdukEloD'qJHdPpSy}_z+U8'w,B^1,sq5&f8qCn,srGDTyUN|hSR8/1F{Kvo s{iUBH7a=:Wq)c`(8:#~~)|q6
1,X #Y>{&M:6
ecok(:a#`v;LbU@\9{)J\&4
#VY),~.=}}2Vq9_ Z-8QV.NA`~uz4Rp& 
k[f(V9#;my^ k.+.m]+!4,c,6zg(z\LgfwQk;]OhZ3|7'p2#i#Wtvr8~cZ@XlvBS~3I#[-XILx2TXU YK<'w?^0r?]`y5 w8]8Q
q,
Gt`% Jr>:Y&#s%sONJ99<buy%Z3>b_<TN~VAxBx~UC{6@'q>PR1r)ba##UnrEI&+O!79zLHx<u$H(IR=  	ie;Yhempz9	,su9$sGJj(Nrl,M4=i6aCS%2<qD'<qyeBlc;{neqfN~y*l{#ihi?AEA@;$1aT:y(bV@DM	
"GnN@WSF Q2lF>VI")4R>]*%$`e8Rvx?*;2p)2zF F3Gvn{
`0bA''*T=O9?L;8qX0xd[VyhP?gAlu >p^4%KW}/ho?1hs:I
dB1FRY/
44yK}|'|x0r1(o/kM^x-]OvIf|4/<3>Tw\~2y;IAcp n#k{PG,xNzO+j=QyI]B5V%3(OME<D	AT[od1wRH?L^+>[GO@@O~WlzU#q9EvPHXFNy*G2T mj$[<'_RJ7\#Qgn-A0Fsk$[A+NAUqWYc~-0JVnNK1s\vQd~qIV|?B0mjmy>'pP4T?:URwAL-RP?Lu:{RgRD`qATi>MRkuybL0N@ |k&E G8?ATF'=;vH?vRVF! 0HfSZGRs.2m:f#nZI;[v[qXsg(AIaWO]b|O#R'NPM<iY}> CuSm$VX1w:T9vSiiWesI>$n`sE'F4nMn'UXBm+:Hcppg]R	e%/vI	?Z);g3[Y9SAJ4RvX;%`=?O?bVHm2(C}p81fjQ{e	psw~.8ORMgVa>za*{U9@<W=ngiu6G' Y;L;hE{K`~l$%HVb\H{yD%w;;~EyWPo@ Vr@_0/'$O(_;]ii0}RMbh$R0dq5dMQGhn=cVl?c?`hx2 ]/c `{~cjP=z(+k{(
39Oqsw aMJ 'Dl? +-}'Yb8I \2 k.m^L1;E_sZNnnB0'p{1Raiv%y( q$7^ 0rH|zT0/k"Wy e~ Zof ,}J [eFb8S?LWW?j&2hOd bjPOg.wiifJTx`Oz <is*5Y H?2OXOksZIpJ%si/MKXl?#V:Tl- ?cP5vKTFm}yKv{b#$?XoS\vI>k,>lTMX_{c w @0icykR7-vi`yj}UJ Gu b5 Jk@d;EnK},7~u N\B#J Kki#OC /m:/o= '?Z j0KzYnY.ftP"H^>9 FRjI7_dc.+BkDs'-f*Q5K^]LPU`%G
Cm c<	|K?6OekMEV^9o.yyT3I?lV?g4%7 {c$qE$gYmR?^,Qcj$!+jW7riGRi^\}mR9V{4MwpG@G4bW5j0]wvs yj  %9Q,l@>0+pMoq1OU'>z >[X J4Tf]]E}o
#'9Ax-RD}P1W?s1mf|Q *F^MvSGQ T~W [UYYi6M%Bxop'MvQ9]yJ}+TK m
 ^j
I| UYz7\x}0cF +aW (\/F9vPpI$~_gVFkO,:x {l YiFP\gcdw^O_VYUG?+R(5uA&E/jc[ J8E5 \mu: YzgCHms*;uFAH-o
u(wh-n {qo*A2 Zr`'\ UYYxfY?mIc# EJh1+%?'oTEQmdB7 g /RCw#vUb6j 
7 ]ot ,6# JWwX??Mj6Ga??bV]~M]^<ZX9 C7mumi *l8oFr %b$\lz fQ>?fk_&-4d]1h[	FCzpejSA0YnQ?vSvVRf?;\FW0mLFeQ''$s W hZN-# eQX?U05bMPsV^@%jj[!A t /YnDX3'G# n(I rXl^ hz[Yn n5<-mTp2ic&u+\zlo
VxwV8+gjL}H<rQ*{}(qi *505n3ofq WI)
<m Vj#;hn5,m<#rTJ1gr~RJa	RJ *T	RK8HB
.qw4DydXVwbO@2eo%-9$`s]i7zojm/ JY|CG   mhJgoYvS_
>_fAeL=p TtRnJdBz:~vmnu?!M $O5vvsiRBhrJeQpI`s@KMqOs-|>[ClzH ?'jlC(!QP2OPR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PGG_IK*qH"w7sH	4 J*PR Jv{Rk+n1w#nQWK[m7f~>x Ji'fh5p#bT.
r9# WR6O!0)=9#1 t-lZV@CIPq|@
Uc=G{wD	}F:n{+|-D qlYaO~kWVXKIE$R[&TYY)VS	RJ *T	RJ *T	RJ *T `-z-snG* |ie#W?+9a6
O,|?}Mc!6tO'[v{Rl	8Dvc' Y%F3N  "_ / [Q K}g /}aP H;Q6O"Ae-]nVGC<~ h=]zIay%qqhm3Mm#$@::u -cy06>eInKEwu`WWAVF *Xx 8 ;   /G?n-6AmRXPT *7mo]ho7v#/ *5? J6q j(U+YH?s oX=cO KOoX=cU W TJWz b F*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PR J*PBm0Z3,Gj5MwR]w0 w/x_!Nk5(WzvBuvNBp]zI.mUc?x@_0t-Yw	R6G7t{[gh>0]nIo$vXq:v{ 4J3/F8iE%TKjKgokiv07,Y$>@tP>v:XN1d/lz>DzN]{i,t?uD@ylS  1?jcO_'ok@Wr,1Zd9t,A }D9d'D`pCAcKyn!R<&vckt5Xku<|>2  |kXR4(a$h
$7Zh_Zu5Ol=WT/i/4>(-)#n1X;W7M=N9<a>TZ5Jh4-i++{$oE0biRvjV4^$Dt*\R(TR%J(TR%J(TR%J(7#[ jJ/rvUk)yO_ltOP\ys2;mj7qZO3YHsxN^kYR#OT!ydD'G@: -m W jY q2Y#QE'Ci:#8[v@mi#@AWa}>2ivg1Qy?Zbzk=+..%noV;SG3$YTc
P?l;kWlmy8^BpT7F`1p  g"_? Rm 	O3qXW5kFFo6,rSj?  `E %?kS.={MyN5c G!:N&Y!Ec,6<D   jO8<( zvF}J58[4bE b,V=Z<3y 0X+k
FDk~sjF]_LxT*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@K,dKI&TW !;%ru 'px  [h:fE]m|ry5eDy6mtx}BUe;<yNGvJ+-vW lGeOJ jhEzZIm O=^mubB:<#_RvmV\B1On4&;"dp~E?* <{-k9")2B8![YcZ2}O-i6}-ioO*'j2vGR5X3Mb5c	< c)){I]is\=N,LxJ1hMa]/}/jBQm>Ups)o`MQ\$)ep?bT#@"oVBTJcFI<_{MG7~ 1{ ]7X,,qnGN
99s/h5tv]J5-TP @$eXX~Ffp}k>9KA$2u*Hx$DceHuz-SI{icqOhvA$'hcim _{i{Zerq/s>boL7uapVbHGm)W6\Gr7>yk+[Y\N!*%1p7`q(~~!Sy_x_c}g?GBUV"Bxyh.rNf*(a29GRyZ_?-l*>)u	RJ *T	RJ *T	RJ *T	RJ *T	RJ *T	RJ gOkmF&&
kvF)Ff[G
>N67s,`^G4 o  kQIU<8k_w}wM^Ms.1i*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@>-h?w,A8nY'#v=Xk*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J*T@J